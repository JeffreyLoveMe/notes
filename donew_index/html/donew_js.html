<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 这里写js代码 -->
    <script type="text/javascript">
        /*
        js的诞生
        1>.js和java没有关系
        2>.js标准 - ECMAScript标准/（2015年6月发布ES6/ECMAScript-6）
        */

        /*
        js介绍 - https://koudashijie.com
        1.概念 - js是一款运行在客户端的网页编程语言/脚本语言
        2.组成部分 - ECMAScript(js标准) + DOM(通过js操作网页元素) + BOM(通过api操作浏览器)
        3.特点 - 简单易用、解释执行（对应于'编译执行'）、基于对象
        4.作用 - 页面特效（pc端的网页特效）/移动端/异步网络交互/服务端开发nodejs
        */

        /*
        js的执行过程
        1.在html页面中出现“script标签”就会让页面暂停等待脚本的解析和执行。
        2.无论当前脚本式内嵌式还是外链式，页面的下载和渲染都必须停下来等待脚本执行完成才能继续。
        注意 - 推荐将js代码写在‘html标签’之后/建议将多个js文件合成问一个js文件
        */

        // 代码提示左边小图标的含义 - https://www.zhihu.com/question/370258254/answer/1003317979

        // 输出信息的几种方式
        // 1.对话框（不含'取消'）
        alert("14期高薪");
        var alert_title = "谢吴军";
        alert("我的姓名是" + alert_title); // 字符串的拼接
        // 2.对话框（含‘取消’）- 常配合if判断使用
        // result - true表示点击了确定/false表示点击了取消
        var result = confirm("14期高薪");
        // 3.控制台输出 - 使用较多
        console.log("14期高薪"); // 显示灰色
        console.error("输出错误"); // 显示红色
        console.warn("输出警告"); // 显示黄色
        // 4.对话框（含’输入框‘用于接收用户信息）
        prompt("请输入你的银行卡号");
        // bankCardNo变量可以接收输入的内容/！！！bankCardNo是一个字符串！！！
        var bankCardNo = prompt("请输入你的银行卡号");
        // 5.在页面输出消息/输出标签
        document.write("14期<br><strong>高薪</strong>");
        // 转义字符 - 常见的转义字符可以百度
        // \n - 换行
        // \r - 回车
        // \"\" = ""
        // \'\' = ''
        alert("我叫\"js\""); // 结果输出 - 我是"js"

        // 注释
        // 单行注释 - //
        // 多行注释 - /*多行注释*/

        // 变量和作用域
        // 第一、变量 - 会变化的量
        // 1.作用 - 用来存储数据的容器
        var name;   // 定义变量 - 与swift一样
        name = "123"; // 赋值
        var age = 18; // 定义变量并赋值
        alert(name);
        alert("name"); // 直接量/常量
        var height, weight; // js支持一行定义多个变量
        // ！！！不推荐这样定义！！！
        // var str = "xwj";
        // str = 18;
        // 2.分类 - 按照作用范围，变量可以分为“局部变量”和“全局变量”/js不支持“块级作用域”
        // 局部变量 - 只有局部能够访问的变量（函数内部使用var定义的变量）
        // 全局变量/成员变量 - 任何位置都可以访问到的变量（函数外部定义的变量/函数内部不使用var定义的变量）
        // 隐式全局变量
        function getWidth() {
            // b/c都是隐式全局变量
            var a = b = c = 1;
            // e/f都是隐式全局变量
            var d = 1; e = 1; f = 1;
            // e/f都是不是隐式全局变量
            var g = 1, h = 2, i = 1;
        }
        // 3.预解析
        // 1>.原理 - js的解析器在页面加载的时候，首先检查页面的语法错误，把变量声明提升起来
        // 2>.作用 - 查看语法错误/变量声明提升和函数整体提升
        // 3>.变量声明提升 - 只会提升变量名，不提升变量值
        getHeight();  // undefined（此处是下面函数使用的）
        /*
        ‘
        console.log(aaa);
        var aaa = 11;
        ’
        相当于
        ‘
        var aaa;
        console.log(aaa);
        aaa = 11;
        ’
        */
        console.log(aaa);
        var aaa = 11;
        // 4>.函数整体提升 - 只有这一种定义函数方式会整体提升
        /*
        ‘
        getHeight();
        function getHeight() {
            console.log(aaa);
        }
        ’
        相当于
        ‘
        function getHeight() {
            console.log(aaa);
        }
        getHeight();
        ’
        */
        getHeight(); // 11 - 解析到这里会将下面的函数整体提升上来
        function getHeight() {
            // 函数内部也适用预解析
            // 函数内部的局部变量不会相互影响
            console.log(aaa);
        }
        // 5>.面试题 - 见demo_20.html

        // 字面量 - 常量/固定的值/也是使用var修饰（这点区别于swift）
        var width = 100;

        // 变量的命名规则 - 以“字母、下划线(_/$)”开头，只能包含“数字、字母、下划线”
        // 支持中文（不推荐使用）、不能使用特殊符号
        // 不能使用‘关键字’作为标识符、可以使用‘保留关键字’作为标识符（不推荐）
        // js严格区分大小写/变量长度不超过255个字符
        // 推荐使用“驼峰命名” - getElementById

        // 数据类型
        // 一、简单数据类型
        // 1>.Number - 数字类型（包含‘正数、负数、小数’）/表示的数字有范围
        // 1.判断数据类型 - typeof
        var a1 = 1.45;
        alert(typeof(a1)); // 判断数据类型
        // 2.数字类型的表达方式 - 十进制表示法/十六进制表示法/八进制表示法
        var a2 = 147;  // 十进制表示法
        var a3 = 0x178; // 十六进制表示法 - 0x
        var a4 = 0367;  // 八进制表示法 - 0
        // 3.最大值和最小值（区别于Infinity/-Infinity）
        // 最大值/最小值 - 指js可以表示的最大值和最小值
        // Infinity/-Infinity - 表示无穷大/无穷小（js无法表示）
        alert(Number.MAX_VALUE);  // 最大值
        alert(Number.MIN_VALUE);  // 最小值
        // 2>.String - 字符串类型/凡是使用“双引号”或“单引号”引起来的都是字符串
        // 字符串不可修改 - 给字符串重复赋值会在栈中重新开辟一个内存，原来的内存会被回收
        var a5 = "14期高薪";
        alert(a5);
        alert(typeof(a5)); // 判断数据类型
        alert(a5.length);  // 字符串长度
        // 3>.Boolean - 布尔类型/只有两个值（true == 1/false == 0）/必须是小写
        // 任何数据类型都可以转换成布尔类型 - 0/""/null/false/undefined/NaN转换成false，其他数值/任何对象转换成true
        var a6 = true;
        var a7 = false;
        // 4>.Undefined - 变量未初始化（初始化 - 第一次赋值）/变量在内存中存在
        // Undefined与任何数值计算都是NaN
        var a8;
        alert(a8); // Undefined
        // 5>.null - 变量未引用（值为空）/变量在内存中不存在（类似于Objective-C中的nil）/属于复杂数据类型（object）
        // null和任何数值计算null都可以当作'0'处理
        // 作用 - 销毁变量
        var a9 = null;
        alert(a9);
        // 二、引用数据类型 - Object/function/Array/Date
        
        // 运算符
        // 一、算术运算符 - +｜-｜*｜/｜% / 优先级 - 有()先计算()、先*/后+-
        // 1>.+
        var a10 = 1;
        var a11 = 2;
        // 两个数字类型的变量相加结果是数字类型（实现加法运算）
        var a12 = a10 + a11; 
        alert(a12); // 3
        alert(typeof(a12));
        // 一个数字类型和一个字符串相加结果是一个字符串（实现字符串链接）
        var a13 = "12";
        var a14 = a10 + a13; 
        alert(a14); // "123"
        // 2>.-
        // 两个数字类型相减结果是一个数字类型
        var a15 = a10 - a11;
        alert(a15); // -1
        // 一个数字类型和一个数字字符串相减结果是一个数字类型(隐式类型转换)
        var a16 = a10 - a13;
        alert(a16); // -11
        // 一个数字类型和一个非数字字符串相减结果是NaN
        // NaN - not a number/NaN是一个数字类型（不是一个数字）
        // NaN与"任何数值（包括NaN）"都不相等
        var a17 = "124ABC";
        var a18 = a16 - a17; // NaN
        alert(isNaN(a18));  // 任何不能被转换成数值的值都会返回true
        // 3>.*|/|% - 两个整数相除会出现小数
        // 两个数字类型相乘除结果是一个数字类型
        var a19 = 6;
        var a20 = 2;
        var a21 = a19 / a20; // 3
        // 一个数字类型和一个数字字符串相乘除结果是一个数字类型(隐式类型转换)
        var a22 = "2";
        var a23 = a19 / a21; // 3
        // 一个数字类型和一个非数字字符串相乘除结果是NaN
        var a24 = "2ABC";
        var a25 = a23 / a24; // NaN
        // 0作为除数的时候结果为Infinity(无穷大)/Infinity是数字类型
        // -Infinity(无穷小)
        var a26 = a23 / 0; // Infinity
        // 4>.%
        // 二、赋值运算符 - +=|-=|*=|/=
        var a27 = 5;
        var a28 = 8;
        a27 += a28; a27 = a27 + a28;
        a27 -= a28; a27 = a27 - a28;
        a27 *= a28; a27 = a27 * a28;
        a27 /= a28; a27 = a27 / a28;
        // 三、比较运算符 - </>/<=/>=/==/!=
        var b0 = "2";
        var b1 = 2;
        var b2 = 3;
        alert(b1 > b2);
        alert(typeof(b1 > b2));
        // 四、逻辑运算符 - 不光只有两个结果true/false(与别的语言的区别)
        // 1>.&& - 两个表达式为true结果为true/只要一个表达式为false结果为false
        // 假前真后
        if (b1 > b2 && b1 < b2) {}
        // 2>.|| - 只要一个表达式为true结果为true
        // 真前假后
        if (b1 > b2 || b1 < b2) {}
        // 3.! - 与表达式结果相反
        if (!(b1 > b2)) {}
        // 真遇到||不再执行 - 只要一个为真就行
        // 假遇到&&不再执行 - 必须全部为真
        var aaaaa = 3 || 0 && 2; // 3...为什么？？？
        // 五、赋值运算符=/比较运算符==/比较运算符===
        // "比较运算符(等于==)"只判断内容是否相同，不判断数据类型
        // “不等于!=”只判断内容是否相同，不判断数据类型
        alert(b1 == b2); // false
        alert(b0 == b1); // true
        alert(b0 != b1); // false
        // "比较运算符(全等===)"既要判断内容是否相同，又需要判断数据类型是否相同
        // “不全等!==”既要判断内容是否相同，又需要判断数据类型是否相同
        alert(b0 === b1); // false
        alert(b0 !== b1); // true
        // 六、逗号运算符
        var c1 = 1, c2 = 2, c3 = 3;
        // 七、三元运算符 - 表达式结果为true执行“结果1”，结果为false执行“结果2”
        // 表达式 ? 结果1 : 结果2
        // 八、自增自减运算符
        var index = 10;
        alert(index++); // index++ = 10/index = 11
        alert(++index); // ++index = 12/index = 12
        alert(index--); // index-- = 12/index = 11
        alert(--index); // --index = 10/index = 10
        alert(index);   // index = 10

        // 类型转换
        // 一、强制数据类型转换
        var b3 = 123;
        var b4 = 24.01;
        var b5 = "123";
        var b6 = "123abc";
        var b7 = "mylove";
        var b8 = "12.34";
        var b9;
        var b10 = null;
        // 一、数字类型Number -> 字符串String
        // 第一种方式
        alert(String(b3));
        alert(typeof(String(b3)));
        // 第二种方式
        alert(b4.toString());
        alert(typeof(b4.toString()));
        // 二、字符串String -> 数字类型Number
        // 第一种方式 - 数字字符串转换之后结果为数字/非数字字符串转换结果为NaN/小数类型的字符串转换结果为原数字
        alert(Number(b5));
        alert(typeof(Number(b5)));
        alert(Number(b6)); // NaN
        // 第二种方式 - 整数数字类型字符串转换结果为整数数字/数字开头的字符串转换结果为前面的数字/非数字开头的字符串转换结果为NaN
        alert(parseInt(b5));
        alert(typeof(parseInt(b5)));
        alert(parseInt(b8)); // ‘小数字符串’转换以后取整（不识别小数点后面的数字）
        // 第三种方式 - 整数数字类型字符串转换结果为整数数字/数字开头的字符串转换结果为前面的数字/非数字开头的字符串转换结果为NaN
        alert(parseFloat(b5)); // 与parseInt()效果一致
        alert(typeof(parseFloat(b5)));
        alert(parseInt(b8)); // ‘小数字符串’转换结果为原数字
        // 三、转布尔类型 - 数字和字符串转换结果为true/undefined、null、0转换结果为false
        alert(Boolean(b3)); // true
        alert(typeof(Boolean(b3)));
        alert(Boolean(b5)); // true
        alert(Boolean(b9)); // false
        alert(Boolean(b10)); // false
        // 二、隐式类型转换 - 运算过程中，程序自动进行的数据转换（程序员不参与）
        var b11 = 12;
        var b12 = "3";
        var b13 = b11 - b12;
        alert(b13); // 9
        alert(typeof(b13)); // number
        alert(typeof(b12)); // string

        // if语句 - 与其他语言一致
        var b14 = 12;
        var b15 = 15;
        // 第一种格式
        if (b14 > b15) {
            alert("js");
        }
        // 第二种格式
        if (b14 < b15) {
            alert("js");
        } else {
            alert("js");
        }
        // 第三种格式
        if (b14 < b15) {
            alert("js");
        } else if (b14 > b15) {
            alert("js");
        } else {
            alert("js");
        }

        // switch语句
        var c4 = 10;
        var c5 = 20;
        // ”switch后面’()‘中的表达式“数据类型（可以是number也可以是string）必须与“case后面的value”数据类型（可以是number也可以是string）保持一致
        // 底层原理 - 使用的是“===”
        switch (c4 + c5) {
            case 1: {
                // 如果“表达式/变量 = 1”执行这里
            }
                break; // 可以阻断代码执行
            case 2: {
                // 如果“表达式/变量 = 2”执行这里
            }
                break;
            case 3:
            case 4:
            case 5: {
                // 多个case可以gong yong e w
            }
                break;
            default: {
                // 如果“表达式/变量”和以上的值都不相等执行这里
            }
                break;
        }

        // 循环语句 - 与其他语言一致
        // 第一种 - while循环
        // 重复执行某一段代码（循环体），直到"不满足条件/false"终止循环
        while (true) {
            // 循环体
        }
        // 第二种 - do...while循环
        // 重复执行某一段代码（循环体），直到"不满足条件/false"终止循环
        // 至少循环一次
        do {
            // 循环体
        } while (true);
        // 第三种 - for循环（最常用）
        // let和var的区别 - https://www.cnblogs.com/fly_dragon/p/8669057.html
        for (let index = 0; index < 100; index++) {
            // 循环体
        }
        // 循环嵌套
        // break - 结束当前循环
        // continue - 结束本次循环，开始下次循环
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 10; j++) {
                document.write("*");
                // break; // 结束内部小循环
                // continue;
            }
            document.write("<br>");
            // break; // 结束外部大循环
        }
        // 死循环
        // for(;;) {

        // }
        // while (true) {
            
        // }
        // do {
            
        // } while (true);
        
        // 代码调试 - js代码错误会暴露在运行时

        // 函数基础
        // 1>.概念 - 可以重复执行的代码块/方便调用
        // 2>.格式 - function 函数名() {}
        // 3>.定义函数
        // 第一种、无参数无返回值函数
        function test() {
            alert("test");
        }
        // 函数调用 - 可以写在函数定义之前
        test();
        // 第二种、有参数无返回值函数
        // 1.实参个数 > 形参个数 - 正常执行，实参多余部分不参与运算/js没有方法重载
        // 2.形参个数 > 实参个数 - 未给定的实参为undefined -> 研究程序本身是否会报错（报错、NaN、undefined）
        function demo(a, b) {
            // a、b形参
            alert(a + b);
        }
        // 1、2实参
        demo(1, 2);
        // 第三种、无参数有返回值函数 - 有return的函数就有返回值，没有return的函数就没有返回值(返回值为undefined)
        function sum() {
            a = 1 + 3;
            return a;
        }
        var c6 = sum();
        // 第四种、有参数有返回值函数
        function getSum(a, b) {
            var sum = a + b;
            return sum;
        }
        // 第五种、匿名函数 - 使用该方法调用有局限性（函数定义必须在使用函数之前）
        var fn_1 = function getMin() {
            alert("匿名函数");
        }
        fn_1();
        var fn_2 = function () {
            alert("匿名函数");
        }
        fn_2();
        var fn_3 = new Function("alert(\"匿名函数\");")
        fn_3();

        alert(getSum(1, 2));
        /*
        4>.函数特性
        1.函数不调用不执行 - js加载函数只会加载函数名，不加载函数体
        2.打印整个函数（函数名 == 整个函数）
        3.参数（形参）相当于局部变量 - 就近原则/两个平级函数中的参数互不影响
        */
        function getMax(a, b) {
            return a - b;
        }
        alert(getMax); // 打印整个函数（函数名 == 整个函数）
        alert(typeof(getMax)); // function也是一种数据类型（属于object）
        alert(getMax(1, 2));  // 打印函数返回值（先执行getMax(1, 2) -> 再执行alert(getMax(1, 2))）
        // 5>.函数递归 - 函数自己调用自己/必须有结束条件
        // 6>.回调函数 - 函数作为参数进行传递和使用
        function getWeight(a, b, test) {
            console.log("开始回调函数");
            test(a, b);
            console.log("结束回调函数");
        }
        function do_test(a, b) {
            alert("我是测试" + a + b);
            return a + b;
        }
        getWeight(11, 12, do_test);
        // 7>.匿名函数
        // 1.直接调用
        (function () {
            console.log("直接调用");
        })()
        // 2.绑定事件
        document.onclick = function () {
            console.log("绑定事件");
        }
        // 3.定时器
        setInterval(function () {
            console.log("定时器");
        }, 1000);

        // 面向对象和基于对象
        // 1>.概念 - 面向对象（可以创建自定义对象，支持封装、继承、多态，例如java）/基于对象（不可以创建自定义对象、不能友好的支持继承、多态，例如js）
        // 2>.属性（颜色、体重）和行为（睡觉、吃饭）- 可以自定义属性和方法
        // 3>.创建单个对象 - 缺点：创建多个对象狠繁琐
        var hero = new Object();
        // 绑定属性
        // 第一种方式
        hero.name = "xwj";
        hero.age = 18;
        // 第二种方式
        hero[height] = "180";
        hero[weight] = 18;
        // 绑定方法
        hero.attack = function () {
            // this - 代表对象
            console.log("攻击" + this.name);
        }
        alert(hero);
        // 4>.创建多个对象 - 使用函数/缺点：代码冗余、创建对象的方式比较low
        function createStudent(name) {
            // new - 开辟内存空间/把this设置为当前对象/执行内部代码，设置属性和方法/返回新创建的对象
            var student = new Object();
            // 属性可以通过函数形参传入
            student.name = name;
            // this - 只会出现在函数中/谁调用函数this就指代谁/指代对象
            student.say = function () {
                console.log(this.name + "你好");
            }
            // 必须有返回值才行
            return student;
        }
        var s1 = createStudent("谢吴军");
        // 调用属性
        console.log(s1.name);
        // 调用方法 - 必须加上()
        s1.say();
        // 5>.构造函数 - 可以创建对象的函数/首字母大写
        // 1.创建一个构造函数 - 类似其他语言中的类
        function Student(name) {
            this.name = name;
            this.say = function () {
                console.log(this.name + "你好");
            }
        }
        // 2.使用构造函数创建对象
        var s2 = new Student("张三");
        // 3.原理
        function Student(num) {
            this["[[PrimitiveValue]]"] = num;
            return num/1;
        }
        // 6>.对象字面量
        // 1.创建对象字面量
        var c7 = {
            // key加不加""都可以
            name: "谢吴军",
            "age": 18,
            sayHi: function () {
                console.log(this.name + "你好");
            }
        };
        // 2.json - javascript object notation(js对象表示形式)
        // json与对象字面量的区别 - json的属性key必须加上""，对象字面量属性key可以省略""
        // json是对象字面量、对象字面量不一定是json
        var json = {
            "name": "谢吴军",
            "age": 18,
            "arr": [1, 2, 3],
            "sayHi": function () {
                console.log(this.name + "你好");
            }
        };
        console.log(json.length); // undefined - json没有长度
        // 遍历对象 - 不能使用for循环（因为对象没有长度）
        for (var key in json) {
            console.log(key);
            console.log(json[key]);
        }
        // 7>.伪代码 - class类（js中没有类的概念/ES6中也开始引入类的概念）

        // 进制转换
        // 1>.任意进制转换十进制
        var c8 = parseInt(10, 2); // “二进制10”转换成“十进制”
        // 2>.十进制转换任意进制 - toString
        var c9 = 7;
        var c10 = c9.toString(2); // “十进制”转换成“二进制”

        // 数据类型的传递和存储
        // 1>.简单数据类型 - 值类型
        var d1 = 1;  // 入栈区 - 开辟空间0x100
        setFunc(d1); // 不是把地址0x100传入（传值）
        function setFunc(num) {
            num = num * 10; // 入栈区 - 开辟空间0x101
        }
        console.log(d1);
        // 2>.复杂数据类型 - 地址传递
        var d2 = new Object(); // 入堆区 - 开辟空间0x102
        d2.name = "xwj";
        setObject(d2);  // 把地址0x102传入（传地址）
        function setObject(object) {
            object.name = "cfj"; // 操作的是同一块内存空间
        }
        console.log(d2.name);
        // 总结 - 当你想要修改成员变量中的简单数据类型时，不要通过参数传递，需要在函数中直接修改

        // 内置对象 - js本身已经帮我们写好的对象（不需要我们创建）
        // 查看文档 - https://developer.mozilla.org/zh-CN
        // 1.Date对象
        var myDate = new Date();  // 通过new创建对象
        alert(myDate); // 完整的当前日期时间/Mon Aug 10 2020 10:37:28 GMT+0800 (中国标准时间)
        alert(myDate.getDate()); // 返回一个月的某一天（1 - 31）
        alert(myDate.getDay()); // 返回当前是周几（0/周天 - 6/周六）- 常用
        alert(myDate.getMonth()); //返回当前月份(0/一月 - 11/十二月) - 返回正常的月份需要“+1”/常用
        alert(myDate.getFullYear()); // 返回当前年份（四位数）- 常用
        alert(myDate.getHours()); // 返回当前的小时（0 - 23）
        alert(myDate.getMinutes()); // 返回当前的分钟（0 - 59）
        alert(myDate.getSeconds()); // 返回当前的秒数（0 - 59）
        alert(myDate.getTime()); // 返回时间戳（1970年01月01日至今的毫秒数）
        alert(myDate.getTimezoneOffset()); // 返回本地时间与格林尼治标准时间(GMT)的分钟差
        // 2.Math对象 - 常用于执行数学任务
        var x1 = 10.5;
        var y1 = - 20;
        alert(Math.abs(y1));   // 返回“绝对值”
        alert(Math.ceil(x1)); // 向上取整（天花板函数）
        alert(Math.floor(x1)); // 向下取整（地板函数）
        alert(Math.max(x1, y1)); // 最大值
        alert(Math.min(x1, y1)); // 最小值
        alert(Math.pow(x1, y1)); // x1^y1
        alert(Math.random());   // 返回“0 - 1的随机数”/不包括”0和1“ - 常用
        alert(Math.round(x1));  // 四舍五入取整/-15.5四舍五入为-15
        alert(Math.PI); // 返回圆周率
        // 3.Array对象 - 数组
        // 1>.创建数组
        // 第一种方式
        var array01 = new Array(); // 空数组
        array01[0] = 12;  // 通过下标给数组赋值 - 数组元素从0开始
        array01[1] = 18;
        // 第二种方式
        var array02 = []; // 常用
        array02[0] = "谢吴军";
        array02[1] = "中国人";
        alert(array01); // 显示数组
        // 第三种方式
        var array03 = [12, 35, "中国人"]; // 定义数组的同时初始化（js数组中可以有不同的数据类型）
        alert(array03);
        alert(array03.length);  // 数组长度
        alert(Array.isArray(array03)); // 是否是数组
        alert(array03.toString()); // 数组转换成字符串/12, 35, "中国人"
        // 2>.数组遍历 - 数组的长度 == 数组下一个元素的索引值
        // 因为数组中的元素数据类型不一样所以筛选数据最好使用‘===’/‘!==’
        // 第一种方式
        for (let index = 0; index < array03.length; index++) {
            alert(array03[index]);
        }
        // 3>.添加元素
        array04.unshift("name"); // 队列操作 - 往数组最前面添加新元素、返回数组长度
        array04.push("xwj");  // 栈操作 - 往数组最后面添加新元素、返回数组长度
        // 4>.删除元素
        array04.shift("name"); // 队列操作 - 删除数组最前面的元素、返回最后一项
        array04.pop("xwj");  // 栈操作 - 删除数组最后面的元素、返回最后一项
        // 5>.数组排序
        array04.reverse(); // 翻转数组 - 原数组也改变，返回新数组
        array04.sort();  // 根据字符排序 - 功能很强大（能够对数字和字母进行排序）、只可以对第一位排序
        array04.sort(function (a,b) {
            return a - b;  // 升序
            return b - a;  // 降序
        }); // 可以设置排序规则 - 底层是“冒泡排序”
        // 6>.数组操作
        // 1.数组连接
        var array04 = [12, 14, 18, "吴军"];
        var array05 = [3, "xwj"];
        var array06 = array04.concat(array05);
        // 2.数组截取 - 原数组不变
        array06 = array04.slice(3); // 从3(0开始算)开始截取
        array08 = array04.slice(1, 2);  // 从1到2（包括左边不包括右边）
        array08 = array04.slice(-3);  // ？？？
        array08 = array04.slice(2, 1); // ？？？
        // 3.数组截取 - 原数组改变
        array06 = array04.splice(0);
        // 4.元素查询索引
        console.log(array04.indexOf("吴军")); // 从前往后查询到第一个元素立刻返回
        console.log(array04.indexOf("15")); // 如果查询不到返回-1
        console.log(array04.lastIndexOf("吴军")); // 从后往前查询到第一个元素立刻返回
        console.log(array04.lastIndexOf("15")); // 如果查询不到返回-1
        // 5.数组迭代
        // item - 元素值
        // index - 元素索引
        // array - 原数组
        // 返回boolean
        array04.every(function (item, index, array) {
            // 代码块
            return true; // 必须返回true才会都打印
        }); // 对每个数组元素都执行该函数：如果都返回true则返回true，如果有一个返回false则停止遍历返回false
        // item - 元素值
        // index - 元素索引
        // array - 原数组
        // 返回[]
        array04.filter(function (item, index, array) {
            return true;
        }); // 对每个数组元素都执行该函数：返回结果为true的元素组成新数组返回
        // item - 元素值
        // index - 元素索引
        // array - 原数组
        // 返回void
        array04.forEach(function (item, index, array) {

        }); // 遍历数组
        // item - 元素值
        // index - 元素索引
        // array - 原数组
        // 返回[]
        var resultArray = array04.map(function (item, index, array) {

        }); // 对每个数组元素都执行该函数：返回函数结果组成的新数组
        // item - 元素值
        // index - 元素索引
        // array - 原数组
        // 返回boolean
        array04.some(function (item, index, array) {

        }); // 对每个数组元素都执行该函数：如果有一个返回true则返回true
        // 7>.清除数组
        // 第一种方法
        array04.splice(0, array04.length);
        // 第二种方法
        array04.length = 0; // 伪数组不能使用
        // 第三种方法 - 推荐使用
        array04 = [];
        // 8>.返回一个字符串 - 将数组元素以“,”连接成string返回
        var array07 = [12, 13, 14, 15];
        var separatorString01 = array07.join(); // 以","连接
        var separatorString02 = array07.join(""); // 用空字符串连接
        var separatorString03 = array07.join("&"); // 用&连接
        alert(typeof(separatorString));
        // 9>.伪数组和arguments
        function getArray(a, b) {
            // 只能在函数中使用：代表实参的数组
            console.log(arguments);
            // 伪数组：不能修改长度的数组（可以修改元素，不能修改长度）
            arguments.push(1); // 报错 - 表面是数组实际不是数组
            arguments[0] = 0;  // 可以修改元素
            console.log(arguments);
            console.log(getArray.length); // 形参个数
            console.log(arguments.length); // 实参个数
            console.log(arguments.callee); // 代表整个函数（函数名）（包括注释）
        }
        // 10>.冒泡排序 - 此处以后使用java写
        var bubbleSortArray = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];
        // 需要排序 (bubbleSortArray.length - 1) 轮
        for (let i = 0; i < bubbleSortArray.length - 1; i++) {
            // 需要比较 (bubbleSortArray.length - i - 1) 次数
            for (let j = 0; j < bubbleSortArray.length - i - 1; j++) {
                // 交换前后位置
                if (bubbleSortArray[j] > bubbleSortArray[j + 1]) {
                    var temp = bubbleSortArray[j];
                    bubbleSortArray[j] = bubbleSortArray[j + 1];
                    bubbleSortArray[j + 1] = temp;
                }
            }
        }
        alert(bubbleSortArray);
        // 4.RegExp对象 - 正则表达式
        // 5.Error对象 - 错误对象
        // 6.String对象 - 字符串对象
    </script>
</head>

<body>
    <!-- 
        js书写位置
        1>.内嵌式 - 可以写在页面的任何位置（推荐位置 - html结束标签后面）
        <head>
            <script type="text/javascript">
                // js书写位置
            </script> 
        </head>
        // 2.外链式
        <script src="login.js"></script>
        注意 - 写js代码‘;’最好不要省略（语句单独一行可以省略';'，类似swift）
        // 3.行内式
        <div onclick="alert('我是行内式')">你好</div>
     -->
</body>

</html>