/**
名称：iOS笔记
作者：谢吴军
*/
/**************************前期概述**************************/
//开班须知
1.建议学习时间：
上午9:00-12:00 | 下午14:00-18:00 | 晚上19:30-21:30
2.学习内容：
基础班(4周)：C语言 | Objective-C | swift语言
就业班(4个月)：多线程 | iOS开发 | HTML | React Native
3.学习方法：
1).专心听讲：注重听懂、理解
2).建议准备笔记本：记录重点
3).先自己解决->百度->谷歌

//iOS开发
1.概述：
1).iOS是一款由苹果公司开发的操作系统(OS)
2).什么是iOS开发：开发iphone/iPad手机软件开发
3).主流操作系统：iOS、Android、黑莓、WP、Symbian
4).什么是操作系统：直接运行在硬件上的最基本的系统软件，其他软件必须依赖操作系统才能运行
5).iOS(基于UNIX、不开源、AppStore)/Android(基于Linux的虚拟机、开源、GooglePlay)
2.准备：
1).编程语言：swift > Objective-C > C语言 > C++
2).开发工具：Xcode
3).电脑系统：MacOS
4).真机设备：iphone/ipad
5).iOS证书：调试证书/发布证书
3.Apple硬件：
1).iPhone：2007年发布iphone1/2008年发布iphone2(3G)
2).iPad：2010年发布iPad1(大概一年发布一款)
3).ipad mini：2012年发布iPad mini1
4).ipod Touch：没有打电话功能的iphone
5).Apple TV：需要翻墙(国内被小米模仿)
4.Mac系统：基于Unix内核
1).Dock工具栏：应用程序列表(默认位于屏幕下方)
2).系统偏好设置：windows的控制面板
3).safari浏览器：windows的IE浏览器
4).App store：苹果应用商店
5).finder文件管理器：windows的计算机
/**************************计算机基础**************************/
//Mac快捷键
command+空格 //切换输入法
command+F //查找、替换
command+N //新建文件
command+tab //切换应用程序
command+shift+3/4 //截图
command+shift+z //恢复撤销
command+W/Q //退出前台|退出后台
command+S/C/V/X/A/Z //保存/复制/粘贴/剪切/全选/撤销
command+B/R //将代码翻译成0/1、编译程序/运行程序
shift+command+N/M //创建工程/模拟内存警告
command+D //保存网址
command+I //排版
command+\ //设置断点
command+press //查看方法名
command+option+左/右 // 折叠/展开代码
option+press // 查看文档
F11 //进入桌面

//常用终端命令
cd+目录 //切换到指定目录
cd+../ //返回上一级目录
cd+/  //切换到root目录
ls  //查询当前目录下子目录活文件
pwd //查看当前路径
clear+l //清屏
mkdir+文件夹名称 // 新建文件夹
rmdir+文件夹名称 // 删除文件夹
open+文件名称 // 打开文件
touch+xxx.txt // 在当前文件夹下新建文件
cat+文件名 //查看文件


//vi编译器的使用：用来编写c语言程序
vi test.c //打开/新建test.c文件
i //命令模式->编辑模式
#include <stdio.h> //编写一段c语言代码
int main() {
    printf("hello world\n");
    return 0;
}
esc //退出编辑模式
:wq //保存代码：返回到命令行模式
//通过gcc编译器编译
gcc test.c -o t //test.c需要编译的C语言源文件/t将要生成可执行文件
./t //运行程序/生成可执行文件

//计算机常识
1.计算机只能识别0|1，计算机能识别的指令也是由0和1组成，计算机中存储和操作的数据都是由0和1组成；
2.计算机语言：机器语言(只有0和1-0表示不加电，1表示加电)/汇编语言(符号化机器语言)/高级语言

//进制转换
1.概念：一般考虑四种进制
十进制：用0-9来表示所以的自然数
int num = 14; // 默认是十进制
printf("%i", num);
二进制：用0-1来表示所有的自然数
int num = 0b1110; // 前面加上0b
注意：在C语言中没有以二进制输出的占位符
八进制：用0-7来表示所有的自然数
int num = 016; // 前面加上0
printf("%o", num);
十六进制：用0-F来表示所以的自然数
int num = 0xF1; // 前面加上0x
printf("%x", num);
2.为什么要引入二进制？
因为计算机是以二进制形式进行数据存储：二进制存储简单方便；
3.进制转换：
大->小：除k取余法/底部是高位、上部是低位
小到大：从低位起*k的n(n从0开始)次幂相加
二进制<-->八进制/十六进制：有特殊技巧（取3位/取4位）

///原码/补码/反码
//！！！有时间可以操作一遍！！！
1.真值：一个数的十进制表示形式/机器数：一个数的二进制的表示形式
2.原理：计算机内存是由大量开关组成的，分别用0和1来表示每一位开关（每一位成为1bit，每8位成为1字节/byte）
1kb=1024byte   1Mb=1024kb   1Gb=1024Mb   1Tb=1024Gb/计算机分配内存的最小单位是字节
1)原码：将一个数的真值的绝对值转为二进制，存储的八位内存空间，最高位存储符号位，1表示负数，0表示正数，其余7位用来存储真值的绝对值的二进制表示形式
结论：计算机不以原码的方式进行数据存储，原码会出现计算错误
2)反码：正数的反码是原码，负数的反码是原码符号位不变，其余位数按位取反（0变1，1变0）反码的反码是原码
结论：计算机不以反码的方式进行数据存储，反码解决不了0的问题
3)补码：正数的补码是原码，负数的补码是反码加1，补码的补码是原码
结论：计算机是以补码的形式进行存储/计算机只会做"加法运算"
/**************************C语言基础**************************/
//C语言重难点
1.运算符：已掌握
2.进制转换/位运算：不掌握不影响iOS开发
3.条件语句：已掌握
4.数组：一维数组XXX
5.循环：已掌握
6.函数：已掌握
7.指针：一级指针、多级指针、指针和数组/函数/结构体之间的关系XXX
8.内存管理：内存泄漏、野指针XXX
9.预处理指令：宏、条件编译
10.多文件开发：已掌握
11.字符串/枚举/指针：XXX

//C语言概述：
1.C语言是由很多"程序段"组成
2.C语言每条语句后面+";"
3.同一个程序有且仅有一个main()函数
4.C语言的标准：ANSI C->C99->C11

//main函数：系统自动调用
#include <stdio.h> //告诉系统printf()函数在什么地方
int main() {
    // \n默认换行
    printf("hello world\n"); //执行代码
    return 0;
}

//C语言的执行流程：编写程序->将自定义函数进行编译->目标文件/C语言函数库进行链接->可执行文件->运行

//关键字
1.特征：全部小写/在Xcode中显示不同的颜色/一共32个
2.分类：流程控制关键字+数据类型关键字/unsigned|signed

//标识符
1.概念：程序员自己在项目中起的名字/不能与关键字同名
2.命名规则：由字母、数字、下划线组成/严格区分大小写、不能以数字开头/必须遵守
3.命名规范：1.有意义的名字/2.驼峰命名（除首单词以外其他单词首字母大写）sendMessage/不是必须遵守
4.常见命名：1).包：域名倒过来（全部小写）cn.com.itcast.javabean
2).类/接口：首字母大写
3).方法：驼峰法sendMessage
4).常量：所有字母大写GET_MAX

//注释：不会参与编译(不会被翻译成0和1)/可以用来查看代码段
1.单行注释：// 单行注释
2.多行注释：/*多行注释*/
3.文档注释：/**文档注释 @brief*/
ps.对于很难的逻辑：可以先写注释、再写代码

//数据类型：
1.静态数据：一般以文件的形式存储在硬盘/静态数据类型->动态数据类型：从磁盘加载到内存
2.动态数据：一般存储在内存中/访问速度快/动态数据类型->静态数据类型：手机拍照
3.计量单位：1B(Byte) = 8bit(10101010)/1KB = 1024B/1MB = 1024KB/1GB = 1024MB/1TB = 1024GB
4.分类：基本数据类型(short/int/long/char/float/double)/构造类型/指针类型/空类型

//常量：不能改变的量
1.整型常量(整数)：二进制/八进制/十进制/十六进制
short sum = 10; int sum = 15; long sum = 100;
signed  有符号整型/unsigned 无符号整型
2.实型常量(小数)：默认情况下所有小数都是double
float sum = 5.2f; //单精度
double sum = 88.8; //双精度
3.字符型常量：普通字符/转义字符
char sum = 'a' //''只能存放单个字符
char sum = '13' //错误：13是由2个字符组成
char name = '男' //错误写法：一个汉字占3个字节
ps.'\n'虽然有两个字符组成、但是还是字符型常量/转义字符：通常以'\'开头/有实际意义/终端看不到输出结果
4.字符串常量："hello world"/"a"也是字符串常量
ps.常量在内存中有存储空间吗？

//变量：可以改变的量
1.使用变量之前必须先定义变量(申请一块存储空间)
int sum; //定义变量：分配唯一的存储空间/申请内存
sum = 9; //给变量赋值：给存储空间存储数据/变量的第一次赋值称为初始化init/使用变量之前必须init、不然存储的都是垃圾数据
int value,number; //连续定义：开辟两块存储空间/声明的时候就会开辟存储空间
printf("value = %i",value); //获取value：占位符/编译期间才知道具体数值
int number = 10; //定义同时初始化：变量第一次赋值称为init/先init、才能使用
//完全初始化：未init变量的值是随机的
int value,number;
value = number = 10;
//部分初始化：value没有init/number = 10
int value,number = 10;
2.作用域：从"定义的那一行"开始直到大括号/遇到return结束/return和"}"一样的效果/一对"{}"可以看做一个"存储空间"
1).局部变量：定义在{//...}内部的变量
2).全局变量：xxx
3).作用域结束：变量销毁/内存管理
3.内存分析：
1).内存是由字节地址组成的/字节地址是连续的
2).内存寻址：从大到小/&变量名称：变量的详细地址/先定义的内存变量地址一定大于后定义的变量
printf("%p\n",&number) //输出变量的详细地址：十六进制/首字节地址：小的那个/%p可以打印详细地址
4.字符
char A; // 错误：A没有 '' 表示标识符
char "A" // 错误： " " 表示字符串
char '12' // 错误： " " 表示2个字符
char '中' // 错误：不能存放中文/中文2个字节
char 'a'  // 正确
char ch = 10; // 正确

//printf()函数/scanf()函数
1.printf()函数：输出函数
1).格式符：%i（整数）、%f（浮点数）、%c（字符）、%lf（double）、%.mf（保留小数点后m位）
2).指定位宽：%mf、%mi //m就是位宽(占据几列)/默认右对齐、左边补空格
int number = 99;
float value = 3.1456
printf("%5i",number); //"补3个空格"99
printf("%-5i",number); //99"补3个空格"
printf("%05i",number); //宽度不够补0、够了按照实际输出/宽度够直接显示/0表示补充0、5表示占5列
printf("%.2f",value); //保留两位小数
printf("%.*f",n,value); //保留n位小数
//怎么计算有效位数：从第一位开始3.1415926
2.scanf()函数：输入函数/阻塞式函数/敲击\n告诉系统输入完毕
int number; //定义number接收数据
printf("请输入一个数据：")
scanf("%i",&number); //必须加上&
scanf("%i,%i",&num1,&num2); //FIXME:什么情况下，scanf()函数自动终止？
实现原理：scanf()函数只要输入缓冲区中有内容，就不会要求用户输入数据；
3.有效位数：从第一位开始算起/float有效位数为7位(系统固定)/double有效位数位15位

//运算符
1.算术运算符：+|-|*|/|%  //相同类型变量才能算术运算：结果类型不变
result = 1 + 3 + 6 * 5 / 3; //result = 14 |优先级：*|/ > +|-
result = -10 % 3; //result = -1/result正负性取决于左边的操作数
1).自动类型转换(隐式转化)
int num = 10.8; //int占4个字节/double占8个字节
printf("number = %i\n", num); //number = 10
2).强制类型转换(显式转化)：原表达式的值不变、强转以后结果改变
int num = (int)10.8; // 有可能丢失精度
3).自动类型提升：系统会将"小类型"->"大类型"/不会损失精度
int result = 10+9.9; //只有相同类型的数据才可以运算：必须"自动类型提升"
注意：参与运算的操作数类型和结果的类型必须一致；
2.赋值运算符：=|+=|-=|*=|/=|%= //结合性：从右到左/优先级很低
result = 5; result += 5; //result = 10
3.自增/自减运算符：
result = 5;int sum = result++; //先赋值、再result+1/result = 6/sum = 5
int sum = ++result; //sum = 6/result = 6
4.sizeof运算符：一个数据类型/常量/变量在内存中占有字节数
int size = sizeof(10);=>int size = size 10; //()可以省略
int x = 9.8; int size = sizeof(x);=>int size = sizeof x; //()可以省略
int size = sizeof(float); //()不能省略
注意：sizeof是一个运算符，不是一个函数；
5.逗号运算符：','
// 一般很少使用 ','  获取表达式的结果/一般使用 ',' 连接多个表达式
// ',' 连接多个表达式：类似于&&的含义
if let count = array.count, let size = count + 1 {
    //整个 , 表达式的结果等于最后一个表达式的值
}
6.关系运算符：>|<|>=|<=|==|!= // C语言规定：非0即真、0为假
a = 10, b = 5; // "="/"=="的区别
int result = a > b;// 怎么理解：a>b吗？
优先级：1.>、<、>=、<=优先级大于!=、==先优先级、再结合性；
2.算术运算符 > 关系运算符 > 逻辑运算符/先"优先级" --> 再"结合性"
7.逻辑运算符：&&、||、!
int sum = a && b; // 与
int sum = a || b; // 或
int sum = !a; // 从右至左
int result = 4 < 5 < 6  // 错误：(5 > 4) && (5 < 6)
注意：1.C语言规定所有的数值都有真假性，非0即真；
2.&&、||会出现短路现象：只要前面的条件为假、真，后面的不再执行
int x = 100; int result = (x > 200) && (++x == 0);   // x = 100
int y = 100; int result = ( y < 200) || (++y == 0);  // y = 100
8.三目运算符:
int max = a > b ? a : b;

//输入函数/输出函数|scanf()/printf()
int a;
scanf(“%d”,&a); // 从键盘输入整型变量a的值/scanf函数里面不能做文字性的说明
printf(“%d”,a); // "\n"不能用在scanf()函数中/只能用在printf()函数中

//流程控制基本概念
1.if语句：if语句可以嵌套/嵌套可以使用&&、||、!替代/互斥
if(表达式1) {
    //执行代码
}
//必有一个执行
if(表达式1) {
    //执行代码
} else {
    //执行代码
}
if(表达式1) {
    //执行代码
} else if (表达式2) {
    //执行代码
} else {
    ///执行代码
    //可以不需要这一句/可选类型
}
if(表达式1) //执行代码：只能执行第一句
2.switch语句：C语言中'条件表达式'的返回值只支持整数/switch的效率比if高/注意格式
switch (条件表达式) {
// case不能重复/不能放置变量/没有if灵活
case 整数: {
    //执行代码
}
    break; // 跳出当前case
// default可以随便放置/可以放置在上面/也可以放置在最底下/default永远都是最后执行
default: {
    //执行代码
}
    break; // break只能用于switch和循环结构
}

//循环语句：反复执行某一段代码
1.循环格式：都是不满足条件停止执行
1).while()语句：当条件满足开始执行循环体直到不满足条件停止执行
while(表达式) {
    //循环体
}
2).do-while()语句：先执行循环体直到不满足条件停止执行/最少执行一次循环体
do {
    //循环体
} while(表达式)
3).for()语句：最常使用的循环语句/企业级开发只要会使用for()足够
for(语句1;表达式;语句2) {
    //循环体
}
2.死循环：下面不允许写无法访问的语句
1).while (YES) {
    // 循环体
}
2).for (;1;) {
    // 循环体
}
3).RunLoop
3.循环嵌套：
for(int i = 0;i < 2; i++) {
    for(int j = 0; j < 5; j++) {
        // i = 0 -> j = 0,1,2,3,4
        // i = 1 -> j = 0,1,2,3,4
        break; // 跳出循环体、终止循环
        continue; // 跳出本次循环、开始下次循环
    }
}
4.循环思想：累加思想/计数思想
5.如果循环的增量在执行完毕循环体以后还需要使用-while/如果循环的增量在执行完毕循环体以后不再使用-for
6.分析内存管理：指定一块内存空间代表该项目 --> 遇到"声明属性"需要开辟内存空间 --> 遇到 {} 需要开辟内存空间

//数组
1.概念：数组是一组有序的数据集合，数组中每个元素都具有相同的数据类型
// 一维数组
int array[5]; // 定义一个长度为5的数组
array[5] = {1, 8, 9, 10, 18, 25}; // 数组元素init：可以部分init/未init的元素为0
int count = array[5]; // 数组访问越界/Segmentation fault
//二维数组
1.概念：元素是一维数组的数组称为二维数组
int array[4][3]; // 定义
// 4;二维数组中一维数组的个数/行数
// 3;每个一维数组的元素个数/列数
array[4][3] = {
    {1,4,6},
    {1,7,8},
    {8,5,6},
    {4,5,7}
}; // init

//函数：见SyGameProxy.h/c

//内存管理
1.变量为什么要定义类型？每种类型占用的内存空间不一样
2.内存寻址：从大到小/先定义的变量内存地址越大
int p = 10;
printf("int类型的p内存地址：%p", &p); // &p取出地址
3.以"补码"形式存储/从高位->低位/一个字节存储8位

//字符串
1.概念：由字符组成的串""/可以使用数组来保存字符串/%s
2.“字符串”和“普通字符数组”的区别：字符串以“\0”结尾，字符串比字符数组多一个元素
char str[] = "xwj";
printf("---%s---", str);
3.了解的方法：#include <ctype.h>
int isalpha(int c); //判断单个字符是否是字母
int isnumber(int c); //判断单个字符是否是表示数字
int isupper(int c); //判断单个字符是否是大写字母
int islower(int c); //判断单个字符是否是小写字母
int toupper(int c); //将单个字符转换为大写字母
int tolower(int c); //将单个字符转换为小写字母
4.掌握的方法：#include<string.h>
//sizeof(const char *s)占用字节大小
size_t strlen(const char *s); //！！！返回字符串的有效字符个数：与sizeof()区别？！！！
char *strcat(char *s1,const char *s2); //！！！将s2的内容拼接到s1后面形成新的字符串s1！！！
//返回子串在s1中首次出现位置的第一个字符的地址
char *strstr(const char *s1, const char *s2); //在字符串s1中，寻找子串s2首次出现的位置
//s1必须有足够大的空间，如果数组越界，可能导致未知的错误
char *strcpy(char *s1,const char *s2); //将字符串s2拷贝到字符数组s1，返回s1
char *strchr(const char *s,char c); //查找字符串s中首次出现字符c的位置，不存在c,返回NULL
//s1 > s2 -> 返回正数，s1 < s2 -> 返回负数，s1 == s2 -> 返回0
int strcmp(const char* s1,const char* s2); //比较两个字符串的大小关系
char *strrchr(char *str, char c); //在串中查找指定字符的最后一个出现，失败返回NULL

//预处理指令
1.概念：均以"#"开头，不要分号/包含"宏定义"、"文件包含"、"条件编译"/编译之前会执行
2.宏定义：#define MAX= 10  // 不要分号、一般需要大写、编译预处理时将源代码中"宏名"替换成"宏内容"
3.文件包含：#include "xxx.h"   // 将xxx.h复制到当前文件中
4.条件编译：见SyGameProxy.h/c

//指针

//值传递/指针传递

//结构体
/**************************Objective-C基础**************************/
//认识Objective-C语言
1.概述：面向对象的C语言/完全兼容C语言/C语言代码可以直接编译在Objective-C工程中；
2.源文件：.h/.m/.mm；
3.关键字：C语言关键字在oc中都可以使用/新增部分关键字：@interface、@public、@implementation等；
4.数据类型：BOOL/Block/SEL/null
5.#include -可能会出现重复包含头文件/#import -可以避免重复包含头文件
6.C语言：int <==> OC语言：NSInteger <==> swift语言：Int

//面向对象OOP
1.概念：OOP是把问题里拥有相同属性的东西建立一个类
2.特性：1)封装：将数据和基于数据的操作封装在一起，数据被保护在类的内部，系统的其它部分只有通过被授权的
操作才可以访问数据；将不需要对外提供的内容隐藏起来：把属性隐藏起来，提供公共方法对外访问；
2)继承：又称为派生；
1.定义：父类的属性(成员变量：不包括私有)和方法，子类可以直接获取；
2.派生：子类保持父类中的行为和属性，新增其它功能；
3).多态：程序中可以有同名的不同方法共存，利用子类对父类方法的覆盖和重载在同一个类中定义多个同名的方法来实现；
3.面向对象编程/面向过程编程的区别：
1)面向对象编程是把问题中拥有相同属性的东西建立一个类，然后创建类的对象；
2)面向对象编程注重生活逻辑、面向过程编程注重数学逻辑；

//类：属性+行为(谁最清楚这个行为，那么行为就属于谁)
1.定义：具有相同和相似性质对象的抽象就是类；对象的抽象就是类，类的具体化就是对象（堆内存）；
2.类 = 结构体(存储数据) + 函数(管理数据)；swift中结构体作用很大！！！

//类方法
1.概念：C++中的静态方法/不属于任何一个对象/通过类名调用，不需要创建对象/不能直接调用对象方法和成员变量
2.对一个功能模块留下简单的对外接口：+(void)addNum:(NSInteger)newNum;

//单例：OC语言不允许对象静态内存分配，不能声明全局变量

//构造方法
1.定义：OC中称所有init开头的方法为构造方法/只能被调用一次；
2.作用：初始化对象/初始化对象的成员变量；
3.-(instancetype)init {
    /// 保留父类初始化操作：调用父类方法
    // 如果调用对象方法：super就是指向父类对象的指针
    // 如果调用类方法：super就是指向父类的指针
    self = [super init];
    /// 重写构造方法
    // 子类方法会覆盖父类方法
    if (self) {
        // 初始化对象的成员变量
        _name = "10";
        _age = 12;
    }
}
4.-(instancetype)initWithName:(NSString *)name withAge:(NSInteger)age {
    self = [super initWithName:name withAge:age]; // 调用父类
    // 自定义构造方法
}

//多态：同一个接口不同的实现、父类指针指向子类对象
1.重写：重新实现子类方法（子类最终执行重写以后得方法）
2.重载：在同一个类定义多个同名方法（每个方法具有不同参数类型和个数）
注意：！！！Objective-C语言没有严格的方法重载！！！
3.实现条件：1).继承关系；2).重写；3).父类指针指向子类对象
4.应用场景：可以减少代码量、避免调用子类特有方法需要强制类型转换

//权限修饰：见WMController.swift/WMGameProxy.h/m

//字符串：FoundationNSObject.h/m

//数组
1.NSArray：不可变数组/数组的长度确定
2.NSMutableArray：可变数组/数组的长度不确定/类
1).NSMutableArray是一个类
2).数组元素不能是基本数据类型int，必须是对象的引用(指针)

//字典
1.NSDictionary

//类别/扩展
1.一旦使用类别给已有的类增补方法，那么这个类的对象就可以使用该方法；
2.给已有的类/系统原生类增加方法：组件化的基础
3.可以对类的方法进行分类管理：将类的实现分散到多个不同的文件和框架中；
注意：1).类别中不能添加成员变量；2).使用类别必须导入类别头文件；3).父类类别中的方法子类也可以使用
4.类扩展/匿名类别：当不想对外公开一些类的方法时可以使用类扩展
@interface SyPerson()
// 可以声明成员变量
// 声明和实现都在.m文件中/可以实现私有方法
-(void)song;
@end

//点语法和属性
1.概念：属性可以在不使用[对象指针 方法名称]的情况下使用点语法
2.注意：点语法只是访问setter/getter方法，不是使用成员变量
//这里不是使用成员变量
xiaoMing.name = @"小明"; <==> [xiaoMing setName:@"小明"];
NSString *name = xiaoMing.name; <==> NSString *name = [xiaoMing getName];

//封装、继承、多态

//网络基础
1.json解析/XML解析

//内存管理
1.C语言的内存管理：
2.oc的内存管理：

//选择器

//协议和代理

//文件操作

//异常处理
@try...@catch...@finally

// RunLoop

// Runtime

// KVC、KVO

// 多线程
/**************************UI基础**************************/
//认识UI(User Interface)
1.概述：用户通过UI与App进行交互/传入用户的请求/反馈运行的结果

//iOS的坐标体系

//Main()函数

//UIWindow

//ViewController的生命周期
1.第一次加载vc：loadView->viewDidLoad->viewWillAppear->viewDidAppear；
//push
2.跳转第二个vc：viewWillDisappear->loadView->viewDidLoad->viewWillAppear->
viewDidDisappear->viewDidAppear；
//present
2.跳转第二个vc：loadView->viewDidLoad->viewWillDisappear->viewWillAppear->
viewDidAppear->viewDidDisappear；
//pop、dismiss
3.返回第一个vc：viewWillDisappear->viewWillAppear->viewDidDisappear->viewDidDisappear
->dealloc；//不重新创建第一个vc，第二个vc销毁
参考：SySkillController.h/m
https://blog.csdn.net/spicyshrimp/article/details/70886516

//定时器
//UIView
//UILabel

//停靠模式Autoresize
1.概念：控制父视图改变大小时，子视图的变化方式；服务于父视图边界修改后，子视图的重新布局
2.作用：等比例缩放、横竖屏旋转
@property (strong,nonatomic) UIViewAutoresizing autoresizingMask;
UIViewAutoresizingNone      = 0  //NO
UIViewAutoresizingFlexibleLeftMargin   = 1 << 0  //右边界和父视图的距离不变，左边界自由
UIViewAutoresizingFlexibleWidth    = 1 << 1  //自由的宽度：左右边距与父视图保持不变
UIViewAutoresizingFlexibleRightMargin  = 1 << 2  //左边界和父视图的距离不变，右边界自由
UIViewAutoresizingFlexibleTopMargin   = 1 << 3  //下边界和父视图的距离不变，上边界自由
UIViewAutoresizingFlexibleHeight    = 1 << 4  //自由的高度，上下边距保持不变
UIViewAutoresizingFlexibleBottomMargin  = 1 << 5  //上边界和父视图的距离不变，下边界自由
3.在xib中怎么使用autoresizingMask：外部4根线固定边距、内部2根线固定宽高和父视图的比例

//UIViewController
1.负责管理UIView：创建/销毁UIView、显示/隐藏UIView、处理UIView和用户之间的交互

//Gif

//传值

//UITableView
一定要搞懂UITableViewDataSource/UITableViewDelegate的所有方法

//关于适配
1.系统适配：
2.机型适配：
3.控件适配：

//自动布局：
1.autosizing：设置视图和父视图的尺寸关系/iOS6.x以前

//Xib/Interface Builder：
/**************************项目实战**************************/
// 开发App
1.模块分析：
2.
3.

//数据的持久化
1.沙盒：
2.
3.

//通信：
1.程序之间通信：

//常见类库：需要分析源码
NSObject

//常见系统库：需要理解怎么用
Foundation-提供OC的基础类
UIKit-创建和管理App的UI
QuartzCore-提供动画特效以及通过硬件进行渲染能力
CoreGraphics-提供2D绘制的基于C的API
SystemConfiguration-检测当前网络是否可用和硬件设备状态
AVFoundation-提供音频录制和回放的c底层API，同时负责管理音频硬件
CFNetwork-访问和配置网络
CoreFoundation-提供抽象的常用数据类型
CoreLocation-使用GPS和WI-FI获取位置信息
GameKit-为游戏提供网络功能：点对点互联和游戏中的语音交流
AddressBook-提供访问用户联系人信息的功能
AddressBookUI-提供用户界面：显示存储在地址簿中的联系人信息
AudioToolBox-提供音频录制和回放的底层API，同时负责管理音频硬件
AudioUnit-提供一个接口，让App可以对音频进行处理
MapKit-为App提供内嵌地图的接口
MediaPlayer-提供播放视频和音频的功能
MessageUI-提供视图控制接口用以处理E-mail和短信
OpenGLES-提供动画特效以及通过硬件进行渲染的能力
StoreKit-为App提供在程序运行中消费的支持

//常见三方libs：需要分析源码
Masonry/SnapKit-用于屏幕适配
MagicRecord-用于简化CoreData
CSStickyHeaderFlowLayout-实现头部悬停
FLAnimatedImage-让GIF播放不卡
SVPullToRefresh-上拉加载/下拉刷新控件
Reachability-用于检测网络类型
SAMKeychain-keyChain保存

//真机调试
1.bundle ID：一般是“反向域名+产品名称”cn.com.donew.easy/不支持中文
2.
3.
4.
/**************************swift基础**************************/
/**************************实用技术(swift版本)**************************/
/**************************补充部分**************************/
//知识点：
https://www.cnblogs.com/W-Kr/p/5248316.html  //解析html
http://modelend.com  //在线json转模型
https://mp.weixin.qq.com/s/ynkun7E1niuXfnnNBRap8Q  //iOS13

//工具网站：
https://soft.macx.cn
https://xclient.info

//抓包：
1.工具：Charles
2.作用：抓包可以很快定位问题
3.步骤|注意事项：
1).下载安装抓包工具Charles
2).将mac的网络分享出去|手动配置端口、ip
3).如果需要抓取https、需要安装证书
4.衍生的面试题：
1).你平时在工作中使用过抓包工具吗？一般是用来干嘛的？
2).抓包的步骤是怎么样的？通过步骤你能猜测一下抓包的工作原理吗？
3).抓包可以抓https吗？怎么才可以让https不被抓包工具抓取？

// iOS13、ipadOS、MacOS
1.
2.
3.

// 开发工具的使用
1.CocoaPods的使用：
2.VSCode的使用：https://code.visualstudio.com/docs

// Xcode编译原理
1.GCC编译器：
2.LLVM(Clang前端专门用来编译代码)：

// 名词术语
WWDC - 全球开发者大会

//知识点速查：
libs // 常见第三方库
WMGameProxy.txt  // 常见知识点/初中级工程师
SYGameProxy.txt  // 常见面试题/中高级工程师
DNGameProxy.txt  // 项目管理/资深工程师
WMGame.swift  // swift基础知识
SyCustomView.swift // swift自定义控件
WMController.swift // swiftUI知识
AppDelegate.h/m   // 常见系统问题查询
SyGameProxy.h/c   // C语言基础知识
WMGameProxy.h/m   // OC基础知识
SyDefaultCustomView.h/c // OC自定义控件
FoundationNSObject.h/c // Foundation常见类
ComponentController.h/m // UI组件库
SyTableViewController.h/m  // UITableView详解
SyCollectionViewController.h/m // UICollectionViewController详解
WMWebViewController.h/m  // js和原生交互详解
SySkillController.h/m // 技能事例
MainController.h/m  // 事例代码
DemoController.h/m // 作业
WMGameProxy.pch // 预编译
WMGameProxy-Bridging-Header.h // 桥接文件
