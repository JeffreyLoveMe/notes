/**
名称：笔记
作者：谢吴军
*/
/**************************计算机基础**************************/
//开班须知
//iOS开发
//Mac快捷键
//XCode快捷键
//常用终端命令
//vi编译器
//计算机常识
//进制转换
//原码/补码/反码
/**************************C语言基础**************************/
//C语言概述
//main函数
//C语言的执行流程
//关键字
//标识符

//预处理指令






















//注释：不会参与编译(不会被翻译成0和1)/可以用来查看代码段
1.单行注释：// 单行注释
2.多行注释：/*多行注释*/
3.文档注释：/**文档注释 @brief*/
ps.对于很难的逻辑：可以先写注释、再写代码

//数据类型：任何变量都有数据类型
1.静态数据：一般以文件的形式存储在硬盘/静态数据类型->动态数据类型：从磁盘加载到内存
2.动态数据：一般存储在内存中/访问速度快/动态数据类型->静态数据类型：手机拍照
3.计量单位：1B(Byte) = 8bit(10101010)/1KB = 1024B/1MB = 1024KB/1GB = 1024MB/1TB = 1024GB
4.分类：基本数据类型(short/int/long/char/float/double)/构造类型/指针类型/空类型
1).整型：默认int/short2/int4/long8/unsigned无符号整数（正数）/signed有符号整数
2).浮点型：用来存放小数/默认double/float4/double8
3).字符型：字符型变量/'A'对/'12'错
4).字符串常量："ADC"

//常量：不能改变的量
1.整型常量(整数)：二进制/八进制/十进制/十六进制
short sum = 10; int sum = 15; long sum = 100;
signed  有符号整型/unsigned 无符号整型
2.实型常量(小数)：默认情况下所有小数都是double
float sum = 5.2f; //单精度
double sum = 88.8; //双精度
3.字符型常量：普通字符/转义字符
char sum = 'a' //''只能存放单个字符
char sum = '13' //错误：13是由2个字符组成
char name = '男' //错误写法：一个汉字占3个字节
ps.'\n'虽然有两个字符组成、但是还是字符型常量/转义字符：通常以'\'开头/有实际意义/终端看不到输出结果
4.字符串常量："hello world"/"a"也是字符串常量
ps.常量在内存中有存储空间吗？

//变量：可以改变的量
1.使用变量之前必须先定义变量(申请一块存储空间)
int sum; //定义变量：分配唯一的存储空间/申请一块存储空间
sum = 9; //给变量赋值：给存储空间存储数据/变量的第一次赋值称为初始化init/使用变量之前必须init、不然存储的都是垃圾数据
int value,number; //连续定义：开辟两块存储空间/声明的时候就会开辟存储空间
printf("value = %i",value); //获取value：占位符/编译期间才知道具体数值
int number = 10; //定义同时初始化：变量第一次赋值称为init/先init、才能使用
//完全初始化：未init变量的值是随机的，实质是垃圾数据
int value,number;
value = number = 10;
//部分初始化：value没有init/number = 10
int value,number = 10;
2.作用域：从 "定义的那一行" 开始直到 “大括号 / return”结束/一对"{}"可以看做一个"存储空间"
1).局部变量：定义在{//...}内部的变量、必须init、存储在栈内存
2).全局变量：定义在所有函数外部的变量、不能定义的同时init、存储在静态区
3).作用域结束：变量销毁/内存管理
3.内存分析：
1).内存是由字节地址组成的/字节地址是连续的
2).内存寻址：从大到小/&变量名称：变量的详细地址/先定义的内存变量地址一定大于后定义的变量
printf("%p\n",&number) //输出变量的详细地址：十六进制/首字节地址：小的那个/%p可以打印详细地址
4.字符
char A; // 错误：A没有 '' 表示标识符
char "A" // 错误： " " 表示字符串
char '12' // 错误： " " 表示2个字符
char '中' // 错误：不能存放中文/中文2个字节
char 'a'  // 正确
char ch = 10; // 正确

//printf()函数/scanf()函数
1.printf()函数：输出函数
1).格式符：%i/d（整数）、%f（浮点数）、%c（字符）、%lf（double）、%.mf（保留小数点后m位）
2).指定位宽：%mf、%mi //m就是位宽(占据几列)/默认右对齐、左边补空格
int number = 99;
float value = 3.1456
printf("%5i",number); //"补3个空格"99
printf("%-5i",number); //99"补3个空格"
printf("%05i",number); //宽度不够补0、够了按照实际输出/宽度够直接显示/0表示补充0、5表示占5列
printf("%.2f",value); //保留两位小数
printf("%.*f",n,value); //保留n位小数
//怎么计算有效位数：从第一位开始3.1415926
2.scanf()函数：输入函数/阻塞式函数/敲击\n告诉系统输入完毕/不能加文字性说明
int number; //定义number接收数据
printf("请输入一个数据：")
scanf("%i",&number); //必须加上&
scanf("%i,%i",&num1,&num2); //FIXME-什么情况下，scanf()函数自动终止？
实现原理：scanf()函数只要输入缓冲区中有内容，就不会要求用户输入数据；
3.有效位数：从第一位开始算起/float有效位数为7位(系统固定)/double有效位数位15位

//运算符
1.算术运算符：+|-|*|/|%  //相同类型变量才能算术运算：结果类型不变
result = 1 + 3 + 6 * 5 / 3; //result = 14 |优先级：*|/ > +|-
result = -10 % 3; //result = -1/result正负性取决于左边的操作数/%只能用于整型
1).自动类型转换(隐式转化)/"大类型"->"小类型"/会损失精度
int num = 10.8; //int占4个字节/double占8个字节
printf("number = %i\n", num); //number = 10
2).强制类型转换(显式转化)：原表达式的值不变、强转以后结果改变
int num = (int)10.8; // 有可能丢失精度
3).自动类型提升：系统会将"小类型"->"大类型"/不会损失精度
int result = 10+9.9; //只有相同类型的数据才可以运算：必须"自动类型提升"
注意：参与运算的操作数类型和结果的类型必须一致；
2.赋值运算符：=|+=|-=|*=|/=|%= //结合性：从右到左/优先级很低
result = 5; result += 5; //result = 10
3.自增/自减运算符：
int result = 5;
int sum = result++; //先赋值、再result+1/result = 6/sum = 5
int sum = ++result; //先result+1、再赋值/result = 6/sum = 6
4.sizeof运算符：一个数据类型/常量/变量在内存中占有字节数
int size = sizeof(10);=>int size = size 10; //()可以省略
int x = 9.8; int size = sizeof(x);=>int size = sizeof x; //()可以省略
int size = sizeof(float); //()不能省略
注意：sizeof运算符是一个运算符，不是一个函数；
5.逗号运算符：','
// 一般很少使用 ','  获取表达式的结果/一般使用 ',' 连接多个表达式
// ',' 连接多个表达式：类似于&&的含义
if let count = array.count, let size = count + 1 {
    //整个 , 表达式的结果等于最后一个表达式的值
}
6.关系运算符：>|<|>=|<=|==|!= // C语言规定：非0即真、0为假
a = 10, b = 5; // "="/"=="的区别
int result = a > b;// 怎么理解：a>b吗？
优先级：1.>、<、>=、<=优先级大于!=、==先优先级、再结合性；
2.算术运算符 > 关系运算符 > 逻辑运算符/先"优先级" --> 再"结合性"
7.逻辑运算符：&&、||、!
int sum = a && b; // 与
int sum = a || b; // 或
int sum = !a; // 从右至左
int result = 4 < 5 < 6  // 错误：(5 > 4) && (5 < 6)
注意：1.C语言规定所有的数值都有真假性，非0即真；
2.&&、||会出现短路现象：只要前面的条件为假、真，后面的不再执行
int x = 100; int result = (x > 200) && (++x == 0);   // x = 100
int y = 100; int result = ( y < 200) || (++y == 0);  // y = 100
8.三目运算符:
int max = a > b ? a : b;

//输入函数/输出函数|scanf()/printf()
int a;
scanf(“%d”,&a); // 从键盘输入整型变量a的值/scanf函数里面不能做文字性的说明
printf(“%d”,a); // "\n"不能用在scanf()函数中/只能用在printf()函数中

//流程控制基本概念
1.if语句：if语句可以嵌套/嵌套可以使用&&、||、!替代/互斥
if(表达式1) {
    //执行代码
}
//必有一个执行
if(表达式1) {
    //执行代码
} else {
    //执行代码
}
if(表达式1) {
    //执行代码
} else if (表达式2) {
    //执行代码
} else {
    ///执行代码
    //可以不需要这一句/可选类型
}
if(表达式1) //执行代码：只能执行第一句
2.switch语句：C语言中'条件表达式'的返回值只支持整数/switch的效率比if高/注意格式
switch (条件表达式) {
// case不能重复/不能放置变量/没有if灵活
case 整数: {
    //执行代码
}
    break; // 跳出当前case
// default可以随便放置/可以放置在上面/也可以放置在最底下/default永远都是最后执行
default: {
    //执行代码
}
    break; // break只能用于switch和循环结构
}

//循环语句：反复执行某一段代码
1.循环格式：都是不满足条件停止执行
1).while()语句：当条件满足开始执行循环体直到不满足条件停止执行
while(表达式) {
    //循环体
}
2).do-while()语句：先执行循环体直到不满足条件停止执行/最少执行一次循环体
do {
    //循环体
} while(表达式)
3).for()语句：最常使用的循环语句/企业级开发只要会使用for()足够
for(语句1;表达式;语句2) {
    //循环体
}
2.死循环：下面不允许写无法访问的语句
1).while (YES) {
    // 循环体
}
2).for (;1;) {
    // 循环体
}
3).RunLoop
3.循环嵌套：
for(int i = 0;i < 2; i++) {
    for(int j = 0; j < 5; j++) {
        // i = 0 -> j = 0,1,2,3,4
        // i = 1 -> j = 0,1,2,3,4
        break; // 跳出循环体、终止循环
        continue; // 跳出本次循环、开始下次循环
    }
}
4.循环思想：累加思想/计数思想
5.如果循环的增量在执行完毕循环体以后还需要使用-while/如果循环的增量在执行完毕循环体以后不再使用-for
6.分析内存管理：指定一块内存空间代表该项目 --> 遇到"声明属性"需要开辟内存空间 --> 遇到 {} 需要开辟内存空间

//数组
1.概念：数组是一组有序数据的集合，数组中每个元素都具有相同的数据类型
/// 一维数组
/*
定义一个长度为5的数组
array-数组名
5-数组长度
array[0]...array[4]-数组元素
*/
int array[5];
array[5] = {1, 8, 9, 10, 18, 25}; // 数组元素完全init：可以部分init/未init的元素为0
int count = array[5]; // 数组访问越界/Segmentation fault
///二维数组
1.概念：元素是一维数组的数组称为二维数组
int array[4][3]; // 定义：4代表横行X轴，3代表竖行Y轴
// 4;二维数组中一维数组的个数/行数
// 3;每个一维数组的元素个数/列数
array[4][3] = {
    {1,4,6},
    {1,7,8},
    {8,5,6},
    {4,5,7}
}; // init

//三种排序（冒泡、选择、快速）
//函数：见SyGameProxy.h/c
//局部变量/全局变量

//内存管理
1.变量为什么要定义类型？每种类型占用的内存空间不一样
2.内存寻址：从大到小/先定义的变量内存地址越大
int p = 10;
printf("int类型的p内存地址：%p", &p); // &p取出地址
3.以"补码"形式存储/从高位->低位/一个字节存储8位

//字符串
1.概念：由字符组成的串""/可以使用数组来保存字符串/%s
2.“字符串”和“普通字符数组”的区别：字符串以“\0”结尾，字符串比字符数组多一个元素
char str[] = "xwj";
printf("---%s---", str);
3.了解的方法：#include <ctype.h>
int isalpha(int c); //判断单个字符是否是字母
int isnumber(int c); //判断单个字符是否是表示数字
int isupper(int c); //判断单个字符是否是大写字母
int islower(int c); //判断单个字符是否是小写字母
int toupper(int c); //将单个字符转换为大写字母
int tolower(int c); //将单个字符转换为小写字母
4.掌握的方法：#include<string.h>
//sizeof(const char *s)占用字节大小
size_t strlen(const char *s); //！！！返回字符串的有效字符个数：与sizeof()区别？！！！
char *strcat(char *s1,const char *s2); //！！！将s2的内容拼接到s1后面形成新的字符串s1！！！
//返回子串在s1中首次出现位置的第一个字符的地址
char *strstr(const char *s1, const char *s2); //在字符串s1中，寻找子串s2首次出现的位置
//s1必须有足够大的空间，如果数组越界，可能导致未知的错误
char *strcpy(char *s1,const char *s2); //将字符串s2拷贝到字符数组s1，返回s1
char *strchr(const char *s,char c); //查找字符串s中首次出现字符c的位置，不存在c,返回NULL
//s1 > s2 -> 返回正数，s1 < s2 -> 返回负数，s1 == s2 -> 返回0
int strcmp(const char* s1,const char* s2); //比较两个字符串的大小关系
char *strrchr(char *str, char c); //在串中查找指定字符的最后一个出现，失败返回NULL

//指针
//值传递/指针传递
//结构体/枚举/共用体
/**************************Objective-C基础**************************/
//认识Objective-C语言
1.概述：面向对象(oop)的C语言/完全兼容C语言/C语言代码可以直接编译在Objective-C工程中；
2.源文件：.h/.m/.mm；
3.关键字：C语言关键字在oc中都可以使用/新增部分关键字：@interface、@public、@implementation等；
4.数据类型：BOOL/SEL/null
5.#include -可能会出现重复包含头文件/#import -可以避免重复包含头文件
6.C语言：int <==> OC语言：NSInteger <==> swift语言：Int

//面向对象OOP
1.概念：
1>.OOP是把问题里拥有相同属性的东西建立一个类
2.特性：
1>.封装：利用类将数据和基于数据的操作封装在一起，数据被保护在类的内部，系统的其它部分只有通过
被授权的操作才可以访问数据；将不需要对外提供的内容隐藏起来：把属性隐藏起来，提供公共方法对外访问；
2>.继承/派生：1.继承：父类的属性（成员变量：不包括私有）和方法（对象方法 & 类方法），子类可以直接获取；2.派生：子类保持父类中的行为和属性，新增其它功能（对象方法 & 类方法可以重写、属性不能重写）；3.提示：每个类都有一个[super class]指针指向自己父类（OC只支持单继承）；4.好处：1).创建大量类抽取重复代码；2).建立类与类之间的关系；3).耦合性（依赖性）太强；
3>.多态：程序中可以有同名的不同方法共存，利用子类对父类方法的覆盖和重载在同一个类中定义多个同名的方法来实现；
3.面向对象编程/面向过程编程的区别：
1>.面向对象编程是把问题中拥有相同属性的东西建立一个类，然后创建类的对象；
2>.面向对象编程注重生活逻辑、面向过程编程注重数学逻辑；

//主头文件
1.主头文件 - copy该工具箱中所有工具的头文件的文件
2.避免每次使用都需要导入一众对应的头文件
3.主头文件的名称都和工具箱的名称相同

//类class：属性 + 行为（谁最清楚这个行为，那么行为就属于谁）
1.定义：具有相同和相似性质对象的抽象就是类；对象的抽象就是类，类的具体化就是对象（堆内存）；
2.类 = 结构体(存储数据) + 函数(管理数据)；！！！swift中结构体作用很大！！！
3.实质：类的实质是一个对象，该对象会在这个类第一次被使用的时候创建；

//类方法
1.概念：C++中的静态方法/不属于任何一个对象/通过类名调用，不需要创建对象/不能直接调用对象方法和成员变量
2.对一个功能模块留下简单的对外接口：+(void)addNum:(NSInteger)newNum;
3.类方法的执行效率比对象方法高：对象方法可以访问成员变量/类方法中不可以直接访问成员变量；

//单例模式

//构造方法
1.定义：OC中称所有init开头的方法为构造方法/只能被调用一次
2.作用：初始化对象/初始化对象的成员变量
3.-(instancetype)init {
    /// 保留父类初始化操作：调用父类方法
    // 如果调用对象方法：super就是指向父类对象的指针
    // 如果调用类方法：super就是指向父类的指针
    self = [super init];  // 1.初始化父类
    /// 重写构造方法
    // 子类方法会覆盖父类方法
    if (self) {   // 2.判断父类是否初始化成功
        // 只有父类初始化成功才可以初始化子类
        // 初始化对象的成员变量
        // 除了这里其他地方都是固定方法
        _name = "10";  // 3.初始化子类
        _age = 12;
    }
    return self;  // 4.返回当前对象地址
}
4.-(instancetype)initWithName:(NSString *)name withAge:(NSInteger)age {
    self = [super initWithName:name withAge:age]; // 调用父类
    // 自定义构造方法
}
特点：一个类中可以自定义零到多个构造方法；构造方法可以有一个到多个参数

//多态：同一个接口不同的实现、父类指针指向子类对象
1.重写：重新实现子类方法（子类最终执行重写以后得方法）
2.重载：在同一个类定义多个同名方法（每个方法具有不同参数类型和个数）
注意：！！！Objective-C语言没有严格的方法重载！！！
3.实现条件：1).继承关系；2).重写；3).父类指针指向子类对象
4.应用场景：可以减少代码量、避免调用子类特有方法需要强制类型转换

//权限修饰：见WMController.swift/WMGameProxy.h/m
//字符串、数组、字典（FoundationNSObject.h/m）

//Category类别
// 1.作用
1.一旦使用类别给已有的类增补方法，那么这个类的对象就可以使用该方法；
2.不修改原有类的基础上给已有的类/系统原生类增加方法：组件化基础；
3.可以对类的方法进行分类管理：将类的实现分散到多个不同的文件和框架中；
// 2.注意
1.类别中不能添加成员变量；
2.使用类别必须导入类别头文件；
3.父类类别中的方法子类也可以使用；
// 3.类扩展/匿名类别：当定义不想对外公开一些类的方法和属性时可以使用类扩展
@interface SyPerson()
// 可以声明私有成员变量
@property (weak, nonatomic) UIImageView *iconImageView;
// 可以声明私有方法：声明和实现都在 “.m文件” 中
-(void)song;
@end

//点语法和属性
1.概念：属性可以在不使用[对象指针 方法名称]的情况下使用点语法
//只是访问setter/getter方法/不是使用成员变量
xiaoMing.name = @"小明"; <==> [xiaoMing setName:@"小明"];
NSString *name = xiaoMing.name; <==> NSString *name = [xiaoMing getName];
2.点语法是一个编译器特征：在程序翻译成二进制的时候自动转换成getter/setter方法

//设计模式（23种设计模式）
1.概念：描述软件开发过程中若干重复出现的问题的解决方案
2.目的：提高程序的可扩展性和维护性

//异常处理
NSArray *array = [NSArray array];
@try {
    // 可能会出现异常的代码
    [array objectAtIndex:5];
} @catch (NSException *exception) {
    // 如果捕捉到错误：执行此处的代码
    NSLog(@"%@", exception);
} @finally {
    // 可选：必执行代码
    NSLog(@"finally");
}

//多态和虚方法
//类的消息机制
//“抽象工厂”模式
//协议和代理（代理实现回调）
//内存管理（数组的内存管理/继承和派生在内存中的体现）
//MRC/ARC（混合编程）
//选择器
//文件操作
//block（block实现回调）
//RunLoop
//Runtime
//KVC、KVO
/**************************UI基础**************************/
//认识UI(User Interface)
1.概述：用户通过UI与App进行交互/传入用户的请求/反馈运行的结果
2.坐标系：坐标系(0,0)在左上角，x轴向右x正向延伸、y轴向下正向延伸

//Apple设备（尺寸、分辨率、坐标）
//iOS的坐标体系
//Main()函数
//UIWindow
//ViewController的生命周期
//NSTimer定时器
//UIView/动画
//UILabel
//UIButton
//UIImageView
//UIApplication
//AppDelegate
//UITextFIeld
//UINavigation
//UIPageController
//UINavigationController
//TabBarController
//UIViewController
//Gif动画
//传值
//手势
//菜单
//UIScrollView
//UIPageControl
//UICollectionView
//iOS动画

//停靠模式Autoresize
1.概念：控制父视图改变大小时，子视图的变化方式；服务于父视图边界修改后，子视图的重新布局
2.作用：等比例缩放、横竖屏旋转
@property (strong,nonatomic) UIViewAutoresizing autoresizingMask;
UIViewAutoresizingNone      = 0  //NO
UIViewAutoresizingFlexibleLeftMargin   = 1 << 0  //右边界和父视图的距离不变，左边界自由
UIViewAutoresizingFlexibleWidth    = 1 << 1  //自由的宽度：左右边距与父视图保持不变
UIViewAutoresizingFlexibleRightMargin  = 1 << 2  //左边界和父视图的距离不变，右边界自由
UIViewAutoresizingFlexibleTopMargin   = 1 << 3  //下边界和父视图的距离不变，上边界自由
UIViewAutoresizingFlexibleHeight    = 1 << 4  //自由的高度，上下边距保持不变
UIViewAutoresizingFlexibleBottomMargin  = 1 << 5  //上边界和父视图的距离不变，下边界自由
3.在xib中怎么使用autoresizingMask：外部4根线固定边距、内部2根线固定宽高和父视图的比例

//UITableView
0.熟悉 UITableView 的常用属性
1.熟悉 UITableViewDataSource/UITableViewDelegate 的所有代理方法
2.熟悉 cell的复用机制
3.熟悉 UITableView 的编辑/多选/折叠

//UIPasteboard

//自动布局
1.autosizing：设置视图和父视图的尺寸关系/iOS6.x以前

//Xib/Interface Builder
1.IBAction和IBOutlet的区别？？？
IBAction用于方法/IBOutlet用于属性
/**************************网络基础**************************/
// 网络概述
1.基础概念：
Client客户端 - 移动应用/ iOS、Android应用
Server服务端 - 为客户端提供服务、数据和资源
Request请求 - 客户端向服务端索取数据的一种行为
Response响应 - 服务端对客户端请求的反应
URL - 统一资源定位符(网址)/协议+主机ip地址+端口号+资源/使用利于记忆的符号来代替IP地址
HTTP协议 - 超文本传输协议/规定客户端和服务端之间的数据传输格式/交互方法GET/POST/PUT/DELETE
2.数据下载：
同步下载：使用主线程进行下载，在下载完成前，线程阻塞
异步下载：开辟新线程负责下载，主线程不会卡死，当子线程完成，回调主线程

// json解析
// xml解析
// xPath
// socket通信
// NSURLSession原生网络请求
/**************************项目实战**************************/
//数据持久化
1.plist
2.
3.

//通信
1.
2.
3.

//真机调试
1.bundle ID：一般是“反向域名+产品名称”cn.com.donew.easy/不支持中文
2.
3.
4.

//适配
1.系统适配：
2.机型适配：
3.控件适配：

//多语言
常见语言： en/tw/hk/cn
定义：根据用户设置的Language and Region Format（语言和区域格式）修改应用本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html
https://www.jianshu.com/p/c7a6408410aa

//启动图-https://www.jianshu.com/p/a0f53f66ccbe/Launch Screen File > Launch Images Source/一般不设置“Launch Screen File”
//多线程
//用户通知
//LBS
//多媒体（图片/音频/视频/直播）
//分享
//三方登录
//多语言
//支付
//断点续传
//IM
//“原生” 与 “js交互”
//Objective-C和Swift混合编程
//二维码
//图文混排
//传感器
//AR
//近景通讯技术（蓝牙）
//iPad开发
//svn/git/CocoaPods
//应用发布（打包测试 / TestFlight /企业包 / AppStore）
//组件化（静态库）
//Cocoapods
//通知中心
//Auto Layout
//地图
//消息推送/本地推送
//即时通讯

///常见系统库
//1.基础框架
NSObject-基类（考虑分析源码）
Foundation-提供OC的基础类
UIKit-创建和管理App的UI
//2.核心框架
QuartzCore-提供动画特效以及通过硬件进行渲染能力/画图相关库
CoreGraphics-提供2D绘制的基于C的API/画图相关库
SystemConfiguration-检测当前网络是否可用和硬件设备状态
CFNetwork-访问和配置网络
CoreFoundation-提供抽象的常用数据类型
GameKit-为游戏提供网络功能：点对点互联和游戏中的语音交流
AddressBook-提供访问用户联系人信息的功能
AddressBookUI-提供用户界面：显示存储在地址簿中的联系人信息
AudioToolBox-提供音频录制和回放的底层API，同时负责管理音频硬件
AudioUnit-提供一个接口，让App可以对音频进行处理
//3.地图框架
MapKit-为App提供内嵌地图的接口
CoreLocation-使用GPS和WI-FI获取位置信息
//4.音视频框架
AVFoundation-提供音频录制和回放的c底层API，同时负责管理音频硬件
MediaPlayer-提供播放视频和音频的功能
MessageUI-提供视图控制接口用以处理E-mail和短信
OpenGLES-提供动画特效以及通过硬件进行渲染的能力
StoreKit-为App提供在程序运行中消费的支持
Security.framework -xxx
libsqlite3.tbd -xxx
libsqlite3.0.tbd -xxx

//常见三方libs
1>.需要分析理解源码
AFNetworking-网络请求下载相关库
Masonry/SnapKit-用于屏幕适配
FMDB-操作数据库相关库
MagicRecord-用于简化CoreData
SVPullToRefresh-上拉加载/下拉刷新控件
JSONKit-xxx
JSONModel/MJExtention-字典转模型
MJReFresh-上拉刷新/下拉加载
SDWebImage-图片下载/上传
2>.需要知道怎么使用
JXSegmentedView-多控制器滑动视图
MBProgressHUD-加载loading
SAMKeychain-keyChain保存
Reachability-用于检测网络类型
CSStickyHeaderFlowLayout-实现头部悬停
FLAnimatedImage-让GIF播放不卡
FXBlurView-实现高斯模糊
https://blog.csdn.net/liuzhihui666/article/details/70152940
https://blog.csdn.net/MinggeQingchun/article/details/77160892

// 开发App
1.
2.
3.
/**************************swift基础**************************/
//怎么导入框架
//swift简介
//定义标识符
//swift语句结束
//常量和变量
//类型推导
//swift中基本运算
//逻辑分支
//循环
//字符串
//数组
//字典
//元组
//可选类型
/**************************实用技术(swift版本)**************************/
/**************************补充部分**************************/
//知识点：
https://www.cnblogs.com/W-Kr/p/5248316.html  //解析html
http://modelend.com  //在线json转模型
https://mp.weixin.qq.com/s/ynkun7E1niuXfnnNBRap8Q  //iOS13

//工具网站：
https://soft.macx.cn
https://xclient.info
https://www.macbed.com
http://down.applex.net/macosx/software.html

//抓包：
1.工具：Charles
2.作用：抓包可以很快定位问题
3.步骤|注意事项：
1).下载安装抓包工具Charles
2).将mac的网络分享出去|手动配置端口、ip
3).如果需要抓取https、需要安装证书
4.衍生的面试题：
1).你平时在工作中使用过抓包工具吗？一般是用来干嘛的？
2).抓包的步骤是怎么样的？通过步骤你能猜测一下抓包的工作原理吗？
3).抓包可以抓https吗？怎么才可以让https不被抓包工具抓取？

// iOS13、ipadOS、MacOS
1.
2.
3.

// 开发工具的使用
1.VSCode的使用：https://code.visualstudio.com/docs

// Xcode编译原理
1.XCode4.0以前使用GCC编译器：
2.XCode4.0以后使用LLVM(Clang前端专门用来编译代码)：

// LLVM项目
// Clang编译器
// Instruments
// RxSwift
// ReactiveCocoa
// Scrumj敏捷开发

// 著名网站
stackoverflow - IT问答网站/可以找到90%以上的答案
https://www.jianshu.com/p/e37914c4d3d9 - iOS大佬博客
http://github.com/lintaoSuper/trip-to-iOS - gitHub

//名词术语
WWDC-全球开发者大会
UUID-设备唯一标识（ https://www.jianshu.com/p/0dce89cdf9f6 ）
UDID-设备识别码（真机调试 / App上架）
邓白氏-xxx
僵尸对象-被释放的对象/开启监听"僵尸对象"( Edit Scheme->Run->Diagnostics->勾选Zombie Objects )
野指针-指向僵尸对象的指针
nil空指针-为了避免给野指针发送消息报错，当一个对象被释放以后我们会将这个对象的指针设置为空指针

//知识点速查：
libs // 常见第三方库
WMGameProxy.txt  // 常见知识点/初中级工程师
SYGameProxy.txt  // 常见面试题/中高级工程师
DNGameProxy.txt  // 项目管理/资深工程师
WMGame.swift  // swift基础知识
SyCustomView.swift // swift自定义控件
WMController.swift // swiftUI知识
AppDelegate.h/m   // 常见系统问题查询
SceneDelegate.h/m // iOS13新特性
SyGameProxy.h/c   // C语言基础知识
WMGameProxy.h/m   // OC基础知识
SyMemoryManager.h/m // 内存管理
WMGameView.h/m    // OC自定义控件
FoundationNSObject.h/c // Foundation常见类
ComponentController.h/m // UI组件库
SyTableViewController.h/m  // UITableView详解
SyCollectionViewController.h/m // UICollectionViewController详解
SyCustomFlowLayout // 自定义"流式布局"
SyCustomCell.h/m // 自定义 Cell
SyPostItem.h/m // 自定义 Model
WMWebViewController.h/m  // js和原生交互详解
SySkillController.h/m // 技能事例
MainController.h/m  // 事例代码
NSString+Extension.h/m // 类目
DemoController.h/m // 作业
WMGameProxy.pch // 预编译
WMGameProxy-Bridging-Header.h // 桥接文件
