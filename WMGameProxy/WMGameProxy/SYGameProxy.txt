！！！！黑魔法！！！！/KVO的工作原理
！！！！“原生” 与 “js交互”！！！！
！！！！动画！！！！
//App启动优化：有哪些建议？了解过dyld吗？
//符号是怎么绑定在地址上的？能写一个hotReload框架吗？
//iOS崩溃是什么导致的？如何监控不同类型的崩溃？
//如何获取详细的内存分配信息：比如不同线程的堆栈调用？
//Apple为什么设计元类？
//Xcode中选择模拟器编译，在 products 中生成的二进制文件后缀是什么？
/// 换一种通用写法
77.图片裁剪方法

107.版本控制
/*
1.在MAC环境下,自带了SVN服务器端和SVN客户端功能,所以只需做一下简单地配置
2.SVN的使用
更新数据:
cd  工程目录
svn update
 
上传数据:
将数据放到工程目录
svn commit -m '本次修改你要说的话'
 
上传失败:
svn status
? 表示没有被svn工具管理的文件（夹）
A 表示被标记为新文件（夹）
C 表示冲突的文件（夹）
! 表示已经被版本管理控制,但是在文件夹下边找不到
D 表示已经被标记为删除
 
没有被svn工具管理的文件（夹）:
如果文件是？,代表这个文件夹不被svn所管理。可以
svn add 文件   //表示这个文件夹以及下边的所有的子目录和文件,全部变成add状态
 
删除被svn版本管理控制的文件:
svn delete
 
遇到冲突:
mc(mine  side)   保留自己做的修改,放弃别人做的修改
tc(their side)   保留别人做的修改,放弃自己做的修改
p(postpone)      保留冲突状态,手动解决
 
手动解决冲突:
在<<< === >>>有两个区间,每一个区间代表谁做的修改。解决冲突：要把左尖括号、右尖括
号、等号删除！
手动解决完了所有的冲突(一定要注意解决完了所有的冲突,可以在代码里边搜索======,都没
有的情况下,才算是解决完了所有的冲突)把已经标记为冲突的文件标记为已解决

svn地址重定向:
cd  工作目录
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --
username sally --password sallyssecret
10.5.154.237  上次svn的地址
10.5.154.142  本次svn的地址
sally         你的用户名
sallyssecret  你的密码
 
svn恢复:
svn revert . -R
svn地址重定向

cd 进入工作目录

svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --username sally --password sallyssecret
SVN客户端
SmartSVN
Versions
CornerStone

svn批量添加、批量删除
将所有状态为问号的，使用svn add批量添加
svn st | grep '^\?' | tr '^\?' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn add
将所有状态为叹号的，使用svn delete --force批量删除
svn st | grep '^!' | tr '^!' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn delete --force
*/
108.消息推送、本地推送
/*
推送功能一般分为两种:本地推送和远程推送
1.对于本地推送(UILocalNotification),我们可以先注册通知,然后新建本地推送
,设置本地推送的属性,最后我们执行推送（会调用一个方法）
2.对于远程推送,我们使用第三方极光推送。登录注册极光推送（创建iOS应用开发证
书,在极光推送递交证书创建应用,获取AppKey）
3.下载SDK,添加到项目中。最后按照极光推送官方文档操作
*/
112.即时通讯
/*
即时通讯（IM）
一.底层原理
1）用于IM的协议：XMPP（基于XML的协议,具有超强的可扩展性）
2）XMPP有三个部分：服务器 网关 客户端（可以任意两个双向发生）
2）XMPP的优缺点
1.优点：
XMPP协议是自由开源的,而且在C/S都有多种实现
任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接
我们用XMPP技术开发软件,资源以及支持的来源都是多样的,这样就不会被“绑架”
XMPP以TCP传递XML数据流,没有中央主服务器,任何人都可以运行自己的XMPP服务器
XMPP基于XML具有很强的扩展性
2.缺点
XMPP协议的服务器流量存在着被重复转发,使数据负载太重
XMPP协议是基于XML文件的（编码成单一的XML文件）,因此无法提供修改二进制数据
 
二.上层实现（利用环信）
1.环信：通过云端开放的Rest api或者客户端SDK包（摆脱了IM底层开发）,使APP内置聊天功能
2.步骤
1）注册登录“环信”
2）创建应用（应用名称会存在你的AppKey）,生成AppKey和相关配置文件
3）制作并上传推送证书
1.进入developer.apple.com
2.点击Member Center,进入Certificates,Identifiers&Profiles,制作证书
3.选择对应的App ID
4.根据Certificate Assistant的提示,创建Certificate Request
5.上传上一步中创建的Certificate Request文件
6.下载下来这个证书,并双击导入系统
4)上传证书
1.打开Application-Utilities-Keychain Access应用,我们会看到有刚刚制作
好的推送证书
2.选中证书对应的私钥,点右键,选择导出,并设定密码
3.登录环信后台
4.选择对应的App,填写证书名称
5.上传（选择的是开发环境证书还是生产证书）
5）通过cocoapods下载SDK
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件： #import <EaseMobSDKFull/EaseMob.h>
6）设置工程属性
1.导入SDK依赖库（Xcode7.0,后缀是tbd）
MobileCoreServices.framework
CFNetwork.framework
libEaseMobClientSDKLite.a
libsqlite3.dylib
libstdc++.6.0.9.dylib
libz.dylib
libiconv.dylib
libresolv.dylib
libxml2.dylib
2.向Build Settings-Linking-Other Linker Flags中添加-ObjC(注意大小
写）
如果项目中使用-ObjC有冲突,可以添加-force_load来解决：
格式：-force_load[空格]EaseMobSDK/lib/libEaseMobClientSDKLite.a(静
态库的路径-SDK lib里面拖过来) 在-force_load下面
3.编译没错误则说明集成SDK成功
*/
122.瀑布流
#指针：
定义：变量的地址(唯一标识一块内存的索引)；
int a;//a变量名、&a变量地址
int *p;//定义一个指针变量p：p指针变量名、*指向
指针变量p的作用：用来存储地址；
*p：指p指向的内容；
p = &a;//将整型变量a的地址赋给指针变量p
*p = a;//*p是p指向的变量
int *p;//变量p是int*类型、int是p指向变量的基类型
int *p = NULL;//指针变量p初始化为空、不能使用空指针
int *p;//未初始化的指针称为野指针、不能使用野指针
printf("&a=%p",&a);//输出变量a的地址：％p地址格式符
注意：1.定义指针时，一定要初始化为空；
2.指针做为参数或者已经赋值，则无需初始化为空；
3.使用指针前，一定要给指针赋值；
4.使用指针时，一定要判空；
if(p == NULL) {
    return;
}
//指针大小：固定4个字节-因为地址在内存中都是以整型的方式分配的

#数组和指针：
概述：数组名作为函数参数，代表数组的首地址；
int *p = NULL;
int a = 5;
p = &a;
p++;//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
//指针数组
int *p[10];//数组：每个元素都是个指向整型的指针
//指向数组的指针
int (*p)[10];//指针：指向10个int元素的数组
//指向指针的指针
int **p;//指针：指向指针
//指向函数的指针
int (*p)(int a);//指向函数的指针
//指针作为函数返回值
格式：数据类型* 函数名(形参列表) {//...}
//交换两个变量？
1.传值：无法实现交换；
2.传地址：交换指针指向，无法实现交换；
3.传地址：交换指针指向变量的值，可以实现交换；

#结构体：
定义：相同或者不同数据类型变量的集合，自定义的数据类型；
格式：放在头文件下面、所有函数上面
//结构体定义用struct关键字，名字为data
struct data {
    //成员变量
    int a;
    char b;
    short c;
};
//结构体别名：wm_data
typedef struct data {
    int a;
    char b;
    short c;
}wm_data;
//难点：结构体指针？

#枚举：枚举就是一串宏
定义：如果变量只有几种可能的值，可以使用枚举；
//枚举可以有无数个：不推荐使用
typedef enum direction {
    枚举1,
    枚举2,
    枚举3
} direction_t;
//定义通用枚举：只能同时存在一个枚举值
typedef NS_ENUM(NSInteger,WMDirection) {
    枚举1,
    枚举2,
    枚举3
};
//定义位移枚举：可以同时存在多个枚举值
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    枚举1,
    枚举2,
    枚举3
};

#共用体：使几个不同变量共同占用一段内存的结构
union date {
    int a;
    char b;
    short c;
};
大小：1.共用体变量所占内存长度等于最长成员的长度；
2.共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种；
3.共用体变量中起作用的成员是最后一次存放的成员；
/******************************Objective-C语言基础******************************/
#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？

#数据持久化的方法
1.数据库：
//sql语句：结构化查询语言
1.创建表
create table if not exists sso (
id integer primary key autoincrement,//将id设为主键
author text,//文本
price real,//浮点型
pages integer);//整型
2.插入
insert into sso (author,price,pages) values(?,?,?);
3.更新
update sso set price = ?,pages = ? where author = ?;
4.删除
delete from sso where pages > ?;
5.查询
select * from sso;
//FMDB
代码：SqliteViewController.h/m
//MagicalRecord：
一.Core Data：
1.新建Core Data；
2.新建表：写上需要存储的文件；
3.关联生成属性类；
二.导入数据：
4.导入MagicalRecord；
三.app启动：
5.设置数据库存放的文件名；
6.让Magical Record支持数据库版本管理；
7.查询所有的数据库内容，如果有内容则送到数据源；
if([MusicInfo MR_findAll].count) {
    for(MusicInfo *music in [MusicInfo MR_findAll]) {
        MusicInformation *musicInfo = [[MusicInformation alloc] init];
        musicInfo.songUrl = music.songUrl;
        musicInfo.songName = music.songName;
        musicInfo.songId = music.songId;
        musicInfo.userName = music.userName;
        musicInfo.albumName = music.albumName;
        musicInfo.albumPic = music.albumPic;
        [[MusicManager sharedIntance].selectMusics addObject:musicInfo];//把对象加到数据源
    }
}
四.app杀掉：
8.删除数据库里的表，将数据源保存；
for(MusicInfo *music in [MusicInfo MR_findAll]) {
    [music MR_deleteEntity];//删除数据表
}
[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
9.新建数据库的表，将数据源所有内容放到数据库，保存；
for(MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
    MusicInfo *zNewMusic = [MusicInfo MR_createEntity];//新建数据表
    zNewMusic.songName = newMusic.songName;
    zNewMusic.songUrl = newMusic.songName;
    zNewMusic.songId = newMusic.songId;
    zNewMusic.userName = newMusic.userName;
    zNewMusic.albumName = newMusic.albumName;
    zNewMusic.albumPic = newMusic.albumPic;
}
/*
1.数据的增删改查
2.多表的链接查询
3.数据回滚
*/
http://hao.jobbole.com/magicalrecord

/******************************补充知识点******************************/
#函数式编程思想(高聚合：代码聚合、方便管理)：把很多功能放在一个函数块(block)去处理
int a = ({
b = 2;
c = 3;
d = 4;
b + c + d; //最后一句设置返回什么
});
UIButton *btn = ({
UIButton *btn = [UIButton alloc]init];
btn.tag = 1;
btn;//最后一句设置返回什么
})
/******************************Objective-C语言基础******************************/
#类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#数据源：
实质：数据源实质就是一个数组(NSArray、NSMutableArray)；
Model类必须是单例：全局都可能使用这个Model；
VC需要网络请求，可以委托(PostStore类)来进行网络请求；
PostStore类网络请求完成，需要告诉VC网络请求操作完成；

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#实现画折线图：利用第三方库
1.加入tk库文件；
2.添加QuartzCore.framework；

#多语言：en/tw/cn
定义：根据用户设置的Language and Region Format(语言和区域格式)修改应用
本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html //特别详细
https://www.jianshu.com/p/c7a6408410aa

#用户通知：
//概述：
推送功能一般分为两种：本地推送和远程推送；
1.对于本地推送(UILocalNotification)，我们可以先注册通知；
然后新建本地推送，设置属性；最后执行推送(会调用某个方法)；
2.对于远程推送，我们使用第三方极光推送，按照极光推送文档操作；
//本地通知(本地推送)：
定义：由App发送到当前设备，不需要网络支持；
问题：什么时候使用本地通知？App在前台需要与客户交互的时候使用本地通知；
本地通知怎么在AppDelegate.m中使用？
代码：AppDelegate.m
//远程通知(远程推送)：由App服务端->APNs服务器->设备
https://www.jianshu.com/p/ad43bc1a970a

#基于位置的服务LBS：
//系统定位
1.导入MapKit.framework，创建MKMapView
2.显示用户位置，把MKMapkit加到self.view，设置代理
3.导入CoreLocation.framework，创建CLLocationManager(定位对象)设置属性
4.问用户是否允许更新用户信息：开始更新
5.设置代理
6.需要在Info里边添加两项:
1)当APP在前台的时候才使用,会跟用户弹出一个确认框：
NSLocationWhenInUseUsageDescription
2)当APP总是请求用户定位的时候,会跟用户弹出一个确认框：
NSLocationAlwaysUsageDescription
代码：MapViewController.h/m
//大头针：知道经纬度就可以标注位置
1.导入两个框架 MapKit.framework、CoreLocation.framework；
2.创建MKMapView把地图显示出来；
3.定义显示标注的类(MyAnnotation类)，实现MKAnnotation协议；
4.从协议复制属性，初始化协议属性；
5.给地图添加标注：MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
6.给地图添加标注：[self.mapview addAnnotation:a];
代码：MKAnnotation.h/m
//高德地图
1.登录LBS开放平台，申请Key；
2.下载相关SDK和实例代码；
https://blog.csdn.net/a910577347/article/details/73499515
//百度地图
1.登录LBS开放平台，获取密钥；
2.下载相关SDK和实例代码；
https://www.jianshu.com/p/b0169d332918
//腾讯地图
1.登录LBS开放平台，获取参数；
2.下载相关SDK和实例代码；
https://blog.csdn.net/liyun123gx/article/details/44222255
96.map（大头针）
/*
1.有哪些技术可以实现定位：GPS 基站
2.系统提供两个框架：MapKit.framework   CoreLocation.framework
3.MKMapView可以加载地图
4.有三种地图类型
typedef NS_ENUM(NSUInteger, MKMapType) {
MKMapTypeStandard = 0,
MKMapTypeSatellite,
MKMapTypeHybrid,
MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
} NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED;
5.设置代理
*/
/*
1.CL-CoreLocation框架
2.导入CoreLocation框架,使用CLLocationManager核心类
3.创建CLLocationManager核心类
4.[self.locationmanager locationServicesEnabled]为YES-GPS服务可用
*/
/*
在地图上标注位置
1.导入两个框架 MapKit.framework   CoreLocation.framework
2.创建MKMapView把地图显示出来
3.定义显示标注的类（MyAnnotation类）,实现MKAnnotation协议
1）从协议复制属性
2）初始化协议属性：
4.给地图添加标注
MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
//给地图添加标注
[self.mapview addAnnotation:a];
//平移
MKCoordinateRegion region;
region.center.latitude=30.5;
region.center.longitude=116.8;
region.span.latitudeDelta=10;
region.span.longitudeDelta=10;
self.mapview.region=region;
5.知道经纬度就可以标注位置（具体位置借助API）
//定位
需要在Info里边添加两项
当APP在前台的时候才使用，会跟用户弹出一个确认框
NSLocationWhenInUseUsageDescription
当APP总是请求用户定位的时候，会跟用户弹出一个确认框
NSLocationAlwaysUsageDescription
*/
97.地图导航
/*
 高德地图：
 1.高德LBS开放平台：LBS-基于位置的服务
 2.申请Key
 3.下载相关SDK和示例代码
 百度地图：
 1.百度LBS开放平台：
 2.获取密钥（一个密钥对应一个bundle identifier）
 3.相关下载-全部下载
 */

#多媒体：图片、音乐、录音、视频
//上传照片：UIImagePickerController-选择图片类(代理类)
注意：保存图片、UIAlertController打不开
//音频：流的形式
音频录音机-AVAudioRecorder
音频播放器-AVAudioPlayer
//视频：vitamio
视频播放器-MPMoviePlayerController
代码：MediaViewController.h/m
练习：找出实用的第三方框架开发出商用级别项目；
https://blog.csdn.net/Dreamandpassion/article/details/82459246
https://www.jianshu.com/p/d8062b1856f3

92.多媒体（图片、音乐、录音、视频）
/*
1.多媒体：图片,声音,录音,视频
2.UIImagePickerController 选择图片类（代理类）
3.AVFoundation  音乐类（代理类）
1）导入第三方库
2）定义声音对象,创建声音对象
3)创建播放对象,需要传入一个URL,此URL指定了媒体文件的位置,从包里求出MP3的路径是个
字符串
4)设置代理
4.图片：
判断传入的参数(照相机、相册)是否被当前的设备所支持
创建选择图片的对象
设置图片对象打开相册还是照相机
设置控件的代理
显示控件
当选择了一张图片时,会进入到这个代理函数
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
     //被选择的图片,以UIImage对象封装起来,在info的UIImagePickerControllerOriginalImage key值里边
    UIImage *pickImage = info[UIImagePickerControllerOriginalImage];
    self.imageView.image = pickImage;
    //实现了此函数,就需要自己手动地隐藏控件
    [picker dismissViewControllerAnimated:YES completion:^{
    }];
}
//音乐播放
 - (void)play:(id)sender {
 //播放之前,先准备播放
 if ([self.player prepareToPlay]) {
 //准备播放没问题,开始播放
 [self.player play];
 }
}
 - (void)pause:(id)sender {
 //暂停
 [self.player pause];
}
 - (void)stop:(id)sender {
 //停止
 [self.player stop];
 }
 currentTime:当前播放的位置(以秒为单位)(可读写)
 duration:声音的总长度(以秒为单位)(只读)
 - (NSString *)formatTimeWithTimeInterval:(NSTimeInterval)interval {
 NSInteger minute = interval / 60;
 NSInteger second = (NSInteger)interval % 60;
 return [NSString stringWithFormat:@"%ld:%02ld", minute, second];
 }
 - (void)timer:(id)sender {
 self.currentTime.text = [self formatTimeWithTimeInterval:self.player.currentTime];
 if (!self.slider.tracking) {
 self.slider.value = self.player.currentTime / self.player.duration;
 }
}
*/
//第三方支付：
http://www.cocoachina.com/ios/20151008/13506.html#0-qzone-1-88885-d020d2d2a4e8d1a374a433f596ad1440
1.支付宝：
https://blog.yayuanzi.com/12276.html
https://openhome.alipay.com/platform/document.htm#down
http://www.cnblogs.com/siyuan123/p/4872378.html?from=timeline&isappinstalled=0
2.微信：
https://www.jianshu.com/p/af8cbc9d51b0
https://www.jianshu.com/p/162ece335b31
3.银联：NO
4.平台币：NO
5.集成三方平台支付：海马、同步推、爱思

#断点续传：
定义：指任务在上传/下载的时候被人为划分为几个部分：每个部分采用一个线程进行上传/下载，如果遇到网络故障可以
继承在未完成的部分继续开始，没必要从头开始下载。
//原理
https://www.cnblogs.com/wangzehuaw/p/5610851.html
https://www.cnblogs.com/findumars/p/5745345.html
//实现
https://www.jianshu.com/p/0e6deea7de87
https://www.jianshu.com/p/01390c7a4957
https://blog.csdn.net/stree7cleaner/article/details/51440774
https://blog.csdn.net/lcg910978041/article/details/51487485

#即时通讯IM：
//底层原理：
1.协议：XMPP协议(基于xml的协议，具有超强的可扩展性)
2.XMPP的三个部分：服务器、网关、客户端(可以任意两者双向发生)
3.XMPP优缺点：
//优点：
1).XMPP协议是自由开源的，而且在C/S都有多种实现；
2).任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接；
3).利用XMPP技术开发软件，资源以及支持的来源都是多样的，这样就不会被“绑架”；
4).XMPP以TCP传递XML数据流，没有中央主服务器，任何人都可以运行自己的XMPP服务器；
5).XMPP基于XML具有很强的扩展性；
//缺点：
1).XMPP协议的服务器流量存在着被重复转发，数据负载太重；
2).XMPP协议基于XML文件(编码成单一的XML文件)，因此无法提供修改二进制数据；
//上层实现：环信
概述：环信通过云端开放的Rest api或者客户端SDK，摆脱IM底层开发，使App内置聊天功能；
步骤：1.制作推送证书、登录环信后台、创建应用生成AppKey；
2.通过cocoapods下载SDK：
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件：#import <EaseMobSDKFull/EaseMob.h>
3.按照环信集成开发文档操作；

#二维码：
应用：ZBarSDK第三方库
https://blog.csdn.net/he_jiabin/article/details/47786031

#App数据统计：
//实时在线人数：使用NSTimer
//热云
//TD

#App换肤：
http://www.cocoachina.com/ios/20171012/20762.html

#图文混排：
https://blog.csdn.net/qcx321/article/details/52194835

#webview混排：
https://blog.csdn.net/u010960265/article/details/80563668

#iPad开发：
//iPad和iPhone开发的异同
https://blog.csdn.net/wujakf/article/details/80223046
//iPad项目开发总结
https://www.jianshu.com/p/522c8993572b

#git：开源的分布式版本控制工具(master/branches/tags)
开发者：Linux操作系统的作者Linus Torvalds；
客户端：SourceTree
安装：NO
创建代码仓库：git init
配置身份：查看是否配置OK
git config --global user.name "Tony"
git config --global user.email "tony@gmail.com"
添加：git add 文件名
提交：git commit -m "说明.txt"
加入.gitignore-允许用户将指定的文件或目录排除在版本控制之外的机制；
查看状态：git status
查看修改内容：git diff
撤销修改：git checkout
查看提交内容：git log
删除person.m文件：git rm person.m
版本回退：git reset --hard HEAD //没有push
1.git reset --hard HEAD^ //有push、回到上一个版本
2.git push -f //强制推送：必须让同事也要版本回退、不然同事本地不是消失！！！
git reset --hard HEAD^^ //回到上上一个版本
git reset --hard HEAD~100 //回到前100个版本
git reset --hard HEAD 版本号(前5位) //回到指定版本
//git分支：
查看分支：git branch -a
创建分支：git branch 分支名
合并分支：git checkout master->git merge 分支名
删除分支：git branch -D 分支名
解决冲突：git无法帮助你；
#与远程版本库协作：NO
//.gitignore
https://github.com/github/gitignore
//忽略UserInterfaceState.xcuserstate的方法：
https://blog.csdn.net/lovenjoe/article/details/50053255
//打tag：发现bug可以直接把这个tag变成分支
git tag -a tag名 -m "你想要说你的话"
git tag
git push origin tag名
//ssh keys认证
1.公钥：存在github上用来解密的key
2.私钥：存在本地一个.ssh文件夹下用来加密

/******************************补充知识点******************************/
#正则表达式：
代码：NewNetworkViewController.h/m
搜索NSRegularExpression

#谓词： NSPredicate
概念：OC中谓词操作是针对于数组类型的，这样的好处是我们可以不需要编写很多代码就可以去操作数组、过滤数据；
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searcgString];
_ArrM = [NSMutableArray arrayWithArray:[_Arr filteredArrayUsingPredicate:predicate];//过滤数据

#DrawRect：NO
概念：Quartz 2D是一个基于CoreGraphics框架来实现的二维绘制引擎，同时支持iOS和Mac系统；
作用：绘制图形、线、三角形、圆、弧形；绘制文字；绘制/生成pdf；截图/裁剪图片；自定义UI；
https://blog.csdn.net/potato512/article/details/56845385
https://blog.csdn.net/mangosnow/article/details/37054765#0-qzone-1-85099-d020d2d2a4e8d1a374a433f596ad1440

#iOS11/12新特性：
https://www.jianshu.com/p/39a5aee18778

1.二维数组
1）定义：元素是一维数组的数组称为二维数组
int arr[4][4];
2）二维数组的初始化
int arr[4][4]={   {1,2,3,4},
               {2,3,4,5},
               {3,4,5,6},
               {4,5,6,7} };
3）二维数组的赋值
arr[0][0] = 4;
arr[2][1] = 4;


1.指针
1）指针就是变量的地址；地址就是唯一标识一块内存的索引
int  a;
a         //a是变量名
&a     //a的地址
&       //取地址符

2）指针变量
1.int  *p;   //定义一个指针变量p
   p           //p是指针变量名
  ＊        //指向
指针变量p的作用：指针变量时用来存储地址的
*p: 指p所指向的内容

2.给指针变量赋值
 p=&a;    // 将整型变量a的地址赋给指针变量p
               //p指向变量a，指针变量p同一时刻只能指向一个变量
  a＝3;    //直接的改变了变量a的值
 *p=5;   //间接的改变了变量a的值
            //＊p是p指向的变量

3.指针作为函数参数的使用
int *p; //变量p是int*类型
            //int是p指向的变量的基类型

4.空指针和野指针
int *p = NULL；   //指针变量p初始化为空
                              //NULL代表空，值为0；
                             //不能使用空指针

int  *p；     //未初始化的指针称为野指针
                   //不能使用野指针
3）printf("&a=%p,&b=%p\n",&a ,&b );   //输出变量a,b的地址，％p地址格式符
int *p=NULL;        //p初始化为空，不能使用空指针
4）使用指针注意事项：
1）定义指针时，一定要初始化为空；
int *p=NULL;//指针作为参数或者已经赋值，则无需初始化为空。
2）使用指针前，一定要给指针赋值；
3）使用指针时，一定要判空
if(p==NULL) {
    return;
}

5)指针大小
固定4个字节（因为地址在内存里都是一整型的方式分配的）
char *p
int *q
//p和q都是4个字节。

例如：交换两个变量
#include "jiaohuan.h"
//传值，无法实现交换
void Swap1(int a,int b)
{
    printf("swap1：%p,%p\n",&a,&b);
    int t;
    t = a;
    a = b;
    b = t;
}
//传地址，交换指针指向，无法实现交换
void Swap2(int *c,int *d)
{
    printf("swap2：%p,%p\n",c,d);
    int *t;
    t = c;
    c = d;
    d = t;
}
//传地址，交换指针指向变量的值，可以实现交换
void Swap3(int *e,int *f) {
    printf("swap3：%p,%p\n",e,f);
    int t;
    t = *e;
    *e = *f;
    *f = t;
}
#include <stdio.h>
void Swap1(int a,int b);
void Swap2(int *a,int *b);
void Swap3(int *a,int *b);

#include <stdio.h>
#include "jiaohuan.h"
int main(int argc, const char * argv[]) {
    // insert code here...
    int a = 3;
    int b = 5;
    printf("主函数:%p,%p\n",&a,&b);
    Swap1(a, b);
    printf("a=%d,b=%d\n",a,b);
    
    int c = 3;
    int d = 5;
    printf("主函数:%p,%p\n",&c,&d);
    Swap2(&c, &d);
    printf("c=%d,d=%d\n",c,d);
    
    int e = 3;
    int f = 5;
    printf("主函数:%p,%p\n",&e,&f);
    Swap3(&e, &f);
    printf("e=%d,f=%d\n",e,f);
}

1.指针
1） 数组和指针
数组名作为函数的参数
数组名代表数组的首地址

2）指针++
int *p=NULL;
int a=5;
p=&a;
p++;
//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数。
//指针的移动：必须赋值地址才可以实现指针的移动，不可以赋值指针所指的内容
 q=p  //正确；
q=*p  //错误；
*q=*p//错误；

2.理解内容：
指针数组
int *p[10];
//这是一个数组，10个元素，每个元素都是个指向整型的指针。
//元素为指针的数组
练习：
快速的声明20个int *指针，分别指向int a[20]中的每个元素
指向数组的指针
int (*p)[10];
//这是一个指针，指向10个int元素的数组。
//指向数组的指针
指向指针的指针
int * * p;
//这是一个指针，指向指针
//二级指针
指向函数的指针
int (*p)(int a);//指向函数的指针
//这是一个指针，指向一个函数。
//函数指针
函数指针的声明方法为：
返回值类型 ( * 指针变量名) (形参列表);

3.字符串
1.认识字符串:字符串就是一串字符。
由一对双引号括起来，双引号里面可以写一串字符 。
//“hello world!”是字符串常量。
//字符串中的每个字符占1个字节，字符的个数，比可视的字符多一个。在字符串结尾处有一个’\0’，称作尾零，其ASCII值就是0.
//如上述字符串中有13个字符，12个有效字符。
例如：int arr[5] = {3,4,5,6,7};
char arr[10] = “hello”;   //长度10
char arr[] = “hello”;     //长度6

2.指向字符串的指针：
char * p = "1234567";
//当我们程序中写下"1234567"，就是在【只读数据段】存储了8个字符。
//"1234567”的值只代表第一个字符的所在空间的地址。
练习：
主函数定义一个字符串，编写函数，传递字符串，统计一下字符串中字母的个数；将统计结果返回给主函数。

3.指针作为函数返回值
数据类型＊  函数名（形参列表）
char * MyStr(char * const str,char c);
在字符串str中查找字符c，返回第一次找到c的首地址，如果找不到，则返回NULL；
#include <stdio.h>
char * MyStr(char * str,char c) {
    if(NULL == str) {
        return NULL;
    }
    while (* != '\0') {
        if(*str == c)
        {
            break;
        }
        str++;
    }
    if (*str == '\0') {
        return NULL;
    } else {
        return str;
    }
}
int main(int argc, const char * argv[]) {
     char *p = "hello c dddworld!";
     char *r = MyStr2(p, 'c');
    printf("%s\n",r);
    return 0;
}

char * MyStr2(char * str,char c);

2.结构体
定义：相同或不同数据类型变量的集合
1.结构体的定义
struct data {
    int a;
    char c;
    short b;
};
 
#include <stdio.h>
//结构体定义用struct关键字，结构体名字为data
//结构体命名遵循标示符的定义
//定义一个结构体后，一个新的数据类型诞生了，结构体是自定义的数据类型
//结构体的声明一般放在头文件内，或者 .c 文件的最上面(放在include定义的下面，放在所有函数的上面)
struct data {
    //{}里是定义结构体的成员变量，成员变量可以有无数个，成员变量的数据类型可以相同或不同
    //结构体的成员变量也叫做结构体的属性
    int i;
    char c;
    short b;
};

//结构体取别名
//方式1：在定义结构体时直接取别名，用typedef关键字
//如下定义相当于给struct student取别名为stu
typedef struct student {
    int age;
    char name[10];
    int num;
}stu;

//方式2：定义结构体之后，另起一行取别名
struct class {
    int a;
    short b;
};
//完成给struct class取别名为cla
typedef struct class  cla;

int main(int argc, const char * argv[]) {
    // insert code here...
    //定义一个结构体类型的变量d(也叫做创建一个结构体对象d)
    //struct data是一个结构体类型，相当于int
    //结构体变量也叫做结构体对象
    struct data d;
    //结构体的初始化
    //结构体初始化要分别对每个成员变量进行初始化
    struct data d1 = {5,'a',3};
    
    int a;
    a = 3;
    
    //结构体对象的赋值
    //通过对象访问结构体成员变量用 . 进行访问
    struct data d2;
    d2.i = 4;
    d2.c = 'x';
    d2.b = 3;
    
    //结构体指针
    int *p;
    p = &a;
    *p = 4;
    
    //定义一个结构体指针
    struct data *pst;
    pst = &d2;

    //结构体指针通过 -> 来访问成员变量
    pst->i = 5;
    pst->c = 't';
    
    //结构体数组
    int arr[5];
    
    //定义一个长度为5的结构体数组
    struct data sct[5];
    
    //通过结构体数组访问成员变量
    sct[0].i = 7;
    sct[0].c = 'u';
    sct[3].i = 6;
    
    return 0;
}

文件操作
1.数据持久化的方法
通常程序在运行中或者程序结束之后，需要保存一些信息，而且需要持久化存储信息,比如登陆信息、视频播放记录、收藏记录等等,那么我们可以采用以下几种方式对数据进行持久化保存。1.文件    2.plist    3.数据库
2.常用文件操作类
1）NSFileManager（文件管理类）
<1>创建文件管理器单例对象
[NSFileManager defaultManager];

<2>遍历目录下的内容
//浅度遍历当前目录下的文件
[manager contentsOfDirectoryAtPath:path error:&error]

//深度遍历
[manager subpathsOfDirectoryAtPath:path error:&error]

<3>判断文件是否存在
[manager fileExistsAtPath:path]

<4>创建文件
//创建文件
/*参数1：创建文件的路径
参数2：内容，如果nil表示创建一个内容为空的文件。
参数3：nil表示采用默认的设置*/
//如果文件已经存在，会覆盖原来文件。
[manager createFileAtPath:path contents:data attributes:nil];
    
//创建目录
/*参数1：文件夹路径
参数2：是否有中间目录(YES针对所有的情况)
参数3：nil表示采用默认设置
参数4：错误*/

//不会覆盖文件夹内容
[manager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];

<5>拷贝文件/目录
//从哪个路径copy
NSString *fromPath = @"/Users/qianfeng/Desktop/文件夹/testff.txt";
//copy哪个路径
NSString *toPath = @"/Users/qianfeng/Desktop/文件夹/新建文件夹/testff.txt";
//如果文件已经存在是copy不成功的
[manager copyItemAtPath:fromPath toPath:toPath error:&error];

<6>移动文件/目录
[manager moveItemAtPath:fromPath toPath:toPath error:&error];

<7>删除文件/目录
[manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件夹/新建文件夹" error:nil]

<8>获取文件属性    (返回的是字典)
[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件夹/testff.txt" error:nil];

2.3 NSFileHandle（文件句柄类）
对文件进行读写首先需要NSFileHandle打开文件,NSFileHandle对文件进行读写都是NSData类型的二进制数据.
                
<1>打开文件方法
//以只读方式打开
NSFileHandle *readOnlyHandle =  [NSFileHandle fileHandleForReadingAtPath:path]
//以只写方式打开
NSFileHandle *writeOnlyHandle = [NSFileHandle fileHandleForWritingAtPath:path]
//以读写方式打开
NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:path]

<2>读指定长度的数据（单位为字节)
[readOnlyHandle readDataOfLength:5]或者 [readWriteHandle readDataOfLength:5]

<3>从当前偏移量读到文件尾
[readOnlyHandle readDataToEndOfFile];

<4>设置文件偏移量（单位为字节)
[readOnlyHandle seekToFileOffset:5];

<5>将文件偏移量定位到文件尾
[readOnlyHandle seekToEndOfFile];

//如果希望这次写入的数据完全覆盖掉原有数据
//常规做法，短的写入，无法覆盖长的数据
//可以截断原来数据
[readWriteHandle truncateFileAtOffset:0];
//截断到0字节长，即清空原有数据。

<6>写文件(不会覆盖的时候需要设置偏移量)
//当前偏移量指到文件最后
[readWriteHandle seekToEndOfFile];
//写入数据
[readWriteHandle writeData:data];

[readWriteHandle writeData:[@"12345678945343543534543" dataUsingEncoding:NSUTF8StringEncoding]];

 <7>关闭文件句柄
//关闭文件句柄,关闭后(不需要)就不能再操作文件了
[readOnlyHandle closeFile];
[readWriteHandle closeFile];
[writeOnlyHandle closeFile];
1.什么是XML？
extensible Markup Language   可扩展性标记语言
特点：1.可扩展性   2.标记
标记：A.就是标签 成对出现（有开始，有结束）   B.标签区分大小写
例如：
<students>董佳迪</students>
students是标签，董佳迪是标签的值
可扩展性：1.体现在标签的名字用户自己随意命名
                    2.XML中的标签是可以嵌套的，嵌套的结构也是随意的。
示例：
<?xml version="1.0" encoding="utf-8" ?>
<Students>
  <Student id="1" >
    <name>王也</name>
    <age>18</age>
  </Student>

  <Student id="2">
    <name>孟凡路</name>
    <age>17</age>
  </Student>

  <Student id="3">
    <name>高家兴</name>
    <age>48</age>
  </Student>
</Students>
XML的相关概念：
XML经常被理解成倒挂一棵树
根节点:只能有一对根节点，位于嵌套结构中最外层的节点
在本例中 Students为根节点。
id为属性     1为属性值（属性值必须加“”）
注意点：
1.文档扩展名  .XML
2.XML跨平台。
3.主要用途就是网络传输数据
4.声明，是整个XML的第一条语句
 <?xml version="1.0" encoding="utf-8" ?>
 属性：属性值必须加""；
 注意：文档扩展名.xml、跨平台
 作用：网络传输数据
 区别：json/xml的对比
 1.目前90%的使用json、10%的使用xml；
 2.json解析简单，但是结构不易理解、xml结构容易理解，但是数据冗余；
 解析：见AnalyzeViewController.h/m
 https://blog.csdn.net/qxuewei/article/details/52369067
 
2.XML和JSON的对比
1）90%使用JSON   10%使用XML
2）JSON解析简单   XML解析复杂
3）JSON阅读时结构不易理解  ， XML容易理解，但是有数据冗余

3.XML解析
Google的GData ——第三方库
使用Google的GData解析XML

1）相关类和方法
GDataXMLNode
//获取当前节点的值
- (NSString *)stringValue;

GDataXMLElement : GDataXMLNode
//根据子节点名字获取所有的节点名为name的子节点数组
- (NSArray *)elementsForName:(NSString *)name;
//获取节点的属性
- (NSArray *)attributes;
//根据属性名获取属性节点
- (GDataXMLNode *)attributeForName:(NSString *)name;

GDataXMLDocument    //XML节点树
//创建文档节点
- (id)initWithData:(NSData *)data options:(unsigned int)mask error:(NSError **)error;
//获取跟节点
- (GDataXMLElement *)rootElement;
//根据xpath 语法 获取 指定的节点数组
- (NSArray *)nodesForXPath:(NSString *)xpath error:(NSError **)error;

2）本地解析
//读取数据
NSData *data = [[NSData alloc]initWithContentsOfFile:PATH];
        
//建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];

3）网络解析
转换为URL类型网址
NSURL * url = [NSURL URLWithString:@"http://mps.manzuo.com/mps/cate?sid=(null)&id=0&cc=beijing&pt=all&ffst=1&mnt=10&st=-1&hs=1"];

向服务器请求数据，并获得数据
NSData * data = [NSData dataWithContentsOfURL:url];

建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];

数据接口
http://www.k780.com/api

xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)
练习：
<1>http://www.oschina.net/action/api/news_detail?id=44392
xml解析
Google的GData 第三方库

今日内容：
XPath语法的使用
//XML路径语法
作用：快速的锁定某一级的节点。可以免去一层层复杂的节点搜索
XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。掌握MVC设计模式

1.选择器
#import <Foundation/Foundation.h>

@interface Person : NSObject

@property NSInteger num;
@property NSString *name;
@property NSInteger age;

-(BOOL)shortreules:(Person*)person;

@end


#import "Person.h"

@implementation Person

-(BOOL)shortreules:(Person *)person {
    BOOL a=self.age>person.age;
    if(self.age==person.age) {
        if(NSOrderedDescending==[self.name compare:person.name])
            a=YES;
    }
    return a;
}

@end


#import <Foundation/Foundation.h>
#import "Person.h"
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                Person *person1=[[Person alloc]init];
                person1.num=001;
                person1.name=@"xiaoming";
                person1.age=12;
                
                Person *person2=[[Person alloc]init];
                person2.num=002;
                person2.name=@"xiaohong";
                person2.age=12;
                
                Person *person3=[[Person alloc]init];
                person3.num=003;
                person3.name=@"hanmeimei";
                person3.age=12;
                
                NSMutableArray *arr=[[NSMutableArray alloc]initWithObjects:person1,person2,person3, nil];
                SEL sel=@selector(shortreules:);
                //NSArray *arr1 = [arr sortedArrayUsingSelector:sel];
                
                [arr sortUsingSelector:sel];
                for (Person *person in arr) {
                    NSLog(@"学号：%lu 姓名：%@ 年龄：%lu",person.num,person.name,person.age);
                }
            }
    return 0;
}


2.文件NSFileManager
#import <Foundation/Foundation.h>

#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //创建文件管理单例对象
        //NSFileManager *file = [NSFileManager defaultManager];
        NSError *error = nil;
        
        NSFileManager *manager=[[NSFileManager alloc]init];
        /*浅度遍历
        NSArray *arr =  [file contentsOfDirectoryAtPath:PATH error:&error];
        if (error != nil) {
            NSLog(@"%@",error);
        }
        NSLog(@"%@",arr);
        
         深度遍历
       arr = [file subpathsOfDirectoryAtPath:PATH error:&error];
       NSLog(@"%@",arr);*/
        
        //判断文件是否存在
        NSLog(@"%d",[manager fileExistsAtPath:PATH]);
        
        //创建文件
        NSString *str=@"飞流直下三千尺";
        
        NSData *data=[str dataUsingEncoding:NSUTF8StringEncoding];
        
        [manager createFileAtPath:PATH contents:data attributes:nil];/*参数1：创建文件的路径
                   参数2：内容，如果nil表示创建一个内容为空的文件。
                   参数3：nil表示采用默认的设置
                   如果文件已经存在，会覆盖原来文件*/
        
       NSString *fromPath =@"/Users/qianfeng/Desktop/文件/文件/main.m";
        
       NSString *toPath =@"/Users/qianfeng/Desktop/文件/Manager.h";
      
        [manager copyItemAtPath:fromPath toPath:toPath error:&error];

        [manager moveItemAtPath:fromPath toPath:toPath error:&error];
        
        [manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件/Manager.h" error:nil];
        
        //获取文件属性,返回的是字典
      NSDictionary *dic=[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件/文件/main.m" error:nil];
        for(NSString *key in dic) {
            NSLog(@"%@",[dic objectForKey:key]);
        }
    }
    return 0;
}


3.文件NSHandle
#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str = @"飞流直下三千尺，不及汪伦送我情";
        
        NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
       
        [data writeToFile:PATH atomically:YES];
        
        //创建一个可读可写的文件句柄
        NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:PATH];
        
        //设置偏移量
        [readWriteHandle seekToFileOffset:9];
        
        //读取指定长度数据
        data = [readWriteHandle readDataOfLength:6];
        
        NSString *str1 = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        
        NSLog(@"%@",str1);
        
        //设置偏移量到文件尾
        [readWriteHandle seekToEndOfFile];
        
        //从当前偏移量读取到文件尾
        data = [readWriteHandle readDataToEndOfFile];
        
        //关闭句柄
        [readWriteHandle closeFile];
        
    }
    return 0;
}


12.Json解析
1.本地解析
JSON:
{
    "error": 0,
    "status": "success",
    "date": "2015-08-24",
    "results": [
        {
            "currentCity": "北京市",
            "pm25": "30",
            "index": [
                {
                    "title": "穿衣",
                    "zs": "热",
                    "tipt": "穿衣指数",
                    "des": "天气热，建议着短裙、短裤、短薄外套、T恤等夏季服装。"
                },
                {
                    "title": "洗车",
                    "zs": "较适宜",
                    "tipt": "洗车指数",
                    "des": "较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。"
                },
                {
                    "title": "旅游",
                    "zs": "适宜",
                    "tipt": "旅游指数",
                    "des": "天气较好，但丝毫不会影响您的心情。微风，虽天气稍热，却仍适宜旅游，不要错过机会呦！"
                },
                {
                    "title": "感冒",
                    "zs": "少发",
                    "tipt": "感冒指数",
                    "des": "各项气象条件适宜，发生感冒机率较低。但请避免长期处于空调房间中，以防感冒。"
                },
                {
                    "title": "运动",
                    "zs": "适宜",
                    "tipt": "运动指数",
                    "des": "天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。"
                },
                {
                    "title": "紫外线强度",
                    "zs": "中等",
                    "tipt": "紫外线强度指数",
                    "des": "属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。"
                }
            ],
            "weather_data": [
                {
                    "date": "周一 08月24日 (实时：28℃)",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周二",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周三",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 20℃"
                },
                {
                    "date": "周四",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 21℃"
                }
            ]
        }
    ]
}


#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *zs;
@property NSString *tipt;
@property NSString *des;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"
#define PATH @"/Users/qianfeng/Desktop/本地解析/解析/2.json"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data=[[NSData alloc]initWithContentsOfFile:PATH];
        NSMutableDictionary *dic=[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        NSArray *arr=dic[@"results"];
        NSMutableDictionary *dic1=arr[0];
        NSArray *arr1=dic1[@"index"];
        NSDictionary *dic2=arr1[0];
        
        NSMutableArray *array=[[NSMutableArray alloc]init];
        Model *m=[[Model alloc]init];
        
        for(int i=0;i<[arr1 count];i++) {
            dic2=arr1[i];
            m.title=dic2[@"title"];
            m.zs=dic2[@"zs"];
            m.tipt=dic2[@"tipt"];
            m.des=dic2[@"des"];
            [array addObject:m];
        }
        
        for(Model *m in array) {
            NSLog(@"title:%@ zs:%@ tipt:%@ des:%@",m.title,m.zs,m.tipt,m.des);
        }
    }
    return 0;
}


2。网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString*uid;
@property NSString*username;
@property NSString*groupid;
@property NSString*credit;
@property NSString*experience;
@property NSString*viewnum;
@property NSString*friendnum;
@property NSString*lastactivity;
@property NSString*headimage;
@property NSString*realname;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //定义字符串网址
        NSString *strUrl = @"http://10.0.8.8/sns/my/user_list.php?number=20&page=1";
        
        //将网址转换为URL类型
        //string类型的字符串网址需要做一个转换
        //转换为NSURL类型的网址，才可以进行申请数据操作
        NSURL *url = [NSURL URLWithString:strUrl];
        
        //向网络服务器请求数据
        //同步请求数据，当服务器响应数据之前，线程一直处于卡死状态
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        
        //网络请求的数据都存储在data里了
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        //到这一步，所有的json数据都存储在字典里了
        NSArray *arr= dic[@"users"];
        NSDictionary *dic1=arr[0];
        NSMutableArray *array=[[NSMutableArray alloc]init];
        
        for(int i=0;i<[arr count];i++) {
            Model *m=[[Model alloc]init];
            dic1=[arr objectAtIndex:i];
            m.uid=dic1[@"uid"];
            m.username=dic1[@"username"];
            m.groupid=dic1[@"groupid"];
            m.credit=dic1[@"credit"];
            m.experience=dic1[@"experience"];
            m.viewnum=dic1[@"viewnum"];
            m.friendnum=dic1[@"friendnum"];
            m.lastactivity=dic1[@"lastactivity"];
            m.headimage=dic1[@"headimage"];
            m.realname=dic1[@"realname"];
            
            [array addObject:m];
        }
        for(Model *m in array) {
            NSLog(@"uid:%@ username:%@ groupid:%@ credit:%@ experience:%@ viewnum:%@ friendnum:%@ lastactivity:%@ headimage%@ realname:%@",m.uid,m.username,m.groupid,m.credit,m.experience,m.viewnum,m.friendnum,m.lastactivity,m.headimage,m.realname);
        }
    }
    return 0;
}


13.XML解析
1.本地解析
xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)

#import <Foundation/Foundation.h>

@interface Book : NSObject

@property NSString *ID;
@property NSString *lag;
@property NSString *name;
@property NSString *authorName;
@property NSInteger price;
@property NSString *summary;

@end


#import <Foundation/Foundation.h>
#import "Book.h"

@interface Manager : NSObject {
    NSMutableArray *arr;
}

- (void)addBook:(Book *)book;

- (void)show;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        arr = [[NSMutableArray alloc]init];
    }
    return self;
}

- (void)addBook:(Book *)book {
    [arr addObject:book];
}

- (void)show {
    for (Book *b in arr) {
        NSLog(@"%@",b.summary);
    }
}
@end


#import "Book.h"

@implementation Book

@end


#import <Foundation/Foundation.h>
#import "Book.h"
#import "Manager.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/demo/xml本地解析4/xml本地解析4/GData/book.xml"];
        GDataXMLDocument *doct = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootElement = [doct rootElement];
        
        //取books节点
        GDataXMLElement *booksElement = [rootElement elementsForName:@"books"].firstObject;
        
        Manager *m=[[Manager alloc]init];
        
        //取book节点
        NSArray *arr = [booksElement elementsForName:@"book"];
        
        for (GDataXMLElement *bookElement in arr) {
            GDataXMLNode *ID = [bookElement attributeForName:@"id"];
            GDataXMLNode *language = [bookElement attributeForName:@"language"];
            GDataXMLElement *nameElement = [bookElement elementsForName:@"name"].firstObject;
            GDataXMLElement *autherElement = [bookElement elementsForName:@"auther"].firstObject;
            GDataXMLElement *autNameElement = [autherElement elementsForName:@"name"].firstObject;
            GDataXMLElement *priceElement = [bookElement elementsForName:@"price"].firstObject;
            GDataXMLElement *summaryElement = [bookElement elementsForName:@"summary"].firstObject;
            
            Book *book = [[Book alloc]init];
            book.ID = [ID stringValue];
            book.lag = [language stringValue];
            book.name = [nameElement stringValue];
            book.authorName = [autNameElement stringValue];
            book.price = [[priceElement stringValue] doubleValue];
            book.summary = [summaryElement stringValue];

            [m addBook:book];
        }
        [m show];
    }
    return 0;
}


2.XML:
<?xml version="1.0" encoding="UTF-8"?>
<root name="中国">
  <province name="天津市" postcode="120000" >
    <city name="市辖区" postcode="120100" >
        <area name="和平区" postcode="120101" />
        <area name="河东区" postcode="120102" />
        <area name="河西区" postcode="120103" />
        <area name="南开区" postcode="120104" />
        <area name="河北区" postcode="120105" />
        <area name="红桥区" postcode="120106" />
        <area name="塘沽区" postcode="120107" />
        <area name="汉沽区" postcode="120108" />
        <area name="大港区" postcode="120109" />
        <area name="东丽区" postcode="120110" />
        <area name="西青区" postcode="120111" />
        <area name="津南区" postcode="120112" />
        <area name="北辰区" postcode="120113" />
        <area name="武清区" postcode="120114" />
        <area name="宝坻区" postcode="120115" />
    </city>
  </province>
</root>


#import <Foundation/Foundation.h>

@interface Area : NSObject

@property NSString *name;
@property NSString *postcode;

@end


#import "Area.h"

@implementation Area

@end


#import <Foundation/Foundation.h>
#import "Area.h"
@interface Manager : NSObject {
    NSMutableArray *_arr;
}

- (void)addArea:(Area *)area;

- (void)showAll;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        _arr = [[NSMutableArray alloc]init];
    }
    return self;
}

-(void)addArea:(Area *)area {
    [_arr addObject:area];
}

-(void)showAll {
    for (Area *area in _arr) {
        NSLog(@"name:%@,postcode:%@",area.name,area.postcode);
    }
}

@end


#import <Foundation/Foundation.h>
#import "GDataXMLNode.h"
#import "Manager.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Manager *m = [[Manager alloc]init];
        
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/伯明利－下午 /2.t/tianjin.xml"];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        
        GDataXMLElement *rootElement = [doc rootElement];
        GDataXMLNode *rootNameElement = [rootElement attributeForName:@"name"];
        Area *area1 = [[Area alloc]init];
        area1.name = rootNameElement.stringValue;
        [m addArea:area1];
        
        GDataXMLElement *provinceElement = [rootElement elementsForName:@"province"].firstObject;
        GDataXMLNode *provinceName = [provinceElement attributeForName:@"name"];
        GDataXMLNode *provincePostcode = [provinceElement attributeForName:@"postcode"];
        Area *area2 = [[Area alloc]init];
        area2.name =provinceName.stringValue;
        area2.postcode =provincePostcode.stringValue;
        [m addArea:area2];
        
        GDataXMLElement *cityElement = [provinceElement elementsForName:@"city"].firstObject;
        GDataXMLNode *cityName = [cityElement attributeForName:@"name"];
        GDataXMLNode *cityPostcode = [cityElement attributeForName:@"postcode"];
        Area *area3 = [[Area alloc]init];
        area3.name = cityName.stringValue;
        area3.postcode = cityPostcode.stringValue;
        [m addArea:area3];
        
        NSArray *arr = [cityElement elementsForName:@"area"];
        for (GDataXMLElement *areaElement in arr) {
            GDataXMLNode *name = [areaElement attributeForName:@"name"];
            GDataXMLNode *postcode = [areaElement attributeForName:@"postcode"];
            Area *area = [[Area alloc]init];
            area.name = name.stringValue;
            area.postcode = postcode.stringValue;
            [m addArea:area];
        }
        [m showAll];
    }
    return 0;
}

3.网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *url;

@end


#import "Model.h"

@implementation Model

@end

#import <Foundation/Foundation.h>
#import "Model.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSURL *url = [NSURL URLWithString:@"http://www.oschina.net/action/api/news_detail?id=44392"];
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootEle = [doc rootElement];
        GDataXMLElement *newsEle = [rootEle elementsForName:@"news"][0];
        GDataXMLElement *relEle = [newsEle elementsForName:@"relativies"][0];

        NSArray *arr = [relEle elementsForName:@"relative"];
        NSMutableArray *mArr = [[NSMutableArray alloc]init];
        
        for (GDataXMLElement *releEle in arr) {
            GDataXMLElement *titleEle = [releEle elementsForName:@"rtitle"][0];
            GDataXMLElement *urlEle = [releEle elementsForName:@"rurl"][0];
            
            Model *m = [[Model alloc]init];
            m.title = [titleEle stringValue];
            m.url = [urlEle stringValue];
            [mArr addObject:m];
        }
        for (Model *m in mArr) {
            NSLog(@"title=%@,url=%@",m.title,m.url);
        }
    }
    return 0;
}

//AFNetworking：
1.概述：2.0使用的是NSURLConnection、3.0使用NSURLSession；
2.代码：NetworkViewController.h/m
注意：不要在子线程中更新UI；
//利用KVO、KVC进行网络请求：参考2015-10-13
1.新建数据模型PostInfo.h/m
2.新建数据源：必须初始化
3.设置单例：全局使用
3.监测数据源变化：KVO
4.新建下拉控件：进入VC->开始下拉加载->网络请求：改变数据源->加载UITableView
5.在View中更新UI
代码：NetworkViewController.h/m
//设置应用支持https
Xcode7.0以后：NSAppTransportSecurity->NSAllowsArbitraryLoads->YES

#网络编程需要掌握的内容：NO
0.实时监测网络变化
1.数据请求、数据上传、下载
2.原生网络请求的原理
3.网络请求第三方库的使用
4.KVC在网络请求中的应用
5.进入VC以后怎么加载操作

今日项目需求(参考2015-10-13/org.mobiletrain.afnetworking-sample)
0 ViewController当中的所有数据，都是来源于Model，但不在ViewController当中保存，是存放在单独的Model类。其他的类也会使用到这一个Model，所以Model必须是单例
1 ViewController当中，不进行网络请求，不使用AFNetworking。
2 ViewController当中，要进行网络请求，委托另外一个类(PostStore)来进行请求
3 PostStore进行网络请求之后，需要告诉ViewController，请求和数据操作都已经完成
4ViewController是一个列表视图控制器，既然委托PostStore进行网络请求，并且PostStore会在网络请求完成之后，操作Model，所以要观察Model([PostList sharedInstance].posts)
5PostStore在网络请求的方法内，需要外部传入两个block，这两个block，会在PostStore网络请求完成并且数据解析完成之后调回去
6PostStore内部需要做3件事：数据下载；唯一性判断；排序。所以应该在最后一步，也就是排序的时候，告诉观察者，数据(Model)已经更新了
7ViewController当中的cell，需要显示Model当中的text，这个text会被改变(DetailViewController)，所以cell需要添加对于这个Model(NSMutableDictionary)的观察者
8 因为有复用机制，所以当设置观察者之前，需要将之前的观察者删除掉
9 ViewController和DetailViewController不应该传输数据，所以，当前被选中的PostInfo，需要放到Model当中([PostList sharedInstance].selectedPost)，设置好之后，再进入下一级页面

1.项目的技术要点/功能模块实现/项目中的难点有哪些，怎么解决的/项目中有哪些你不满意的地方/如果现在让你做，你可以怎么做？/做过最得意的是什么项目/
2.关于版本控制系统：一般可以讲svn/git就行/优缺点/怎么使用/具体命令行又什么区别和作用？
3.你通常用什么数据格式与服务端交互：json/xml|json、xml解析方式的底层是如何处理的？
2.什么时候需要使用delegate/什么时候需要使用notification /// delegate/block/notification有什么不同点？？？
12.代理delegate/通知/block之间有什么区别？
13.iOS怎么做数据持久化？coredata/sqlite之间又什么联系？coredata是关系型数据库吗？
15.说说iOS中常用的多线程？最好能结合代码好好说；在哪里用到了多线程？三种多线程哪种会比较全面一些，
然后谈一谈线程安全问题的解决方案？
19.使用过哪些第三方库？jsonKit/AFNetworking/SnapKit/MJRefresh///要有针对性，涉及到每个方面；
20.怎么实现UITableView的懒加载？
21.iOS开发中常见的异常有哪些？
22.什么时候使用栈/队列？什么时候使用链表/数组？
34.性能优化：重点
35.静态初始化什么场合可以使用？什么场合不能使用？
36.导致app异常假死的情况有哪些？有什么解决方案？
38.怎么为App设计缓存？
40.obj中可修改/不可修改类型？
47.iOS中类有哪些通讯方式？
53.消息推送中心的过程？
55.指针函数和函数指针有什么区别？
56.怎样才能一次遍历就能确认链表中存在环？
62.为什么category只能为对象添加方法？却不能添加成员变量？
63.简述NSInteger* a/NSInteger a的区别？
64.block和gcd的并发执行？
65.Xib/代码方法创建界面的优缺点？
66.关于Objective的异常处理？
70.app一个页面crash、你可以用什么工具去查内存之类的状态；
关于View的一些高级动画：目前是一点都不会

1.给定链表的头指针和一个结点指针，在O(1)时间删除该结点。
链表结点的定义如下：
struct ListNode {
    int m_nKey;
    ListNode* m_pNext;
}
函数的声明：void DeleteNode(ListNode* pListHead, ListNode* pToBeDeleted);
2.语句倒序：I am Bruch；（语言随意：不能使用伪代码）
4.将一个链表逆序？/输出一个字符串是否对称？/输出树的深度？
5.定义一个标准宏MIN：输入两个参数并返回最小值？
6.C语言中默认的随机数random()是从x->y?
9.id obj = [[NSMutableArray alloc]init];/id obj = [NSMutableArray array];初始化
有什么不同？
10.在ARC模式下，autoreleasepool的使用？（使用伪代码）/autoreleasepool的作用？
11.id obj = [[[NSMutableArray alloc]init] autorelease];obj在什么时候释放？有什么
方法可以让obj马上释放？（用伪代码表示）
12.for(int index = 0; index < 20; index++) {
    NSString *tempStr = @"tempStr";
    NSLog(tempStr)
    NSNumber *tempNumber = [NSNumber numberWithInt:2];
    NSLog(tempNumber)
}
这段代码有什么问题？会不会导致内存泄漏(多线程)/在内存紧张的设备上做大循环时


17.NSString *name; [name release]; // 执行代码会出现什么结果？简述原因


14.程序运行报错：请找出错误并改正
#include <stdio.h>
#include <malloc.h>
typedef struct {
    TNode* left;
    TNode* right;
    int value;
} TNode;

14.写出以下操作以后person的retain count是多少？
Person *person = [Person alloc] init]；
[person retain];
[person release];
[person release];

//面试题：技术部分
2.iOS程序在执行main函数之前做了哪些操作？
3.一个App可以有几个UIWindow？
7.NSOperation什么时候从queue中移除？
18.怎么提高客户端的性能？（这点需要深入研究一番）
25.有哪些方法可以启动一个线程？
26.xib/nib之间的区别？
28.json解析内部是怎么实现的？
29.试说明SEL和@selector的用途、有什么作用？
30.iOS中App数据持久化机制有哪几种方案？（详细说明）
31.请说明Touch和非Touch事件发生时在系统中的传递过程？（事件传递hitest）
34.如果开启异步线程？如果想要延迟执行某个线程怎么实现？
42.iOS应用是如何实现后台多任务处理？
43.category是怎么样一个机制？一般什么时候使用？
//参考网站：
http://www.cnblogs.com/Piosa/archive/2012/02/22/2363234.html
CGFloat/Float之间的区别？
//谈谈UITableView的优化
1.利用cell的复用：可以不用每次都创建cell、表述一下cell的复用机制、场景；//最基础的
2.设计尽量统一cell的样式；//这个没办法避免
3.布局方面：可以提前计算并缓存cell高度、不用每次调用delegate都去计算；
4.遇到复杂页面：可以考虑异步绘制、减少子视图的层级关系；
5.尽量不要动态add/remove子控件、可以在init()中就加载完毕，然后通过hidden控制显示/隐藏；
6.使用调试工具分析问题；

赶集网的面试：1.传值 2.推送 3.数据存储 4.代理/单例
第一轮：推送机制->多线程->开发流程
第二轮：支付

1.读写文件的例子？
2.读写数据库的例子？
3.异步加载网络图片的例子？

总结推送：
1.从APNS获取device token作为设备唯一标识符

数据结构；树

//iOS推送原理机制：

//网络部分
1.http请求分几部分？

UITableView调用reloadData()会发生什么问题？

### 面试题
4. 同一个游戏包(GameID相同)怎么区分下载来自哪一个渠道？
5. UITableView怎么做预加载？
6. 懂不懂OpenGL？
7. 知道多线程吗？介绍一下iOS中多线程的情况？平时你喜欢使用哪种？在哪些开发中使用到了多线程？
8. swift中结构体和类之间的区别？
11. keyWindow和一般Window的区别？
12. delegate/通知/block之间的区别？
13. AF2.0和AF3.0之间的区别？AF2.0有常驻子线程而AF3.0没有是什么原因？
14. git rebase/git merge的区别？
16. 数组指针/指针数组的区别？
17. 三种动画？各种动画的区别联系？
18. block的循环引用：渐变动画会出现循环引用吗？
19. atomic一定是安全的吗？
20. ViewDidLoad()/loadView()的区别？
21. if(self=[super init]) { //...}为什么需要这样写？[super init]按照常理
只是初始化父类的空间、为什么self可以调用子类的方法？
22. ARC是什么？工作机制详细讲下？
23. 常见的第三方库你见过那些多线程？/有盟、高德地图、AFNetWorking、SDWebImage、FMDB
31. 在iOS中有哪些常见第三方库：实现的功能是什么？你看过第三方库的源码吗？有过根据需求修改过源码吗？
32. 写一个NSString类的实现；
33. 描述OC和swift的联系和不同；
34. 描述ARC机制的原理和实现；
35. 描述controller和view之间的关系。为什么要使用viewController；
36. 描述SQLite.swift的大致实现原理；
37. 描述IP/TCP/UDP/HTTP几种协议的理解；
38. 描述web Service和Web Api的区别；（发展思路和应用场景）；
39. 描述web后端Session在什么时候产生、什么时候结束？Cookie又是什么关系？
40. iOS的后台运行是什么原理和机制？
41. 创建一个对象、放在可变数组中。释放整个对象会发生什么？释放数组会发生什么？
44. WWDC是什么？你有关注过WWDC吗？
45. Xcode选择模拟器编译：在Products中生成的二进制文件后缀是什么？
46. 重点理解SEL的用法；

//数据持久化
1.NSCache和数据持久化使用场景有什么区别？
2.常用的数据持久化方法有哪些？各自有什么利弊？

// 数据库开发：sql语句/连表查询
例1.有两张表，用户表(Z_User)和黑名单表(Z_Blackuser)，userid是Z_User的
主键，Z_BlackUser的外键。现在需要查询用户表中不在黑名单表中的数据，请写出sql语句。

是否参与过GitHubiOS开源项目?
请描述一下你的iOS应用开发流程？

//UI问题
layer和UIView、UIWindow的区别是什么？

5.怎么实现连表查询？ //重点中的重点！！！

//数据库方面
1.什么是视图？
2.使用索引查询一定可以提高查询性能呢？为什么？
3.内联接和外联接的区别？

//类方法
1.类方法随着类的加载而加载、所以类方法不能访问成员变量、
self在对象方法中代表对象、self在类方法中代表类、
self.age = 10代表set方法[self setAge:10];

1.解释一下block、使用block应该注意什么;
2.block的用法？
3.如何避免使用block引起循环引用问题？
1.dispatch_get_current_queue会引起什么问题？
1.CoreAnimation/CoreGraphics是否使用过？
Xcode支持在一个工程里面新建多个项目
1.怎么开启异步线程、如果需要线程过段时间再开启、如果实现？
1.列举常见使用到多线程的地方、2.多线程安全的几种解决办法？
//数据存储
1.单例保存的数据App杀死、数据清空
2.数据库/NSUserDefaults保存的数据在App被杀死数据不会清空、App被卸载数据会清空

###人事问题
1.今年的目标是什么？5年的规划是什么？
2.希望从我们公司学习到什么？
3.住哪里？有没有女朋友？上家工资多少？//按照实际回答即可
4.为什么离职？//这个总结一下
5.公司有多少人？iOS部门有多少人？具体是怎么样的工作流程？
6.App哪些模块是你做的？
7.你投简历投了几家？拿到几个offer；//这个想一下具体回答
8.工作中遇到什么技术难点（这个一般不是人事问题、但是需要好好总结）

//链表/数组的不同

//nullable、__nullable、__Nullable之间的关系？
1.目的：为了兼容swift
2.三者之间没有任何的区别？就是书写的时候位置有不同
3.-(nullable NSString*)method;nonNull表示对象不应该为空、nullable表示对象可以为空?
4.不带下划线在类的前面、写下划线的在类的后面
参考：https://blog.csdn.net/conglin1991/article/details/77159652
建议：使用nullable这样符合属性修饰符的位置、跟copy、strong一样

关于数据结构：一定需要自己好好梳理知识点：
1.二叉树
2.链表
3.哈希表

//网络相关方面
1.有没有用过socket、一般怎么使用？如果预防socket丢包？

//加密算法
1.MD5-概念、应用场景、

###趣味问答
//这一块最好需要有人帮你总结：因为你感觉很自豪的事情在别人看来就是很垃圾！！！
//你最引以为豪的项目是什么？你做的最成功的项目是什么？
你项目有哪些不足？如果是现在给你修改、你可以怎么修改？
Xcode有哪些可以改进的地方、你最爱使用什么方法检查某种新技术是否好用？

///iOS职位要求
### 必须项：
1.丰富的客户端App架构经验、可以独立承担架构设计、主导项目；
2.熟悉iOS的调试工具和方法、crash追踪；
3.精通Objective-C语言/swift语言；
4.精通UI、动画、网络编程(Socket、https/web)、数据库、多线程、
h5/js交互；
5.熟悉常用软件架构模式、算法与数据结构；
6.熟悉CocoaPods、git、svn等工具；
7.至少参加两款商业应用开发并上架AppStore；
8.学习能力强、工作积极主动、有强烈责任心和严谨作风、协作沟通能力、解决问题能力；
### 加分项：
1.提供github账号或者技术博客账号(为开源项目做过贡献)；
2.深入了解iOS动画机制、音频、视频开发经验；
3.熟悉C/C++语言、前端、后端、RN、Weex、H5混合开发；
4.内存泄漏、App性能调优经验优先；
5.了解常用的设计模式，有架构和组件化经验；
6.扎实的计算机基础，了解数据结构和常见算法；
7.有移动端(iOS/Android)脱壳、反混淆相关经验；
8.深入研究AR相关技术的优先；
9.良好的产品和业务sense；
10.有App Store上架作品优先；

### 项目细节
1.自己的事情自己做：
1).业务参数最好在model中先处理好，直接赋值
2).View需要改变状态最好在View内部先处理好逻辑，外部使用数据去驱动

swift中enum/struct都是比类更厉害

App中哪些需要存放在本机|App中的缓存机制

隐藏View：1.使用隐藏属性、2.将View的宽和高设置为0

如果是数组就是dateList

如果是字典就是DateModel/DateInfo

constrain to magins //没有作用：为了plus/iPhone X布局尽量到中间

对于cell 我们一般不需要把model传进去 再传出来 我们一般是把cell传出来 然后通过cell拿到indexPath 再通过indexPath拿到model

- 创建UILabel/UIButton有固定方法(不使用系统方法)；
- 封装可以使用的BadgeView；
- 学习snapkit使用方法；
- UIView中不能跳转：使用代理让实现在VC中进行；让View具有公用型

## snapkit中有三个方法
- makeConstraints  //设置布局
- remakeConstraints  //移除以前的布局、重新布局
- updateConstraints //更新布局

App开发不能限制用户的操作
/***********************json按页下载数据******************************/
//1.声明当前页数、总页数
self.page = 1
self.maxPage = 1
//2.首次加载
page传入1-开始网络请求
//3.请求完成：开始赋值
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
//4.再次网络请求：
page++ //判断是否大于最大页面：大于停止刷新
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
/////CommunityCommentDetailController.swift
15.什么是"Jenkins"/TabBar这么实现动画效果/hook

1. 一般项目都是使用cocoaPods管理：更加方便；
2. 一般使用Assets管理图片：自己试试；
3. 一般技术用来看后台接口的工具App是什么？？？
4. 一般App不需要什么都写在服务端
5. //这个坐标是在哪里开始算起的：状态栏？导航栏头部、导航栏底部
    _topView = [[UIView alloc]initWithFrame:CGRectMake(0, 20, self.view.frame.size.width, 40)];
read Base value to memory

App哪些信息需要存储在本地：可能会涉及到多表查询

学会了怎么设置cell自适应：配合设置控件高度为0一起使用；/需要预估高度/可以把内部的高度传出来

一般使用svn管理资源文件、使用git管理代码文件

YYText怎么使用、有什么作用？？？

对json的格式还不是很熟悉

//使用SnapKit给控件添加约束常见错误：https://blog.csdn.net/Haikuotiankong11111/article/details/51800761
1.简单的约束冲突不能有：比如控制了左边和把右边就不能在设置宽度

CGFloat的意思是什么？

iOS中关于图片缓存和缓存cell的高度

系统适配
iphone尺寸
iPad尺寸

UILabel在Autolayout中可以自动设置高度

cell内部如果某一个控件不需要我们可以更新布局为0

//项目中：如果Model中需要新的数据：可以直接在Model中创建->然后拿出来使用
如果某个ui需要改变：可以在内部改变->vc中可以调用方法告诉view你的view显示需要改变

在开发中，我们一般UIButton会使用custom、而不使用system

看控制器会不会走 deinit方法，有内存泄漏 deinit这个方法是不会走的

NSNotFound
int和NSInteger都是基本数据类型、一般OC使用NSInteger代替int/Swift使用Int、然后需要放在字典中的话：需要包装：@(NSInteger)

自定义UI：如果你希望整个UI都可以点击：可以直接在整个UI上面添加touch方法

给对象赋值不需要初始化

1.什么时候更新model?
1).网络加载数据：更新model；2).本地上传数据：之后更新model；

一般对象我们都设置var
对象赋值不需要init
给对象属性赋值：必须要init

不能欺骗Apple

对于布局：一般不建议写死
一般先把左上角|中点控制好；
然后把宽|高控制好
间距：一般不用up|all
尺寸：一般使用up|all
如果对于5s的屏幕：太小了  间距也可以使用up|all
自己的代码必须有足够的兼容性

git上面的：stash
fir的使用：怎么使用
一般公司打包：怎么打包

SnapKit布局：我们不用按顺序布局|可以直接先布局底下的样式、再布局上部的样式

可以规定约束的优先级

// 组件化开发实践
https://www.jianshu.com/p/f472fa9f0616

swift中一般都需要init|对于Int等数据类型、默认赋值等于-1
为什么是-1呢？？？？因为-1代表着不正确

自己的问题自己把关：不能让别人给自己把关

找问题一定要从外向内找、找不到在找旁边的
千万不要还没有找进去  就开始在旁边找
这样很能迷失方向：让人很烦躁、不安   然后找不到答案、一定要静下心来

写代码一定要细心  超级细心

pod repo update // 更新电脑本地保存的版本库中的版本信息

遇到{就会给它分配一个存储空间、直到遇到}该存储空间会被释放

如果只需要上拉加载、不需要下拉刷新

这时候可以把下拉刷新不写：直接在viewDidLoad() {
    中网络请求：然后执行上拉加载：最开始的网络请求可以设置为page = 1
}

swift怎么写网络请求：

OC怎么处理网络请求：

// 将一个图片位于什么部位开始拉伸(以原点为中心点)
// 返回一个UIImage
UIImage.resiezableImage(with: UIImage(named: "calendar_bg_white"), edgeInsets: UIEdgeInsets(top: 0.5, left: 0.5, bottom: 0.5, right: 0.5))

拿到页面首先分析UI布局  写出UI界面    然后再分析要不要分页加载

每次写代码如果有疑问  或者测试改了代码   都需要做标记：// FIXME  然后最重要的是
必须在发版的时候全局搜索FIXME

1.严格按照设计稿设计UI
2.一般设置UI的时候一定要想到怎么当文字过长会怎么样

如果UI显示不正确  变小了    考虑可能的原因   图片压缩了   图片有边角   但是UI没有给图片   这样一般让图片和UI一样大

如果App的跳转比较像（就是model不一样）
我们可以对model进行赋值
新建一个model   对model进行赋值

在xib中，command选中两个控件   可以让他们等宽、然后修改比例

数据库问的问题：数据的增删改查、多表的链接查询、数据回滚

内部用的什么类型数据
外部就必须用什么类型的数据接受

不能内部是字典/外部是数组

如果json是一个model   你就用字典接受
然后传出来的必须也是model
"data":{
    // 这是一个字典
}
外层也必须使用model去接收->然后取出来model里面的list->如果需要分页还需要拼接list

如果json是数组的话。必须用数组接受
"data"[{
    // 这是一个数组
},{
    
}]
必须使用数组去接受-> 然后外层也必须使用数组来接受：可以直接等于

swift中main函数消失：https://blog.csdn.net/zhao18933/article/details/46640657

1.修复线上bug/增加线上内容...base分支
2.新功能/新需求_01...新建分支 <br>
3.新功能/新需求_02...新建分支 <br>
4.新功能/新需求_03...新建分支 <br>
发版本...把1，2，3，4合并到发版分支->新建v3.3.x发版本分支

cell因为是复用的、所以cell有if/就必须有else
不然做不到让数据驱动UI

国际化：文字的国际化、图片的国际化

// UICollectionViewCell的自适应：
1.我们可以现在外部给cell一个预估的宽/高
2.然后在内部给cell进行内容向外部撑开
3.cell内部的UILabel不要设置高度

//写App之前
1.确定App的整体框架；
2.封装各种UI（图片+文字的btn/toast/alert）
3.网络请求封装
4.确定各种数字/文字等UI显示
5.确定开发需要的适配代码(怎么做适配)
6.设置BaseViewController
以上就是最基本的一些封装和前期准备。。。然后再考虑你要写App。。。你要做业务开发

通过基本UI去渲染控件和直接用图片去渲染界面对性能而言谁更优异

在vc中不要初始化UI相关的逻辑：
1.因为在init里面、self.view还没有被创建、直接在
初始化中调用会导致loadView()/viewDidLoad()提前被调用、
2.加载xib的时候关联的IBOutlet组件未被加载到内存的时候直接
调用会导致nil
//self.view被使用会调用loadView()创建并执行viewDidLoad()

占位图：全局占位图、底部占位图
实现方式不一样：全局占位图隐藏UITableView、底部占位图直接使用cell

UICollectionViewCell如果需要等间距显示的话：需要重写UICollectionFlowLayout

对象想要使用：要不初始化/要不直接赋值、不然不能是使用
如果一个对象没有被销毁、则这个对象带着的属性和方法一致存在、保持不变

id/Class/SEL之间的区别？分别代表什么意思？
格式化：obj/String -> %@ / float -> %f
NSPredicate //过滤
NSAssert //代码调试

积分墙
iOS中的指令集是什么意思？
符号表：xxx

// 组件化开发
基础组件库-category
基础UI库-UI样式
基础网络库-网络请求
基础数据库-数据库
基础埋点库-数据埋点
业务逻辑库-业务逻辑
链式编程-简易编程
路由-简易跳

### 上架注意点
1.不能导致手机故障(包括崩溃、UI问题)
2.不要使用任何SDK的私有API
3.不要提及用户设备上不存在的硬件功能
4.如果App需要网络连接、在没有网络的情况下需要告知用户
5.不要模仿/山寨某一个App(马甲包)
6.不要恶搞知名公众人物/不要包含敏感政治话题
7.不要包含执行下载文件的脚本解释器/插件/runtime(不能包含热更新)
8.仅在连接wifi的情况下才可以播放视频和下载其他大型文件
9.不要偷偷使用摄像头/话筒/GPS(可以给用户带来切实好处、需要提前告知用户)

# 提交注意点
1.程序文件名和iTunes应用商店里面显示的名称必须一致(缩写也行)
2.iTunes中描述力求描述应用功能准确、不需要包含价格、Android
3.iTunes关键词要与应用程序功能相匹配、不包含其他App名称
4.App截图不能包含错误状态、UI布局错乱
5.App分类与其功能相符、含有彩蛋必须在演示账号中透漏
6.能够提供各种尺寸图标、不同尺寸图标都包含同样的内容
7.版本号>=1.0
8.info.plist中所需要的设备功能和应用的实际需求相符
9.NSZombieEnabled设置为fasle
10.如果使用推送通知，需要在xxx.entitlements中添加用于
aps-enviroment授权信息、你的appID必须激活推送通知功能
11.更新App的时候当前版本号>上个版本、内容描述和App实际变化相符
12.应用不能够是一个简单的浏览器窗口的网站
13.如果你的App需要登录、需要提供测试账号
14.其他存在的版权信息

1.看下面的程序,三次NSLog会输出什么？为什么？
NSMutableArray* ary = [[NSMutableArray array] retain];
NSString *str = [NSString stringWithFormat:@"test"];  // 1
[str retain];   // 2
[ary addObject:str]; // 3
NSLog(@"%d", [str retainCount]);
[str retain];  // 4
[str release];   // 3
[str release];   // 2
NSLog(@"%d", [str retainCount]);
[ary removeAllObjects]; // 1
NSLog(@"%d", [str retainCount]);
结果：3、2、1

1.loadView方法作用以及注意点有哪些?
   作用:控制器会调用方法去创建控制器的View.
   什么时候调用:当第一次使用控制器的View
   开发中loadView使用场景:自定义控制器的View.
   1.一旦重写了loadView,表示需要自己创建控制器的View.
2.如果控制器的View还没有赋值,就不能调用控制器View的get方法.会造成死循环.因为控制器View的get方法底层会调用loadView方法.
   
2.KVC底层实现?
  setValue:obj forKeyPath:key的底层实现:
  1.它会调用这个属性的set方法.
  2.如果没有set方法,它会去判断有没有跟key值同名的成员属性.如果有,就直接赋值.icon = obj.
  3.如果没有,那么它还会去判断有没有跟key值名相同带有下划线的成员属性,如果有,就直接赋值,_icon = obj.
  4.如果都没有, 就直接报错.找不到对应的成员属性.
        
4.导航控制器管理原则?
  当调用导航控制器的push方法时, 就会把一个控制器压入到导航控制器的栈中.
  压入栈中是, 那么刚压入栈中的这个导航控制器就在栈的最顶部.
  它就会把原来导航控制器View当中存放的子控制器View的内容移除,
  然后把导航控制器栈顶控制器的View添加到导航控制器专门存放子控制器View当中.
  注意:只是把控制器的View从导航控制器存放子控制器的View当中移除,并没有把控制器从栈中移除.所以上一个控制器还在.
  当调用pop当方法时, 就会把导航控制器存放子控制器View当中控制器的View移除,并且会把该控制器从栈里面移除.
  此时该控制器就会被销毁.接着它就会把上一个控制器的View添加到导航控制器专门存放子控制器的View当中.
  
  1.CGAffineTransformMake与CGAffineTransform的区别?

  2.事件是怎么样产生与传递的?

  3.一个控件什么情况下不能够接收事件?

  4.如果寻找最适合的View?

  5.事件传递与响应的完整过程是什么?
  
  谈谈你对 Socket 的理解? TCP 和 UDP 协议有什么区别
  Socket 简单来说是一种通信机制， 是面向 C/S(客户端 / 服务端)模型而设计的。 针对客户端和服务端提供不同的 socket 对象，客户端有客户端的 socket 对象， 服务端有服务端的 socket 对象，两个 socket 之间就可以进行通信了。
  TCP(Transmission Control Protocol ，传输控制协议)是基于连接的协议，正 式收发数据前必须和对方建立可靠的连接 (“三次握手”)，传输速度相对 UDP较慢。
  UDP(User Data Protocol ，用户数据报协议)是与 TCP相对应的协议。它是面 向非连接的协议 ,UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境， 但是传输速度快


*(a+1）就是a[1]，*(ptr-1)就是a[4]执行结果是2，5
 a+1不是首地址+1，编制会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
int *ptr=(int *)( a+1);
则ptr实际 是 (a[5])也就是a+5
原因如下：
 a是数组指针，其类型为int (*)[5];
而 指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。
a是长度为5的int数组指针，所以要加 5*sizeof(int)
所以ptr实际是a[5]
但是prt与( a+1)类型是不一样的(这点很严重)
所以prt-1只会减去sizeof(int*)
a的地址是一样的，但意思不一样
a是数组首地址，也就是a[0]的地址， a是对象（数组）首地址，
a+1是数组下一元素的地址，即a[1] a+1是下一个对象的地址，即a[5].

10.为什么标准头文件都有类似以下的布局？
#ifndef__INCvxWorksh
#define__INCvxWorksh
#ifdef__cplusplus
extern "C"{
#endif
#ifdef__cplusplus
}
#endif
#endif
// 防止重复导入

Core Animation
通过 CoreAnimation，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。

Core Audio
Core Audio是播放，你知道ios。处理和录制音频，能够轻松为您的应用程序添加强大的音频效用。

Core Data
提供了一个面向对象的数据管理解决计划，它易于使用和理解，以至可处理任何应用或大或小的数据模型。

?如果您通过分配和初始化（比如[[MyClass alloc] init]）的方式来创建对象，Windows Phone。您就拥
有这个对象，须要负责该对象的开释。这个规则在使用NSObject的便利方法new时也同样适用。
?如果您拷贝一个对象，您也拥有拷贝得到的对象，事实上Windows Phone。须要负责该对象的开释。
?如果您保持一个对象，您就局部拥有这个对象，须要在不再使用时开释该对象。
反过去，
?如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该开释它（这个规则有少数
的例外，在参考文档中有显式的说明）。

信号量
dispatch_semaphore_t
dispatch_semaphore_create
dispatch_semaphore_wait
dispatch_semaphore_signal
信号量
跟线程锁(NSLock)概念差不多
将线程锁，理解成来回两车道，同方向前车在那停着，后车必须等
其实就是信号量为1的时候
信号量可以定义堵塞的数量
比如说信号定义了堵塞数量为2，同方向前车在那堵着，但是另外一条车道有一个空的，所以后车可以选择绕过去
但是如果同方向两车道都有车在那停着，后车必须也等待，等待到有任何一个车被释放，才可以继续往前开

27. 用变量a给出下面的定义
a) 一个整型数（Aninteger）
b)一 个指向整型数的指针（ A pointer to some kind ofinteger）
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to some kind ofintege）r
d)一个有10个整型数的数组（ An assortment of 10integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An assortment of 10 pointers tointegers）
f) 一个指向有10个整型数数组的指针（ A pointer to some kind of assortment of 10integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takessome kind of integer as some kind of argument
some kind ofd returns some kind ofinteger）
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An assortment of tenpointers to functions t
hat take some kind of integer argument some kind ofd return some kind of integer）
答 案是：
a) int a; // Aninteger
b) int *a; // A pointer to some kind ofinteger
c) int **a; // A pointer to a pointer to some kind ofinteger
d) int a[10]; // An assortment of 10integers
e) int *a[10]; // An assortment of 10 pointers tointegers
f) int (*a)[10]; // A pointer to some kind of assortment of 10integers
g) int (*a)(int); // A pointer to a function athattakes some kind of integer argument some kind ofd returns some kind ofinteger
h) int (*a[10])(int); // An assortment of 10 pointers tofunctionsthat take some kind of integer argument some kind ofdreturn some kind of integer

9.iphone应用程序的项目基本结构
classes:里面存放object-c类源代码文件(可以创建子文件夹来组织代码);
other sources:存放除objective-c类之外的源代码文件；
resources: 包含应用程序中的非代码文件(因为应用程序只能在自己的沙盒中运行，不然找不到)；
Frameworks:特殊的库，可以存放库、框架、图像、声音等资源；
Products：包含项目在编译时生成的应用程序(xxx.app);

12. Object C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？

//// 使用 copy 外部修改了字符串不会影响内部
//// copy 会判断字符串是不可变字符串还是可变字符串
//// 不可变字符串直接赋值
//// 可变字符串生成新的对象
//@property (copy, nonatomic) NSString *name;

    技术
1.WWDC是什么？你关注过哪些？
7.数据保存怎么实现？
8.block和gcd的并发执行
9.app的优化,你用什么工具去优化一个qpp,例如,例如一个页面,万一崩了,你用什么工具去查内存之类的状态
10.你项目遇到的问题,怎么解决的
11.你用过的认为好的app,为什么
12.其他的一些基础的知识
13,项目中你觉得好的动画什么的,可以show一下
3. 异步线程如何开启，如果想线程过一段时间再执行，如何实现？
 5. 如何测试一个iOS设备的性能？

14、delegate和notification区别，分别在什么情况下使用？
24、以下每行代码执行后，person对象的retain count分别是多少
Person *person = [Person alloc] init];
[person retain];
[person release];
[person release];
2.你实现过多线程的 Core Data
么 ?NSPersistentStoreCoordinator ，NSManagedObjectContext 和 NSManagedObject 中的哪些需要在线程中创建或者传递 ?你是 用什么样的策略来实现的 ?
3.Core 开头的系列的内容。是否使用过 CoreAnimation 和 CoreGraphics 。 UI 框架和 CA ，CG 框架的联系是什么 ?分别用 CA 和 CG 做过些什么动画或者图像上的内容。 (有需要的话还可以涉及 Quartz 的一些内容 )
4.是否使用过 CoreText 或者 CoreImage 等?如果使用过， 请谈 谈你使用 CoreText 或者 CoreImage 的体验。
5.NSNotification 和 KVO 的区别和用法是什么 ?什么时候应该 使用通知，什么时候应该使用 KVO ，它们的实现上有什么区别吗 ?如 果用 protocol 和 delegate( 或者 delegate 的 Array) 来实现类似的功 能可能吗 ?如果可能，会有什么潜在的问题 ?如果不能，为什么 ?(虽然 protocol 和 delegate 这种东西面试已经面烂了⋯)
7. block 在 ARC 中和传统的 MRC 中的行 为和用法有没有什么区别，需要注意些什么 ?
8. 您是否做过异步的网络处理和通讯方面的工作 ?如果有，能具体介绍一些实现策略么 ?

  OC部分：
 int *a;
int b[4]={1,2,3,4};
char *c;
char d[4]={‘q’,’w’,’r’,’t’};
printf(“%d,%d,%d,%d”,sizeof(a),sizeof(b),sizeof(c),sizeof(d));
写出打印结果
const int a;
const int *a;
int * const a;
const int * const a;
       写出各语句的功能
有integer :5,6,10,34,25,用NSArray实现逆序
NSThread  NSLock 等实现线程锁，即当一个线程说话时锁定另一个线程，说完后再解锁

1：ARC是什么？工作机制详细讲下。
2：三方库里面的你见过那些多线程，讲一下。
5：GCD
6：还有就是把你的项目下载下来，问你功能的实现问题
2、写一个view动画从顶到底部再消失，
5、输出数组不同元素的组合。
14.什么时候使用delegate什么时候使用Notification？

面试时最好准备纸、 笔、简历，可能用不上， 但很能体现认真程度。 有条件的话带着 Mac 和源码，手机中装好所有在简历中出现的 App

关于算法 - 我们是实用主义， iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中

这是一个重点考察项，曾经在微博上发过一个风格纠错题:
 也曾在面试时让人当场改过， 槽点不少， 能够有 10 处以上修改的就基本达到标准了 (处 女座的人在这方面表现都很优秀)
一个区分度很大的面试题

什么情况使用 weak 关键字，相比 assign 有什么不同?
怎么用 copy 关键字?
这个写法会出什么问题: @property (copy) NSMutableArray *array;

如何让自己的类用 copy 修饰符?如何重写带 copy 关键字的 setter? 这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的

ARC 下，不显示指定任何属性关键字时，默认的关键字都有哪些?
用 @property 声明的 NSString (或 NSArray ，NSDictionary )经常使用 copy 关键字，
为什么?如果改用 strong 关键字，可能造成什么问题?
objc 中向一个 nil 对象发送消息将会发生什么?
objc 中向一个对象发送消息 [obj foo] 和 objc_msgSend() 函数之间有什么关系? 什么时候会报 unrecognized selector 的异常?
一个 objc 对象的 isa的指针指向什么?有什么作用?
runtime 如何通过 selector 找到对应的 IMP 地址?(分别考虑类方法和实例方法)
使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么? [※※※※※ ]objc 中的类方法和实例方法有什么本质区别和联系?
runtime 如何实现 weak 变量的自动置 nil ?
能否向编译后得到的类中增加实例变量?能否向运行时创建的类中添加实例
//objc 使用什么机制管理对象内存?
ARC 通过什么方式帮助开发者管理内存?
不手动指定 autoreleasepool 的前提下， 一个 autorealese 对象在什么时刻释放? (比 如在一个 vc 的 viewDidLoad 中创建)
BAD_ACCESS 在什么情况下出现?
苹果是如何实现 autoreleasepool 的?
使用 block 时什么情况会发生引用循环，如何解决?
在 block 内如何修改 block 外部变量?
使用系统的某些 block api (如 UIView 的 block 版本写动画时) ，是否也考虑引用循 环问题?
GCD 的队列( dispatch_queue_t)分哪两种类型?
如何用 GCD 同步若干个异步调用? (如根据若干个 url 异步加载多张图片， 然后在都下载完成后合成一张整图)
苹果为什么要废弃 dispatch_get_current_queue ?
addObserver:forKeyPath:options:context: 实现哪个方法才能获得 KVO 回调?
各个参数的作用分别是什么，
observer 中需要
如何手动触发一个 value 的 KVO
若一个类有实例变量 NSString *_foo ，调用 setValue:forKey: 时，可以以 foo 还是 _foo
作为 key?
KVC 的 keyPath 中的集合运算符如何使用?
KVC 和 KVO 的 keyPath 一定是属性么?
如何关闭默认的 KVO 的默认实现，并进入自定义的 [※※※※※ ]apple 用什么方式实现对一个对象的 KVO ?
IBOutlet 连出来的视图属性为什么可以被设置成 weak?
IB 中 User Defined Runtime Attributes 如何使用? 如何调试 BAD_ACCESS 错误
lldb (gdb)常用的调试命令?
KVO 实现?
这些小题可以做为讨论的入口， 根据面试者的回答再继续聊下去。 是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。
业务能力
其中一些题比较底层，
毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法， 80% 的时 间都是和搭建页面、写业务逻辑、网络请求打交道。
要求面试者能够熟练构建 UI ，我会找一个面试者做过的页面让他分析下页面结构、约 束或者 frame 布局的连法和计算方法;有时也会让面试者说说 UITableView 常用的几个
delegate 和 data source 代理方法， 动态 Cell 高度计算什么的; 接下来， 在手机里随便找一 个 App 的页面， 让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。 问几个
问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout ，假如面试者依然 使用代码码 UI 也到没关系，有“从良”意愿就很好 ~
程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说
Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现?
架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有 正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到UIView 的子类里面干。
网络请求、 数据库等各家都有成熟的封装，基本知道咋用就行。除此之外， 带的问下除了 iOS 开发外， 还会什么其他编程语言、 或者熟悉哪种脚本语言和 作等，甚至还问问是如何翻墙 - -，相信这些技能都是很重要的。
大家都是写程序的， 没啥必要用奇怪的、 很难的问题难为对方，更关键的还是性格， 和Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表 达要正常， 经常遇到问一个问题后一两分钟一直处于沉思状态， 一句话不说， 交流像挤牙膏
一样，很是憋屈;还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪 口上就别怪不客气了 。决定要不要一个人基本上聊 5 分钟就可以确定了， 喜欢水到渠成 的感觉，看对眼了挡都挡不住。
招聘告一段落， 后面将会有更精彩的事情发生。 最后， 再次感谢大家的支持和对我的信 任。

谈谈你对代理设计模式的理解?
25、 谈谈你对 Socket 的理解? TCP 和 UDP 协议有什么区别
26、 你常用的数据存储方式有哪些?
27、 通知中心和代理都可以用来发送消息和数据，两者有什么区别?

如何判断字典元素为空

请描述IOS的动画机制

6. NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？

7.什么是安全释放？
 
12.委托是什么？委托的property声明用什么属性？为什么？
 
16.for(int index = 0; index < 20; index ++){
    NSString *tempStr = @”tempStr”;
    NSLog(tempStr);
    NSNumber *tempNumber = [NSNumber numberWithInt:2];
    NSLog(tempNumber);
}
这段代码有什么问题.？会不会造成内存泄露（多线程）？在内存紧张的设备上做大循环时自动释放池是写在循环内好还是循环外好？为什么？
 
18.在一个对象释放前.如果他被加到了notificationCenter 中.不在notificationcenter中remove这个对象可能会出现什么问题？

20.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.
 
22.在iphone上有两件事情要做,请问是在一个线程里按顺序做效率高还是两个线程里做效率高？为什么？

24.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系？coredata是一个关系型数据库吗？
 
25.阐述一个nil对象从interface bulider产生，到载入程序运行空间，最后被释放时所经历的生命周期.
 
26.notification是同步还是异步? kvo是同步还是异步？notification是全进程空间的通知吗？kvo呢？
 
29.unix上进程怎么通信？
 
30.timer的间隔周期准吗？为什么？怎样实现一个精准的timer?
 
31.UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？
 
3. OC中 SEL是什么，有什么作用?
4. 如何在 OC的字典或数组中存取一个基本数据类型的值?如何把字典或数组中的
  值转换成基本数据类型的值?
5. IOS 中界面间传值的方式有哪些?
6. OC中通知有哪几类?请简述苹果推送的流程?
8. 什么是 block ? block 如何使用?
程中使用非 ARC的类和开源框架?
10.简要说明下 OC的延展和分类的作用和区别 11.OC中多线程的实现方式有哪些?如何实现在一个异步线程中使用一个定时器? 12. 请例举常用的网络请求开源框架、 JSON解析开源框架、 UI 开源框架。
14. 请列举出你所知道的设计模式及各种设计模式的特点。
 
1.iOS 平台怎么做数据持久化(本地保存)，请列举至少 4 种方法。
2. 什么情况使用 weak 关键字， weak和 assign 的区别是什么?
3.@synthesize 和@dynamic分别有什么作用?
4. 列举几种反向传值的方法
5.ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些?
11. 简述 iOS 常使用的几种设计模式
13.objc 使用什么机制管理对象内存?
14.ARC通过什么方式帮助开发者管理内存?
15.BAD_ACCES在S什么情况下出现?
17. 什么时候用代理，什么时候用通知?
18.Category (类别)和 extension (扩展)有什么区别?
19. 网络图片处理问题中怎么解决一个相同的网络地址重复请求的问 题?
20. 你用过 NSOperationQueue 么?如果用过或者了解的话，你为什 么要使用 NSOperationQueue，实现了什么?请描述它和 GCD的区别
和类似的地方?

3. SDWebImage的原理以及实现机制。如何解决 卡的问题

总结了一下:新浪微博爱问 UI ，数据缓存应用方面的实现，腾讯爱问原理，坑 爹的百度就喜欢拿算法来得瑟。
面试制胜之招: 1.原理性的知识，必须背下来，代码不需要会写，没人要求写原理、底层的代码 (这是一个空子，可以钻 )
2.链表操作，排序算法最好是能默写 3.面试始终保持平静，冷静，镇静，面试再刁难也要保持端坐，面带一丝微笑
4.对喜欢的公司最好能表现出对加入目标公司的渴望，对技术的追求 5.加分的地方:对简历上的项目很熟悉，技术点都有所研究，包括封装，细节实现;最好能把 MJExtension 框架多敲几遍，包装成自己开发的工具(显示自 己大神的威力)

7.请简述 KVO 内部的实现，使用条件 --- 新浪微博
8.请用代码描述错误消息处理 ---腾讯，百度 9.消息转发内部原理(结构指针，方法选择器， forwarding... 一串破玩意儿) -- 百度
9.iOS 消息传递机制都有什么?如何传递? --- 腾讯，百度，新浪微博
10.有网络或无网络情况下两个 APP之间如何通信 ---新浪微博
11.将 UIButton 添加到 UIView 上，如果 UIButton 的 frame 的(0,0)不在 UIView 上， UIButton 能不能被点击，为什么?， UIButton 如果被添加到 UILabel 上， 点击能响应吗? ---新浪微博
12.如果每个 View 上都想增加一个时间播放控件，如何实现? ---新浪微博
13.利用 UIScrollView 缩放性，如何实现地图上商家地理位置的动态显示 14.运行时的工作原理， OC动态行 ---腾讯，百度，新浪微博
15.AFN 与 asi 的本质区别 ---腾讯，百度，新浪微博(主要问底层实现) 16.clayer 的坐标与 frame 的坐标如何转化 ---腾讯，百度，新浪微博
17.循环引用 ---腾讯，百度，新浪微博 18.runloop 原理---腾讯，百度，新浪微博
---腾讯

3.下面程序有什么错误
for(int i =0; i< someLageNumber; i++) {
    NSString * str = @"ABC";
    str = [str lowercaseString];
    str = [str stringByAppendingString:@"123"];
    NSLog(@"%@",str);
}
1.autorelease和垃圾回收机制(gc)有什么关系？
2,ifndef/define/endif左右
33、线程理解，有什么好处 

30、什么是KVC和KVO？
31、Notification和KVO有什么不同？
32、KVO在ObjC中是怎么实现的？  
14、delegate和notification区别，分别在什么情况下使用？

4,c++程序中调用被C编译的函数为什么要加extern "C"
5,重载重写区别
7,哪几种情况能使用构造函数初始化列表初始化,有什么好处
8,内存分配方式简述
9,单项链表逆序
10,int a=4;
A:a+=(a++)
B:a+=(++a)
C:(a++)+=a
D:(++a)+=(a++)
哪个使用没问题
还有运行结果
11,非C++内建类型A,B,哪几种情B隐式转化为A

  OC部分：
    •     int *a;
int b[4]={1,2,3,4};
char *c;
char d[4]={‘q’,’w’,’r’,’t’};
printf(“%d,%d,%d,%d”,sizeof(a),sizeof(b),sizeof(c),sizeof(d));
写出打印结果
    •    const int a;
const int *a;
int * const a;
const int * const a;
       写出各语句的功能
    •    有integer :5,6,10,34,25,用NSArray实现逆序
    •    NSThread  NSLock 等实现线程锁，即当一个线程说话时锁定另一个线程，说完后再解锁

3、tableView加载大量图片时应该注意什么？
    应该使用多线程和异步加载数据
    - (void)updateImageForCellAtIndexPath:(NSIndexPath *)indexPath
    {
        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
        UIImage *image = [self getImageForCellAtIndexPath:indexPath];
        UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
        [cell.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];
        [pool release];
}
    然后再新开一个线程去做这件事情
    - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
    {
        [NSThread detachNewThreadSelector:@selector(updateImageForCellAtIndexPath:) toTarget:self withObject:indexPath];
    }
    同理当我们需要长时间的计算时,也要新开一个线程 去做这个计算以避免程序处于假死状态


       系统相机照相之后图片怎么压缩
        cell很乱的情况下怎么办，有几种方法
        sorket套接字    http   tcp
        地图api
        网络加载大图片时应该怎么做
        
 Cocoa中常用多线程实现？多线程安全问题解决方案？什么地方用到多线程？ 另外面试过程中还会问及C语言内存管理，和asihttp请求中断处理？

4.XML有哪些解析方式，有何优缺点？XML解析有哪些解析技术，区别是什么？
12.IphoneOS有没有垃圾回收?
13.什么是Notification模式？
14.什么时候使用delegate什么时候使用Notification？
1.分别以下列序列构造二叉排序树，与用其他三个序列所构造的结果不同的是( )。 A．(100，80，90，60，120，110，130) B．(100，120，110，130，80，60，90) C．(100，60，80，90，120，110，130) D．(100，80，60，90，120，130，110)   字典是一个二叉树吗？为什么?   2、[array alloca] 和 Narray *array; array 的内存技术是几。把它放入字典中是几。在从字典中remove是几。  4、网络请求为什么用jSON多，XML少 5、工场。IOS还有什么模式。用伪代码表示 6.arc 中unsafe_unretained 是作用。一个@property (strong) NSString *string1 默认是什么操作。 7，宏 和 函数的区别，在什么情况下用宏。宏扩展又是什么 8、多线程是什么，多线程同步是什么，异步？        写一个NSOPENRATION队列，体现初始化和填入队列方法 9、block的作用，不用block可以用什么实现。 10、在多线程中,下面代码有什么问题 怎么改 i nterface a:NSobject { NSmutableArray *array; } .... @im.... -(void)add:(*item item){ [array addObject :item]; } -(void)rem:(*item item){ [array removeobject:item]; }  11.什么是观察者模式。 12.NSOpertaion有几种种形式.


TCP 传输控制协议  是一种面向连接的、可靠的、基于字节流的运输层通信协议   短链接协议
TCP层是位于IP层之上，应用层之下的传输层
文件传送协议FTP(File TransferProtocol）允许用户从一台计算机到另一台取得文件，或发送文件到另外一台计算机。
UDP 用户数据报协议  是 OSI 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务
它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成，提供面向事务的简单不可靠信息传送服务。UDP 协议基本上是IP协议与上层协议的接口
UDP协议的主要作用是将网络数据流量压缩成数据包的形式
   长链接协议
TCP协议和UDP协议的区别
1，TCP协议面向连接，UDP协议面向非连接
2，TCP协议传输速度慢，UDP协议传输速度快
3，TCP协议保证数据顺序，UDP协议不保证
4，TCP协议保证数据正确性，UDP协议可能丢包
5，TCP协议对系统资源要求多，UDP协议要求少
特点：
支持客户/服务器模式
简单快速
灵活
无连接
无状态

流媒体  流媒体技术也称流式媒体技术。所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器，让用户一边下载一边观看、收听，而不需要等整个压缩文件下载到自己的计算机上才可以看到的网络传输技术。
   该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲
  
多线程：
Grand Central Dispatch或者GCD，是一套低层API
GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行
GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分
GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算

GCD中有三种队列类型：
The main queue：主队列
The main queue：全局队列即并发队列
用户队列：是用函数 dispatch_queue_create 创建的队列

第一题：service有时会被自动回收，你如何解决。
第二题：listview网络获取图片时会发生错位，如何解决。
第三题：数据算法实现：1,1,2,3,5,8,13....
第四题: 网络协议的两种时间
第五题: 自定义UI你都实现过哪些 怎么实现的
第六题: A activity start B activity 他俩的生命周期如何变化
第七题: Tabhost的生命周期
第八题: 敲一遍数据库操作 和 http连接网络
第九题: 图片如何加载不会发生内存的溢出,你对内存回收机制了解吗

一、微博登录时第一次授权之后，下次登录时就不需要授权了 为什么
二、项目需要连接网络时用的是系统的 还是第三方的？
三、ASI里的代理是用来干什么的

1、如何定义实现notification，参数如何传递？
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeLabel:) name:@"changeLabel" object:nil];

- (void)changeLabel:(nsnotifcation *)_notification
{
id a = [_notifcation object];
}

用的时候[[NSNotificationCenter defaultCenter] postNotificationName:@"changeLabel"  object:self];

2、打印当前时间，
    NSString * date;
    NSDateFormatter * formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"YYYY/MM/dd hh.mm.ss"];
        date = [formatter stringFromDate:[NSDate date]];
        NSLog(@"%@\n",date);

3、用换行符合并字符串
    NSString * str1 = @"asdfas";
       NSString * str2 = @"zxcv";
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
        NSString * str3 = [array componentsJoinedByString:@"\n"];
        NSLog(@"str3 is %@",str3);

4、查找拼接的字符串是否有换行符，有则log出它的位置，并以换行符为界，log其前后两段字符串，没有则return空。
    -(NSString *)logStr1:(NSString *)str1 andStr2:(NSString *)str2
{
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
    NSString * str3 = [array componentsJoinedByString:@"\n"];
    NSLog(@"str3 is %@",str3);

    NSRange range = [str3 rangeOfString:@"\n"];
    if (range.location != NSNotFound)
     {
        NSLog(@"range is %d",range.location);
        NSLog(@"str length is %d",[str3 length]);
        NSString * str = [str3 substringToIndex:range.location];
        NSLog(@"%d",[str length]);
        NSString * hou = [str3 substringFromIndex:range.location+1];
        NSLog(@"hou is %d",[hou length]);
    }
    else
    {
    return nil;
        }
}

5、创建一个线程，并写出线程执行函数
- (void)updateImageForCellAtIndexPath:(NSIndexPath *)indexPath
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    UIImage *image = [self getImageForCellAtIndexPath:indexPath];
    UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
    [cell.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];
    [pool release];
}
然后再新开一个线程去做这件事情
- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
{
    [NSThread detachNewThreadSelector:@selector(updateImageForCellAtIndexPath:) toTarget:self withObject:indexPath];
}

6、
    id object = nil;
        NSArray * array = [[NSArray alloc] init];
        for (id obj in array)
    {
               if ([obj isEqual:object])
        {
            
            }
            if ([obj isEqual:nil])
         {
            
               }
                if ([obj isEqual:NULL])
        {
            
            }
        }


AsyncSocket套接字

Socket描述了一个IP、端口对。它简化了程序员的操作，知道对方的IP以及PORT就可以给对方发送消息，再由服务器端来处理发送的这些消息。所以，Socket一定包含了通信的双发，即客户端（Client）与服务端（server）。
1）服务端利用Socket监听端口；
2）客户端发起连接；
3）服务端返回信息，建立连接，开始通信；
4）客户端，服务端断开连接。

1套接字（socket）概念
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
2 建立socket连接
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

4、SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

5、Socket连接与HTTP连接
由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很多情况下，需要服务器端主动向客户端推送

iphone 的标准推荐CFNetwork C库编程.但是编程比较烦躁。在其它OS往往用类来封装的对Socket函数的处理。比如MFC的CAsysncSocket.在iphone也有类似于 开源项目.cocoa AsyncSocket库, 官方网站:http://code.google.com/p/cocoaasyncsocket/ 它用来简化 CFnetwork的调用.
一.在项目引入ASyncSocket库
 1.下载ASyncSocket库源码
 2.把ASyncSocket库源码加入项目：只需要增加RunLoop目录中的AsyncSocket.h、AsyncSocket.m、AsyncUdpSocket.h和AsyncUdpSocket.m四个文件。
 3.在项目增加CFNetwork框架
      在Framework目录右健,选择Add-->Existing Files...    , 选择 CFNetwork.framework

二.TCP客户端
 1. 在controller头文件定义AsyncSocket对象
#import <UIKit/UIKit.h>
#import "AsyncSocket.h"

@interface HelloiPhoneViewController : UIViewController {
   UITextField    * textField;
   AsyncSocket * asyncSocket;
}
@property (retain, nonatomic) IBOutlet UITextField *textField;
- (IBAction) buttonPressed: (id)sender;
- (IBAction) textFieldDoneEditing: (id)sender;
@end

 2.在需要联接地方使用connectToHost联接服务器
 其中initWithDelegate的参数中self是必须。这个对象指针中的各个Socket响应的函数将被ASyncSocket所调用.

   asyncSocket = [[AsyncSocket alloc] initWithDelegate:self];
   NSError *err = nil;
   if(![asyncSocket connectToHost:host on:port error:&err])
   {
       NSLog(@"Error: %@", err);
   }

3.增加Socket响应事件
    因为initWithDelegate把将当前对象传递进去，这样只要在当前对象方法实现相应方法.

4.关于NSData对象
   无论SOCKET收发都采用NSData对象.它的定义是 http://developer.apple.com/library/mac /#documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/Reference/Reference.html
  NSData主要是带一个(id)data指向的数据空间和长度 length.
   NSString 转换成NSData 对象

     NSData* xmlData = [@"testdata" dataUsingEncoding:NSUTF8StringEncoding];

  NSData 转换成NSString对象

  NSData * data;
  NSString *result = [[NSString alloc] initWithData:data  encoding:NSUTF8StringEncoding];

4.发送数据
    AsyncSocket  writeData    方法来发送数据，它有如下定义
   - (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;

以下是一个实例语句.
    NSData* aData= [@"test data" dataUsingEncoding: NSUTF8StringEncoding];
    [sock writeData:aData withTimeout:-1 tag:1];
在onSocket重载函数，有如定义采用是专门用来处理SOCKET的发送数据的：
   -(void)onSocket(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{
     NSLog(@"thread(%),onSocket:%p didWriteDataWithTag:%d",[[NSThread currentThread] name],
    sock,tag);
}

5.接收Socket数据.
   在onSocket重载函数，有如定义采用是专门用来处理SOCKET的接收数据的.
   -(void) onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
在中间将其转换成NSString进行显示.

   NSString* aStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
   NSLog(@"===%@",aStr);
   [aStr release];

6.     什么是工厂
8.     为什么要异步下载图片
9.     xml如何解析
10. json如何解析

11. 数据库能否存放图片
    可以
    在iOS下用sqlite数据库存储图片，先把你的图片转换成NSData形式，然后再数据库中加一行blob数据。
12. 如何连接数据库
13. 如何关闭数据库
14. cell如何复用/复用的工作原理
    1.）每一行中都有一个Cell
    2.）有100行不代表有100个Cell的实力
    3.）如果在Cell标签相同的情况下，一个屏幕上最多看到多少行就有多少个Cell的实力
    4.）当TableView滚动式，被完全遮盖的行中的Cell会进入到当前TableViewCell复用池中，当有新的行进入屏幕显示时会先从TableViewCell池中寻找对应标签的闲置的Cell如果有直接拿来使用，如果没有再实例化新的Cell
    5.）Cell的复用机制的优点是节省内存，缺点是会造成数据的混乱(由于是复用之前已经实例化好的Cell，在复用时也会把之前设置好的内容得到由此造成数据的混乱，为了避免数据的混乱每次取出Cell后先进行数据的清空再使用)

16、 cell行数太多，如何滑动流畅
 
18.自动释放池是什么,如何工作  当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。
它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。
当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。 1.  ojc-c 是通过一种"referring counting"(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一, 以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁. 2. NSAutoreleasePool 就是用来做引用计数的管理工作的,这个东西一般不用你管的. 3. autorelease和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一.
19.objc优点：   1) Cateogies   2) Posing   3) 动态识别   4) 指标计算   5）弹性讯息传递   6) 不是一个过度复杂的 C 衍生语言   7) Objective-C 与 C++ 可混合编程   objc缺点:   1) 不支援命名空間   2)  不支持运算符重载   3） 不支持多重继承   4） 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。
20.sprintf,strcpy,memcpy使用上有什么要注意的地方    srcpy是一个字符串拷贝的函数，它的函数原型为strcpy(char *dst, const char *src);  将src开始的一段字符串拷贝到dst开始的内存中去结束的标志符号为 '\0'，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。具备字符串拷贝功能的函数有memcpy，这是一个内存拷贝函数，它的函数原型为memcpy(char *dst, const char* src, unsigned int len);将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存叠加的问题。 sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。 21. 用变量a给出下面的定义 a) 一个整型数（An integer）   b)一个指向整型数的指针（ A pointer to an integer）   c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r   d)一个有10个整型数的数组（ An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）   f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）   g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argumentand returns an integer）   h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）   答案是：   a) int a; // An integer   b) int *a; // A pointer to an integer   c) int **a; // A pointer to a pointer to an integer   d) int a[10]; // An array of 10 integers   e) int *a[10]; // An array of 10 pointers to integers   f) int (*a)[10]; // A pointer to an array of 10 integers   g) int (*a)(int); // A pointer to a function a that  takes an integer argument and returns an integer   h) int (*a[10])(int); // An array of 10 pointers to functions  that take an integer argument and return an integer
 
22.readwrite，readonly，assign，retain，copy，nonatomic 属性的作用@property是一个属性访问声明，扩号内支持以下几个属性： 1，getter=getterName，setter=setterName，设置setter与 getter的方法名 2，readwrite,readonly，设置可供访问级别 2，assign，setter方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题 3，retain，setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序(CC上有相关资料) 4，copy，setter方法进行Copy操作，与retain处理流程一样，先旧值release，再 Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。 5，nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级 25.你了解svn,cvs等版本控制工具么？ 版本控制 svn,cvs 是两种版控制的器,需要配套相关的svn，cvs服务器。 scm是xcode里配置版本控制的地方。版本控制的原理就是a和b同时开发一个项目，a写完当天的代码之后把代码提交给服务器，b要做的时候先从服务器得到最新版本，就可以接着做。 如果a和b都要提交给服务器，并且同时修改了同一个方法，就会产生代码冲突，如果a先提交，那么b提交时，服务器可以提示冲突的代码，b可以清晰的看到，并做出相应的修改或融合后再提交到服务器。
26.什么是push(了解一下）。
客户端程序留下后门端口，客户端总是监听针对这个后门的请求，于是 服务器可以主动像这个端口推送消息。
27.静态链接库(了解一下）
（此为.a文件，相当于java里的jar包，把一些类编译到一个包中，在不同的工程中如果导入此文件就可以使用里面的类， 具体使用依然是#import “ xx.h”）。
28.fmmpeg框架(了解一下）
（音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的）.
29.fmdb框架(了解一下)
（数据库框架，对sqllite的数据操作进行了封装，使用着可把精力都放在sql语句上面）。
30.320框架（了解一下）
（ui框架，导入320工程作为框架包如同添加一个普通框架一样）。cover(open)   flower框架 (2d 仿射技术)，内部核心类是CATransform3D.
31.什么是沙箱模型？哪些操作是属于私有api范畴? 某个iphone工程进行文件操作有此工程对应的指定的位置，不能逾越。iphone沙箱模型的有四个文件夹，分别是什么，永久数据存储一般放在什么位置，得到模拟器的路径的简单方式是什么.documents，tmp，app，Library。（NSHomeDirectory()），手动保存的文件在documents文件里Nsuserdefaults保存的文件在tmp文件夹里
 Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。 AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，
所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。 Library 目录：这个目录下有两个子目录：Caches 和 PreferencesPreferences 目录包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好. Caches 目录用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。 tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。 获取这些目录路径的方法： 1，获取家目录路径的函数： NSString *homeDir = NSHomeDirectory(); 2，获取Documents目录路径的方法： NSArray*paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; 3，获取Caches目录路径的方法： NSArray*paths=NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cachesDir = [paths objectAtIndex:0]; 4，获取tmp目录路径的方法： NSString *tmpDir = NSTemporaryDirectory(); 5，获取应用程序程序包中资源文件路径的方法： 例如获取程序包中一个图片资源（apple.png）路径的方法： NSString *imagePath = [[NSBundle mainBundle] pathForResource:@”apple” ofType:@”png”]; UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath]; 代码中的mainBundle类方法用于返回一个代表应用程序包的对象。 文件IO写入 1，将数据写到Documents目录： - (BOOL)writeApplicationData:(NSData *)data toFile:(NSString *)fileName {    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
   NSString *docDir = [paths objectAtIndex:0];
   if (!docDir) {
    NSLog(@”Documents directory not found!”); return NO;
   }   NSString*filePath=[docDirstringByAppendingPathComponent:fileName];    return [data writeToFile:filePath atomically:YES];
} 2，从Documents目录读取数据： - (NSData *)applicationDataFromFile:(NSString *)fileName {    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
   NSString *docDir = [paths objectAtIndex:0];
   NSString *filePath = [docDir stringByAppendingPathComponent:fileName];
   NSData *data = [[[NSData alloc] initWithContentsOfFile:filePath] autorelease];
   return data;
} NSSearchPathForDirectoriesInDomains这个主要就是返回一个绝对路径用来存放我们需要储存的文件。
 - (NSString *)dataFilePath {    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    return [documentsDirectory stringByAppendingPathComponent:@"shoppingCar.plist"]; } NSFileManager* fm=[NSFileManager defaultManager]; if(![fm fileExistsAtPath:[self dataFilePath]]){
 //下面是对该文件进行制定路径的保存 [fm createDirectoryAtPath:[self dataFilePath] withIntermediateDirectories:YES attributes:nil error:nil];
 //取得一个目录下得所有文件名 NSArray *files = [fm subpathsAtPath: [self dataFilePath] ]; //读取某个文件 NSData *data = [fm contentsAtPath:[self dataFilePath]]; //或者 NSData *data = [NSData dataWithContentOfPath:[self dataFilePath]]; }
iphone常见私有api的应用（比如直接发送短信，访问沙箱之外的磁盘文件）. 32.你在开发项目中时，用到了哪些数据存储方式，iphone中常见的方式有哪些，各有什么区别？
数据存储五种形式的应用范围和性能区别
（core data,  sqllite,对象序列化，文件直接读写，NSUserDefault(保存数据到temp文件夹中)） 文件直接读写 >core data> 对象序列化> sqllite>NSUserDefault.
33.线程的常见方法有哪些，你是如何处理多线程的，多线程同步问题你了解么？ 线程创建的几种方式，线程的加锁，休眠，唤醒，解锁，退出，多线程要考虑同步问题,解决同步问题的方式就是对某一资源加锁，当一个线程操作本资源时，其他线程不能操作 。 系统自带线程池（NSOpertionQueue）的作用：
凡是需要启动多个线程的地方都可以使用NSOpertionQueue，加入到NSOpertionQueue中的对象都需要继承NSOpertion。 NSOpertionQueue会在系统内部启动一个独立线程去执行这个被加入对象的main方法。
常用的地方是用nsoprationqueue 下载图片，文件。如果是自己创建一个线程池，无非就是启动多个线程的时候，把这些线程对象放到一个大数组中，如果需要启动线程的时候，先从数组中找空闲线程来使用。自己管理线程池最大的难题是不好处理当启动多个线程后，用户在多个界面的跳转的时候，对线程方法的回调管理。而NSOpertionQueue可以很好的处理他。
34.init和initwithobject区别（语法）？
 init创建的对象不带自动释放
 36.你使用过json解析方式么，他们的底层是如何处理的你了解么？ json解析的用法，用框架的用法简单介绍：
底层原理遍历字符串中的字符，最终根据格式规定的特殊字符，比如{}号，[]号, : 号 等进行区分，  {}号是一个字典的开始，[]号是一个数组的开始, : 号是字典的键和值的分水岭，最终乃是将json数据转化为字典，字典中值可能是字典，数组，或字符串而已。
37.xml解析的原理是什么，你还用过其他解析方式么？ NSXMLParser, 其他解析方式有自定义二进制解析，就是按字节去解析，电话会谈就是如此，还可以是字符串之间用特殊符号连接的数据，将此数据用特殊符号可以分割成所用数据。
38.协议是什么，有什么作用.？ 协议很像java中的接口，某个类实现协议后，就必须实现协议中规定的@require的方法，比如一个类A, 一个类B都实现某“协议”后，这个类A的对象和B的对象都可以赋值给这个协议的类型变量，比如  id<协议> 变量名 = A类或B类的对象，于是这个变量就完成了能够指向多个不同的类的对象并调用对象中的实现协议的方法。 39.类别有什么作用？ 类别的使用 。 类别有三大作用，
1. 可以使本来需要在.h中声明的方法放到.m文件中声明，达到了可以使方法不对外公开。
2. 可以方便的扩展类，甚至系统类都可以轻易扩展，维护了代码原本的结构不受影响。
3. 类别可以写到不同的.h或.m文件中，可以分散代码到跟类别的扩展功能想关联的地方，方便查看。 
42.你在开发大型项目的时候，如何进行内存泄露检测的?   可以通过xcode的自带工具run---start with performance tool里有instruments下有个leaks工具，
启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄露的处理。
43.你做iphone开发时候，有哪些传值方式，view和view之间是如何传值的？
     压栈。
44.让一个物体从界面中的一点运动到另外一点，有哪些方法？ 四种方式：1. beginAnimation
              2. 线程
              3. NSTimer
              4. 图层动画（路径）
45.你了解哪些加密方式？    Base64, MD5, 循环右移位等.
46.地图定位
CLLocationManager位置管理器  使用Core Location框架来确定iphone的位置（GPS，蜂窝基站三角网，wps三种方式）
MKMapView提供了一套可植入的地图接口，可以让我们在应用中展示地图，并对其进行相关的操作。一般来说，我们可以指定一个展示区域，放一些标记在上面，还可以加盖一些层在上面。
MKMapView依赖Google map里面相关服务（如Google Earth API等），所以地图的左下角会有Google字样。
47.打开url
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://8004664411"]];HYPERLINK "mailto://www.cnblogs.com"mailto://   sms://
48. http网络通信
ASIHTTPRequest 是一个直接在CFNetwork上做的开源项目：提供直接提交(HTTP POST)文件的API，异步请求与队列，自动管理上传与下载队列管理机,ASIFormDataRequest用于适合上传文件，图片数据。
49. 图片浏览
UIImagePickerController可以从相册，相机，胶卷里获得图片。
50. 对像序列化
NSCoding    encodeWithCoder   initWithCoder
NSKeyedUnarchiver   NSKeyedArchiver
     
53.线程 ？
  a. 线程的创建和使用规则?
答：NSThread三种方法
- (id)init; // designated initializer
-(id)initWithTarget:(id)targetselector:(SEL)selector object:(id)argument;
+(void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument
- (void)start;
b. 主分线程
答：启动分线程，上面已提到！加到主线程方法performSelector！
//加到主线程addData()是主线程的方法！只有加到主线程后，才能调用主线程的方法
 [targetperformSelector:@selector(addData:) onThread:[NSThread mainThread] withObject:item waitUntilDone:YES];
//[target addData:item];//没有加到主线程后，调用主线程的方法！一定会崩！
c.线程锁
答：NSCondition方法：
 [thread lock];//加锁
sleep(n);//线程休眠
 [thread singnal];//相当于通知，线程启动
 [thread unlock];//解锁
 [thread exit];//线程退出

答： 会引起循环引用所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系：
* 对象a创建并引用到了对象b.
* 对象b创建并引用到了对象c.
* 对象c创建并引用到了对象b.
这时候b和c的引用计数分别是2和1。
当a不再使用b，调用release释放对b的所有权，因为c还引用了b，所以b的引用计数为1，b不会被释放。b不释放，c的引用计数就是1，c也不会被释放。从此，b和c永远留在内存中。这种情况，必须打断循环引用，通过其他规则来维护引用关系。我们常见的delegate往往是assign方式的属性而不是retain方式 的属性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。如果一个UITableViewController 对象a通过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a，如果这个delegate是retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。
57. 以下每行代码执行后，person对象的retain count分别是多少？
      Person *person = [[Person alloc] init]; count 1
      [person retain]; retain  count 2
      [person release];retain count 1
      [person release];retain count = 0
  60.1.main()  {    int a[5]={1,2,3,4,5};    int *ptr=(int *)(&a+1);    printf("%d,%d",*(a+1),*(ptr-1)); } 答：2,5      *(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）int *ptr=(int *)(&a+1); 则ptr实际是&(a[5]),也就是a+5 原因如下： 　　&a是数组指针，其类型为 int (*)[5]; 　　而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 但是prt与(&a+1)类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*)a,&a的地址是一样的，但意思不一样a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址， a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].

 int *a;
int b[4]={1,2,3,4};
char *c;
char d[4]={‘q’,’w’,’r’,’t’};
printf(“%d,%d,%d,%d”,sizeof(a),sizeof(b),sizeof(c),sizeof(d));
写出打印结果
const int a;
const int *a;
int * const a;
const int * const a;
       写出各语句的功能
有integer :5,6,10,34,25,用NSArray实现逆序
NSThread  NSLock 等实现线程锁，即当一个线程说话时锁定另一个线程，说完后再解锁

2、Notification封装了哪3个内容
    1.）(NSString *)name;
    2.）(id)object;
    3.）(NSDictionary *)userInfo;

3.     你如何理解代理/委托
    委托代理（delegate），顾名思义，把某个对象要做的事情委托给别的对象去做，那么别的对象就是这个对象的代理，代替它来打理要做的事。
    在cocoa框架中的Delegate模式中，委托人往往是框架中的对象（视图中的控件、表视图神马的），代理人往往是视图控制器对象。

7.     网络你如何下载图片

18、tableview滑动时图片加载缓慢解决办法
    使图片异步加载
    在
    -(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath函数中加载图片的时候使用
    [cell.imageView setImageWithURL:[NSURL URLWithString:url] placeholderImage:nil ];
    这里的nil也可以换成默认的一张图片，这样系统运行起来就比较流畅，因为图片是异步加载的，加载好了直接放到缓存里，下次的时候就不再去跟服务器通讯了。

TCP 传输控制协议  是一种面向连接的、可靠的、基于字节流的运输层通信协议   短链接协议

TCP层是位于IP层之上，应用层之下的传输层

文件传送协议FTP(File TransferProtocol）允许用户从一台计算机到另一台取得文件，或发送文件到另外一台计算机。

UDP 用户数据报协议  是 OSI 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务

它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成，提供面向事务的简单不可靠信息传送服务。UDP 协议基本上是IP协议与上层协议的接口

UDP协议的主要作用是将网络数据流量压缩成数据包的形式
   长链接协议

TCP协议和UDP协议的区别
1，TCP协议面向连接，UDP协议面向非连接
2，TCP协议传输速度慢，UDP协议传输速度快
3，TCP协议保证数据顺序，UDP协议不保证
4，TCP协议保证数据正确性，UDP协议可能丢包
5，TCP协议对系统资源要求多，UDP协议要求少

流媒体  流媒体技术也称流式媒体技术。所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器，让用户一边下载一边观看、收听，而不需要等整个压缩文件下载到自己的计算机上才可以看到的网络传输技术。
   该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲
  
多线程：

Grand Central Dispatch或者GCD，是一套低层API

GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行
GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分/Users/jerry/Downloads/MapKit-LBS项目-FindMe.pdf
/Users/jerry/Downloads/额外视频.tar.gz

GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算

GCD中有三种队列类型：
The main queue：主队列
The main queue：全局队列即并发队列
用户队列：是用函数 dispatch_queue_create 创建的队列

下面的代码存在的潜在的问题，请指出来，并纠正它
for(int i=0;i<someLargeNumber;i++){
NSMutableString*string=[ NSMutableString  stringWithString:@”a long long text…….”];
string=[ string lowercaseString];
string=[ string stringByAppendingString:…….];
NSLog(@”%@”, string);
}
10.请扩展NSString类，增加一个isEmpty方法，要求字符串有内容是返回YES无内容时返回NO

程序运行的时候内存分几个区？各区的用途？
C中分配内存的方式有哪些？
Kvo/kvc的机制？
阐述以下推送功能的原理机制？
Object-c中用什么修饰私有变量？
Object-c中创建一个工程需要用到那两个框架？
写一个委托Delegate的interface

写出下面a的含义：
 int a，int *a，int a[10]，int *a[10]，int (*a)[10]， int (*a)(int)， int (*a[10])(int);

1、如何定义实现notification，参数如何传递？
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeLabel:) name:@"changeLabel" object:nil];

- (void)changeLabel:(nsnotifcation *)_notification
{
id a = [_notifcation object];
}

用的时候[[NSNotificationCenter defaultCenter] postNotificationName:@"changeLabel"  object:self];

2、打印当前时间，
    NSString * date;
    NSDateFormatter * formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"YYYY/MM/dd hh.mm.ss"];
        date = [formatter stringFromDate:[NSDate date]];
        NSLog(@"%@\n",date);

3、用换行符合并字符串
    NSString * str1 = @"asdfas";
       NSString * str2 = @"zxcv";
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
        NSString * str3 = [array componentsJoinedByString:@"\n"];
        NSLog(@"str3 is %@",str3);

4、查找拼接的字符串是否有换行符，有则log出它的位置，并以换行符为界，log其前后两段字符串，没有则return空。
    -(NSString *)logStr1:(NSString *)str1 andStr2:(NSString *)str2
{
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
    NSString * str3 = [array componentsJoinedByString:@"\n"];
    NSLog(@"str3 is %@",str3);

    NSRange range = [str3 rangeOfString:@"\n"];
    if (range.location != NSNotFound)
     {
        NSLog(@"range is %d",range.location);
        NSLog(@"str length is %d",[str3 length]);
        NSString * str = [str3 substringToIndex:range.location];
        NSLog(@"%d",[str length]);
        NSString * hou = [str3 substringFromIndex:range.location+1];
        NSLog(@"hou is %d",[hou length]);
    }
    else
    {
    return nil;
        }
}

category 和 extension 的区别
* 分类有名字，类扩展没有分类名字，是一种特殊的分类
* 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法
define 和 const常量有什么区别?
* define在预处理阶段进行替换，const常量在编译阶段使用
* 宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查
* define不能调试，const常量可以调试
* define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高
* define可以定义一些简单的函数，const不可以
block和weak修饰符的区别？
* __block不管是ARC还是MRC模式下都可以使用，可以修饰对象，也可以修饰基本数据类型
* __weak只能在ARC模式下使用，只能修饰对象（NSString），不能修饰基本数据类型
* block修饰的对象可以在block中被重新赋值，weak修饰的对象不可以
static关键字的作用
* 函数（方法）体内 static 变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
* 在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
* 在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内；
* 在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
* 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量

+(void)load;
+(void)initialize;有什么用处？
* +(void)load;
    * 当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息
    * load 方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类, 子类优先于分类
    * 由于 load 方法会在类被import 时调用一次,而这时往往是改变类的行为的最佳时机，在这里可以使用例如method swizlling 来修改原有的方法
    * load 方法不会被类自动继承
* +(void)initialize;
    * 也是在第一次使用这个类的时候会调用这个方法，也就是说 initialize也是懒加载
* 总结：
    * 在Objective-C中，runtime会自动调用每个类的这两个方法
    * +load会在类初始加载时调用
    * +initialize会在第一次调用类的类方法或实例方法之前被调用
    * 这两个方法是可选的，且只有在实现了它们时才会被调用
    * 两者的共同点：两个方法都只会被调用一次
Foundation对象与Core Foundation对象有什么区别
* Foundation框架是使用OC实现的，Core Foundation是使用C实现的
* Foundation对象 和 Core Foundation对象间的转换：俗称桥接
    * ARC环境桥接关键字： // 可用于Foundation对象 和 Core Foundation对象间的转换
    * __bridge
    *
    * // 用于Foundation对象 转成 Core Foundation对象
    * __bridge_retained
    *
    * // Core Foundation对象 转成 Foundation对象
    * __bridge_transfer
    *
    *
        * Foundation对象 转成 Core Foundation对象
            * 使用__bridge桥接
                * 如果使用__bridge桥接,它仅仅是将strOC的地址给了strC, 并没有转移对象的所有权，也就是说, 如果使用__bridge桥接, 那么如果strOC释放了,strC也不能用了
                * 注意:在ARC条件下,如果是使用__bridge桥接,那么strC可以不用主动释放, 因为ARC会自动管理strOC和strC
            * NSString *strOC1 = [NSString stringWithFormat:@"abcdefg"];
            * CFStringRef strC1 = (__bridge CFStringRef)strOC1;
            * NSLog(@"%@ %@", strOC1, strC1);
            *
            *  
            * 使用__bridge_retained桥接
                * 如果使用__bridge_retained桥接,它会将对象的所有权转移给strC, 也就是说, 即便strOC被释放了, strC也可以使用
                * 注意:在ARC条件下,如果是使用__bridge_retained桥接,那么strC必须自己手动释放,因为桥接的时候已经将对象的所有权转移给了strC,而C语言的东西不是不归ARC管理的
            * NSString *strOC2 = [NSString stringWithFormat:@"abcdefg"];
            * //    CFStringRef strC2 = (__bridge_retained CFStringRef)strOC2;
            * CFStringRef strC2 = CFBridgingRetain(strOC2);// 这一句, 就等同于上一句
            * CFRelease(strC2);
            *
            *  
        * Core Foundation对象 转成 Foundation对象
            * 使用__bridge桥接
                * 如果使用__bridge桥接,它仅仅是将strC的地址给了strOC, 并没有转移对象的所有权
                * 也就是说如果使用__bridge桥接,那么如果strC释放了,strOC也不能用了
            * CFStringRef strC3 = CFStringCreateWithCString(CFAllocatorGetDefault(), "12345678", kCFStringEncodingASCII);
            * NSString *strOC3 = (__bridge NSString *)strC3;
            * CFRelease(strC3);
            *
            *  
            * 使用__bridge_transfer桥接
                * 如果使用__bridge_transfer桥接,它会将对象的所有权转移给strOC, 也就是说, 即便strC被释放了, strOC也可以使用
                * 如果使用__bridge_transfer桥接, 他会自动释放strC, 也就是以后我们不用手动释放strC
            * CFStringRef strC4 = CFStringCreateWithCString(CFAllocatorGetDefault(), "12345678", kCFStringEncodingASCII);
            * //     NSString *strOC = (__bridge_transfer NSString *)strC;
            * NSString *strOC4 = CFBridgingRelease(strC4); // 这一句, 就等同于上一句
            *
            *  
    * MRC环境：直接强转 -(void)bridgeInMRC
    * {
    *   // 将Foundation对象转换为Core Foundation对象，直接强制类型转换即可
    *   NSString *strOC1 = [NSString stringWithFormat:@"xxxxxx"];
    *   CFStringRef strC1 = (CFStringRef)strOC1;
    *   NSLog(@"%@ %@", strOC1, strC1);
    *   [strOC1 release];
    *   CFRelease(strC1);
    *
    *   // 将Core Foundation对象转换为Foundation对象，直接强制类型转换即可
    *   CFStringRef strC2 = CFStringCreateWithCString(CFAllocatorGetDefault(), "12345678", kCFStringEncodingASCII);
    *   NSString *strOC2 = (NSString *)strC2;
    *   NSLog(@"%@ %@", strOC2, strC2);
    *   [strOC2 release];
    *   CFRelease(strC2);
    * }
    *
    *  
addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？
/**
 1. self.person：要监听的对象
 2. 参数说明
    1> 观察者，负责处理监听事件的对象
    2> 要监听的属性
    3> 观察的选项（观察新、旧值，也可以都观察）
    4> 上下文，用于传递数据，可以利用上下文区分不同的监听
 */
[self.person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];

/**
 *  当监控的某个属性的值改变了就会调用
 *
 *  @param keyPath 监听的属性名
 *  @param object  属性所属的对象
 *  @param change  属性的修改情况（属性原来的值、属性最新的值）
 *  @param context 传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
    NSLog(@"%@对象的%@属性改变了：%@", object, keyPath, change);
}

KVO内部实现原理
* KVO是基于runtime机制实现的
* 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制
* 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person
* 每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法
* 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。
    •    补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类
￼
*
如何手动触发一个value的KVO
* 自动触发的场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了
* 想知道如何手动触发，必须知道自动触发 KVO 的原理，见上面的描述
* 手动触发演示
@property (nonatomic, strong) NSDate *now;

- (void)viewDidLoad
{
    [super viewDidLoad];

    // “手动触发self.now的KVO”，必写。
    [self willChangeValueForKey:@"now"];

    // “手动触发self.now的KVO”，必写。
    [self didChangeValueForKey:@"now"];
}

若一个类有实例变量NSString *_foo，调用setValue:forKey:时，是以foo还是_foo作为key？
* 都可以
KVC的keyPath中的集合运算符如何使用？
* 必须用在集合对象上或普通对象的集合属性上
* 简单集合运算符有@avg， @count ， @max ， @min ，@sum
* 格式 @"@sum.age" 或 @"集合属性.@max.age"？？？
KVC和KVO的keyPath一定是属性么？
* 可以是成员变量
如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？
* 如何自己动手实现 KVO
apple用什么方式实现对一个对象的KVO？
* 此题就是问KVO的实现原理

Size Classes 具体使用
* 对屏幕进行分类
UIView和CALayer是什么关系?
* UIView显示在屏幕上归功于CALayer，通过调用drawRect方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承自UIResponder，比起CALayer可以响应用户事件，Xcode6之后可以方便的通过视图调试功能查看图层之间的关系
* UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它内部是由Core Animation来实现的，它真正的绘图部分，是由一个叫CALayer(Core Animation Layer)的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性
* UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，如：
- (class) layerClass {
    // 使某个UIView的子类使用GL来进行绘制
    return ([CAEAGLLayer class]);
}

 UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的显示。例如下面的代码会在目标View上敷上一层黑色的透明薄膜。
grayCover = [[CALayer alloc]init];
grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor;
[self.layer addSubLayer:grayCover];

* 补充部分，这部分有深度了，大致了解一下吧，UIView的layer树形在系统内部被系统维护着三份copy
    * 逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份
    * 动画树，这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作
    * 显示树，这棵树的内容是当前正被显示在屏幕上的内容
    * 这三棵树的逻辑结构都是一样的，区别只有各自的属性
loadView的作用？
* loadView用来自定义view，只要实现了这个方法，其他通过xib或storyboard创建的view都不会被加载
    •    看懂控制器view创建的这个图就行
￼
IBOutlet连出来的视图属性为什么可以被设置成weak?
* 因为父控件的subViews数组已经对它有一个强引用
IB中User Defined Runtime Attributes如何使用？
* User Defined Runtime Attributes是一个不被看重但功能非常强大的的特性，它能够通过KVC的方式配置一些你在interface builder中不能配置的属性
* 当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller
沙盒目录结构是怎样的？各自用于那些场景？
* Application：存放程序源文件，上架前经过数字签名，上架后不可修改
* Documents：常用目录，iCloud备份目录，存放数据
* Library
    * Caches：存放体积大又不需要备份的数据
    * Preference：设置目录，iCloud会备份设置信息
* tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能
pushViewController和presentViewController有什么区别
* 两者都是在多个试图控制器间跳转的函数
* presentViewController提供的是一个模态视图控制器(modal)
* pushViewController提供一个栈控制器数组，push/pop
请简述UITableView的复用机制
* 每次创建cell的时候通过dequeueReusableCellWithIdentifier:方法创建cell，它先到缓存池中找指定标识的cell，如果没有就直接返回nil
* 如果没有找到指定标识的cell，那么会通过initWithStyle:reuseIdentifier:创建一个cell
* 当cell离开界面就会被放到缓存池中，以供下次复用
如何高性能的给 UIImageView 加个圆角?
* 不好的解决方案
    * 使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现 self.view.layer.cornerRadius = 5;
    * self.view.layer.masksToBounds = YES;

* 正确的解决方案：使用绘图技术 
- (UIImage *)circleImage
{
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);

    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);

    // 裁剪
    CGContextClip(ctx);

    // 将图片画上去
    [self drawInRect:rect];

    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();

    // 关闭上下文
    UIGraphicsEndImageContext();

    return image;
}

* 还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];

使用drawRect有什么影响？
* drawRect方法依赖Core Graphics框架来进行自定义的绘制
* 缺点：它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了
* 这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前图层标记为dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将标记为 dirty 的图层重新建立Core Graphics上下文,然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制
描述下SDWebImage里面给UIImageView加载图片的逻辑
* SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后在替换占位图片
* 加载图片的过程大致如下：
    * 首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存
    * 如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来
    * 如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片
    * 下载后的图片会加入缓存中，并写入磁盘中
    * 整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来
设计个简单的图片内存缓存器
* 类似上面SDWebImage实现原理即可
* 一定要有移除策略：释放数据模型对象
控制器的生命周期
* 就是问的view的生命周期，下面已经按方法执行顺序进行了排序
// 自定义控制器view，这个方法只有实现了才会执行
- (void)loadView
{
    self.view = [[UIView alloc] init];
    self.view.backgroundColor = [UIColor orangeColor];
}
// view是懒加载，只要view加载完毕就调用这个方法
- (void)viewDidLoad
{
    [super viewDidLoad];

    NSLog(@"%s",__func__);
}

// view即将显示
- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];

    NSLog(@"%s",__func__);
}
// view即将开始布局子控件
- (void)viewWillLayoutSubviews
{
    [super viewWillLayoutSubviews];

    NSLog(@"%s",__func__);
}
// view已经完成子控件的布局
- (void)viewDidLayoutSubviews
{
    [super viewDidLayoutSubviews];

    NSLog(@"%s",__func__);
}
// view已经出现
- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];

    NSLog(@"%s",__func__);
}
// view即将消失
- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];

    NSLog(@"%s",__func__);
}
// view已经消失
- (void)viewDidDisappear:(BOOL)animated
{
    [super viewDidDisappear:animated];

    NSLog(@"%s",__func__);
}
// 收到内存警告
- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];

    NSLog(@"%s",__func__);
}
// 方法已过期，即将销毁view
- (void)viewWillUnload
{

}
// 方法已过期，已经销毁view
- (void)viewDidUnload
{

}

你是怎么封装一个view的
* 可以通过纯代码或者xib的方式来封装子控件
* 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值
/**
 *  纯代码初始化控件时一定会走这个方法
 */
- (instancetype)initWithFrame:(CGRect)frame
{
    if(self = [super initWithFrame:frame])
    {
        [self setup];
    }

    return self;
}

/**
 *  通过xib初始化控件时一定会走这个方法
 */
- (id)initWithCoder:(NSCoder *)aDecoder
{
    if(self = [super initWithCoder:aDecoder])
    {
        [self setup];
    }

    return self;
}

- (void)setup
{
    // 初始化代码
}

如何渲染UILabel的文字？
* 通过NSAttributedString/NSMutableAttributedString（富文本）
UIScrollView的contentSize能否在viewDidLoad中设置？
* 能
* 因为UIScrollView的内容尺寸是根据其内部的内容来决定的，所以是可以在viewDidLoad中设置的
* 补充：（这仅仅是一种特殊情况）
    * 前提，控制器B是控制器A的一个子控制器，且控制器B的内容只在控制器A的view的部分区域中显示
    * 假设控制器B的view中有一个UIScrollView这样一个子控件
    * 如果此时在控制器B的viewDidLoad中设置UIScrollView的contentSize的话会导致不准确的问题
    * 因为任何控制器的view在viewDidLoad的时候的尺寸都是不准确的，如果有子控件的尺寸依赖父控件的尺寸，在这个方法中设置会导致子控件的frame不准确，所以这时应该在下面的方法中设置子控件的尺寸
-(void)viewDidLayoutSubviews;

如何实现类似QQ的三角形头像
* Quartz2D
* 使用coreGraphics裁剪出一个三角形
核心动画里包含什么？
* 基本动画
* 回头自己总结吧
如何使用核心动画？
* 创建
* 设置相关属性
* 添加到CALayer上，会自动执行动画

10.object-c中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码，方法又是什么？
答:a、线程创建有三种方法：使用NSThread创建(detachNewThreadSelector:toTarget:withObject:)、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;
b、在主线程执行代码，方法是performSelectorOnMainThread，
c、如果想延时执行代码可以用performSelector:withObject:afterDelay:

14. UITableViewCell怎样使用更流畅？
首先cell的复用机制节约了系统资源；其次应当注意有些复杂的大数据或网络数据应采用异步加载的方式进行加载，以免cell刷出时发生卡顿。

15. 在UIWebView上点击回复，如何使用UITextField进行回复？
UIWebView有一个stringByEvaluatingJavaScriptFromString方法可以将javascript嵌入页面中，通过这个方法我们可以在iOS中与UIWebView中的网页元素交互。通过JAVAScript获取点击时间，弹出UITextField，输入字符串后，可以通过post请求发送回复。

16. 关于图文混排是如何排版的？
图文混排应当以图片为起点，首先明确图片的位置，文字可以选择位于图片的下方，或者是环绕效果。环绕效果可以采用2个以上label或textView来实现；也可以通过AttributeString的属性设置，或者CoreText重绘UIVIew，添加文字的方式，修改文字间的间隔，达到让出图片的效果。如果图文显示在高度可变的视图中，如tableView的Cell中，可以计算文字占位Rect，动态修改视图或cell的高度。

17. @property (nonatomic, retain) IBOutlet UIView * view这个对象需要release吗，如果需要，如何做?
其实XIB文件所生成的视图对象是无法真正释放的，因此关联XIB的属性也可以设置为assign属性，而视图不会释放。从这个角度上讲，这个对象不释放也可以，但是既然用retain做修饰符，出于尊重内存管理法则，理应进行释放，最简单的方式就是将视图在dealloc方法中设为nil，适用于非ARC，但ARC中这样写也没关系。

18. 两种传输协议在什么时候使用？
所谓的两种传输协议，是指网络协议中的传输层协议，即TCP协议和UDP协议。TCP协议会在收发数据的两端建立稳定可靠，有序的链接，传输数据稳定可靠，但系统资源消耗较大，适合，数据或文件的下载或上传，Http网络协议就是采用TCP传输协议传输数据的。UDP是通俗讲得漂流瓶协议，发出协议的主机就像扔出漂流瓶的鲁滨逊一样，不再负责数据的跟踪和校验，优点是系统资源占用低，缺陷是没有在收发两端建立稳定的传输路线，数据有丢包，损坏或后发先至等缺陷，优秀的UDP传输服务器，会反复发送校验序列，以保证数据的正确。

19. push推送机制
iOS 在系统级别有一个推送服务程序使用 5223 端口。使用这个端口的协议源于 Jabber 后来发展为 XMPP ，被用于 Gtalk 等 IM 软件中。所以， iOS 的推送，可以不严谨的理解为：
苹果服务器朝手机后台挂的一个 IM 服务程序发送的消息。
然后，系统根据该 IM 消息识别告诉哪个 Apps 具体发生了什么事。
然后，系统分别通知这些 Apps 。

20. iOS 播放音频的几种方法?
iPhone OS 主要提供以下了几种播放音频的方法：
System Sound Services
AVAudioPlayer 类
Audio Queue Services
OpenAL

21. 代理的作用
代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为java中的回调监听机制的一种类似。
22. int  retVal=UIApplication(argc,argv,nil,nil):是什么意思

对UIApplication对象进行了初始化，这个方法除了argc 和argv 参数外，另外这个函数还有2个两个字符串参数来识别UIApplication类和UIApplication代理类，在这里默认是2个nil,第一个参数为nil就默认把UIApplication类作为缺省值进行初始化，可以在这里不填nil而是使用自己定义的UIApplication子类。至于第二个参数nil就设置为nil就把模板生成的HelloWorldAppdelegate类作为默认值。

23. 保存一个变量到本地，列举两个简单的方法
    1，用NSUserDefaults存储小量数据
    2，直接writeTofF ile
    3，存数据库
    4，归档

24. 如果UIView * view 已经实例化，在view仅添加了n 个UIButton 类的实例，这些button不是全局的，并且button已经用tag区分开，如何快速找出指定的一个button改变他的属性？
     
    button=(UIButton*)[view viewWithTag:tag]

25. 当A类 中的某个方法执行到某处时，这时想在B类中执行某个方法，如何做？并做简单说明
        用代理执行代理方法
    说明：在b类中实现协议方法，设置a的代理为b，在指定方法内    调用代理的协议方法

26. oc中加号方法与减号方法的区别

    加号方法是类方法，用类名直接调用
    减号方法为实例方法，需要创建一个实例对象调用
    
28，一个UITableview的实例，重新加载数据的方法是什么？

    reloadData  刷新整个表格  和 reloadSections:     withRowAnimation  刷新一组数据
29. XML有哪几种解析方式，他们各有什么优点
答：有Sax和Dom两种解析方式，sax是逐行解析。dom是一次性全部加载xml文件，然后解析

29.iOS平台怎么做数据持久化
有以下方式做
1、NSUserDefaults
2、Plist
3、数据库
4、文件保存
5、归档与反归档

30.int  retVal=UIApplication(argc,argv,nil,nil):是什么意思

对UIApplication对象进行了初始化，这个方法除了argc 和argv 参数外，另外这个函数还有2个两个字符串参数来识别UIApplication类和UIApplication代理类，在这里默认是2个nil,第一个参数为nil就默认把UIApplication类作为缺省值进行初始化，可以在这里不填nil而是使用自己定义的UIApplication子类。至于第二个参数nil就设置为nil就把模板生成的HelloWorldAppdelegate类作为默认值。

31.iOS平台怎么做数据的持久化?Core Data和SQLite有无必然联系？Core Data是一个关系型数据库吗？
答：iOS中可以有四种持久化数据的方式： 属性列表、对象归档、SQLite3和Core Data
 Core data与sqlite还是有联系的，core data 是对sqlite的封装，因为sqlite是c语言的api，然而有人也需要obj-c 的api，所以有了 core data 另外，core data不仅仅是把c的api翻译成oc 的api，还提供了一些管理的功能，使用更加方便
Core Data不是一个关系型数据库，也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型，但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系

37. 你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。
使用NSOperationQueue用来管理子类化的NSOperation对象，控制其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接口简单，建议在复杂项目中使用。
项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。

38. 谈谈对swift的看法
Swift 作为 Apple 钦定的 objc 的继承者，作为 iOS/Mac 开发者的话，是觉得必须和值得学习和使用的。现在 Swift 可以和原来的 objc 或者 c 系的代码混用。因为在很多语法特性上 Swift 确实和一些脚本非常相似。但是首先需要明确的是，至少在 Apple 开发中，Swift 不是以一种脚本语言来运行的，所有的 Swift 代码都将被 LLVM 编译为 native code，以极高的效率运行。按照官方今天给出的 benchmark 数据，运行时比 Python 快 3.9 倍，比 objc 快 1.4 倍左右。我相信官方数据肯定是有些水分，但是即使这样，Swift 也给人带来很多遐想和期待。Swift 和原来的 objc 一样，是类型安全的语言，变量和方法都有明确的返回，并且变量在使用前需要进行初始化。而在语法方面，Swift 迁移到了业界公认的非常先进的语法体系，其中包含了闭包，多返回，泛型和大量的函数式编程的理念，函数也终于成为一等公民可以作为变量保存了（虽然具体实现和用法上来看和 js 那种传统意义的好像不太一样）。初步看下来语法上借鉴了很多 Ruby 的人性化的设计，但是借助于 Apple 自己手中 强大的 LLVM，性能上必须要甩开 Ruby 不止一两个量级。

另一方面，Swift 的代码又是可以 Interactive 来“解释”执行的。新的 Xcode 中加入了所谓的 Playground 来对开发者输入的 Swift 代码进行交互式的相应，开发者也可是使用 swift 的命令行工具来交互式地执行 swift 语句。细心的朋友可能注意到了，我在这里把“解释”两个字打上了双引号。这是因为即使在命令行中， Swift 其实也不是被解释执行的，而是在每个指令后进对从开始以来的 swift 代码行了一遍编译，然后执行的。这样的做法下依然可以让人“感到”是在做交互解释执行，这门语言的编译速度和优化水平，可见一斑。同时 Playground 还顺便记录了每条语句的执行时候的各种情况，叫做一组 timeline。可以使用 timeline 对代码的执行逐步检查，省去了断点 debug 的时间，也非常方便。
39. 简述一下IOS中线程同步机制
1：原子操作 不同线程如果通过原子操作函数对同一变量进行操作，可以保证一个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是原子式的。因为原子操作只能对内置类型进行操作，所以原子操作能够同步的线程只能位于同一个进程的地址空间内。2：锁 iOS平台下的锁对象为NSLock对象，进入锁通过调用lock函数，解锁调用unlock函数（因为iOS中大部分的线程同步类都继承自NSLocking协议，所以其加锁/解锁的操作基本都为lock/unlock函数），同一个NSLock对象成功调用lock函数后，在其显式unlock之前任何线程都不能再对此NSLock对象加锁，以达到互斥访问的目的。 3：事件 NSConditon类型提供了wait与signal函数，分别代表了等待事件的操作以及触发事件的操作。除了wait函数，NSCondition还提供了waitUntilDate函数，其功能与NSLock中的lockBeforeDate大致相同，简要来说就是提供了一个带超时的wait函数。

1、给定字符串的长度，还有换行方式 算出高度。
UIFont *font = [UIFont systemFontOfSize:14];
CGSize size = [text sizeWithFont:font constrainedToSize:CGSizeMake(140, 1000) lineBreakMode:UILineBreakModeCharacterWrap];

Objective-C 开发面试题
知识面:
说所你了解以及日常使用的版本控制系统，以及它们的优缺点
Svn简单实用，缺点是服务端只有一份代码，可能由于网络或者别的原因造成损失。
Git是一个分布式版本管理工具，分支都在本地，特别适合处理临时需求，或者小实验。缺点：因为是分布式的，有时候忘了push到远程服务器，那就会使得不同步，而且git对Windows系统和中文的支持比较不稳定。

4. 你了解的第三方库，常用哪些 Framework
ASIHttpRequest,SBJson,JsonKit，SDWebImage，KissXML,FMDB
音频和视频 Core Audio Media Library AV Foundation
数据管理 Core Data SQLite
图形和动画 Core Animation Quartz 2D
网络 WebKit
用户应用 Address Book Core Location Map Kit

1. 如何实现Push 通知的机制（大致写下）
首先应用程序把要发送的消息、目的iPhone的标识打包，发给苹果服务器，苹果服务器在自身的已注册Push服务的iPhone列表中，查找有相应标识的iPhone，并把消息发送到iPhone，最后，iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。

Key-Value Coding是什么？
KVC通过传递一个”key”（通常是一个字符串）来获取或更改与这个”key”相关的属性。是用来使得一个类的行为摆脱它需要依附执行的特定属性的一种方式。它通常与NSKeyValueCoding协议联系在一起当然也有一系列其他的方法来实现相同的效果。
通过“setValue：ForKey：”的方法对相关属性进行赋值。

加分题:
1. 如何实现一个实现渲染自定义格式字符串的 UILabel
自定义一个MyLabel继承于UILabel，然后复写drawRect:方法。

2. Protocol 与 performSelector: 的相同与区别，哪个更好（基础参数类型传递）
二者都可以调用相关方法，可进行函数回调。
Protocol是用来定义对象的属性，行为和用于回调的。必须遵守其协议方可使用其方法。
performSelector:可自定义进行函数回调，可调用实现在其后的方法。

3.如何使用多线程进行编码
a.使用NSThread
b.使用performSelectorInBackground： withObject:的方法在后台对某对象发送相应的消息。
c.使用NSTimer
d.使用NSOperation开启多线程。

一、中金在线：（没有人力面试，只有技术面试）
    面试：
        1、项目中提醒功能怎么实现，怎么和设置的时间相匹配。
        2、HTTP、TCP、UDP、Socket套接字
        3、平时用到哪些三方库

        3、一下三条输出语句分别输出什么？
            char str1[] = "abc";
            char str2[] = "abc";
            const char str3[] = "abc";
            const char str4[] = "abc";
            const char * str5 = "abc";
            const char * str6 = "abc";
            cout << boolalpha << (str1 == str2) << endl;
            cout << boolalpha << (str3 == str4) << endl;
            cout << boolalpha << (str5 == str6) << endl;
        输出结果：
            false
            false
            turn
        boolalpha : 把bool值显示为true或false
        tr1,str2,str3,str4是数组变量，它们有各自的内存空间；
        str5,str6是指针，它们指向相同的常量区域
        char * const p; //常量指针，p的值不可以修改
        char const * p；//指向常量的指针，指向的常量值不可以改
        const char *p； //和char const *p
        4、struct A
            {
                int a;
                char b;
                short c;
            }
            struct B
            {
                char b;
                int a;
                short c;
            }
            sizeof(strcut A) = ?
            sizeof(struct B) = ?
        5、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
            #define SECONDS_OF_ONE_YEAR (365*24*60*60)UL
            意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数
            UL : 表示无符号长整型
        6、NSMutableArray 类  + (id)array WithCapacity:(NSUInteger)numItems;此方法传入的整形参数numItems的作用？此方法的返回值具有什么特征（内存上）。
            作用：创建一个指定初始化长度的数组。
            内存上特征：系统自动加上autorelease，自动释放内存，不用手动管理内存。
        7、简述事件响应链的传递过程
            用户点击下载--〉开一个新的下载线程---〉线程开始的时候--〉（用委托）异步变化tree的图标--〉开始下载数据并处理--〉下载完成有用委托异步变化tree的图标
        8、delegate用assign而不用retain，为什么？
            delegate往往是assign方式的属性而不是retain方式的属性，赋值不会增加引用计数，就是为了防止delegation两端产生不必要的循环引用。
            如果一个UITableViewController 对象a通过retain获取了UITableView对象b的所有权，这个UITableView对象b的delegate又是a， 如果这个delegate是retain方式的，那基本上就没有机会释放这两个对象了。自己在设计使用delegate模式时，也要注意这点。
        9、什么时候用delegate，什么时候用Notification?NSNotification封装了3个数据？
        1）.参数的不同
使用delegate参数更加直观，使用notification参数不那么直观，所以能使用delegate的地方，尽量使用delegate
        2）.传递的长度
有时候你的页面会一次跳好几个页面，那么你想把这个页面的数据传回到底层是很麻烦的事情，因为你要把delegate指针从底层界面一直传上来。
        3）.传递多个数据
当你在同一个对象传递给多个对象，用delegate就不可行了。
        
链表逆序

12. Object C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？

线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:

什么时候使用NSMutableArray，什么时候使用NSArray？
答案：当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。

16.什么是谓词？
答案：谓词是通过NSPredicate，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。
    predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n];
    a = [customers filteredArrayUsingPredicate:predicate];

17.使用coredata有哪几种持久化存储机制？
答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。
kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
 
18.代理的作用？
答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为java中的回调监听机制的一种类似。

7.oc中可修改和不可以修改类型。
答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。

9.通知和协议的不同之处？
答案：协议有控制链(has-a)的关系，通知没有。
首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。

17.NSOperation queue?
答案：存放NSOperation的集合类。
操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。
网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。
这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，
但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。
但是后来看到一票关于这操作队列话题的文章，其中有一句提到
“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”
瞬间觉得这个queue名字有点忽悠人了，还不如pool~
综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。

20.一个tableView是否可以关联两个不同的数据源？你会怎么处理？
答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。
因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。
因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？

1.Object -c 的类可以多重继承么?可以实现多个接口么? Category 是什么?重写一个类的方式用继承好还是分类好?
为什么?
7. 什么是安全释放?
注意事项?
12. 委托是什么?委托的 property 声明用什么属性?为什么?
14.Cocoa 中与虚基类的概念么?怎么简洁的实现?
15. 自动释放池跟 GC有什么区别? iPhone 上有 GC么?[ pool release ] 和[ pool drain ]有什么区别? 16.
?
1 <span style="font-family: 幼圆 ;">for(int index = 0; index < 20; index ++){
2 NSString *tempStr = @ ”tempStr ”;
3 NSLog(tempStr);
4 NSNumber *tempNumber = [NSNumber numberWithInt:2];
5 NSLog(tempNumber);
 6}
7 </span>
这段代码有什么问题 . ?会不会造成内存泄露(多线程)?在内存紧张的设备上做大循环时自动释放池是写在循环内好 还是循环外好?为什么?
30.timer 的间隔周期准吗?为什么?怎样实现一个精准的
notification 是全进程空间的通知吗? kvo 呢?
timer?
库中找到类似的吗?
32 如果要开发一个类似 eclipse 的软件，支持插件结构。且开放给第三方开发。你会怎样去设计它?(大概思路)
这篇文章先记录一下题目，下一篇开始从第一题解答 .
下面从第一题开始解答 :
题目 :1.Object -c 的类可以多重继承么?可以实现多个接口么? Category
类好?为什么? 关于多继承 :
首先 object-c 不能够多继承 , 类似下面代码的这种方式是绝对通不过编译的 再试试，呵呵 !
是什么?重写一个类的方式用继承好还是分
. 当然 , 你也可以把 NSString 前面的 ":" 去掉

 那么有没有别的方式来替代呢?有，一种我们称之为伪继承，另一种我们可以通过 ios 中无处不在的 @protocol 委托方 式来实现 .
1. 伪继承
尽管再 objtive-C 中不提供多继承， 但它提供了另外一种解决方案 , 使对象可以响应在其它类中实现的消息 ( 别的语言中，
一般叫方法，两者无差别 ). 这种解决方案叫做消息转发，它可以使一个类响应另外一个类中实现的消息。
在一般情况下， 发送一个无法识别的消息会产生一个运行时的错误， 导致应用程序崩溃 , 但是注意， 在崩溃之前， iphone
运行时对象为每个对象提供了第二次机会来处理消息。捕捉到一条消息后可以把它重定向到可以响应该消息的对象。 这个功能完全通过消息转发来实现，发送消息给一个无法处理该选择器的对象时，这个选择器就会被转发给
forwardInvocation 方法 . 接收这条消息的对象， 用一个 NSInvocation 的实例保存原始的选择器和被请求的参数 我们可以覆盖 forwardInvocation 方法，并把消息转发给另外一个对象 .
. 所以，
。
将选
1.1 实现消息转发功能
在给程序添加消息转发功能以前，必须覆盖两个方法，即 methodSignatureForSelector:
methodSignatureForSelector: 的作用在于为另一个类实现的消息创建一个有效的方法签名。 择器转发给一个真正实现了该消息的对象 .
例子 : 1.
1 - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector 2{
和 forwardInvocation: forwardInvocation:
3 4 5 6 7 8 9}
2.
NSMethodSignature* signature = [super methodSignatureForSelector:selector];
if (!signature)
signature = [self.carInfo methodSignatureForSelector:selector];
return signature;

 1 - (
void )forwardInvocation:(NSInvocation *)invocation
2{
3
4
5 6{ 7 8} 9}
SEL selector = [invocation selector];
if ([self.carInfo respondsToSelector:selector])
[invocation invokeWithTarget:self.carInfo];
3. 调用
1 Car *myCar = [Car car]; //Car 为一个类
2 [(NSString *)myCar UTF8String] // 这里调用 NSString 中的 UTF8String 方, 注意 Car 中并未实现该方法
解释 : 这里借 iphone 开发秘籍的例子来说明 , self.carInfo 是一个只读的 NSString 对象 , 存在于 Car 类中 . 例子中 实例是无法正确的为另外一个对象 (NSString) 实现的选择器创建一个有效的签名。运行时当检查到当前没有有效的签名
即进入该对象 ( 这里是 myCar) 的 methodSignatureForSelector: 方法中 , 此时，将在这个方法中对每个伪继承进行迭代并 尝试构建一个有效的方法签名的机会 . 例如代码中 , 当 myCar 调用 UTF8String 时, 由于无法从当前对象中获得消息，转入 第二次机会捕捉消息， 首先进入 methodSignatureForSelector: 方法 , 采用迭代的方式为当前被调用的方法创建一个有效 的签名，得到签名后，转入 forwardInvocation: 方法对其调用的方法 (UTF8String) 进行实现 . forwardInvocation: 首先获得调用的方法 (UTF8String), 判断 self.carInfo( 一个 nsstring 对象 ) 能否响应该方法，如果可以，将调用 UTF8String 对象的目标转换为 self.carInfo 对象 . 这样 ，我们就实现了多继承，呵呵!!
?
注 : 如果您仍有疑问，可访问苹果的官方文档查询消息转发相关内容 : 地址
http://www.apple.com.cn/developer/mac/library/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ chapter_6_section_1.html#//<br> apple_ref/doc/uid/TP40008048-CH105-SW1
2. 委托
Car ,
中，
在 IOS 中委托通过一种 @protocol 的方式实现 , 所以又称为协议 . 协议是多个类共享的一个方法列表 , 在协议中所列出的方 法没有响应的实现，由其它人来实现 . 这叫好比我想买个手机，所以我有个 buyIphone 方法 , 但是我不知道谁那买手机 , 所以把这个需求发布出去 ( 比如公布在网站上 ), 如果有卖手机的商人 ( 也就是说他能实现 buyIphone 这个方法 ) 看到，他 就会接受我的委托 ,( 在商人自己的类中实现 <XXXdelegate>), 那么我的委托对象就指向了这个商人 .. 当我要买手机的时 候，直接找他就行了 .
例如 :
@protocol MyDelegate
-( void )buyIphone:(NSString *)iphoneType money:(NSString *)money;

 @end
@interface My : NSObject {
id <MyDelegate> deleage; }
@property(assign,nonatomic) @end
代码中声明了一个协议 名叫
通过 delegate 调用 BuyIphone 方法即可 .
如下 :
-( void )willbuy
{
}
[ delegate buyIphone: @"iphone 4s"
money: @"4888"];
id <MyDelegate> delegate ;
Mydelegate,
在其中有一个
buyIphone
方法， 即一个委托项。
当我要购买手机的时候只需要
我不必关心谁现实了这一委托，只要实现了这个委托的类，并且 定能够得到结果 .
例如 : 商人类实现了这一委托 ( 用<Mydelegate> 表示实现 ) #import <Foundation/Foundation.h>
#import "My.h"
@interface Business : NSObject<MyDelegate>
@end
然后在 @implementation Business 中调用 buyIphone 方法
#import "Business.h"
@implementation Business
-( void )buyIphone:(NSString *)iphoneType money:(NSString *)money {
NSLog( @"手机有货，这个价钱卖你了，发货中 !!" ); }
@end
buyIphone 是声明的委托中必须实现的方法，那么就一
就 ok 啦。这样是不是也模拟了多继承呢?通过委托，其实你也就摆脱了去考虑多继承方面的事情，从而关注当前类。 汗，一道题才写了一半，下一篇继续。。。。手打字酸了!

亲，开发一个 ios 应用没那么容易 .!
开发之前需要仔细考虑的 别做拍脑瓜的决策，在开工之前你需要考虑的比你想象的要多。我通常会帮助或者指导客户把以下几个要素都过一
遍:
一:和客户谈他们的移动应用，最让我吃惊的是他们从来没有想过支撑一个 iPhone 应用运行，背后需要涉及到的
方方面面。他们想象中的 iPhone 是独立存在于这个宇宙的，是如此的简单，以至于他们要我很快就给出一个项目预算 报价，而不用讨论诸多细节。我问他们:“你们是否考虑过后台服务器的事情?你们的应用需要和后端服务器做数据通 讯?” 什么，听不懂?好吧，我用地球人的语言再把这个问题讲一遍:“你们的应用不是需要用户注册嘛，你们考虑 过把用户的数据存放在哪里了吗?我们需要一个地方去保存这些以后会用到的数据。” 第一次碰到这样的客户时，哥 简直就怒了。后来我发现这不是客户的错:我是搞编程的， CS 架构对我来说就像吃饭睡觉一样是不假思索的东西，而 我的客户尽是些高富帅，他们懂个毛 CS 架构!
所以，如果你不大懂技术，那请仔细听我说:如果你想做的移动应用需要用户注册和登录，或者你想随时控制移动 应用的一些输出，甚至是你仅仅是需要一个用户反馈意见调查表这么简单的功能，那么，你得搞一台后端服务器。
二:好了，现在你知道你需要一台后端服务器。同时你还需要想办法让你的 iOS 应用和你的服务器能够对话，就 是相互间接收数据什么的。不，这个问题不是简答靠什么标准的即插即用的东东就能解决的，不是你们想象的那样!所
有的东西都需要定制化开发，这就好比发明一门语言:你希望你的服务器和你的应用之间能够通过一种语言沟通，但是 你不希望其他人听得懂这门语言。
用行话说这就是制定服务器端 API 接口，或简称 API 。这些 API 应该在开发 iPhone 客户端之前就到位了。为什 么?因为你必须先规定好一门语言的单词和语法，然后才能用这门语言说话吧!?好了，这就带出了第三点—如何开发
这些 API 。
三: API 的成功定制是项目成功的一半(反之亦然)，所以千万不要掉以轻心。你要考虑你的业务数据模型、业务 流程、调用业务需要提供的参数、特定事件发生时数据间该如何互动等等。简单来说，我们要做的就是开发一个网站， 上门跑着你的业务流程，只不过这个网站的所有运行结果都不是通过网页形式展现出来，而是呈现在一行行的文本和数 字中。举个例子:一个登录成功的反馈页面仅仅包含 YES 一个单词。
iPhone 应用需要访问这些预先定义好的接口，并且按预定义格式提供必要的输入(比如用户名和密码)，然后要 对服务器端的反馈( YES 或者 NO)做出解析处理。所以，没有什么移动应用能够自动的含有用户注册和登录功能。
服务器端开发需要考虑的问题太多了: 选择服务器， 选择用什么语言开发， 主机放在哪里才能增加访问速度， 等等， 这里我就不展开了。 如果这一切对你来说很陌生， 那么你最好去问问团队里的技术负责人， 或者干脆让开发人员做决策。
四: 所以，关于服务器端 API ，你或者让自己的技术团队把它开发好，再将完善的 API 文档交给 iPhone 应用开 发人员;或者你支付 iPhone 应用开发人员额外的报酬来搞定这些。你找的 iPhone 应用开发人员可能会服务器端开发 也可能不会。如果他会的话，我建议最好让他也同时负责服务器端开发，因为他最清楚 iPhone 应用中需要哪些服务器 端 API 。
如果你的服务器端 API 已经存在了，那么除了向 iPhone 应用开发人员提供相关文档之外，你还要考虑让他能够 便捷的同服务器开发团队沟通，因为大多数情况下， iPhone 应用需要在已有 API 基础上增加一些新的接口。
现在我们来看看 iPhone 应用开发本身
扯了大半天，我们终于开始谈 iPhone 应用开发本身了。一般来说， iOS 平台上做所有事情都不能随心所欲。你最 好在开发人员写代码之前把所有的需求都确认好好。这和开发网站不一样，按照实现签订的合同开发 iOS 应用，开发 过程中对需求变更的容纳度可能很低:
用户界面:无论你打算采用 iOS 标准界面还是自定义元素，在开发开始前一定要确认清楚，因为应用的程序架构 是根据界面和用户使用流程来设计的。一个很好的例子就是在界面底部使用了 iOS 标准的标签栏( Tab Bar )，此后如 果你想让标签栏里面的图标变成彩色的，这个代码改动量可没你想象的那么小!
代码之间的耦合:如果是开发网站，你可以随意的添加一个页面或者一处链接。做 很多东西一开始都要设计好，后期的一处改动会牵连很多东西，具体原因是你无法理解的。
再改动行不行?行!但必须小心。 这就像设计电路板一样， 如果你不小心把那根线搭错了，整块电路板就会不工作。 有人说架构优良的程序可以有很高的延展性，那纯属纸上谈兵。在 About 屏幕上添加一个电子邮件按钮可能只需要几
iOS 应用就没有那么简单了， iOS 应用的代码写好之后，

行代码的工作量，而添加一个转发到新浪微薄的按钮(译者注:原文是添加一个 Facebook Like )就完全不是那么简单 的事儿了!
让一个 iPhone 应用同时也支持 iPad :如果要评选最坑爹“需求变更”，那么这个绝对是当之无愧的。理由很简 单:支持 iPad 根本不是 TMD 什么附加功能! iPad 应用基本上都比 iPhone 应用来得要复杂，界面设计和用户体验也 大不一样。我问你，制造一辆电动自行车，然后把它改装成一部烧汽油的摩托车，这能是一回事儿吗!?电动自行车跟 摩托车看起来是很像，但是制造它们完全是两码事。
拿广受欢迎的 Facebook 官方应用来说，它的 iPhone 和 iPad 版本看似相似，实际用户操作流程完全不同。不仅 仅是界面上的不同会带来额外的工作，对后台服务器 API 的需求也可能不一样。拿我熟悉的一个应用 Denso 来说(我 熟悉它因为这是我开发的)，它的 iPad 版本比 iPhone 多了几个功能，这些都需要额外的服务器端 API 来支持。记 住， iPhone 和 iPad 应用的用户体验需求是完全不一样的。
准备好开始了吗?
希望此文能够帮助你和你的团队了解移动应用开发幕后的方方面面。除非你们要做一个像计算器那么简单的单机应 用，否则你们很难用极低的成本搞定。综上所述，如果你觉得外包成本太高，那你只好招人自己开发。
当然，如果你决定了要外包移动应用开发，那么我还要提醒一点:公司政治。如果你是在一家大公司或者有着严格 制度的机构里面干活，那么帮助合同开发者搞定那些个规章制度上的繁文缛节，对你来说是非常重要的一项工作，必要 的时候甚至可以做一些政策上的变通。 我同几个大型企业客户接触过，当我要求看他们的服务器端数据接口的时候， 他们流露出很不安的表情。我想这或许是因为他们受制于公司规定而不能透露信息，这无可厚非;或者他们还没有想好 这种情况下该如何操作;或者他们的品牌制度蛋疼到需要在移动应用的每个屏幕上都摆着公司 logo !最终我没有和这
样的企业客户合作，因为我无法想象如果有一天我需要增加一些服务器端 那将会是多么悲剧的事情。
PS:开发移动应用很耗费时间，你最好有耐心。 英文原文: Kent Nguyen 编译:伯乐在线 – 陈远
转自 :http://www.html5cn.org/article-2386-1.html
英文原文: Dear business people, an iOS app actually takes a lot of work!
API 接口的话，和他们的规章和流程折腾，
Objective-C 学习笔记 :数据类型和表达式
1. 数据类型和常量 :
在 Objective-c 中提供了 4 种基本的数据类型 :int float double 以及 char. 声明为 int 的变量只能用于保存整形值
声明为 float 类型的变量可存储浮点类型值 ( 即包含小数位数 .).
double 类型和 float 类型一样，只不过前者的精度大约是后者的 2 倍。
最后是 char 数据类型 ,char 类型可用来存储单个字符，例如字母 a, 数字 6 ，或是一个分号。
在 OBJ 中 ( 为了打字快点， 以下 Objective-C 都简称 OBJ) 中，任何的数字、 单个字符或者字符串， 都称为常量。 例如: 数字 58 为一个整数常量，字符串 @"this is OBJ!\n" 表示一个常量的字符串对象。完全又常量组成的表达式我们就称 为常量表达式。
所以，表达式 :

 128+7-17
是一个常量表达式，这是因为其表达式的每一项都是一个常量值。但是如果把
128+7-i
就不是一个常量表达式了 . 下面说说关于 4 个数据类型的情况 ..
2.int 类型
i 声明为了整形的变量，那么表达式:
在 OBJ 中，整数常量是又一个或多个数字的序列所组成。 序列前的负号表面该值是一个负数。 合法值例如: 10 、-10 、 158. 切记数字之间不能出现空格，且大于 999 的值不适用逗号来表示。比如: 11000 是一个合法的整数常量，但 11
000 是一个非法的常量 .
OBJ 中存在两种特殊的格式，它们用于非十进制方式保存整数常量。第一种:如果整形值的第一位为 0，那么这个整数 将用八进制的方式表示，也就是说用基数 8 来表示。这种情况下改值的其他余位的值必须都是合法的八进制数字，即必
须是 0 到 7 之间的数字。例如在 OBJ 八进制表示的值 50 ，表示的方式为 050 ，等价于十进制表示的值 40.
同理，八进制的常量 0177 表示为十进制的值 127 ，算法为 1*64+7*8+7 =127.
可以通过在 NSLog( 如果不理解 NSLog, 暂时可以把它想象为 C# 的 message.show() 或者 js 的 alert()) 中调用的格式
字符串中使用格式符号 %o, 可在终端上用八进制显示整型值: 例:
1 int a =177
2 NSLog(@"int is : %o\n",a);
在上面例子的情况下，输出的八进制值不带有前导
1 inta=177;
2 NSLog(@"%#o" ,a);
第二种情况 :
如果整形常量以 0 和字母 x(x 无论大写还是小写
0 ，输出带有
0 的写法如下:
) 开头，那么这个值都将采用十六进制
0 到 9 之间的任意数字或 a 到 f(A 到 F) 之间的字母组成。字母表示
格式符号 %x 表示显示一个十六进制的值，该值不会带有前导 0x, 都是用 a--f 的小写字母表示十六进制的数字，需要带 有前导 0x, 使用格式字符 %#x 表示 :
( 即以
的数字分别为 10 到 15 。因此，给一个名为 rgbColor 的整型常量指派一个十六进制的值 FFEF0D, 可以使用以下语句:
紧跟在字母 x 后面的是十六进制的的数字，它可由
1 rgbColor = 0xFFEF0D;
16 为基数 ) 计数法里表示。

 1 NSLog(@"%#x\n",rgbColor);
不管是字符，浮点，整数，都有与其对应的值域，这个值域与存储特定类型的值而分配到的内存量有关，一般在语言当 中没有规定这个量的大小，它依托于所运行的计算机，所以叫做设备的相关量 .如一个整数可在计算机上占用 32 位，也 可以使用 64 位存储。
2.float 类型 :
float 类型可包含存储小数位数的值，例如值 3. 、 125.8 以及 -.0001 都是合法的浮点数。显示浮点数，可以使用 NSL
og(@"%f",floatType) 。
浮点常量也能使用科学计数法的方式来表示，值 1.74e4 就是一种科学计数法，他表示的是 1.7 乘以 10 的 4 次方。位
于字母 e 前面的称为尾数，后面的称为指数，指数的前面可以放置正好和负号。指数表示将与尾数相乘的 10 的幕。因 此， 2.225e-3 表示 2.225 乘以 10 的 -3 次方，值为 0.00225.
3.double 类型
double 类型和 float 类型很相似，一般使用 double 是在 float 不能满足精度 ( 即所提供的值域 ) 的要求时候。 double
类型变量可存储的位数大概是 float 的两倍多，大多数的计算机使用 64 位来表示 double 值。注意 : 除非你自己声明， 否则 OBJ 均把所有浮点常量看都是 double 值，要清楚地表示 float 常量，一是声明 float 类型，二是在数字的尾部加 一个 f或则 F,例如:
CGSizeMake(12.5f,13f);
要显示 double 类型的值，可使用 %f,%e, 或%g, 它们显示 float 值所用的格式是相同的 .
4.char 类型
char 类型可存储单个的字符。 将字符放入一对括号中就可以得到字符常量。 因此， 'a'.'3' 和';' 都是合法的字符常量 . 第一
个表示字母 a, 第二个表示字符 3, 第三个表示分号。第二个并不等同于数字的 3.
字符常量 '\n'( 换行符 ) 是一个合法的字符常量。 因为反斜杠符号是 尽管它是由两个字符组成。
如下示例，使用了基本的数据类型:
1 #import <Foundation/Foundation.h> 2
3 int main (int argc,char *argv[])
4
5{
OBJ 中特殊符号。 OBJ 中将字符 '\n' 看作单个的字符，
6
7 NSAutoreleasePool *pool =[[NSAutorelelasePool alloc]init];
8
9 int numVar =10; 10
11 float floaVar =331.79;

 12
13 double doubleVar =9.44e+11;
14
15 char charVar ='W';
16
17 NSLog(@"numVar:=%i" ,numVar);
18
19 NSLog(@"floatVar:=%f" ,floatVar);
20
21 NSLog(@"doubleVar:=%e" ,doubleVar ); 22
23 NSLog(@"doubleVar :=%g" ,doubleVar ); 24
25 NSLog(@"charVar:=%c" ,charVar);
26
27 [pool drain];
28
29 return 0;
30
31 }
输出 :numVar =10;
floatVar
doubleVar
doubleVar
charVar
注意 : 我们指派给 floatVar 的值实际上是 331.79, 但是为什么输出
=331.790009; =8.440000e+11; =8.44e+11;
='W';
除以 3 ，计算出为 3.3333333, 这一串的 3 实际只是一个近似值，理论上，应存在无数个 3 。然而计算机只能保存这 些数字，这就是计算机的不确定性所致。此处应用了相同的不确定性，所以在内存中不能精确的表示一些浮点值!!

1 shallow copy 拷贝了对象的基本类型，不拷贝资源和对象中指针指向的堆上内存。
2 category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 继承可以增加，修改或者删除方法，并且可以增
加属性。
3 category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。 extensions 可以认为是一个私有的 Category
4 OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。 informal protocol 中的方法属于设计模式考虑范畴，不是 必须实现的，但是如果有实现，就会改变类的属性。
5 key-value code , key -value observer.
6 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度
7 可修改不可修改的集合类。
8 多态。 主要是将数据类型的确定由编译时，推迟到了运行时。
9 协议有控制链 (has-a) 的关系，通知没有。
11 多态，子类指针可以赋值给父类。
13 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。

15 selector 是一个方法的名字， method 是一个组合体，包含了名字和实现
16 OC2.0 有 Garbage collection ，但是 iOS 平台不提供。
17 存放 NSOperation 的集合类。
18 懒汉模式，只在用到的时候才去初始化。 下面的问题大多数都没什么技术含量，
1 shallow copy 拷贝了对象的基本类型，不拷贝资源和对象中指针指向的堆上内存。
2 category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 加属性。
3 category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。
4 OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。 informal protocol 中的方法属于设计模式考虑范畴，不是
必须实现的，但是如果有实现，就会改变类的属性。
5 key-value code , key -value observer.
6 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度 7 可修改不可修改的集合类。
继承可以增加，修改或者删除方法，并且可以增
extensions 可以认为是一个私有的 Category

15 selector 是一个方法的名字， method 是一个组合体，包含了名字和实现
16 OC2.0 有 Garbage collection ，但是 iOS 平台不提供。
17 存放 NSOperation 的集合类。
18 懒汉模式，只在用到的时候才去初始化。 下面的问题大多数都没什么技术含量，
1 shallow copy 拷贝了对象的基本类型，不拷贝资源和对象中指针指向的堆上内存。
2 category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 加属性。
3 category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。
4 OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。 informal protocol 中的方法属于设计模式考虑范畴，不是
必须实现的，但是如果有实现，就会改变类的属性。
5 key-value code , key -value observer.
6 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度 7 可修改不可修改的集合类。
8 多态。 主要是将数据类型的确定由编译时，推迟到了运行时。
9 协议有控制链 (has-a) 的关系，通知没有。

11 多态，子类指针可以赋值给父类。
13 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。
15 selector 是一个方法的名字， method 是一个组合体，包含了名字和实现
16 OC2.0 有 Garbage collection ，但是 iOS 平台不提供。
17 存放 NSOperation 的集合类。
18 懒汉模式，只在用到的时候才去初始化。 下面的问题大多数都没什么技术含量，
继承可以增加，修改或者删除方法，并且可以增
extensions 可以认为是一个私有的 Category


34. .UIscrollVew 用到了什么设计模式?还能再 组合模式 composition ，所有的 container view
NSWindow对象作为结束，虽然其它对象也可以作为下一个响应者被加入
foundation 库中找到类似的吗? 都用了这个模式
观察者模式 observer ，所有的 UIResponder 都用了这个模式。
模板 (Template) 模式，所有 datasource 和 delegate 接口都是模板模式的典型应用
33. .timer 的间隔周期准吗?为什么?怎样实现一个精准的 timer?
NSTimer 可以精确到 50-100 毫秒 .
NSTimer 不是绝对准确的 , 而且中间耗时或阻塞错过下一个点 , 那么下一个点就 pass 过去了 34.
此份面试题包含 40 个题目，是现在网上能搜索到的一个比较热的一份，但是答案并不是很详细和完整，基本答案来着 cocoaChina ，和一些自己的 补充。
代理的作用? 答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.What are mutable and immutable types in Objective C? oc 中可修改和不可以修改类型。
答案:可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。
8.When we call objective c is runtime language what does it mean?
我们说的 oc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。
这个问题其实浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类( life )都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只需调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 eat 这个选择器)。
因此也可以说，运行时机制是多态的基础? ~~~
9.what is difference between NSNotification and protocol?
通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。
首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
kvc 机制的道理是一样的。
首先查找对象是否带有
someKey -(id) valueForUndefinedKey:

17.NSOperation queue? 答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发的问题。
网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。 这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，

但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。 但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认为这还是一个队列。 但是后来看到一票关于这操作队列话题的文章，其中有一句提到 “因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”
瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
18.What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。
也可以理解成延时加载。
我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。
19.Can we use two tableview controllers on one viewcontroller?
是否在一个视图控制器中嵌入两个
答案:一个视图控制只提供了一个
只能说可以嵌入一个 tableview 而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如 TabbarController 那样的感觉。
20.Can we use one tableview with two different datasources? How you will achieve this? 一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案:首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。
因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示?
本身这个 ios 面试题集绵有 40 个题目，但是后面的 20 个基本都没答案，那位 lz 直接是:”后面的太简单，就不多说了 ~~~“ 并且答案的话也是概述性而非直接可以定义的。
因此，下礼拜我抽空把剩下 20 个题觉得有点意思的挑出来，然后在找找其他的，准备再凑 20 题。


1. 一般静态方法中返回的结果对象，是否需要手动释放
A. 需要 B. 不需要 C.都可以
3. 如何判断一个对象是否实现了某一个方法 ___________________
4. 当一个线程进入某方法后， 在方法执行之前， 不允许其它线程访问， 使用 ___lock_________
二、 简答题
2. 静态变量和实例变量的区别是什么 ?
3. 如果要实现后台线程进行文件下载，应使用哪些类或框架来进行，请简述。
4. 写出你的团队中使用的版本控制系统，和版本控制系统的作用?
5. 你还了解哪些其它语言，技术或框架?
三、 程序与设计
1. 有 test.h 和 test.m 两个文件。 现在想给 test 类里中增加一个私有方法 hello ，那么在 test.h 和 test.m 文件中该如何编写
2. 用递归实现 N! = N*(N-1) *(N-2) * ⋯*2*1.

卷一 : 技术题部分 一、不定项选择题:基础理论知识，( 10题× 4分，合计 40分)
1、以下线性表中能使用二分查找的有()
A. 链接方式存储，元素无序 B. 链接方式存储，元素有序 C. 顺序方式存储，元素无序 D. 顺序方式存储，元素有序
2、贪婪法是一种()的算法。
A.不求最优，只求满意 B.只求最优 C.求取全部可行解 D.求取全部最优解
3、下列是散列(哈希)算法的有()
A. MD5B. DESC. SHA-1D. RSAE. RC4
4、下列四个不同数制表示的数中，数值最大的是()
A.二进制数 01111011 B. 八进制数 175C. 十进制数 123D. 十六进制数 7B
5、0x12345678 在采用 BigEndian 字节序时在内存中的排列顺序是 ()， 在采用 LittleEndian 字节序时在内存中的排列顺序是()
A. 12 34 56 78B . 34 12 78 56C . 78 56 34 12D . 56 78 12 34
6、在提供虚拟存储的系统中，用户的逻辑地址空间主要受()的限制。
A. 内存空闲块的大小 B.外存的大小 C.计算机编址范围 D.页表大小
7、虚存页面调度算法有多种，()调度算法不是页面调度算法。 A.后进先出 B.先进先出 C.最近最少使用 D.随机选择
8、在 LINUX某个目录下执行命令 ls -l 后，得到关于某个文件(假设文件名为 a)权限的字符 串为 “-rwxr-xr-- ”，则与此用户在同一组的用户对该文件 a所拥有的操作权限有()
A. 读B. 写C. 执行 D. 没有任何操作权限
9、当出现()情况时，系统可能产生死锁。
A. 进程释放资源 B. 一个进程进入死循环
C. 多个进程竞争，资源出现了循环等待 D. 多个进程竞争共享型设备
10、 FTP默认的数据端口号是()， HTTP默认的端口号是() A.20 B .21 C .22 D .23
E.25 F .80 G .1024 H .8080
二、不定项选择题:语言知识。( 5题×4分，合计 20分)请注意: C语言类和 JAVA语言类选 做其中一类即可
C语言部分

1、有变量
charbuf[] = ”SH_600570_”;
想把其内容修改为 ”SH__600570”，下列哪些语句是正确的() A. strcpy(buf + 3, buf + 2);
B. strncpy(buf + 3, buf + 2, 7);
C. memcpy(buf + 3, buf + 2, 7);
D. memmove(buf + 3, buf + 2, 7);
2、有变量
struct
{
char type; intnum;
char name[10]; } rec;
char 是 1字节， int 是4字节，若按 4字节对齐，那么 sizeof ( rec )等于() A. 15B. 16C. 18D. 20
3、 int 是 4字节，函数 void foo()
{
unsignedint a = 4;
int b = -5;
int c = -1;
(a + b > 4) ? (c = 0) : (c = 1); printf("%d, %d", a + b, c); }4294967295, 0
的输出是()
A. -1, 0B. -1, 1
C. 4294967295, 0D. 4294967295, 1
4、下列关于类的继承描述中，错误的有() A.派生类可以访问基类的所有数据成员，调用基类的所有成员函数
B. 派生类继承了基类的全部属性
C. 可以在派生类中把基类的虚函数重写( override )为非虚函数 D. 一个基类可以有多个派生类，一个派生类可以有多个基类
5、用 gcc/vs 在 link 时报告未定义符号 / 无法解析外部符号，可能的原因有() A.源代码语法错误
B. 链接参数缺少库文件
C. 链接参数缺少 obj 文件
D. 变量声明了但没有定义 JAVA语言部分

 1、定义一个类名为 "MyClass.java" 的类，并且该类可被一个工程中的所有类访问，那么该 类的正确声明应为()
A. private class MyClass extends Object
B. class MyClass extends Object
C. public class MyClass
D. public class MyClass extends Object
2、在 Java中，当在类中定义两个或更多方法，它们有相同的名称而参数项不同时，这称为 ()
A. 方法重写 B. 多态性 C. 构造方法 D. 方法重载
3、以下说法正确的是() A.一个源程序文件中，能有多于一个的 Public 类
B.类的构造方法名必须和类名相同 C.构造函数可以重载 D.类的私有属性和私有方法能被其子类直接访问
4、方法代码如下，其返回值是() publicint count(){
try{
return 5/0;
}catch(Exception e){
return 2*3; }finally{ return 3;
}
}
A. 6 B. 3 C.
编译失败 D. 以上都不对 包中接口的有()
三、数据库( 5题× 3分，合计 15分) 有一个银行客户资金数据库，包括客户信息、资金流水，表结构结构如下:
客户信息表 Customer, 客户号为主键
资金流水 Currents，每发生一次业务 (资金存取 )，就记录一条记录
5、属于 java.sql
A. ResultSet B. Connection C. PreparedStatement
D. Session

 注:业务日期 2011年1月10日用字符串 “20110110”表示 写出完成下列要求的 SQL语句:
1) 找出资金余额大于 1000 万的客户，并按资金余额排序从大到小排序
2) 找出 2011年没有发生任何业务的客户号、客户姓名
3) 对于业务类型为支取的，把发生金额改成用负数表示
4) 找出平均发生金额大于等于 1000元的客户号
5) 资金流水表中建立客户号的索引
四、编程题( 1题 *15 分，合计 15分。请先对试题进行分析并写出解题思路，然后编码实现)
有两个已经排好序 ( 从小到大 ) 的整数数组，请用 C或 Java 语言编写函数求出这两个数组的交 集。
Java 函数原型: public int[] getIntersection(int []aArray,int []bArray);
返回值为交集结果数组
C语言函数原型: intgetIntersection(intaArray[], intbArray[],intaLength, intbLength,int *result);
返回值为交集中数字个数， result 中为交集结果数组
五、算法题( 1题 *10 分，合计 10分)
用 C或 C++或 JAVA实现:设有 m个人围坐一圈 ,并已 1..m 编号,按1到 n的报数 ,报数到第 n 数的人出圈 , 再从他的下一个人重新开始 1 到 n 的报数，如此进行下去，计算最后一人的编
号。
卷二 : 综合题部分 一、逻辑测试题( 15题× 1分，合计 15分)
1. 有人养了一些兔子。别人问他有多少只雌兔?多少只雄兔?他答:在他所养的兔子中， 每只雄兔的雌性同伴比它的雄性同伴少 1只;而每只雌兔的雄性同伴比它的雌性同伴的两倍 少2只。根据上述回答，可以判断他养了多少只雌兔?多少只雄兔?()
A.8只雄兔， 6只雌兔。
B.10只雄兔， 8只雌兔。 C.12只雄兔， 10只雌兔。 D.14只雄兔， 8只雌兔。
2. 1,11,21,1211 ，()
A. 11211 B.111211 C.111221 D.1112211

 3. 请选择最合适的一个填入问号处。 ( )
4. 把一张纸剪成 6块，从所得的纸片中取出若干块， 每块剪成 6块;再从所有的纸片中取出若 干块，每块各剪成 6块 ..... 如此进行下去， 到剪完某一次后停止， 所得的纸片总数可能是 2000 ， 2001， 2002， 2003 这四个数的()
A.2000 B.2001 C.2002 D.2003
5.10 年前， 癌症病人在发现疾病后平均生存 的提高使癌症病人存活的时间延长了。 上述结论依赖于下述哪一段假设?()
A.10 年前接受治疗的病人数目与现在相近。 B.10 年前购买医疗保险的人不如现在多。 C.10 年前癌症诊断技术水平与现在相近。 D.10 年来癌症病人的职业类型没什么变化。
6. 3,11,13,29,31, ()
A.52 B.53 C.54 D.55
7. 请选择最合适的一个填入问号处。 (
8. 将一个正方形分成 9个小正方形，填上
5.4 年， 现在已经达到
6.7 年。 这说明，医疗水平
以及每一个对角线上的
A.4 B. 5 C.6 D.7
3个数字之和等于
1到 9这 9个自然数，使得任意一个横行，一个纵行 15 ，请问位于中间的小正方形应该填哪个数:()
)
9. 某单位组织职工游览上海世博园。所有参观沙特馆的职工都未能参观德国馆。凡参观沙 特馆的职工也未能参观日本馆。 有些参观丹麦馆的职工参观了德国馆， 有些参观丹麦馆的职 工参观了日本馆，有些参观丹麦馆的职工参观了沙特馆。 如果以上陈述为真，下面哪项关于该单位职工的陈述必然为真?() A.有些参观了日本馆的职工未能参观德国馆。
B.有些参观了德国馆的职工既没有参观日本馆，也没有参观丹麦馆。 C.有些参观了丹麦馆的职工既没有参观德国馆，也没有参观日本馆。 D.所有参观丹麦馆的职工或参观了德国馆，或参观了日本馆，或参观了沙特馆。
10. 33.1,88.1,47.1 ，()

 敏捷原则: 开放 --封闭原则 工厂模式优缺点
 优点: 简单工厂模式的优点是客户端可以直接消费产品， 而不必关心具体产品的实现， 消除了客 户端直接创建产品对象的责任，实现了对责任的分割。
 缺点是工厂类几种了所有产品的创建逻辑， 一旦不能正常工作， 整个系统都会受到影响， 产品类多结构复杂的时候，把所有创建工作放进一个工厂中来，回事后期程序的扩展较为困难。
 通过优缺点的分析，我们可以再如下场景中使用简单工厂模式:
 (1 )工厂类负责创建的对象较少时;
 (2 )客户端只知道传入工厂类的参数，对于如何创建对象的逻辑不必关心时。
 5. 观察者模式 Observer 观察者模式完美的将观察者和被观察者分离开。
 观察者模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态 发生变化时，所有依赖它的对象都得到通知并自动刷新。
 在IOS 开发中经典观察者模式的实现方式有: NSNotificationCenter 、KVO 等
 优势: 解耦合
 解耦合: 把原来引用很紧密的对象通过中间一层的分离，
 敏捷原则: 开放 —封闭原则
 而且当
 不直接引用

 通知 NSNotificationCenter :
 一般为 model 层对 controller 和 view 进行的通知方式，不关心
 谁去接收，只负责发布信息。
 通知可以是一对一，也可以是一对多。 实例: Notification 通 知中心，注册通知中心，任何位置可以发送消息，注册观察 者的对象可以接收。
 kvo 键 -值观察机制 Key-Value Observing :
 当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
 键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
 是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。
 6. 代理模式 代理的目的是改变或传递控制链。
 允许一个类在某些特定时刻通知到其他类，而不需要获取到 那些类的指针。可以减少框架复杂度。

  应用场景: 当一个类的某些功能需要由别的类实现，但是又 不确定由哪个类实现，可以使用代理实现。
 实例: tableview 、 Scrollview 等中的 delegete ⋯

 OC 的垃圾回收机制?
OC2.0 有 Garbage collection ，但是 iOS 平台不提供 , 只针
对 mac应用程序开发。 注意要与 MRC、 ARC区分开。
16. 什么是引用计数 (Retain Count) ? 判断对象是否被回收的标志，如果为 0回收，不为 0不回收。
每个 OC对象都有自己的引用计数器，它是一个整数，表示对 象被引用的数量。
每个 OC对象内部专门有 4个字节的存储空间来存储引用计数 器。

 1. 什么是谓词?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作
为约束条件，完成对数据的筛选。
predicate = [NSPredicatepredicateWithFormat:@"customerID == %d",n];
a = [customers filteredArrayUsingPredicate:predicate];
2. 什么是数据持久化?简单谈一下你所了解的 中的数据持久化的方式。
IOS
数据持久化就是将内存中的数据模型转换为存储模型 将存储模型转换为内存中的数据模型的统称 . 数据模型可以 是任何数据结构或对象模型 ,存储模型可以是关系模型、 XML 、 二进制流等。
在 IOS 中，少量的数据持久化可以使用属性列表、 NSUserDefaults 、归档等;
大量的数据持久化可以使用 SQLite 数据库、 CoreData 等， 也可以使用 FMDB 第三方类库完成。
2. NSUserDefaults ?
, 以及

 NSUserDefaults 适合存储轻量级的本地数据， 以键值对的形 式进行存储，只能存储基本的 OC 对象(不包括自定义的对 象)。
NSUserDefaults 非常好用，并不需要用户在程序中设置 NSUserDefaults 的全局变量，需要在哪里使用 NSUserDefaults 的数据，那么就在哪里创建一个 NSUserDefaults 对象，然后进行读或者写操作。
针对同一个关键字对应的对象或者数据，可以对它进行重写， 重写之后关键字就对应新的对象或者数据，旧的对象或者数 据会被自动清理。
NSUserDefaults 是典型的单例模式。
3. ProtocolList属性列表，是一种用来存储串行化后的对象的文件。因为扩 展名为 plist ，因此通常被称为 plist 文件。
plist 文件通常用于储存用户设置，也可以用于存储捆绑的信 息，其内容为 xml 格式。它可以在程序运行期间动态的创建
和读写，因此可以用于少量数据时候的数据持久化。 3. 归档?优缺点?

 归档也叫序列化，是将文件存在硬盘，解档是从硬盘还原数 据。
归档的形式来保存数据，只能一次性归档保存以及一次性解 压。所以只能针对小量数据，而且对数据操作比较笨拙，即 如果想改动数据的某一小部分，还是需要解压整个数据或者 归档整个数据。
除了简单的归档，还可以实现对象的归档。对象归档是指对 象写入文件保存到硬盘上，当再次重写打开程序时，可以还
原这些对象。可以实现对象序列化或者对象持久化。
除了原有的 OC 对象以外，归档还可以对自定义的对象实现 归档，需要注意的是，自定义的归档对象必须要实现 NSCoding 协议，实现里面的解码和编码的方法。
4. 什么是数据库?使用步骤?特点? 数据库是按照数据结构来组织、存储和管理数据的仓库。
SQLite 使用步骤:创建数据库、引入类库、获得沙盒路径、 创建或打开数据库
SQLite 比较原始，需要通过 sql 语句来创建表格，对数据进 行操作，用起来比较麻烦，但是可控性强。

 5. Core Data
Core Data 是 ios3 以后引入的数据库持久化解决方案， 是苹 果官方推荐的，在使用的过程中不需要写 sql 语句，可以很 方便的将数据存储到数据库中。 正因为不需要要写 sql 语句， 具体的功能已经被封装好了，因此可控性要弱一些。
5. 数据持久化方面用过哪些第三方类库?
FMDB ，以 OC 的方式封装了 SQLite 的 C 语言的 API 。
优点: 1. 更加面向对象，省去了很多冗余的 C 代码; 2. 对比苹果自带的 CoreData 框架，更加灵活和轻量级;
3. 提供了多线程安全的数据库操作方法， 能有效的防止数据 混乱。
6. XML 可扩展标记语言
XML 用于标记电子文件使其具有结构性的标记语言， 可以用
来标记数据、定义数据类型，是一种允许用户对自己的标记 语言进行定义的源语言。
extensible markup language

 数据库提供了更强有力的数据存储和分析能力，例如: 序、查找、相关一致性等， XML 仅仅是存储数据。
XML 与 HTML 的设计区别?
XML 的核心是数据，其重点是数据的内容。而
计用来显示数据，其重点是数据的显示。 XML 和 HTML 语法区别?
HTML 的标记不是所有的都需要成对出现， 的标记必须成对出现;
HTML 标记不区分大小写， XML 则大小敏感 ,即区分大小写。
数据索引、 排
HTML 被设
XML 则要求所有

 14 ， tableview 的优化 优化:
1.1 正确的复用 cell 。
1.2 减少在返回每个 cell 里面的处理逻辑和处理时间。尽量将数据进行缓存和复用。
1.3，尽量减少处理加载和计算的时间，不阻塞 1.4 ，尽量使用绘制每个 cell 。
1.5 ，设置每个 cell 的 opaque 属性。 1.6，尽量返回每行固定的 height 。
1.7 ，在每个 cell 减少图形效果。 1.8 ，分段加载数据。
15 ， opengl ， quatarz 2d
上面 2 种方式是进行图形绘制会使用到的技术。
UI 线程。
quatarz 2d 是 Apple 提供的基于 Core graphic 能够满足大部分需要。只是适用于 2D 图形的绘制。
opengl ，是一个跨平台的图形开发库。适用于 2D 和 3D 图形的绘制。功能强大但是复杂。
16, animation
IOS 提供丰富的 Core Animation 动画满足用户的需要，主要实现方式如下 3 种:
1.1 commitAnimations 方式使用 UIView 动画
的绘制基本图形工具库。操作简单方便，

 UIView Animations 动画 :
[UIView beginAnimations:@"animationID" context:nil];
[UIView setAnimationDuration:0.5f];
[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
[UIView setAnimationRepeatAutoreverses:NO]; // 以下四种效果
/*
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.view cache:YES];//oglFlip, fromLeft
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.view cache:YES];//oglFlip, fromRight
[UIView setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.view cache:YES];
[UIView setAnimationTransition:UIViewAnimationTransitionCurlDown forView:self.view cache:YES];
*/
// 你自己的操作
[UIView commitAnimations];
1.2 、 CATransition
CATransition *animation = [CATransitionanimation]; animation.duration = 0.5f;
animation.timingFunction =UIViewAnimationCurveEaseInOut; animation.fillMode = kCAFillModeForwards;
animation.type = kCATransitionMoveIn;
animation.subtype = kCATransitionFromTop; [self.window.layeraddAnimation:animationforKey:@"animation"];

 //自己的操作
1.3 、 UIView animateWithDuration
方法 : +(void)animateWithDuration:(NSTimeInterval)duration
animations:(void (^)(void))animations;
+ (void)animateWithDuration:(NSTimeInterval)duration
animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; // 多一个动画结束后可以执行的操作 .
[UIView animateWithDuration:1.25 animations:^{
CGAffineTransform newTransform = CGAffineTransformMakeScale(1.2, 1.2);
[firstImageView setTransform:newTransform];
[secondImageView setTransform:newTransform];}
completion:^(BOOL finished){
[UIView animateWithDuration:1.2 animations:^{
//自己的操作 } completion:^(BOOL finished){
}];
17, 定制化 view
需要自己自己继承自 cocoa touch 提供的丰富的类。如(
UIView ， UiScrollView ， UITableView 等等)。需要重载实现 drawRect ，touch 事件， init ，initFrame 等方法。
18.core Data,sqlite,file ， NSUserDefaults 上面四种是 IOS 中数据存取的方式。
Core Data ， sqlite 涉及到数据库。 sqlite 需要通过 sqlite 语句操作数据库，而 core data 是 Apple 提供的一个基于 sqlite 更抽象成对象的一种对数据库操作方式。
file ，主要是把数据存储在磁盘中。通过写和读文件操作。
自己的操作 }];

 NSUserDefaults ，主要是存储应用程序中的一些轻量级数据如应用程序的设置和属性和用 户信息等。
19. 机型和尺寸的适配
Iphone 的主要尺寸是
IPad 主要尺寸是 7.9 和 9.7
20.添加手势的方式(
1. 自己重载实现 touchMoved
和 touches 事件)
， touchBegin ， touchEnd ， touchCanceled 事件。
2.通过 UIGestureRecongnizer 诸如点击，双击，拖动等基本的手势事件。
3.5 和 4 英寸。分辨率为: 320*480,480*960 (retina )。 英寸。分辨率为: 1024*768 ， 2048*1536 ( retina )。
gesture
21. 应用程序的生命周期和状态(参照: http://blog.csdn.net/totogo2010/article/details/8048652 )
Not running 未运行 程序没启动
添加 AddGestureRecognier 事件。该方式方便添加一些
Inactive 未激活 况下程序通常停留在这个状态 Active 激活 常的模式
Backgroud 后台
在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended) 。有的程序经过特殊的 请求后可以长期处于 Backgroud 状态
Suspended 挂起 程序在后台不能执行代码。 系统会自动把程序变成这个状态而 且不会发出通知。当挂起时，程序还是停留在内存中的， 当系统内存低时， 系统就把挂起的 程序清除掉，为前台程序提供更多的内存。
下图是程序状态变化图:
程序在前台运行，不过没有接收到事件。在没有事件处理情
程序在前台运行而且接收到了事件。这也是前台的一个正
程序在后台而且能执行代码，大多数程序进入这个状态后会

 各个程序运行状态时代理的回调:
- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions
   告诉代理进程启动但还没进入状态保存
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
  告诉代理启动基本完成程序准备开始运行
- (void)applicationWillResignActive:(UIApplication *)application
  当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电
话了
- (void)applicationDidBecomeActive:(UIApplication *)application
  当应用程序入活动状态执行，这个刚好跟上面那个方法相反
- (void)applicationDidEnterBackground:(UIApplication *)application
当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即 可
- (void)applicationWillEnterForeground:(UIApplication *)application
当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。
- (void)applicationWillTerminate:(UIApplication *)application

 当程序将要退出是被调用， 通常是用来保存数据和一些退出前的清理工作。 这个需要要设置 UIApplicationExitsOnSuspend 的键值。
- (void)applicationDidFinishLaunching:(UIApplication*)application
当程序载入后执行 加载应用程序进入前台
加载应用程序进入后台
22.block 编程
Block 是一种具有匿名功能的内嵌函数块。 Block 一般是用来表示、简化一小段的程式码， 它特别适合用来建立一些同步执行的程式片段、封装一些小型的工作或是用来做为某一个工作 完成时的回传呼叫( callback ) 。格式如下: ^( 传入参数列 ) { 行为主体 };
23. 常用的开源框架
网络框架: ASIHttpRequest ， AFNetworking,coocaHttpServer 等。 进度条: SVprogressHUD,MBprogressHUD,
工具类: SSToolKit 等。
分享类: ShareKit 等
日志框架: log4j ， cocoa lumberJack 等。

 等等。
24. 通知消息和代理的区别 通知:分为本地和远程通知。接受通知的接受者需要进行注册改通知。这样通知被
NSNotificationCenter 发送出来后会被注册的接受者所接受。 远程通知需要借助苹果的 服务器去实现通知的中转。
代理: 把某个对象要做的事情委托给别的对象去做。 两者区别:
delegate 针对 one-to-one 关系，用于 sender 接受到 reciever 的某个功能反馈值。
notification 针对 one-to-one/many/none,reciver, 只是负责把 notification 发送出去。
25. 数据解析( json 和 XML )
json 数据的解析通常借助一些开源的框架如:
用于通知多个 object 某个事件， sender
SBJson ，TouchJson,jsonKit,Apple 提供 等。去 json 数据转化为 IOS 中常用的字典等。
的原生的 JSon 解析 NSJSON Serialization
XML 数据的解析。 xml 分为 SAX 和 DOM 两种解析方式。
DOM解析 XML时，读入整个 XML文档并构建一个驻留内存的树结构(节点树)，通过遍历树 结构可以检索任意 XML节点，读取它的属性和值。而且通常情况下，可以借助 XPath ，直接 查询 XML节点。
SAX解析 XML，是基于事件通知的模式，一边读取 XML文档一边处理，不必等整个文档加载 完之后才采取操作，当在读取解析过程中遇到需要处理的对象，会发出通知对其进行处理。
一般在 iOS 平台下，比较常用的 XML解析类库有如下几种:
NSXMLParser，，这是一个 SAX方式解析 XML的类库，默认包含在 iOS SDK 中，使用也比较
简单。
libxml2 ，是一套默认包含在 iOS SDK 中的开源类库，它是基于 C 语言的 API，所以使用起 来可能不如 NSXML方便。这套类库同时支持 DOM和 SAX解析， libxml2 的 SAX解析方式还是

 非常酷的， 因为它可以边读取边解析， 尤其是在从网上下载一个很大的 XML文件，就可以一 边下载一边对已经下载好的内容进行解析，极大的提高解析效率。
TBXML，这是一套轻量级的 DOM方式的 XML解析类库，有很好的性能和低内存占用，不过它 不对 XML格式进行校验，不支持 XPath，并且只支持解析，不支持对 XML进行修改。
TouchXML，这也是一套 DOM方式的 XML解析类库，支持 XPath ，不支持 XML的修改。 KissXML，这是一套基于 TouchXML的 XML解析类库， 和 TouchXML相比，支持了 XML的修改。
TinyXML，这是一套小巧的基于 C 语言的 DOM方式进行 XML解析的类库，支持对 XML的读取 和修改，不直接支持 XPath ，需要借助另一个相关的类库 TinyXPath 才可以支持 XPath 。
GDataXML，这是一套 Google 开发的 DOM方式 XML解析类库，支持读取和修改 XML文档，支 持 XPath 方式查询。
26.webservice
Web service 是一个 平台 独立的， 松耦合 的，自包含的、基于可 编程 的 web 的应用程序， 可使用开放的 XML 标准 来 描述 、发布、发现、协调和配置这些应用程序，用于开发分布式 的互操作的 应用程序 。技术支持包含如下:
1.1 xml 和 xsd 1.2 Soap
1.3wsdl 1.4 uddi
1.5 调用 RPC 和消息传递
27. 开发 App 的步骤，开发者账号，发布 app 到 证书分两种:开发者证书、发布者证书。前者开发时使用，后者发布使用
appstore

 ( 1) 模拟器调试无需代码签名; 真机调试需开发者证书代码签名; (2) 代码签名需要:证书 +私钥，
( 3) 真机调试时要求在设备上安装描述文件( provision profile 试者证书，
授权调试设备清单，应用 ID 。一个应用对应一个描述文件。
28. 类继承，类的扩展( extension )，类别( category )
发布时需发布证书签名
)，该文件包含信息:调
category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能 删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有 更高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。
category 和 extensions 的不同在于后者可以添加属性。另外后者添加的方法是必须要实 现的。
extensions 可以认为是一个私有的 Category 。 29.CAlayer 介绍
一个 UIView 包含 CALayer 树， CALayer 是一个数据模型。包含了一些用来显示的对象，
在 UIView 的子类中都可以找到层这个组件， 层是位于固定的画布上的一个子片， 可以被覆 盖。层是彼此堆叠在一起的最终产生一个界面。除此之层可以包含多个层，通过层可以操 作位于此层上面的其他内容，例如旋转，动画，翻页等。
30.ios 怎么实现多继承
IOS 通过实现 protocol 委托代理，实现多个接口来实现多继承。

 31.app 性能测试方式
通过 Xcode 提供的工具如 Instrument ，测试 CPU ，Mermory 性能。也可以适用一些开源
的自动化测试工具:如 Frank ，KIF 等。
32.NSArray 可以放基本数据类型不( int ， float ， nil )怎么放进一个结构体 NSArray 只能存放 objective -c 对象数据模型，这些基本数据类型需要先转化为
NSNumber 对象再存放进数组中。
33.objective-c 和 c，c++混合编写
在 Objective-C++ 中，可以用 C++ 代码调用方法也可以从 Objective-C
调用方法。在这两 Objective-C 对象
Xcode 需要源
种语言里对象都是指针，可以在任何地方使用。例 的指针作为数据成员， Objective-C 类也可以有 文件以 ".mm" 为扩展名，这样才能启动编译器的
如， C++ 类可以使用 C++ 对象指针做实例变量。
Objective-C++ 扩展。

 23. 使用自动释放池( Use AutoRelease Pool )
 24. 缓存图像( Cache Images-Or not )
25. 尽可能避免日期格式化器(
39.UIScrollView 的 contentSize contentSize 表示 UIScrollView
Avoid Date Formatters Where Possible )
、contentOffSet 和 contentInset 属性的区别 滚动区域的大小。 UIScrollView 的 frame 属性在设置好了
以后不会随内容的变化而变化。
contentOffSet 表示是 UIScrollView 当前显示区域顶点相对于 frame 顶点的偏移量，一般用
来设置 UIScrollView 显示的位置。
contentInset 表示是 scrollview 的 contentView 的顶点相对于 scrollview 的位置，假设你
的 contentInset = (0 ,100) ，那么你的 contentView 就是从 scrollview 的 (0 ,100) 开始显 示。一般都是( 0 ， 0 )表示从 scrollView 的开始显示。
40.IOS6 AutoLayout
AutoLayout 是 IOS6 之后引进的自动布局功能，有点类型有 android 的相对布局属性。通过勾选 AutoLayout 设置各种 Constraint 约束来实现在不同设备和不同方向上的自动布局。 autosizing
mask 也就是 “ springs and struts 模式”。 autosizing mask 决定了一个 view 会发生什么 当它的 superview 改变大小的时候。而 autolayout 不仅可以设置 superview 改变时 view 所做的变化，还支持当相邻 view 变化时自己所做的变化。

1. 回答person的retainCount值,并解释为什么 Person * per = [[Person alloc] init]; 此时 person
的 retainCount的值是 1 self.person = per; 在 self.person 时,如果是assign,person的 retainCount
的值不变 ,仍为 1 若是 :retain person的 retainCount的 值加 1,变为 2 若是 :copy person的 retainCount值不 变,仍为1
2、 这段代码有什么问题吗 : @implementation Person - (void)setAge:(int)newAge {
self.age = newAge; }
@end
会死循环 ,会重复调用自己 !self.age 改为 _age即可 ;
并且书写不规范 :setter方法中的 newAge应该为 age
3、这段代码有什么问题 ,如何修改 for (int i = 0; i < someLargeNumber; i++) { NSString *string =
@” Abc”;string = [string lowercaseString]; string = [string stringByAppendingString:@"xyz"];
NSLog(@“ %@” , string); } 会出现内存泄露 修 改之后 : for(int i = 0; i<1000;i++){
NSAutoreleasePool * pool1 = [[NSAutoreleasePool alloc] init]; NSString *string = @"Abc"; string = [string lowercaseString]; string = [string

stringByAppendingString:@"xyz"]; NSLog(@"%@",string);
// 释放池
[pool1 drain]; } 延伸:堆栈的区别 :
(1)管理方式 :对于栈来讲 ,是由编译器自动管理 ,无 需我们手工控制 ;对于堆来说 ,释放工作由程序员控 制,容易产生 memory leak。 (2)申请大小 :能从栈获 得的空间较小 ,堆是向高地址扩展的数据结构 ,是不 连续的内存区域。堆的大小受限于计算机系统中 有效的虚拟内存。由此可见 ,堆获得的空间比较灵 活,也比较大。 (3)碎片问题 :对于堆来讲 ,频繁的
new/delete势必会造成内存空间的不连续 ,从而造成 大量的碎片 ,使程序效率降低。 对于栈来讲 ,则不会 存在这个问题 ,因为栈是先进后出的队列 ,他们是如
此的一一对应 ,以至于永远都不可能有一个内存块 从栈中间弹出 (4)分配方式 :堆都是动态分配的 ,没 有静态分配的堆。 栈有2种分配方式 :静态分配和动 态分配。 静态分配是编译器完成 的,比如局部变量 的分配。动态分配由 alloca函数进行分配 ,但是栈 的动态分配和堆是不同的 ,他的动态分配是由编译 器 进行释放 ,无需我们手工实现。 (5)分配效率 :栈 是机器系统提供的数据结构 ,计算机会在底层对栈

提供支持 :分配专门的寄存器存放栈的地址 ,压栈出 栈 都有专门的指令执行 ,这就决定了栈的效率比 较高。堆则是 C/C++函数库提供的 ,它的机制是很复 杂的。 4、 写一个便利构造器
+(id)Person {
Person *person=[Person alloc]init]; return [person
autorelease]; 备注:ARC时不用 autorelease }
5、 截取字符串 ” 20 | http://www.baidu.com中, ”字| ” 符前面和后面的数据 ,分别输出它们。
?? NSString * str = @"20 | http://www.baidu.com"; NSArray *array = [str
componentsSeparatedByString:@"|"]; // 这是分别输 出的截取后的字符串
for (int i = 0; i<[array count]; ++i)
{ NSLog(@"%d=%@",i,[array objectAtIndex:i]);
}

(2)用指针数组给字符串排序 void sort_a(char * name[],int n) {

 char *temp; for(int i=0;i<n-1;i++) { for(int j=0;j<n-1-i;j++) { if(strcmp(name[j], name[j+1])>0)
{ temp=name[j]; name[j]=name[j+1]; name[j+1]=temp;
}} }}
(3)给字符串数组排序 {
for(int i=0;i<n-1;i++) {
for(int j=0;j<n-1-i;j++) {
void rang(char str[][20],int n)
int result=strcmp(str[j],str[j+1]); if(result>=0) {
char temp[20]; strcpy(temp, str[j]); strcpy(str[j], str[j+1]); strcpy(str[j+1], temp);
}} }}
7、简述你对 UIView 、UIWindow 和CALayer的理解 UIView: 属于 UIkit.framework 框架 ,负责渲染矩形区 域的内容 ,为矩形区域添加动画 ,响应区域的触摸事

件,布局和管 理一个或多个子视图 UIWindow: 属 于UIKit.framework框架,是一种特殊的 UIView,通 常在一个程序中只会有一个 UIWindow, 但可以手 动创建多个 UIWindow, 同时加到程序里面。 UIWindow 在程序中主要起到三个作用 :
1、作为容器 ,包含 app所要显示的所有视图 2、传 递触摸消息到程序中 view和其他对象 3、与 UIViewController 协同工作 ,方便完成设备方向旋转 的支持
CAlayer:属于 QuartzCore.framework,是用来绘制内 容的 ,对内容进行动画处理依赖与 UIView 来进行显 示,不能处 理用户事件。 UIView和CALayer是相互 依赖的 ,UIView 依赖 CALayer提供内容 ,CALayer依 赖 UIView 一共容器显示 绘制内容。 延伸 : UIViewController: 管理视图的几成熟 ,每个视图控 制器都有一个自带的视图 ,并且负责这个视图相关 的一切事务。方便 管理视图中的子视图 ,负责 model与view的通信 ;检测设备旋转以及内存警告 ; 是所有视图控制类的积累 ,定义了控制器 的基本 功能。

27、什么是 Protocol?什么是代理 ?写一个委托的 interface?委托的 property声明用什么属性 ?为什么 ?
Protocol:一个方法签名的列表 ,在其中可以定义若 干个方法。根据配臵 ,遵守协议的类 ,会实现这个协 议中的若干个方 法。
代理 :实现这个协议中的方法的类 委托的 interface: 声明一个某协议的属性 delagate 用 assgin属性 ,原 因是 ,为了避免循环引用。 28、分别描述类别 (categories)和延展 (extensions)是什么 ?以及两者的 区别 ?继承和类别在实现中有何区
别 ?为什么 Category只能为对象添加方法 ,却不能添 加成员变量 ?
类别:在没有原类 .m文件的基础上 ,给该类添加方法 ; 延展 :一种特殊形式的类别 ,主要在一个类的 .m文件
里声明和实现延展的作用 ,就是给某类添加私有方 法或是私有变量。 两个的区别 :延展可以添加属性 并且它添加的方法是必须要实现的。 延展可以认为 是一个私有的类目。 继承和类别在实现中的区别 : 类别可以在不获悉 ,不改变原来代码的情况下往里

面添加新的方法 ,只能添加 ,不能删除修 改。并且如 果类别和原来类中的方法产生名称冲突 ,则类别将
覆盖原来的方法 ,因为类别具有更高的优先级。 Category只能为对象添加方法 ,却不能添加成员变
量的原因 :如果可以添加成员变量 ,添加的成员变量 没有办法初始 化----这是语言规则 29、写一个
NSString类的实现 + (id)initWithCString:(constchar *)nullTerminatedCString encoding:
(NSStringEncoding)encoding;
{ NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return [obj autorelease];
}

; 33、
{ self = [super init]; if (self) {
NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
addObserver:self selector:@selector(keyboardDidShow)
name:UIKeyboardDidShowNotification object:nil]; [center addObserver:self selector:@selector(keyboardDidHide)
[center
name:UIKeyboardWillHideNotification object:nil]; _keyboardIsVisible = NO;

}
return self; }
- (void)keyboardDidShow
{ _keyboardIsVisible = YES; }
- (void)keyboardDidHide
{ _keyboardIsVisible = NO; }
- (BOOL)keyboardIsVisible { return _keyboardIsVisible; } 34、objective-c中的词
典对象、可变词典对象是哪个 ,初始化一个含有 两个键值对的可变词典对象 ,并动态的添 加和 删除一条记录 ,输出第一条记录
词典NSDictionary,可变词典 NSMutableDictionary, //初始化一个可变词典 ,带有2个键值对
NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"value1",@"key1" ,@"value2",@"key2",nil]; // 添加
[dic setObject:@"value3" forKey:@"key3"]; // 删除 [dic removeObjectForKey:@"key3"]; // 获取 (按key
获取)
[dic objectForKey:@"key1"];

74、什么是序列化或者 Acrchiving,可以用来做什么 , 怎样与 copy结合 ,原理是什么 ?. 序列化就是 :归档 75、runloop是什么 ?在主线程中的某个函数里调用 了异步函数 ,怎么样block当前线程 ,且还能响应当 前线程的

timer事件 ,touch事件等 .---NSRunLoop,NSTimer 需 要自己实现 ----GCD 的返回主线程的方法 ,看前面
的题
run loop,正如其名称所示 ,是线程进入和被线程用 来响应事件以及调用事件处理函数的地方。 需要在 代码中使用控制语 句实现 run loop的循环 ,也就是 说 ,需要代码提供 while 或者 for 循环来驱动 run loop。在这个循环中 ,使用一个 runloop对象 [NSRunloop currentRunloop]执行接收消息 ,调用对 应的处理函数。 76、 描述下拉刷新的实现机制 ?
获取数据 ,刷新页面
77、什么是沙盒 ?沙盒包含哪些文件 ,描述每个文件 的使用场景。如何获取这些文件的路径 ?如何获取 应用程序包 中文件的路径 ?
沙盒是某个 iphone工程进行文件操作有此工程对 应的指定的位臵 ,不能逾越。 包括 :四个文件
夹:documents,tmp,app,Library。 手动保存的文件在 documents文件里。 Nsuserdefaults保存的文件在 tmp文件夹里。

Documents 目录:您应该将所有 de应用程序数据文 件写入到这个目录下。 这个目录用于存储用户数据
或其它应该定期备 份的信息。AppName.app 目录: 这是应用程序的程序包目录 ,包含应用程序的本身。 由于应用程序必须经过签名 ,所以 您在运行时不 能对这个目录中的内容进行修改 ,否则可能会使应 用程序无法启动。 Library 目录 :这个目录下有两个 子目 录:Caches 和 PreferencesPreferences目录包 含应用程序的偏好设臵文件。 您不应该直接创建偏 好设臵文件 ,而是 应该使用 NSUserDefaults类来取 得和设臵应用程序的偏好 .Caches 目录用于存放 应用程序专用的支持文件 ,保存应用程 序再次启 动过程中需要的信息。 tmp 目录 :这个目录用于存 放临时文件 ,保存应用程序再次启动过程中不需要 的信息。
获取这些目录路径的方法 : 1,获取家目录路径的
函数 : NSString *homeDir =
NSHomeDirectory(); 2,获取 Documents目录路径的
方法 : NSArray *paths =NSSearchPathForDirectoriesInDomains(NSDocum
entDirectory, NSUserDomainMask, YES); NSString *docDir = [paths

objectAtIndex:0]; 3,获取 Caches目录路径的方 法: NSArray *paths =
NSSearchPathForDirectoriesInDomains(NSCachesDi rectory, NSUserDomainMask, YES); NSString
*cachesDir = [paths objectAtIndex:0]; 4,获取 tmp目
录路径的方法 : NSString *tmpDir =
NSTemporaryDirectory(); 5,获取应用程序程序包
中资源文件路径的方法 : 例如获取程序包中一个
图片资源 (apple.png)路径的方法 : NSString
*imagePath = [[NSBundle mainBundle] pathForResource:@ ” apple ” ofType:@ ” png ” ]; UIImage *appleImage = [[UIImage alloc]
initWithContentsOfFile:imagePath]; 代码中的 mainBundle类方法用于返回一个代表应用程序包
的对象。 78、介绍一下 XMPP?有什么优缺点 吗? XMPP(Extensible Messaging and Presence
Protocol,前称 )是一种以 XML 为基础的开放式实时 通信协议 ,是 经由互联网工程工作小组 (IETF) 通过 的互联网标准。简单的说 ,XMPP 就是一种协议 ,一 种规定。就是说 ,在网络上传 东西 ,要建立连 接,TCP/IP连接,建立后再传东西 ,而XMPP就是规定 你传的东西的格式。 XMPP是基于 XML 的协议。 优 点 开放:

XMPP 协议是自由、开放、公开的 ,并且易于了解。 而且在客户端 、 服务器 、 组件 、 源码库等方
面 ,都已经各自有多种实现。 标准 :
互联网工程工作小组 ( IETF )已经将 Jabber的核心 XML 流协议以 XMPP之名 ,正式列为认可的实时通 信及Presence技术。 而XMPP的技术规格已被定义 在 RFC 3920及 RFC 3921 。 任何 IM 供应商在遵循 XMPP协议下 ,都可与 Google Talk实现连接。 证实 可用:
第一个 Jabber(现在 XMPP)技术是 Jeremie Miller在 1998年开发的 ,现在已经相当稳定 ;数以百计的开发 者为 XMPP 技术而努 力。 今日的互联网上有数以 万计的 XMPP服务器运作着 ,并有数以百万计的人 们使用 XMPP实时传讯软件。 分散式 :
XMPP 网络的架构和电子邮件十分相像 ;XMPP 核 心协议通信方式是先创建一个 stream,XMPP以 TCP 传递 XML 数据流 ,没有 中央主服务器。 任何人都 可以运行自己的 XMPP服务器,使个人及组织能够 掌控他们的实时传讯体验。 安全 :

任何 XMPP 协议的服务器可以独立于公众 XMPP 网 络(例如在企业内部网络中 ),而使用 SASL及TLS等 技术的可靠安全性 ,已自 带于核心 XMPP 技术规格 中。 可扩展:
XML 命名空间的威力可使任何人在核心协议的 基础上建造定制化的功能 ;为了维持通透性 ,常见的 扩展由 XMPP标准基金会 。 弹性佳 :
XMPP 除了可用在实时通信的应用程序 ,还能用在 网络管理、内容供稿、协同工具、文件共享、游戏、 远程系统监控等。 多样性 :
用 XMPP 协议来建造及布署实时应用程序及服务 的公司及开放源代码计划分布在各种领域 ;用 XMPP 技术开发软件 ,资源及支持的 来源是多样的 , 使得使你不会陷于被 “绑架 ”的困境。 缺点 数据 负载太重 :
随着通常超过 70%的XMPP协议的服务器的数据流 量的存在和近 60%的被重复转发 ,XMPP协议目前 拥有一个大型架空中存在的 数据提供给多个收件 人。 新的议定书正在研究 ,以减轻这一问题。 没 有二进制数据 : XMPP 协议的方式被编码为一个

单一的长的 XML 文件 ,因此无法提供修改二进制数 据。 因此 , 文件传输协议一样使用外部的 HTTP。 如果不可避免 ,XMPP协议还提供了带编码的文件 传输的所有数据使用的 Base64 。 至于其他二进制 数据加密会话 (encrypted conversations或) 图形图 标(graphic icons)以嵌入式使用相同的方法。 79、 谈谈对性能优化的看法 ,如何做 ? 控制好内存 ,不用 的内存实时释放 ;冗余代码 ;用户体验度 ;耗时操作 , 开线程进行处理 80、 写一个递归方法 :计算 N的阶 乘 ,然后将计算结果进行存储。以便应用退出后下 次启动可直接获取该值。 开启一个线程 ,在线程种 实现递归的方法 ,将结果存到本地 ,下次运行时先看 本地 ,没有在运行这个递归方法。 
85、 isKindOfClass、 isMemberOfClass、 selector作 用分别是什么 isKindOfClass,作用是 ,某个对象属 于某个类型 ,包括继承的类型 --- isMemberOfClass: 某个对象确切属于某个类型 ,是不是具体的实例 selector:通过方法名 ,获取在内存中的函数的入口 地址 86、 写出下面程序段的输出结果
NSDictionary *dict = [NSDictionary dictionaryWithObject:@"a string value" forKey:@"akey"]; NSLog(@"%@", [dict objectForKey:@"akey"]); [dict release]; 打印输出
a string value,然后崩溃 ---- 原因 :便利构造器创建的 对象,之后的release会,造成过度释放87、请写出以 下代码的执行结果

NSString * name = [ [ NSString alloc] init ]; name = @” Habb”;[ name release]; 打印输出结果是 :
Habb,在 [name release前] 后打印均有输出结果 --- 会造成内存泄露 --- 原先指向的区域变成了野指针 ,
之后的释放 ,不能释放之前创建的区域
88、请分别写出 SEL、id、@的意思 ? SEL是“ selector ” 的一个类型 ,表示一个方法的名字 ------- 就是一个方 法的入口地址 id是一个指向任何一个继承了
Object(或者 NSObject)类的对象。需要注意的是 id 是一个指针 ,所以在使用 id 的时候不需要加 *。
@:OC中的指令符
89、以.mm为拓展名的文件里 ,可以包含的代码有哪 些 ? .mm是 oc和 C++混编类型文件后缀 ,给编译器识
别的。 90、说说如何进行后台运行程序 ? 答 :判断 是否支持多线程
UIDevice* device = [UIDevice
currentDevice]; BOOL backgroundSupported =
NO; if ([device respondsToSelector:@selector(isMultitaskingSupport
ed)]) backgroundSupported = device.multitaskingSupported; 声明你需要的后台

任务 Info.plist 中添加 UIBackgroundModes键值 ,它包 含一个或多个 string的值,包括audio:在后台提供声
音 播放功能 ,包括音频流和播放视频时的声音 location:在后台可以保持用户的位臵信息 voip:在
后台使用 VOIP 功能 前面的每个 value让系统知道 你的应用程序应该在适当的时候被唤醒。例如 ,一 个应用程序 ,开始播放音乐 ,然后移动到后台仍然需 要 执行时间 ,以填补音频输出缓冲区。添加 audio 键用来告诉系统框架 ,需要继续播放音频 ,并且可以 在合适的时间间隔下回调应用程 序;如果应用程 序不包括此项 ,任何音频播放在移到后台后将停止 运行。除了添加键值的方法 ,IOS还提供了两种途径 使应用程序在后 台工作 : Task completion—应用 程序可以向系统申请额外的时间去完成给定的任
务 Local notifications — 应用程序可以预先安排时 间执行 local notifications 传递实现长时间的后台 任务 :应用程序可以请求在后台 运行以实现特殊 的服务。这些应用程序并不连续的运行 ,但是会被 系统框架在合适的时间唤醒 ,以实现这些服务 91 、 你了解svn,cvs等版本控制工具么 ? 版本控制 svn,cvs 是两种版控制的器 ,需要配套相关的 svn,cvs服务器。scm是 xcode里配臵版本控制的地方。

版本控制 的原理就是 a和 b同时开发一个项目 ,a写 完当天的代码之后把代码提交给服务器 ,b要做的 时候先从服务器得到最新版本 , 就可以接着做。 如果a和b都要提交给服务器 ,并且同时修改了同一 个方法,就会产生代码冲突 ,如果a先提交,那么b提 交 时,服务器可以提示冲突的代码 ,b可以清晰的看 到 ,并做出相应的修改或融合后再提交到服务器。



1.用 objective-c 写一个插入法排序
2. 写一个 NSString 类的实现
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWIthCString: nullTerminatedCString encoding: encoding]; return AUTORELEASE(obj);
}
3. 写一个委托的 interface
#import <Foundation/Foundation.h> @protocol MyDelegate;// 声明 @interface MyClass : NSObject
{
id <MyDelegate> delegate; }
@end
@protocol MyDelegate// 委托方法
- (void)didJobs:(NSArray *)args;
@end
4.obj-c 有私有方法么 ?私有变量呢
在 Objective-C 有私有方法，有静态方法和实例方法。也有私有变量。
@interface MyClass (Private) - (void)testPrivate;
@end
objective-c - 类里面的方法只有两种 的原则就是一个对象只暴露有用的东西
么顺手了 . 在类里面声名一个私有方法
@interface Controller : NSObject { NSString *something; } + (void)thisIsAStaticMethod;
- (void)thisIsAnInstanceMethod; @end
@interface Controller (private) - (void)thisIsAPrivateMethod; @end
@private 可以用来修饰私有变量


6. 代理的作用? 答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到
那些类的指针。可以减少框架复杂度。 7.oc 中可修改和不可以修改类型。
答案:就是可动态添加修改和不可动态添加修改一样。 比如 NSArray 和 NSMutableArray 。前者在 初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。

13 、什么是 Notification ?
答:观察者模式， controller 向 defaultNotificationCenter 添加自己的 notification ，其他类注 册这个 notification 就可以收到通知，这些类可以在收到通知时做自己的操作(多观察者默认随机 顺序发通知给观察者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到他来操作，
可以用 NotificationQueue 的方式安排观察者的反应顺序，也可以在添加观察者中设定反映时间， 取消观察需要在 viewDidUnload 跟 dealloc 中都要注销)
14 、什么时候用 delegate ，什么时候用 Notification ?
答:
15 、什么是 KVC 和KVO ?
答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 法名找到运行方法的时候所需要的环境参数。( 2 )他会从自己
方法实现的接口。( 3)再直接查找得来的具体的方法实现。 KVO (Key-Value-Observing ):当 观察者为一个对象的属性进行了注册，被观察对象的 isa 指针被修改的时候， isa 指针就会指向一个 中间类，而不是真实的类。所以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不 要依赖于 isa 指针。在调用类的方法的时候，最好要明确对象实例的类名。
1.objective-c 中是所有对象间的交互是如何实现的 ?(深圳皆凯科技有限公司笔试题)
2. 如何将产品进行多语言发布?
3.objective-c 中是如何实现线程同步的 ?
4.编写函数 _memmove 说明如下:实现 C 语言库函数 memmove 的功能:将一块缓冲区中的数据移 动到另一块缓冲区中。可能有重复。
5. 什么叫数据结构?(面试顺风快递 iphone 开发) 6. 编程中，保存数据有哪几种方式?
7.Sizeof 与 strlen 的区别和联系?
8. 什么是抽象类?抽象类有什么作用?能实例化吗?
9. 线程中有哪些函数?写出来
10. 有没有写过自定义的控件
11. 调用一个类的静态方法需不需要 12.do-while 与 while-do 的区别?
13. 写出几个死循环?
14. 考察对 @interface 和@property
15. Iphone 开发中控制类有什么作用?
16. 用 Objective-C 写冒泡法.
Object-C 有多继承吗?没有的话用什么代替?
cocoa 中所有的类都是 NSObject 的子类 多继承在这里是用 protocol 委托代理 来实现的 你不用去考虑繁琐的多继承 ,虚基类的概念 . ood 的多态特性 在 obj-c 中通过委托来实现 .
Object-C 有私有方法吗?私有变量呢?
release ?
的理解?
setValue 的时候，( 1 )首先根据方 isa 指针结合环境参数，找到具体的


还应该重载重写 viewDidUnload 来释放对 view 的任何索引 viewDidLoad 后调用数 据 Model
viewDidUnload 方法 当系统内存吃紧的时候会调用该方法(注: viewController 没有被 dealloc ) 内存吃紧时， 在 iPhone OS 3.0 之前 didReceiveMemoryWarning 是释放无用内存的唯一方式， 但是 OS 3.0 及以后 viewDidUnload 方法是更好的方式 在该方法中将所有 IBOutlet (无论是 property 还是实例变量)置为 nil (系统 release view 时已经将其 release 掉了)
在该方法中释放其他与 view 有关的对象、其他在运行时创建(但非系统必须)的对
象、在 viewDidLoad 中被创建的对象、缓存数据等 release 对象后，将对象置为 nil
( IBOutlet 只需要将其置为 nil ，系统 release view 时已经将其 release 掉了) 一般认为 viewDidUnload 是 viewDidLoad 的镜像，因为当 view 被重新请求时，
viewDidLoad 还会重新被执行
viewDidUnload 中被release 的对象 必须是很容易被 重新创 建的对象 (比如在
viewDidLoad 或其他方法中创建的对象) ，不要 release 用户数据或其他很难被重新创 建的对象
dealloc 方法 viewDidUnload 和dealloc 方法没有关联， dealloc 还是继续做它该做 的事情
ViewController 的 didReceiveMemoryWarning 是在什么时候调用的?默认的操作是什 么?
当程序接到内存警告时 View Controller 将会收到这个消息: didReceiveMemoryWarning 从iOS3.0 开始，不需要重载这个函数，把释放内存的代码放到 viewDidUnload 中去。 这个函数的默认实现是 :检查 controller 是否可以安全地释放它的 view( 这里加粗的 view 指的是 controller 的view 属性 )，比如 view 本身没有 superview 并且可以被很容易地重建(从 nib 或者 loadView 函数)。
如果 view 可以被释放，那么这个函数释放
你可以重载这个函数来释放 controller
来允许父类(一般是 UIVIewController
如果你的 ViewController 保存着 view 的子 view 的引用，那么，在早期的 iOS 版本中，你应该在 这个函数中来释放这些引用。而在 iOS3.0 或更高版本中，你应该在 viewDidUnload 中释放这些 引用。
列举 Cocoa 中常见的集中多线程的实现，并谈谈多线程安全的几种解决办法，一般什么地方 会用到多线程?
NSOperation NSThread @sychonized
delegate 和 notification 区别，分别在什么情况下使用?
view 并调用 viewDidUnload 。 中使用的其他内存。但要记得调用这个函数的 super 实现
)释放 view 。

KVC(Key-Value-Coding) KVO (Key-Value-Observing ) 理解 KVC 与 KVO (键 -值-编码与键 -值-监看)
当通过 KVC调用对象时，比如: [vsaellufeForKey:@ 试图通过几种不同的方式解析这个调用。首先查找对象是否带有 法，如果没找到，会继续查找对象是否带有 someKey 这个实例变量( iVar )，如果还 没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个 方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。
(Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey 以及 _getsomeKey 这几种
形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从 对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。


 void Func ( char str[100] ) {
sizeof( str ) = ? }
void *p = malloc( 100 ); sizeof ( p ) = ?
节，故 sizeof( str ) 、sizeof ( p ) 都为 4。
3. 还是考指针 ,不过我对 cocoa 的代码还是不太熟悉 大概是这样的
- ( void ) *getNSString(const NSString * inputString) {
is a main test\n"; return ;
} -main(void)
{
NSString ";
NSString *aString = [NSString stringWithString:@"%@",getNSString(a)];
NSLog(@"%@\n", aString); }
最后问输出的字符串 :NULL,output 在 函数返回后，内存已经被释放。
4. 用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题) #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
函数中数组名作为函数形参时，
自减等 操作，可以被修改。 Windows NT 32 位平台下，指针的长度(占用内存的大小)为 4字
这题 很常见了 ,Func ( char str[100] ) 本身的内涵，仅仅只是一个指针;在失去其内涵的同时，它还失去了其常量特性，可以作自增、
在函数体内， 数组名失去了


 数据模型。 功能列表:框架分类
下面是 Cocoa Touch 音频和视频
Core Audio OpenAL Media Library AV Foundation 数据管理
Core Data SQLite
图形和动画
Core Animation OpenGL ES Quartz 2D
网络 /li> Bonjour WebKit
BSD Sockets
用
? 如果您通过分配和初始化(比如
有这个对象，需要负责该对象的释放。这个规则在使用
用。
? 如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放。
? 如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。
反过来，
? 如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它(这个规则有少 数
的例外，在参考文档中有显式的说明) 。
21. 自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对 象的一个引用放入到最新的 自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送
消息。 当程序执行到作用域结束的位置 时，自动释放池就会被释放， 池中的所有对象也就被释放。
[[MyClass alloc] init]
)的方式来创建对象，您就拥
NSObject 的便利方法 new 时也同样适

2.CALayer 和 View 的关系
一个 UIView 包含 CALayer 树， CALayer
为啥离开团队?
1. 针对第一个问题，可以看看下面的教程
是一个数据模型，包含了一些用于显示的对象，但本
身不用于显示。
CALayer 相当于 photoshop 的一个层，很多动画可以通过设置 CALayer 来实现。据说有人用
CALayer 显示图片来播放视频。
Core animation 应该是用 CAlayer 来实现各种动画。

用继承好还是分类好?为什么?
7. 什么是安全释放?
10. 异常 exception 怎么捕获?不同的 CPU 结构上开销怎样? C 中又什么类似的方法?
11.property 中属性 retain,copy,assgin 的含义分别是什么?有什么区别?将其转换成 get /set方 法怎么做?有什么注意事项?
12. 委托是什么?委托的 property 声明用什么属性?为什么?
14.Cocoa 中与虚基类的概念么?怎么简洁的实现?
18. 在一个对象释放前 .如果他被加到了 notificationCenter 中 .不在 notificationcenter 中 remove 这个对象可能会出现什么问题?
19. 怎样实现一个 singleton 的类 .给出思路。
20. 什么是序列化或者 Acrchiving, 可以用来做什么 ,怎样与 copy 结合 ,原理是什么 ?.
22. 在 iphone 上有两件事情要做 ,请问是在一个线程里按顺序做效率高还是两个线程里做效率高? 为什么?
17. 列举 Cocoa 中常用的几种多线程实现，并谈谈多线程安全问题的几种解 决方案，什么地方会用到多线程 NSOperation NSThread @sychonized

19. (Key-Value-Observing
KVC,KVO Ewe KVC(Key-Value-Coding) KVO
- 值- 监看)
) 理解 KVC 与 KVO (键 - 值- 编码与键 http://www.cocoachina.com/macdev/cocoa/2009/0611/221.html
k-v-o 扫盲
http://www.cnblogs.com/scorpiozj/archive/2011/03/14/1983643.ht ml
当通过 KVC 调用对象时，比如: [self valueForKey:@ 序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有
someKey 这个方法， 如果没找到， 会继续查找对象是否带有 someKey 这个实 例变量(iVar )，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。 如果这个方法还是没有被实现的话， 程序 会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey 以及 _getsomeKey 这几种形式。 同时， 查找实例变量的时候也会不 仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 时，对象能够在错误发生前，有最后的机会响应这个请求。

6. 对于语句 NSString* testObject = [[NSData alloc] init];testObject 在编译时和运行时分别时 什么类型的对象?
7. 什么是安全释放?
8. 为什么有些 4.0 独有的 objective - c 函数在 3.1 上运行时会报错 .而 4.0 独有的类在 3.1 上分配内存 时不会报错?分配的结果是什么?
9. 为什么 4.0 独有的 c 函数在 3.1 的机器上运行不会报错 (在没有调用的情况下?) 在3.1 的机器上一运行就报错?
10. 常见的 object-c 的数据类型有那些， 和 c 的 基本数据类型有什么区别?如: 11.property 中属性 retain,copy,assgin 的含义分别是什么?有什么区别?将其转换成
而 4.0 独有的类名 nsinteger 和 int
get /set方
法怎么做?有什么注意事项?
12. 委托是什么?委托的 property 声明用什么属性?为什么?
7 [invocation invokeWithTarget:self.carInfo]; 8}
(NSMethodSignature*)methodSignatureForSelector:(SEL)selector
NSMethodSignature* signature = [super methodSignatureForSelector:selector];
if (!signature)
signature = [self.carInfo methodSignatureForSelector:selector];
return signature;
(void)forwardInvocation:(NSInvocation *)invocation
SEL selector = [invocation selector];
if ([self.carInfo respondsToSelector:selector])
9}
3. 调用
1 Car *myCar = [Car car]; //Car
2 [(NSString *)myCar UTF8String]
为一个类
// 这里调用 NSString
中的 UTF8String
方 ,注意 Car 中并未实现该
方法
复制代码
解释 : 这里借 iphone 开发秘籍的例子来说明 , self.carInfo 是一个只读的 NSString 对象 ,存在于 Car 类中 .
例子中 Car 实例是无法正确的为另外一个对象 (NSString) 实现的选择器创建一个有效的签名。 查到当前没有有效的签名 , 即进入该对象 ( 这里是 myCar) 的 methodSignatureForSelector: 将在这个方法中对每个伪继承进行迭代并尝试构建一个有效的方法签名的机会 .例如代码中
用 UTF8String 时 ,由于无法从当前对象中获得消息，转入第二次机会捕捉消息，首先进入 methodSignatureForSelector: 方法 ,采用迭代的方式为当前被调用的方法创建一个有效的签名，
名后，转入 forwardInvocation: 方法对其调用的方法 (UTF8String) 进行实现 . forwardInvocation: 中， 首先获得调用的方法 (UTF8String), 判断 self.carInfo( 一个 nsstring 对象 )能否响应该方法，如果可以，将 调用 UTF8String 对象的目标转换为 self.carInfo 对象 . 这样 ，我们就实现了多继承，呵呵!!
注 : 如果您仍有疑问，可访问苹果的官方文档查询消息转发相关内容 :
地址 http://www.apple.com.cn/developer/mac/library/documentation/Cocoa/Conceptual/ObjCRun timeGuide/Articles/chapter_6_section_1.html#//
apple_ref/doc/uid/TP40008048-CH105-SW1
运行时当检 方法中 ,此时，
,当 myCar 调 得到签

2. 委托
在IOS 中委托通过一种 @protocol 的方式实现 ,所以又称为协议 .协议是多个类共享的一个方法列表 ,在协 议中所列出的方法没有响应的实现， 由其它人来实现 .这叫好比我想买个手机， 所以我有个 buyIphone 方 法,但是我不知道谁那买手机 ,所以把这个需求发布出去 (比如公布在网站上 ),如果有卖手机的商人 ( 也就是 说他能实现 buyIphone 这个方法 )看到， 他就会接受我的委托 ,( 在商人自己的类中实现 <XXXdelegate>), 那么我的委托对象就指向了这个商人 ..当我要买手机的时候，直接找他就行了 .
例如:
@protocol MyDelegate
-(void)buyIphone:(NSString *)iphoneType money:(NSString *)money;
@end
@interface My : NSObject
{
id<MyDelegate> deleage; }
@property(assign,nonatomic)id<MyDelegate> delegate; @end
代码中声明了一个协议 名叫 Mydelegate, 在其中有一个 buyIphone 方法， 即一个委托项。 当我要购买手 机的时候只需要通过 delegate 调用 BuyIphone 方法即可 .
如下: -(void)willbuy {
[delegate buyIphone:@"iphone 4s" money:@"4888"];
}
我不必关心谁现实了这一委托，只要实现了这个委托的类，并且 方法，那么就一定能够得到结果 .
buyIphone 是声明的委托中必须实现的
方法
例如:商人类实现了这一委托 (用<Mydelegate> #import <Foundation/Foundation.h>
#import "My.h"
@interface Business : NSObject<MyDelegate> @end
然后在 @implementation Business 中调用 #import "Business.h"
@implementation Business
表示实现 )
buyIphone
-(void)buyIphone:(NSString *)iphoneType money:(NSString *)money {
NSLog(@" 手机有货，这个价钱卖你了，发货中 !!"); }

@end
就ok 啦。这样是不是也模拟了多继承呢?通过委托，其实你也就摆脱了去考虑多继承方面的
事情，从而关注当前类。



类别的作用?继承和类别在实现中有何区别?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修 改。
并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先
级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。
3.Difference between categories and extensions?
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。
extensions 可以认为是一个私有的 Category 。
Page 1 of 30

 4.Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。 informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的 属性。
其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里 “非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他 们更好的完成工作”。 这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后 你在后期可以直接使用这些更好的方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用 interface 修饰“，
现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
5.What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，
直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。 kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
if ([keyPath isEqualToString:@"highlighted"] ) {
Page 2 of 30

 [self setNeedsDisplay]; }
}
对于系统是根据 keypath 去取的到相应的值发生改变，理论上来说是和 kvc 机制的道理是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
“当通过 KVC调用对象时，比如: [self valueForKey:@ ” someKey” ] 时，程序会自动试图通过几种不同
的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带 有 someKey 这个实例变量( iVar )，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey以及 _getsomeKey 这几种形式。同时，查找实例 变量的时候也会不仅仅查找 someKey这个变量，也会查找 _someKey这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对 象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做 的好处。“
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 . 因此为何上面我们只是 add 一个相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
6.What is purpose of delegates?
代理的作用? 答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那 些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。 答案:可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
Page 3 of 30

 比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可 以动态申请新的内存空间。
8.When we call objective c is runtime language what does it mean?
我们说的 oc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类( life )都用有一 个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只需调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~
9.what is difference between NSNotification and protocol?
eat 这个选择器)。
通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。
首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的行为模式，我 们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人 负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。

 推送通知更是一种技术。 简单点就是客户端获取资源的一种手段。 普通情况下，都是客户端主动的 pull 。 推送则是服务器端主动 push。




19.cocoa touch 框架
iPhone OS 应用程序的基础 CocoaTouch 框架重用了许多 Mac 编制的成熟模式，但是它更
多地专注于触摸的接口和优化。 UIKit
的基础工具，其建立在和 Mac OS X
字符串操作等。 Cocoa Touch 具有和 iPhone 用户接口一致的特殊设计。有了 UIKit ，您可
为您提供了在 iPhone OS 上完成图形，事件驱动程序 中一样的 Foundation 框架上，包括文件处理，网络，
Page 20 of 30

 以使用 iPhone OS 上的独特的图形接口控件，按钮，以及全屏视图的效用，您还可以使用加 快仪和多点触摸手势来控制您的应用。
各色俱全的框架 除了 UIKit 外，CocoaTouch 包括了创建世界一流 iPhone 应用程序须要 的所有框架，从三维图形，到专业音效，听听开发。以至提供设备访问 API 以控制摄像头， 或通过 GPS 获知当前位置。 Cocoa Touch 既包括只须要几行代码就可以完成全部任务的强
大的 Objective-C 括:
Core Animation
通过 CoreAnimation 用户体验。
Core Audio
框架，也在须要时提供基础的 C 言语 API 来直接访问编制。这些框架包
，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的
Core Audio 是播放，你知道 ios 。处理和录制音频的专业技术，
com的人员
能够轻松为您的应用程序添加强大的音频效用。
Core Data
提供了一个面向对象的数据管理解决计划，它易于使用和理解，以至可处理任何应用或大或 小的数据模型。
效用列表:框架分类
下面是 Cocoa Touch 中一小局部可用的框架:
音频和视频




 23. 单件实例是什么
Foundation 和 ApplicationKit 框架中的一些类只允许创建单件对象，即这些类在当前进 程中的唯一实例。举例来说， NSFileMsome kind ofager 和 NSWorkspace类在使用时都是基 于进程进行单件对象的实例化。当向这些类请求实例的时期，它们会向您传递单一实例的一 个引用，如果该实例还不存在，则首先进行实例的分配和初始化。 单件对象充当控制中心 的角色，负责指引或调解类的各种服务。如果类在概念上唯有一个实例(比如 NSWorkspace)，就应该产生 一个单件实例，而不是多个实例;如果将来某一天可能有多个 实例，您可
以使用单件实例机制，而不是工厂方法或函数。

 1)Cateogies
2)Posing
3) 动态识别
4) 指标计算
5)弹性讯息传递
6) 不是一个过度纷乱的 C 衍生言语 7) Objective-C 与 C++可混合编程 缺点:
1) 不支援命名空間 2) 不接济运算符重载
3)不接济多重继承
4)使用动态运转时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。 iPhone 。(如内联函数等)，性能低劣。
26.sprintfstrcpymemcpy 使用上有什么要注意的地方
strcpy 是一个字符串拷贝的函数，它的函数原型为 strcpy(char*dst const char *src);
将 src 开始的一段字符串拷贝到 dst 开始的内存中去，结束的标志符号为 '\0' ，由于拷贝的 长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。具备字符串拷贝效用的函数
有 memcpy，这是一个内存拷贝函数，它的函数原型为 memcpy(char *dst const char* src unsigned intlen);
将长度为 len 的一段内存，从 src 拷贝到 dst 中去，这个函数的长度可控。但是会有内存叠 加的问题。
sprintf 是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。 sprintf 格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小， Android 开发。造成溢出。
Page 25 of 30

 27. 用变量 a 给出下面的定义
a) 一个整型数( Aninteger ) b) 一 个指向整型数的指针( ofinteger )
c) 一个指向指针的的指针，它指向的指针是指向一个整型数( some kind ofintege )r
A pointer to some kind
A pointer to a pointer to
d) 一个有 10 个整型数的数组( An assortment of 10integers
e) 一个有 10 个指针的数组，该指针是指向一个整型数的。(
pointers tointegers )
f) 一个指向有 10 个整型数数组的指针( A pointer to some kind of assortment of 10integers )
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数( A pointer to a function that takessome kind of integer as some kind of argument
some kind ofd returns some kind ofinteger )
h) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型 数( An assortment of tenpointers to functions t
hat take some kind of integer argument some kind ofd return some kind of integer )
答 案是:
a) int a; // Aninteger
b) int *a; // A pointer to some kind ofinteger
c) int **a; // A pointer to a pointer to some kind ofinteger
d) int a[10]; // An assortment of 10integers
e) int *a[10]; // An assortment of 10 pointers tointegers
f) int (*a)[10]; // A pointer to some kind of assortment of 10integers
g) int (*a)(int); // A pointer to a function athattakes some kind of integer argument some kind ofd returns some kind ofinteger
h) int (*a[10])(int); // An assortment of 10 pointers tofunctionsthat take some kind of integer argument some kind ofdreturn some kind of integer
Page 26 of 30
)
An assortment of 10

 28.repostingwrite ， repostingonly ， assign ， retain ， copy ， nonatomic 属性的作用
@property 是一个属性访问声明，扩号内接济以下几个属性: 1，getter=getterName ，setter=setterName ，设置 setter 2， repostingwriterepostingonly ，设置可供访问级别
2， assign ，看看 iOS 开发。 setter 方法直接赋值，不进行 类型与环循引用问题
3， retain ， setter 方法对参数进行 release 旧值再 retain
(CC 上有相关原料 )
4，copy，setter 方法进行 Copy操作，与 retain 处理流程一样，先旧值 release ，再 Copy 出新的对象， retainCount 为 1。这是为了减少对上下文的依赖而引入的机制。
5，nonatomic ，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此 属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级 ( 我是这么理 解的 ...) 。
@synthesizexxx; 来完成实际代码
*********************************
1Objective -C 外部的完成 2CALayer 和 View 的关系 3 http 协议， tcp/ip4 UITableView 的
那些元素是可以自定义的? 5 c 言语的，定义变量，比如 不同的 6 比较 32 位平台和 64 位平台不同 7 iphone app 为啥离开团队?
1. 针对第一个问题，可以看看下面的教程
Object c 研究的比较深入的教程
int ，在什么情况下，其最大值是 为什么会被打回来，如何制止 ??8
Page 27 of 30
与 getter 的方法名
任何 retain 操作，为了解决原
新值，所有完成都是这个秩序

 第 6章写的加倍好
KVO/KVC完成机理分析
2.CALayer 和 View 的关系
一个 UIView 包括 CALayer 树， CALayer 是一个数据模型，听说 示的对象，但本身不用于显示。
CALayer 相当于 photoshop 的一个层，很多动画可以通过设置 CALayer 显示图片来播放视频。
Coresome kind ofimation 应该是用 CAlayer 来完成各种动画。
这里有篇博文，介绍的还可以
1.objc 是扩充 C的面向对象，开发 mac osx 的编程语言。
iPhone 。包括了一些用于显
CALayer 来完成。据说有人用
2.objc 中的减号与加号
1减号表示一个函数、或者方法或者消息的开始 ( 在一个类的实例上被调用和实施 ) 2加号 表示其他的函数可以直接调用这个类中的方法，而不用创建这个类的实例
3.NS 开发包
乔布斯的 NextStep 公司缩写，现今 mac os 使用 NS这套函数库
4.#import 作用如同 #include, 用于声明头文件。
5.nil 表示空指针，相当于 java 的 null
6.objc 中使用字符串，前面要加上 "@"，是因为在前面加上 " 符号 " ，编译器在编译的时候会 在程序中给你留出位置，这样才能保证这个字符串不会丢失。 (@是把 C的字符串转成
Page 28 of 30

 NSString 的一个简写 )
7. 开发 objc 类，需要创建一个头文件和一个实现文件
1头文件 (.h): 包含类的实例变量的名称和类型、描述方法参数和返回值类型的方法签名 ; 2实现文件 (.m): 包含这些方法的实现代码，以及对别的类不可见的，仅与实现本身相关的 局部变量的声明和使用。
8. 九宫格解法原理; ( 右上解法 ) 左出右写入、右出左写入、上出下写入、下出上写入、重排置下;
9.iphone 应用程序的项目基本结构
classes: 里面存放 object-c 类源代码文件 ( 可以创建子文件夹来组织代码 );
other sources: 存放除 objective-c 类之外的源代码文件;
resources: 包含应用程序中的非代码文件 ( 因为应用程序只能在自己的沙盒中运行，不然找 不到 ) ;
Frameworks: 特殊的库，可以存放库、框架、图像、声音等资源;
Products :包含项目在编译时生成的应用程序 (xxx.app);
10.Info.plist 文件里的 bundle identifier( 束标识符 ) 它是应用程序的唯一标识符，要始终配置，命名格式为:顶级 Internet 应用名称;
域+.+公司名称 +.+
11. 一个在代码里对 nib 中对象 (UILabel 、UITextField 等 ) 的引用被称为一个插座变量
( outlet )，用关键字 IBOutlet 标明 ( 在头文件里 ) ;能够被 nib 中对象调用的方法称为动 作( action )，用关键字 IBAction 标明 ( 在实现文件里 ) 。
12. 在实现某个动作或是对象后要对这个动作或是对象后要使用 release 13.IBOutlet
输出口 使用关键字 IBOutlet 来声明实例变量 , 并通过这个实例变量来引用
14.-(IBAction)doSomething:(id)sender
释放内存。
nib 中的对象;




13. Object C 中创建线程的方法是什么 ?如果在主线程中执行代码，方法是什 么 ?如果想延时执行代码、方法又是什么 ?

 答:线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch 、使 用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行 代码，方法是 performSelectorOnMainThread ，如果想延时执行代码可以用
performSelector:onThread:withObject:waitUntilDone:


19. 什么是 KVO 和 KVC?
答: KVC: 键 – 值编码是一种间接访问对象的属性使用字符串来标识属性，而
不是通过调用存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。

 KVO: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个 button
1[self?addObserver:self?forKeyPath:@ "highlighted" ?options:0?co 2ntext:nil];
3#pragma?mark?KVO 4-?(void)observeValueForKeyPath:(NSString?*)keyPath?ofObject:( 5id)object?change:(NSDictionary?*)change?context:(void?*)conte
6xt
7{
8if ?([keyPath?isEqualToString:@
[self?setNeedsDisplay]; }
}
"highlighted"
]?)?{
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机 制的道理是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
―当通过 KVC 调用对象时，比如: [self valueFo rKey:@ ‖ someKe时y ，程‖序] 会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有
someKey 这个方法， 如果没找到， 会继续查找对象是否带有 someKey 这个实
例变量(iVar) ，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话，程序
会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法， 还会查找 getsomeKey 这个方法， 前面加一个 get ，或者

 _someKey 以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不 仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。
这样做有很多好处，下面的两个例子说明了这样做的好处。 ―
来至 cocoa ，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们 只是 add 一个相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
20. 代理的作用 ?
答:代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类，
而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
21. oc 中可修改和不可以修改类型。
答:可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可
动态添加修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不 可变的，后者可以添加等，可以动态申请新的内存空间。
22. 我们说的 oc 是动态运行时语言是什么意思 ?

 答:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 以及调用该 类别对象指定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生 物类 (life) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用 是我们只需调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息 ( 响应了 eat 这个选择器 )。
因此也可以说，运行时机制是多态的基础 ?~~~
23. 通知和协议的不同之处 ? 答:协议有控制链 (has-a) 的关系，通知没有。
首先我一开始也不太明白，什么叫控制链 (专业术语了 ~) 。但是简单分析下通知 和代理的行为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解，到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间， 代理的事物对象都是不一样的， 一一对应， 不可能说明天 要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的

 发布会了。但是通知就不一样， 他只关心发出通知， 而不关心多少接收到感兴趣 要处理。
因此控制链 (has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
24. 什么是推送消息 ? 答:推送通知更是一种技术。
简单点就是客户端获取资源的一种手段。 普通情况下，都是客户端主动的 pull 。
推送则是服务器端主动 push 。 测试 push 的实现可以查看该博文。
25. 关于多态性 答:多态，子类指针可以赋值给父类。
这个题目其实可以出到一切面向对象语言中，
因此关于多态， 继承和封装基本最好都有个自我意识的理解， 上资料上写的能背出来
也并非一定要把书


 30. OC 的垃圾回收机制 ?
答: OC2.0 有 Garbage collection ，但是 iOS 平台不提供。
一般我们了解的 objective-c 对于内存管理都是手动操作的， 但是也有自动释放 池。
但是差了大部分资料，貌似不要和 arc 机制搞混就好了。
31. NSOperation queue?
答:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发的问题。
网上部分资料提到一点是， 虽然是 queue ，但是却并不是带有队列的概念， 放入 的操作并非是按照严格的先进现出。
这边又有个疑点是， 对于队列来说，先进先出的概念是 Afunc 添加进队列，Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，
但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行， 因此队列的 概念离乱上有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作， 我们亦然可以感性认为这 还是一个队列。

 但是后来看到一票关于这操作队列话题的文章，其中有一句提到 ―因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。 ‖
瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。


 因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的 需要去设置如相关的数据源。
因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢 ?想让 列表如何显示，不同的数据源分区块显示 ?
35. 什么时候使用 NSMutableArray ，什么时候使用 NSArray?
答:当数组在程序运行时，需要不断变化的，使用 NSMutableArray ，当数组
在初始化后，便不再改变的，使用 NSArray 。需要指出的是，使用 NSArray
只表明的是该数组在运行时不发生改变， 即不能往 NSAarry 的数组里新增和删
除元素，但不表明其数组內的元素的内容不能发生改变。 NSArray 是线程安全
的，NSMutableArray 不是线程安全的，多线程使用到 NSMutableArray 需 要注意。
36. 给出委托方法的实例，并且说出 UITableVIew 的 Data Source 方法 答: CocoaTouch 框架中用到了大量委托，其中 UITableViewDelegate 就是
委托机制的典型应用，是一个典型的使用委托来实现适配器模式，其中 UITableViewDelegate 协议是目标， tableview 是适配器，实现
UITableViewDelegate 协议，并将自身设置为 talbeview 的 delegate 的对象， 是被适配器，一般情况下该对象是 UITableViewController 。
UITableVIew 的 Data Source 方法有 - (NSInteger)tableView:(UITableView *)tableView
numberOfRowsInSection:(NSInteger)section;

 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
37. 在应用中可以创建多少 autorelease 对象，是否有限制 ? 答案:无
38. 如果我们不创建内存池，是否有内存池提供给我们 ?
答 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线
程的内存池
39. 什么时候需要在程序中创建内存池 ? 答:用户自己创建的数据线程，则需要创建该线程的内存池 40. 类 NSObject 的那些方法经常被使用 ?
答: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。
其中类方法 alloc 、class、 description 对象方法 init 、dealloc 、– performSelector:withObject:afterDelay: 等经常被使用
41. 什么是简便构造方法 ?
答:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber 的 +
numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:

 Foundation 下大部分类均有简便构造方法， 我们可以通过简便构造方法， 获得 系统给我们创建好的对象，并且不需要手动释放。

43. UIView 的动画效果有那些 ?
答:有很多，如 UIViewAnimationOptionCurveEaseInOut
UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTr ansitionCurlDown
44. 在 iPhone 应用中如何保存数据 ? 答:有以下几种保存机制:
1). 通过 web 服务，保存在服务器上

 2). 通过 NSCoder 固化机制，将对象保存在文件中
3). 通过 SQlite 或 CoreData 保存在文件数据库中
45. 什么是 coredata?
答: coredata 是苹果提供一套数据保存框架，其基于 SQlite
46. 什么是 NSManagedObject 模型 ?
答: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成 部分，它是一个通用的类 ,实现了 core data 模型层所需的基本功能， 用户可通 过子类化 NSManagedObject ，建立自己的数据模型。
47. 什么是 NSManagedobjectContext?
答: NSManagedobjectContext 对象负责应用和数据库之间的交互。
48. 什么是谓词 ?
答:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对
数据的筛选。
1predicate?=?[NSPredicate?predicateWithFormat:@ "customerID?==? 2%d",n];
a?=?[customers?filteredArrayUsingPredicate:predicate]; 49. 和 coredata 一起有哪几种持久化存储机制 ?
答:存入到文件、 存入到 NSUserDefaults( 系统 plist 文件中 )、存入到 Sqlite 文件数据库

delegate和 notification 区别，分别在什么情况下 使用?
KVC(Key-Value-Coding)
KVO ( Key-Value-Observing ) 理解 KVC与 KVO(键-值-编码与键 -值-监看)
当通过 KVC 调用对象时，比如:[self valueForKey:@ ” someKe时y，”程]序会自动试图通
过几种不同的方式解析这个调用。首先查找对象是
否带有 someKey 这个方法，如果没找到，会继续 查找对象是否带有 someKey 这个实例变量( iVar )， 如果还没有找到，程序会继续试图调用 -(id)
valueForUndefinedKey: 这个方法。如果这个方法 还是没有被实现的话，程序会抛出一个
NSUndefinedKeyException 异常错误。
(Key-Value Coding 查找方法的时候，不仅仅会查
找 someKey 这个方法，还会查找 getsomeKey 这 个方法，前面加一个 get ，或者 _someKey 以及
_getsomeKey 这几种形式。同时，查找实例变量 的时候也会不仅仅查找 someKey 这个变量，也会
查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当 你使用 -(id)valueForKey 方法从对象中请求值时， 对象能够在错误发生前，有最后的机会响应这个请 求。


三、类别 (Category) 和类扩展 (Extension) 的区别?
1、相同点:都可以给类添加额外的方法
2 、不同点:类扩展是分类的一个特例，或者说是一个私有的分类、匿名类， Extension 中的方法必须在 @implementation 中实现，否则编译会报警告
分类只能添加方法不能添加属性，且方法的实现不一定在 @implementation 实现。
四、什么是 KVO和KVC?
1、KVO:即:Key-Value Observing，它提供一种机制，当指定的对象的属性被 修改后，则对象就会接受到通知。 简单的说就是每次指定的被观察的对象的属性 被修改后， KVO就会自动通知相应的观察者，极大的简化了代码! 2、KVC:即:KeyValueCoding 的简称，它是一种可以直接通过字符串的名字 (key) 来访问类属性的机制。而不是通过调用 Setter、Getter 方法访问，也可以简化代 码!
五、代理的作用?
1、代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。 可以减少框架复杂程度。另外一点， 代理和 java 中的回调监听机制比较类似。
六、 OC中的可修改和不可修改类型?

1、个人理解为可变和不可变，如 NSAray、NSString、NSDictionary 等是不可变 的，一旦初始化完毕，里面的内容就是固定不变的，既不能删除，也不能添加;
而 NSMutableArray 、NSMutableString 、NSMutableDictionary 等是可变的， 即能 添加也能删除，在内存中的存储空间和内容都不固定!
七、 OC中的动态运行时语言是什么意思? 1、多态。主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实
浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时 才去决定一个对象的类别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。如: Person 和 Dog 都继承自生物 Life 类，且都有一个 eat 方法，但是调用时只需要调用各自的 eat 方法，就是说不同对象以自己的方式响应相同的方法和消息! 因此也可以说， 运行时机制是多态的基础。
八、通知和代理的异同? 1、相同点:利用通知和代理都能完成对象之间的通信
2、不同点:代理是一对一的关系，通知是多对多的关系。一般来说代理是两个 类之间的关系，通知可以一对多，也可以多对一，还可以多对多，就是一个发布 者一个监听者， 一个发布者多个监听者， 多个发布者多个多个监听者， 代理需要 有协议、要声明协议、实现协议中方法、设置代理;通知需要设置通知中心、设 置发布者和监听者。
十二、 ios 中的垃圾回收机制?
1、Objective-c 2.0 后提供了垃圾回收机制 Garbage Collection，但是 ios 移动端不 支持垃圾回收机制，需要注意的是 ARC 并不是垃圾回收机制， ARC 也是需要管 理内存的，只不过是隐式的管理内存， 编译器会在适当的位置添加 retain 、release、 autorelease 等消息!

二十五、自动释放池什么时候被创建和销毁?有什么作用?底层如何实现?
1、作用:自动释放对象;所有 autorelease 的对象，在出了作用域之后，会被自 动添加到最近创建的自动释放池中; 自动释放池被销毁或者耗尽时， 会向池中所 有对象发送 release 消息，释放池中对象;自动释放池，在 ARC & MRC程序中都 有效 2、生命周期:运行循环检测到事件并启动后，就会创建自动释放池;一次完整 的运行循环结束之前，会被销毁
3、底层实现:自动释放池以栈的形式实现 :当你创建一个新的自动释放池时，它 将被添加到栈顶。当一个对象收到 autorelease 消息时 ,该对象会被添加到这个处 于栈顶的自动释放池中 ,当自动释放池被回收时 ,它们会从栈中被删除 , 并且会给 池子里面所有的对象都会做一次 release 操作。
二十六、简要说明工厂方法?
1、概念:在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂 方法让一个类的实例化延迟到子类中进行 ，工厂方法要解决的问题是对象的创 建时机，它提供了一种扩展的策略，很好地符合了开放封闭原则。 2、何时使用:一个类不知道它所必须创建的对象的类时，一个类希望有它的子 类决定所创建的对象时


作用:负责创建控制器的 view
2、viewDidLoad 在视图 view 加载完毕时调用，无论怎样创建的 view
作用:一般可以在这里做一些初始化操作，如添加子视图等
3、 viewDidUnload 在应用程序内存过多，收到内存警告释放 view 时调用
作用:主要是释放界面元素的相关资源，将相关的实例赋值为 nil 4、三者的顺序:第一次访问 VC的 view 时，view 为 nil，然后调用 loadView 方
法创建 view ，view 创建完毕调用 viewDidLoad 进行界面初始化，当内存警告时， 系统可能会释放 VC 的 view ，并将 view 设置为 nil ，并且调用 viewDidUnload 方 法，当再次访问 VC的 view 时，view 之前已经设置为 nil，所以重新调 loadView 方法 ,,

三十、图层 CALayer 和 UIView 的区别?
1、UIView 是 iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本
身完全是由 CoreAnimation 来实现的。真正的绘图部分，是由 CALayer类来管理。 UIView 本身更像是一个 CALayer 的管理器。
2、UIView 继承结构为:UIResponder---------NSObject ，直接父类为 UIResponder， 直接父类是用来响应用户事件的，所以 UIView 可以响应用户事件
CALayer 的继承结构为: NSObject，直接父类没有 UIResponder ，所以 CALayer 不能响应任何用户事件
3、UIView 属于 UIKit 框架,CALayer属于 QuartzCore 框架 三十一、简要说明 GCD?
1、全称: Grand Central Dispatch ，纯 C 语言，提供了非常强大的函数 2、优势: a、是苹果公司为多核的并发运算提出的解决方法
毁线程 ) 线程管理的代码
b、会自动利用更多得 CPU内核(双核、四核 ) c、自动管理线程的生命周期 ( 创建线程、调度任务、销
d、程序员只需告诉 GCD 要执行什么任务，不需要编写
3、核心概念:将任务添加到队列， 并指定执行任务的函数， 任务用 block 封装， 执行函数分同步和异步，队列分串行、并发和主队列


三十二、什么是 TCP 连接的三次握手?
1、第一次握手:客户端发送 syn( 同步序列编号 )包 (syn=j) 到服务器，并进入 SYN_SEND状态，等待服务器确认;
2、第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1 )，同时自 己也发送一个 SYN包(syn=k)，即 SYN+ACK包，此时服务器进入 SYN_RECV状
态;
3、第三次握手:客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成 三次握手。 4、如果要断开连接，就需要任意一方主动发起请求，可以理解为第四次握手!


三十三、利用 Socket 建立网络连接的步骤 ( 等同于 Socket 间如何通信 ) ? 1、创建套接字，建立地址和套接字之间的联系
2、服务器监听客户端的请求，之后建立客户端和服务器的连接 3、发送和接受数据
4、关闭套接字 三十四、什么是指针的释放?
1、其实是释放指针指向的内存空间，指针是一个变量，程序结束时才会销毁， 并且只有堆上的内存才需要我们手动管理
2、将该指针初始化为 NULL 三十五、指针和地址的区别?
1、指针意味着已经有一个指针变量存在 ,他的值是一个地址 ,指针变量本身也存放 在一个长度为 8 个字节的地址当中 ,而地址概念本身并不代表有任何变量存在 .
2 、指针的值 ,如果没有限制 ,通常是可以变化的 ,也可以指向另外一个地址 . 地址表 示内存空间的一个位置点 ,他是用来赋给指针的 ,地址本身是没有大小概念 ,指针
指向变量的大小 ,取决于地址后面存放的变量类型 .
三十六、 Internet 采用哪种网络协议?该协议的主要层次结构?
1、 TCP/IP
2、应用层 / 传输层 / 网络互联层 / 网络接口层
三十七、局部变量能否和全局变量重名?
1、能，局部会屏蔽全局。要用全局变量，需要使用 "::" 局部变量可以与全局变量同名， 在函数内引用这个变量时， 会用到同名的局部变 量，而

不会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多个同名的 局部变
量，比如在两个循环体内都定义一个同名的局部变量， 就在那
个循环体内
三十八、语句 for( ; 1 ; ) 有什么问题?它是什么意思?
1、死循环，和
三十九、 do,, 1、前一个循环一遍再判断，后一个判断以后再循环、 四十、针对 APP显示 webView 时的内存问题应该如果优化?
1、后端程序员做优化 2、专门针对手机做页面，需要精简内容
3、优化框架，有些后端的框架非常消耗内存，需要精简框架 4、优化网络统计 js
5、针对手机提供定制的图片
四十一、谈谈运行时 Runtime 机制，适用范围是什么，并写出相关的头文件和 方法名?
1、runtime 是一套 C 语言比较底层的 API，属于一个 C 语言库， 平时编写的 OC 代码在程序运行过程中都转成了 runtime 的 C 语言代码
2、适用范围: A 、动态获取类的属性，常见于字典转模型的框架 B、利用关联对象为分类动态添加属性
C、利用交换方法拦截系统或框架的方法
D、动态给某个类添加属性和方法
3、相关应用: A、NSCoding(归档和解档，利用 runtime 遍历模型对象的所有
属性)
B、字典转模型 ( 利用 runtime 遍历模型对象的所有属性，根号属性 名从字典中取出对应的值，设置到模型属性上 )
C、KVO(利用 runtime 动态产生一个类 )
D、用于封装框架
4、头文件: #import <objc/runtime.h> #import<objc/message.h> 5、方法名:获取类的属性 :class_copyPropertyList()
关联对象: objc_getAssociatedObject() 和 objc_setAssociatedObject() 交换方法: class_getInstanceMethod()
四十二、简述 KVO 的底层实现原理?
1、KVO(Key Value Observing)是观察者模式在 Foundation 中的实现，是基
while(1) 一样 ,最简单的死循环
while 和 while ,, do 有什么区别?
而那个局部变量的作用域

于 runtime 实现的
2、原理:以 Person *p = [[Person alloc]init] 为例 ;
a、当给对象 p 添加了观察者时，会动态创建这个 Person 类的子类 ( NSKVONotifying_Person)
b 、对被观察对象 p 的属性重写其 set 方法
c、在重写的 set 方法中调用 willChangeValueForKey 和 didChangeValueForKey 方法通知观察者进行观察
d、当属性没有观察者时就会删除重写的 set 方法，当没有观察者观察任何 一个属性时，就会动态删除这个类的子类
四十三、写一个标准的宏定义求三个数最小值和最大值? 1、最小值: #define Min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c))
2、最大值: #define Max(a,b,c) (a>b?(a>c?a:c):(b>c?b:c)) 四十四、 KVC的底层实现 :setValuesForKeysWithDictionary:
1、逐个取出字典当中的 key,判断调用对象有没有 set 方法 ,如果有 ,直接赋值 ; 2、若没有，去对象中查找 ,有没有带下划线的成员属性 _key,如果有就直接赋值 ; 3 、若没有，去对象中查找 ,有没有不带下划线的成员属性 key,如果有就直接赋
值;
4、若没有，表示没有找到对象里面的属性 ,就会直接报错 .
所以 ,我们在利用 KVC 的时候 ,要保证对象里面的属性和 Key 要一一对应 ; 四十五、这个写法会出什么问题: @property (atomic ， copy) NSMutableArray
*array
1、添加 ,删除 ,修改数组内的元素的时候 ,程序会因为找不到对应的方法而崩溃 .因
为 copy 就是复制一个不可变 NSArray 的对象
2、atomic 应写成 nonatominc ，因为他会影响性能，该属性使用了同步锁，会在 创建时生成一些额外的代码用于帮助编写多线程程序， 这会带来性能问题， 通过 声明 nonatomic 可以节省这些虽然很小但是不必要额外开销，因此，开发 iOS 程序时一般都会使用 nonatomic 属性
四十六、 @property 的本质是什么? 1、@property = ivar + getter + setter;
“属性” (property) 有两大概念: ivar(实例变量 / 成员变量)、存取方法(access method = getter + setter )
四十七、交换两个数值的方法?
例如: int a = 6 b = 8 1、中间 变量 int temp;
temp = a; a = b;

b = temp;
2、加减法 a = a + b; b = a - b ; a = a - b;
3、按位异或 a = a ^ b; b = a ^ b; a = a ^ b;
四十八、MRC 和 ARC混合开发， 项目开发中遇到 MRC 开发的第三方库怎么办? 例如: ASI
1、首先尝试使用 Xcode的转换工具(但失败率比较高) Edit --> Convert --> To Objective-C ARC
2、在编译选项中，为 MRC 的程序添加 -fno-objc-arc 标记，表明在编译时，该文 件使用 MRC编译，如果要在 MRC 项目中添加 ARC的文件，可以使用 -fobjc-arc 标记
3、将 MRC的第三方库直接编译成静态库使用， 需要注意的是:在编译静态库时， 不能添加动态库引用， 在项目中，如果使用的静态库中包含分类， 则需要在 Other Link Flag 中添加 -ObjC 选项


五十、 Swift 和 OC的区别?
1、Swift 没有地址和指针的概念
2、Swift 对数据类型要求极为严谨 3、泛型，泛型代码能写出更加灵活清晰、可重复使用的函数
五十一、如何实现 OC 和 Javascript 交互?
1、ios 应用一般通过 UIWebView 实现 OC与 Javascript 的交互，具体如下 2、OC 调用 JS:在 UIWebView 的代理方法 webViewDidFinishLoad 中利用 WebView 唯一与 JS交互的方法
- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 3、JS调用 OC:利用 html 的重定向技术，使用下面方法截取重定向
-(BOOL)webView:(UIWebView *)webView
shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
五十二、 HTTP 和 Socket 通信之间的区别?
1、A > HTTP(超文本传输协议 )是建立在 TCP协议上的应用，简单、规模 小、通信速度快，用于定义网络数据传输的格式
B >最显著特点是客户端每次请求都需要服务器的响应，响应完成会主动 释放连接，节约传输时间
C >完整的 HTTP 通信必须包含请求 (请求头、请求行、请求体 ) 和响应 (状 态行、响应头、实体内容 )
2、A > Socket 是纯 C语言的，客户端与服务器使用 socket 套接字进行连接， 它是一种用于传输网络数据的工具

B > Scoket 是对 TCP/IP 协议的封装和应用 ,简单说，TCP/IP 协议是传输层 协议，主要解决数据如何在网络上传输， HTTP 是应用层协议，主要负责解决如
何包装数据
C > Socket 连接过程:建立连接、客户端请求数据、服务器回应数据、 结束连接
D > Socket 有长短连接和心跳包的概念 ( 短连接是数据请求结束立刻 断开;长连接是一旦建立连接始终保持; 心跳包是检测长连接的手段客户端和服 务器都可以发送 )
五十三、 TCP与 UDP 的区别?
1、概念:TCP(传输控制协议 )是基于连接的协议， 正式收发数据前必须建立可靠
的连接
UDF(用户数据报协议 )是基于非连接的协议，只管发送，不与对方建立 连接
2、数据传输大小: UDP 每个数据报大小在 64k 之内
TCP传输数据大小不受限， 所以对系统资源的要求要高于 UDP
3、可靠性: UDP无需建立连接故而不可靠，易丢包 TCP 需要三次握手才能建立连接，可靠
4、传输效率: UDP > TCP，因为 TCP多了建立连接的步骤 五十四、 SAX解析与 DOM 解析的区别?
1、SAX: 是只读的方式，从上向下的方式解析;是苹果提供的解析方式; 速度快;适合对大型的 XML 的解析;用 5 个代理方法解析
2、DOM:是在 MAC 使用的解析方式， 可读可写， 内存消耗极大， 解析速度慢， ios 默认不支持
五十五、多线程有什么优点和缺点?
1、优点:使应用程序响应速度更快，用户界面在进行其他工作时仍始终保持活 动状态，提高程序执行效率
  优化任务的执行，适当提高资源利用率
2、缺点:线程占用内存空间，管理内存需要额外的 cpu 开销，开启大量线程降 低程序的性能
    增加程序复杂程度，如线程间通信，多线程的资源共享
五十六、 GCD和 NSOperation 的区别?
1、相对于 GCD:
A> NSOperation 有更多的函数可用
B> NSOperationQueue 中可以跨对列设置操作的依赖关系

C>可使用 KVO监听操作是否执行结束或取消
D>可以设置最大操作并发数 2、相当于 NSOperation:
A> GCD是 C 语言的 API，ios4.0 推出在性能上做了优化， 而且对 NSOperation 底层全部重写
B> GCD充分利用多核处理器并发处理任务，效率高
C> GCD不用程序员管理线程开闭，完全由系统管理，比较轻量级
D>高级功能:调度组、延时操作 after、和一次性 (单例) 五十七、 ios 多线程技术 (实现方案 )及特点?
1、pthread 是一套通用的多线程 API，适用于多个系统，跨平台可移植使用难度 大，底层是 C语言，线程生命周期由程序员管理，几乎不用
2、NSThread 更加面向对象，简单易用，可直接操作线程对象， OC语言，线程 生命周期也由程序员管理，偶尔使用
3、GCD是替代 NSThread 的线程技术，底层也是 C 语言，线程的生命周期由系 统管理，经常使用
4、NSOperation 基于 GCD，比 GCD多了些实用的功能，更加面向对象， OC编 写，线程生命周期也是系统管理，经常使用


六十二、应用的状态和生命周期?
1、状态:
A、Not running 未运行:程序未启动
B、Inactive 程序正在前台运行不过没有接收到事件 C、Active 程序在前台运行而且在接收事件 D、Backgroound 程序在后台运行执行代码 E、Suspended 程序在后台运行但不执行代码 注意:状态发生转换时会调用代理对象对应的方法相应 就是常用的代理方法
App 状态的改变，上面
2、生命周期:
A、application:willFinishLaunchingWithOptions: - 将要完成启动(此时会告诉 代理进程启动但还没进入状态保存)
B、application:didFinishLaunchingWithOptions: - 启动完成 (告诉代理启动完成 准备开始运行，该方法允许显示 app 给用户前执行最后的初始化操作 )
C、applicationWillResignActive: - app 将要从前台切换到后台时需要执行的操作 ( 如来电话了，此时程序不接收消息和事件 )
D、applicationDidBecomeActive: - app 从后台再切回至前台时调用

E、applicationDidEnterBackground: - app 已经进入后台后需要执行的操作 F、applicationWillEnterForeground: - app 将要从后台切换到前台需要执行的操
作，但 app 还不是 active 状态
G、applicationWillTerminate: - app 将要退出时需要执行的操作 (通常可以做一些
保存数据清理缓存的工作 )
注意: APP 在不同状态下 3、4、5、6 的执行顺序并不固定!
六十三、开发中哪些地方用到过多线程?
1、预先加载图像，用到 dispatch_group_enter ，利用通知统一监听
2、SQLite 的异步操作，使用串行队列顺序调度任务，保证数据的完整性 3、图像压缩，异步压缩，完成之后回调
六十四、 load 和 initialize 的异同? 1、相同点:方法只会被调用一次 ( 开发者不主动调用的前提下 )
2、不同点: A: load 是只要类所在文件被引用 (import) 的时候就会被调用 initialize 是在当前类第一次被执行到的时候会被调用
B:若自身未定义 initialize 会沿用父类的方法， load 不会沿用 六十五、block 属性为什么用 copy?使用时应注意什么?使用场景?原理是什么?
有什么优点?
1、A:使用 copy 可以将 block 从栈区复制到堆区，因为栈区由系统管理，存在 栈区随时可能被回收，或是出作用域即被回收!
B:block 用于保存代码，调用时才执行，但有时调用 block 时， block 中用到的其他对象可能已经被释放，使用 copy 可以保证调用 block 是外界对象
依然存在
2、注意:循环引用， block 中用到 self 可以用 __weak修饰防止循环引用 3、应用场景:动画、数组字典排序遍历、网络访问时错误回调、 GCD
4、原理:本质是指向结构体的指针，编译器会将 5、优点:代码思路更加清晰，易于阅读和维护
六十六、开发中最容易引起循环引用的场景?
1、声明代理属性要使用 weak
2、block 代码块中的 self 要换成 weakSelf
weakSelf = self)
3、NSTimer 定时器 self.timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(nextPage) userInfo:nil repeats:YES];// 类 持 有 timer ， timer 又持有 self( 即: target : self) ，所以每次需要将 timer 设置为无效 invalidate 并设置为 nil
block 内部代码生成对应函数
( __weak typeof(self)

六十九、用 @property 声明的 NSString 属性通常使用 copy 修饰，为什么?如果 换成 strong 会有什么影响?
1、因为父类指针可以指向子类对象 ,使用 copy 可以让对象的属性不受外界影响 , 使用 copy 后无论给属性传入是一个可变对象还是不可对象 ,属性本身持有的就是 一个不可变的副本 .
2、如果使用是 strong, 那么这个属性就有可能指向一个可变对象 ,如果这个可变对 象在外部被修改了 ,那么会影响该属性 .
注意:


1、类方法: A:类方法是属于类对象的 B;类方法只能通过类对象调用 C:类方法中的 self 是类对象 D:类方法可以调用其他的类方法 E:类方法不能直接访问成员变量 F:类方法中不能直接调用对象方法
2、对象方法:
A:对象方法属于实例对象 B;对象方法只能通过实例对象调用 C:对象方法中的 self 是实例对象 D:对象方法中可以访问成员变量 E:对象方法中可直接调用其他对象方法 F:对象方法中也可以调用类方法 ( 通过类 )
七十三、 OC中有哪几种遍历的方法?哪个效率比较高? 1、普通 for 循环
2、for 循环增强 for-in
3、block 代码块 enumrateObjectsUsingBlock
4、枚举器: NSEnumerator
效率: for -in 效率最高 2s 左右，其余都在 2.6~3.0s 之间
七十四、 runtime 如何实现将 weak 修饰的对象自动设置为 nil ? 1、runtime 对注册的类，会进行布局， 对于 weak 对象会放入一个
用 weak 指向的对象内存地址作为 key ，当此对象的引用计数为
dealloc，假如 weak 指向的对象内存地址是 a，那么就会以 a 为键，在这个 weak
表中搜索，找到所有以 a 为键的 weak 对象，并设置为 nil
七十九、 addObserver:forKeyPath:options:context: 各个参数的作用分别是什么， observer 中需要实现哪个方法才能获得 KVO回调?
1、添加观察者方法的参数:观察者、观察的属性、观察的选项、上下文 2、回调方法的参数:观察的属性、观察的对象、 change 属性变化的字典、上下 文(与添加时一致 )
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
八十、 IB 中 User Defined Runtime Attributes 如何使用?
1、它能够通过 KVC 的方式配置一些你在 interface builder 中不能配置的属性。 当你希望在 IB 中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的
viewcontroller ，只要响应的 attribute type 代表相同的数据类型，那么他们就可 以相互替换使用
八十一、 lldb 常用调试指令?
1、b:查看当前所有断点 c:继续 r:重新运行 n:下一

步 p :打印 s:单步 po :打印对象 八十二、如何调试 BAD_ACCESS错误?
1、重写 object 的 respondsToSelector 方法，现实出现 EXEC_BAD_ACCES前S访 问的最后一个 object
2、通过开启 Edit Scheme 中的 Zombie 3、设置全局断点定位
4、Xcode 7 已经集成了 BAD_ACCESS捕获功能: Address Sanitizer 在配置中勾 选?Enable Address Sanitizer
八十三、风格纠错题! !
八十四、 initWithCoder 、 awakeFromNib 、 initWithNibName 、 initWithFrame ?
1、 initWithCoder :当一个类在 IB 中创建，但在 Xcode 中被实例化的时候被调 用的，也可以说当从 nib 文件中加载对象的时候调用。如:通过 IB 拖一个控制 器，然后在 Xcode 中通过 initWithNibName 来实例化这个控制器的时候，这个 控制器的 initWithCoder 就会被调用
2、awakeFromNib :当 nib 文件被加载的时候，会向 nib 文件中的每个对象发送 一个 awakeFromNib 消息，每个对象都可以定义自己的 awakeFromNib 函数来相 应这个消息，总之:通过 nib 文件创建 view 对象时会调用 awakeFromNib 3、initWithNibName :当一个控制器或某个控件在 IB 中创建，在 Xcode 中需要 调用这个方法来实例化它们，此时调用该方法
4、initWithFrame :当我们使用代码创建视图内容，不使用 Nib 文件时，需要调 用 initWithFrame 去初始化对象
补充:1、xib 和 nib 都是 Interface Builder 的图形界面设计文档， xib 是一个 XML 格式的纯文本文件， nib 是一个二进制文件，目前 Xcode 默认使用 xib 格式的文 档
补充: 2、IB，即 Interface Biulder ，是 Mac OS X 系统下用与设计和测试用 户界面的应用程序
八十五、 Notification 是同步还是异步?和代理相比有什么效率上有什么区别? 1、通知的注册和发送都通过通知中心完成的，通知中心的消息转发是同步执行
的
2、通知可以一对多、多对多，代理是一对一的关系 效率上:如果不需要返回值，视图层次嵌套比较深的时候建议使用通知
    代理常用在视图和控制器之间，当视图视图不能实现某种功能是可以让

控制器做代理，辅助实现!
八十六、 ViewController 中的 didReceiveMemoryWaring 是在什么时候调用?默 认的操作是什么?
1、当程序接收到内存警告时会调用该方法
2、会将控制器的 view 释放掉，并调用 viewDidUnLoad 方法

八十八、对于 NSString *obj = [[NSData alloc] init];, 编译时和运行时 obj 分 别是什么类型?
1、编译时是 NSString 类型 2、运行时是 NSData 类型
八十九、常见的 OC数据类型有哪些?和 C 的基本数据类型有什么区别? 1、OC常用数据类型: NSString、NSSArray、NSDictionary 、NSData、NSNumber
等
2、区别: OC 对象需要手动管理内存， C 语言的基本数据类型不需要管理内存
九十、简要说明消息推送? 1、通俗的讲:应用程序在没有运行的状态下也可以接收到消息
2、本地推送:程序内部弹出，即本应用负责执行推送的操作 3、远程推送:由服务器的程序发送推送通知 APNS，再由 APNS把消息推送给设
备上的程序
九十一、 TableView 为什么使用的重用机制?简述过程?
1、原因:对于一个 TableView 可能需要显示大量的 cell，如果每个 cell 都需要 单独创建会消耗很大的内存，为
了避免这种情况，所以引入了重用机制
2、过程:在创建 cell 的时候绑定一个可重用的标示符，当 cell 离开界面时会添

加重用队列中，要显示新的 cell 的时候直接去重用队列中取，不用再单独创建，提高效率，节约内存消
耗 九十二、为什么使用第三方框架?
1、第三方框架把复杂的底层操作，封装成了友好的类和方法，并且加入了异常 处理
2、优点:大大提升开发效率，节约开发时间 九十三、简述 NSURLSession?
1、ios7 之后推出，为了方便程序员使用，苹果提供了一个全局 代 NSURLConection
session，用于替
2、支持后台运行的网络任务，网络任务可以实现暂停、停止、重启
3、使用 URLSession后， NSURLRequest通常只用于指定 HTTP 请求方法，而其 他的额外信息都可以通过 NSURLSessionConfiguration 设置 4、默认所有任务都是挂起的状态，需要手动 resume 5、支持三种类型任务:加载数据、下载和上传
九十四、 ios 应用中地图是如何实现定位的?
1、ios 中通过 Core Location 框架进行定位操作，和地图开发框架 MapKit 完
全独立，二者可配合使用
2、Core Location 中包含定位、地理编码等功能
九十五、 obj-c 有多重继承吗?没有的话有什么代替?
1、Object-c 只支持单继承，如果要实现多继承可以通过类别和协议的方式实现
九十六、简单介绍下真机上调试时开发证书的申请流程? 1、先在本地生成获取证书的文件
2、请求证书，填写必要的信息，保存路径和生成文件的名称 3、到苹果官网的开发者界面，添加证书，然后把申请完成的
4、申请 AppID，填写信息
5、绑定 iphone 设备，填写设备信息
CSR文件下载下来
6、配置文件信息
7、绑定之前的 AppID 、调试证书、和设备信息，把申请的配置文件下载到本地 8、修改 Xcode 信息 Bundle Identifier
九十七、真机调试的主要步骤?

1、登录开发者主页
2、生成 cer 证书:cer 是一个跟电脑相关的证书文件， 能
3、添加 AppID :调试哪些 app 4、注册真机设备:那台设备需要做真机测试
5、生成 MobileProvision 文件
6、导入 cer、MobileProvision 文件
让电脑具备真机调试的功
九十八、什么是 XMPP?工作原理是什么?
1、XMPP 是基于 XML 通讯的协议，基于 TCP 发送 XML 数据，一般用于即时通
讯(QQ/微信)
2、原理: A 、节点连接到服务器 B、服务器利用本地目录系统中的证书对其认证 C、节点指定目标地址，让服务器告知目标状态 D、服务器查找、连接并进行相互认证 E、节点之间进行交互
九十九、 http 中的 POST请求和 GET请求的区别和联系?如何选择? 1、GET 是从服务器获取数据， POST是向服务器发送数据
2、GET请求能够被缓存， POST请求不能被缓存 3、GET 请求对数据大小有限制， POST没有大小限制
4、使用 GET请求，参数会显示出来，而 POST则不会， POST更安全一些 5、GET 的效率要高于 POST，因为 POST多了一步解析二进制参数的过程 如何选择: 如果数据是中文数据而且是非敏感数据应该使用 GET，如果数据中包 含用户的隐私信息 (账户、密码
等)尽量使用 POST
一零零、 iOS的远程消息推送 (Push)是怎么实现的?
1、[Client App] 注册消息推送 ( 通过设备唯一标示 UDID 和应用的唯一标示 Bundle ID) ;
2、[Client App] 跟[APNS Service]要 deviceToken, Client App 接收 deviceToken; 3、[Client App] 将 deviceToken 发送给 [Provider]Push 服务端程序;
4、当 Push 服务端程序满足发送消息条件时， [Provider] 将 deviceToken 和消息 体等打包向 [APNS Service]发送消息;
5、[APNS Service]会利用 deviceToken 找到对应的 [Client App] 并将消息体传达 . 一零一、逻辑运算和位运算的区别?

1、位运算针对的是二进制数据，逻辑运算用于判断条件


2、选择排序原理:选择一个值 array[0] 作为标杆，然后循环找到除这个值外最 小的值(查找小于标杆的最小值) ，交换这两个值，这时最小值就被放到了 array[0] 上，然后再将 array[1] 作为标杆，从剩下未排序的值中找到最小值，并交换这两 个值
核心代码: for (int i=0; i<len-1; i++) { for (int j=i+1; j<len; j++) {
if(arr[i]>arr[j]){ int temp;
temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;
} }
}

1、 NSKeyedArchiver 采用归档的形式存储 ( 常用于 NSString, NSDictionary,
NSArray, NSData, NSNumber等类型 ) ，需遵守 NSCoding 协议 归档对象时:会调用 encodeWithCoder，一般在这个方法里面指定如何归档对象 中的每个实例变量 .可以使用 :encodeObject:forkey: 方法归档实例变量 解档对象时:会调用 initWithCoder ，一般在这个方法里面指定如何解码文件中 的数据为对象的实例变量 ,可以使用 decodeObject:forkey 方法解码实例变量

2、NSUserDefaults 偏好设置存储，常见保存用户名和密码，一般需要调用 synchronize 方法强制写入
存入:
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:@"JN521" forKey:@"username"];
[defaults setFloat:18.0f forKey:@"text_size"]; [defaults setBool:YES forKey:@"auto_login"];
读取:
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSString *username = [defaults stringForKey:@"username"];
float textSize = [defaults floatForKey:@"text_size"];
BOOL autoLogin = [defaults boolForKey:@"auto_login"];
3、write 写入的形式永久保存到磁盘
NSArray *docPath =
[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask, YES) objectAtIndex:0]; NSString
stringByAppendingPathComponent:fileName] [data writeToFile:FileName atomically:YES];
// 获取文件即将保存的路径 *FileName=[documentDirectory
// 生成该路径下得文件 // 写入
4、属性列表 (plist 存储 )属性列表是一种 XML 格式的文件 ,拓展名为 plist 如果 对象是 NSString, NSDictionary, NSArray, NSData, NSNumber 等类型,就可以使 用:writeToFile:atomiclly: 方法直接将对象写到属性列表文件中 .
存入:
// 将数据封装成字典
NSMutableDictionary *dict = [NSMutableDictionary dictionary];
[dict setObject:@"15013141314" forKey:@"phone"];
[dict setObject:@"27" forKey:@"age"];
// 将字典持久化到 Documents/stu.plist 文件中
[dict writeToFile:path atomically:YES];
读取:
// 读取 Documents/stu.plist 的内容，实例化 NSDictionary NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path]; NSLog(@"phone:%@", [dict objectForKey:@"phone"]); NSLog(@"age:%@", [dict objectForKey:@"age"]);
5、数据库存储 SQLite
概念: SQLite 是一个进程内的库，本质上就是一个文件，是一个 SQL 数据
库引擎
特点:自给自足不需要外部依赖、无需单独服务器、零配置、轻量级、占用 资源少、处理速度快

使用步骤:添加动态库 (libsqlite3.dylib) 、导头文件 sqlite3 、建立数据库、创 建数据表、利用 SQL 命令增删改查
  优点:将网络数据存到本地不用每次都加载，减少网络流量开销，可对本地
数据进行系统性查询
SQLite 命令: INSERT增/UPDATE 改/DELETE 删/SELECT 查
一零四、线程间如何通信?
1、线程间通信:在一个进程中往往不止一条线程，那么多个线程之间就需要协 调工作，此时就需要线程间通信
2、体现:线程间传递数据、一个线程执行完任务转到另一个线程继续执行 3、常用方法:
主 线 程 执 行 操 作 ， 刷 新 UI : - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitU
ntilDone:(BOOL)wait;
指定线程执行:
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(i d)arg waitUntilDone:(BOOL)wait;
后 台 线 程 执 行 耗 时 的 下 载 操 作 : [self performSelectorInBackground:@selector(downloadImage) withObject:nil];
一零四、线程间如何通信?
1、线程间通信:在一个进程中往往不止一条线程，那么多个线程之间就需要协 调工作，此时就需要线程间通信 2、体现:线程间传递数据、一个线程执行完任务转到另一个线程继续执行 3、常用方法:
主 线 程 执 行 操 作 ， 刷 新 UI : - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitU
ntilDone:(BOOL)wait;
指定线程执行:
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(i d)arg waitUntilDone:(BOOL)wait;
后 台 线 程 执 行 耗 时 的 下 载 操 作 : [self performSelectorInBackground:@selector(downloadImage) withObject:nil];
一零五、谈谈多线程安全的几种解决办法?
1、主线程负责刷新 UI
2、防止资源抢夺的情况，要进行加锁保护
3、如果异步操作要保证线程安全， 尽量使用 GCD，因为 GCD 有些默认的接口就

是安全的
一零六、 GCD底层是如何实现的?
1、iOS 和 OS X 的核心是 XNU 内核， GCD是基于 XNU 内核实现的
2、GCD的 API 全部在 libdispatch 库中
3、GCD的底层实现主要有 Dispatch Queue 和 Dispatch Source，前者管理操 作(block) ，后者处理事件
一零七、 block 在 ARC中和 MRC中的用法有什么区别 ,需要注意什么? 1、MRC中 block 默认在栈区， ARC中的 block 会被复制到堆区
2、对于没有引用外部变量的 Block ，无论在 ARC 还是 MRC 下，类型都是 __NSGlobalBlock_，_这种类型的block可以理解成一种全局的block，不需要考 虑作用域问题。同时，对他进行 Copy 或者 Retain 操作也是无效的
3、需要注意:循环引用
一零八、 Foundation 对象和 Core Foundation 对象有什么区别?
1、前者针对 OC对象，后者针对的是 C 语言对象 (结构体 )
2、ARC 机制下，只管理 OC 的对象，不能管理 CF 对象，需要手动 (CFRetain/CFRealease) 管 理 ， 所 以 需 要 使 用 到 __bridge,__bridge_retained 和 __bridge_transfer 三个转换关键字
3、__bridge_retained 后面跟 CF对象，会转让所有权， 将 OC对象转成 CF对象， 后续需要调用 CFRealease或相关方法释放对象;
__bridge_transfer 后面跟 OC 对象，也会转让所有权 ,将 CF 对象转成 OC 对象 ,转换后自动调用 CFRealease
一零九、简述客户端的缓存机制? 1、缓存可分为:内存数据缓存、数据库缓存、文件缓存
2、步骤: A:每次想获取数据时，先检查内存是否有缓存 B:再检查本地是否有缓存 ( 数据库、沙盒 )
C:最终发送网络请求去网络加载 D:将服务器返回的网络数据进行缓存以便再次使用
一一零、怎么解决缓存池满的问题 (cell) ?
1、一般情况下， ios 中不存在缓存池满的情况
2、因为通常我们 ios 中开发，对象都是在需要的时候才会创建，有种常用的说

话叫做懒加载，还有在 UITableView 中一般只会创建刚开始出现在屏幕中的 cell， 之后都是从缓存池里取， 不会在创建新对象。 缓存池里最多也就一两个对象， 缓
存池满的这种情况一般在开发 java 中比较常见， java 中一般把最近最少使用的 对象先释放。
一一一、 iOS7之前，后台执行内容有几种形式，都是什么?
1、一般的应用在进入后台的时候可以获取一定的时间来运行相关任务，也就是 说可以在后台运行一小段时间 (10s 左右 )
2、后台播放音乐、后台 GPS跟踪、后台 voip 支持
一一二、简单说明 App 的启动过程?
1、第一种情况:有 storyboard
A:程序入口 main 函数
B: UIApplicationMain ;创建 UIApplication 对象，创建 UIApplication 的
delegate 对象
C:根据 info.plist 加载 Main storyboard file base name 所执行的 storyboard D:创建 UIWindow ，创建和设置 UIWindow 的根控制器 rootViewController ，
显示窗口
2、第二种情况:没有 storyboard
A:程序入口 main 函数
B: UIApplicationMain ;创建 UIApplication 对象，创建 UIApplication 的
delegate 对象
C:delegate 对象开始监听系统事件，程序启动完毕时调用代理的
application:didFinishLaunchingWithOptions: 方法，在该方法中创建窗口，设置 根控制器，显示窗口
一一三、有些图片加载的比较慢如何处理?
1、图片下载要放下异步线程执行 2、图片下载过程中使用占位图片 3、如果图片较大，可以考虑使用断点下载
一一四、 你实现过一个框架或者库以供别人使用么?如果有， 或者库时候的经验;如果没有，请设想和设计框架的 public 的 API，并指出大概 需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架?
1、提供给外界的接口功能是否充足够用 2、别人使用我的框架时能够根据类名方法名猜出大概能实现的功能
3、别人调用框架的接口时提供的参数是否够用，调用起来是否简单 4、当使用我的框架时要不要依赖其他的框架
请谈一谈构建框架

一一五、App 需要加载大量的数据， 给服务器发送请求时， 服务器卡住了怎么解 决?
1、设置请求超时 2、提示用户请求超时 3、根据用户操作再次请求数据
一一六、 AFN 和 ASI 有什么区别?
1、底层实现: AFN 的底层基于 OC的 NSURLConection 和 NSURLSession
ASI 的底层基于纯 C 语言的 CFNetwork 框架， ASI 的性能高于 2、对服务器返回数据的处理: AFN 提供多种处理方式 JSON/XML 等
ASI 没有提供处理方式，直接返回二进制数据 3、处理请求的方式: AFN 采用 block 的方式，监听请求成功或失败
AFN
ASI最初采用的是代理的方式进行处理， 后面也相应增加了 block 4、功能: AFN 只封装一个一些常用功能，满足基本需求
ASI 提供的功能较多，如控制菊花在请求过程中的转动、设置请求间的 依赖、统一管理所有请求等;还预留了很多接口供开发者自行扩展 5、文件下载和上传的使用难易度: AFN 不太容易监听下载和上传进度，不容易 实现断点续传，一般只用来下载较小的文件
ASI 在这些方法都比较容易的实现
6、注意: ASI 几年前已经停止更新，所以现在使用 AFN 的还是占大多数
一一七、网络数据处理过程中，发现某部分比较卡，一般怎么解决?
1、检查网络请求操作是否被放在主线程了 2、检查异步请求的数量是不是太多 (子线程数量 )
3、查看是不是因为数据量过大造成的卡顿，如果是可以先清理一些不必要的对 象 (看不见的数据、图片 )
4、查看手机 cpu 的使用率和内存使用 一一八、怎么解决 sqlite 锁定的问题?
1、设置数据库锁定的处理函数 int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
2、设定锁定时的等待时间 int sqlite3_busy_timeout(sqlite3*, 60);
一九、简单介绍 isa 指针?
1、在 OC中任何类的定义都是对象，类和类的对象没有本质的区别，任何对象
都有 isa 指针
2、 isa 就是一个 Class 类型的指针。每个实例对象都有一个 isa 的指针，并指向
的方式

该对象所属的类
一二零、 OC有私有方法吗?私有变量呢?
1、 OC 是一种动态消息传递机制，所有本质上不存在真正意义上的私有方法 2、但是，如果方法只在 .m 中实现而不在 .h 中进行声明， 或者说在 .m 文件的 Class Extension 中声明，可以算作是私有方法
3、私有变量可以通过 @private 修饰实现私有
一二一、如何提升 ios 程序的性能? 1、使用 ARC去管理内存
2、适当的地方使用重用机制 reuseIndentifier 3、避免使用臃肿的 xib
4、使用延时加载 5、选择合适的数据存储方式，不合理的存储方式也是耗性能的 6、对于内存警告要及时处理
7、使用自动释放池
8、缓存，缓存，缓存，如图片、 UITableView 的行高 9、不要在主线程做一些耗时繁重的操作 10、选择正确的数据格式，常用 JSON和 XML
一二二、 用预处理指令 #define 声明一个常数， 用来表示一年有多少秒 ( 忽略闰年 问题 )?
1、#define SECONDS_PER_YEAR (60 * 60 * 24 * 365) UL 2、注意不能以分号结尾， # 和 define 中间不能有任何东西， UL 表示无符号长整
型
附:预处理主要内容:宏定义 (#define) 、条件编译 (#ifdef/#else/#endif) 、文件 包含 (#incldue)
一二三、写一段程序将字符串 "I Love .Chinese"反转成 "Chinese Love I"? 1、先用 componentsSeparatedByString :方法通过 . 将字符串分成 I Love
和 Chinese 保存到数组 array1 中
2、在用该方法利用空格将 I 和 Love 分割保存到数组 array2 中
3、最后拼接字符串 array1[1] + array2[1] + array2[0]
附:字符串常用函数: -(NSString *)substringFromIndex: (NSUInteger)from; 含义: 从指定位置 from 开始到尾部 ( 包括指定位置的字符 )
-(NSString *)substringToIndex: (NSUInteger)to; 含义:从字符串 开始截取，截取到指定的位置 to( 不包含指定位置的字符 )

-(NSString *)substringWithRange: (NSRange)range; 含义:按照所 给出的范围从字符中截取 ,且包含指定位置的字符
-(NSString *)stringByReplacingOccurrentsOfString:(NSString *)target withString:(NSString*)replacement;
对应的字符
含义:用 replacement 代替 target -(unichar)characterAtIndex:(NSUInteger)index; 返回 index 位置
-(BOOL) hasPrefix:(NSString *)aString; 检查字符串是否以某个
字符串开头， Suffix 结尾
一二四、简要说明 const 关键字?
1、概念:const 是一个类型修饰符，使用 const 修饰的变量可以让变量的值不能
被修改，也可以修饰函数的参数和返回值
2 、作用: A:使变量不可变，保护被修饰的东西，防止意外修改，增强健壮 性
B:便于进行类型检查 C:节约内存空间，避免不必要的内存分配
3、使用技巧:修饰常指针时:先看“ * ”的位置
A:如果 const 在 *的左侧表示值不能修改 ,但是指向可以改。
B:如果 const 在 *的右侧表示指向不能改 ,但是值可以改 C:如果在“ *”的两侧都有 const 标识指向和值都不能改。
一二五、简单介绍下 cocoa touch 框架?
1、Cocoa Touch 是苹果公司提供的软件开发 api( 类库)，用于开发 iPhone、iPad
等设备
2、Cocoa Touch 由多个框架组成:
UIKit 框架负责启动和结束应用程序，控制界面和多触点事件 Core Animation 提供强大的动画效果
Core Audio 提供播放处理和录制音频等技术
Core Data 提供数据管理的解决方案
其他的如 MapKit( 地图)、Address Book( 电子邮件、联系人 )使用也很广泛
一二六、写一个 NSString 类的实现?
1 、 + (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id) stringWithCString: (const char*)nullTerminatedCString
encoding: (NSStringEncoding)encoding {
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];

obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return AUTORELEASE(obj);
}



10.代理一般是什么时候用呢 ?
答 :自身不做实际的事 ,要求其它类做。 代理也可用来传值。 代理的目的是改变或传递 控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。 可以减 少框架复杂度。另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
11.有关 copy 和 retain 的区别
答: retain 是指针拷贝 ,copy 是内容拷贝
12. Object C 中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果 想延时执行代码、方法又是什么?
线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是
performSelectorOnMainThread ，如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone:


17.谈谈 KVO and KVC? 答案:
后者可以添加属性。
Category 。
kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用 存取方法，直接或通过实例变量访问的机制。很多情况下可以简化程序代码。 apple 文档其

实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。具体用看 到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。

21.自动释放池跟 GC(垃圾回收)有什么区别? iPhone 上有 GC 么?[ pool release]和 [pool drain ]有什么区别?
iPhone 上没有 GC。 iPhone 开发的时候没有垃圾回收机制。
在垃圾回收环境中， release 是一个空操作。 因此， NSAutoreleasePool 提供了 drain 方法， 在引用计数环境中， 该方法的作用等同于调用 release，但在垃圾回收环境中， 它会触发垃圾 回收(如果自上次垃圾回收以来分配的内存大于当前的阈值) 。因此，在通常情况下，您应 该使用 drain 而不是 release 来销毁自动释放池。


其他类型小谈面试题:
1.讲讲 OC 和其他语言好在哪里
objc 优点 :
1)Cateogies
,不好在哪里
2) Posing
3) 动态识别
4) 指标计算
5)弹性讯息传递
6) 不是一个过度复杂的
7) Objective-C++ 与 C++ 可混合编程
缺点 :
1) 不支援命名空間
2) 不支持运算符重载 3)不支持多重继承
C 衍生语言

2.SEL 和一个函数指针调用同一个方法的结果是不是相同
答:得到了 SEL 变量之后 ,可以通过下面的调用来给一个对象发送消息 :
[对象 performSelector:SEL 变量 withObject: 参数 1 withObject: 参数 2];
结论 :SEL 只是方法名标识 ,实际运行时需要通过消息发送来调用 ,IMP 是”
implementation”的缩 写,它是 objetive-C 方法 (method)实现代码块的地址 ,类似函数指针 ,通 过它可以 直接访问任意一个方法。免去发送消息的代价。
3.project workspace scheme 的区别 Project:
一般的某个应用单独新建一个 project 就可以了 ,然后把所有的程序文件都放在里面 ,这个 可以满足大部分普通的需求。
Workspace:
项目有可能要使用其他的项目 文件 ,或者引入其他的静态库 文件 ,这个时候 workspace
就派上用场了 ,workspace 既可以单独管理多个项目 ,又可以通过配置 ,让各个项目相互依赖。 Scheme:
Xcode scheme 定义了编译集合中的若干 target,编译时的一些设置以及要执行的测试集 合。可以自定义若干个 scheme,但是同一时刻只能运行一个。
4.把你知道的 framework 写出来 写出功能
UIKit.framework 包含 iOS 应用程序用户界面层使用的类和方法。
CoreGraphics.framework 包含 Quartz 2D 绘图 API 接口
Foundation.framework 为 CoreFoundation 框架的许多功能提供 Objective-C 封装。
CoreFoundation.framework 一组 C 语言接口 ,它们为 iOS 应用程序提供基本数据管理和 服务功能。
MapKit.framework 该框架供一个可被嵌入到应用程序的地图界面 ,该界面包含一个可以 滚动的地图视图。
CoreLocation.framework 可用于定位某个设备当前经纬度。
CFNetwork.framework 提供一组高性能基于 C 语言的接口 , 它们为使用网络协议提供面 向对象抽象。

5.const 的用法?
(1)欲阻止一个变量被改变 ,可以使用 const 关键字。 在定义该 const 变量时 ,通常需要对它
进行初始化 ,因为以后就没有机会再去改变它了 ;
(2)对指针来说 ,可以指定指针本身为 const,也可以指定指针所指的数据为 const,或二者同
时指定为 const; (3)在一个函数声明中
其值 ; (4)对于类的成员函数
员变量 ; (5)对于类的成员函数
值”。
6.ios 平台怎么做数据的持久化 数据库吗?
iOS 中可以有四种持久化数据的方式: 可以使你以图形界面的方式快速的定义
,const 可以修饰形参 ,表明它是一个输入参数 ,在函数内部不能改变
,若指定其为 const 类型 ,则表明其是一个常函数 , 不能修改类的成
,有时候必须指定其返回值为 const 类型 ,以使得其 返回值不为 “左
?coredata 和 sqlite 有无必然联系? coredata 是一个关系型
属性列表、 对象归档、 SQLite3 和 CoreData;coredata app 的数据模型，同时在你的代码中容易获取到它。
core data 提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在 app 中继续创建新的任务。 在使用 core data 的时候，你不用安装额外的数据库系统， 因为 core data 使用内置的 sqlite 数据库。 coredata 将你 app 的模型层放入到一组定义在内存中的数据对象。
core data 会追踪这些对象的改变， 同时可以根据需要做相反的改变， 例如用户执行撤销命令。
当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些数据归档， 并永久性 保存。
mac os x 中 sqlite 库，它是一个轻量级功能强大的关系数据引擎， 也很容易嵌入到应用程序。 可以在多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。 与 coredata 框架不同的
是， sqlite 是使用程序式的， sql 的主要的 API 来直接操作数据表。
Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 CoreDta
支持 SQLite 作为一种存储类型， 但它不能使用任意的 SQLite 数据库。 CoreData 在使用的过 程种自己创建这个数据库。 Core Data 支持对一、对多的关系。

XML 数据解析方式各有什么不同， JSON解析有哪些框架?
 XML数据解析的两种解析方式: DOM解析和 SAX解析;
DOM解析必须完成 DOM树的构造， 在处理规模较大的 XML文档时就很耗内 存， 占用资源较多， 读入整个 XML文档并构建一个驻留内存的树结构 (节 点树) ，通过遍历树结构可以检索任意 XML节点， 读取它的属性和值， 通 常情况下，可以借助 XPath 查询 XML节点;
SAX与 DOM不同，它是事件驱动模型，解析 XML文档时每遇到一个开始或 者结束标签、属性或者一条指令时， 程序就产生一个事件进行相应的处理， 一边读取 XML文档一边处理， 不必等整个文档加载完才采取措施， 当在读 取解析过程中遇到需要处理的对象，会发出通知进行处理。因此， SAX相 对于 DOM来说更适合操作大的 XML文档。
JSON解析: 性能比较好的主要是第三方的 JSONKIT和 iOS 自带的 JSON解 析类，其中自带的 JSON解析性能最高，但只能用于 iOS5 之后。
如何进行真机调试?
1. 首先需要用钥匙串创建一个钥匙( key);
2. 将钥匙串上传到官网，获取 iOS Development 证书;
3. 创建 App ID 即我们应用程序中的 Boundle ID ;
4. 添加 Device ID 即 UDID;
5. 通过勾选前面所创建的证书: App ID 、Device ID ; 6. 生成 mobileprovision 文件;
7. 先决条件:申请开发者账号 99 美刀
APP 发布的上架流程
1. 登录应用发布网站 添加应用信息; 2. 下载安装发布证书;

 3. 选择发布证书， 使用 Archive 编译发布包， 用 Xcode将代码(发布包) 上传到 服务器;
4. 等待审核通过 ;
5. 生成 IPA:菜单栏 ->Product->Archive.
SVN 的使用
SVN=版本控制 +备份服务器，可以把 SVN当成备份服务器，并且可以帮助 你记住每次上服务器的档案内容，并自动赋予每次变更的版本;
SVN的版本控制:所有上传版本都会帮您记录下来，也有版本分支及合并 等功能。 SVN可以让不同的开发者存取同样的档案，并且利用 SVNServer 作为档案同步的机制， 即您有档案更新时， 无需将档案寄送给您的开发成 员。SVN的存放档案方式是采用差异备份的方式， 即会备份到不同的地方， 节省硬盘空间，也可以对非文字文件进行差异备份。 SVN的重要性:备份工作档案的重要性、版本控管的重要性、伙伴间的数 据同步的重要性、备份不同版本是很耗费硬盘空间的;
防止冲突:
1. 防止代码冲突: 不要多人同时修改同一文件， 例如:A、B都修改同一个文件， 先让 A修改，然后提交到服务器，然后 B更新下来，再进行修改;
2. 服务器上的项目文件 Xcodeproj ，仅让一个人管理提交，其他人只更新，防止 文件发生冲突。
如何进行网络消息推送
一种是 Apple 自己提供的通知服务( APNS服务器)、一种是用第三方推 送机制。
首先应用发送通知， 系统弹出提示框询问用户是否允许， 当用户允许后向 苹果服务器 (APNS)请求 deviceToken ，并由苹果服务器发送给自己的应用， 自己的应用将 DeviceToken 发送自己的服务器， 自己服务器想要发送网络 推送时将 deviceToken 以及想要推送的信息发送给苹果服务器， 苹果服务 器将信息发送给应用。
推送信息内容，总容量不超过 256 个字节;

 iOS SDK本身提供的 APNS服务器推送，它可以直接推送给目标用户并根 据您的方式弹出提示。
优点:不论应用是否开启，都会发送到手机端;
缺点: 消息推送机制是苹果服务端控制， 个别时候可能会有延迟， 因为苹果服务 器也有队列来处理所有的消息请求;
第三方推送机制，普遍使用 Socket 机制来实现，几乎可以达到即时的发 送到目标用户手机端，适用于即时通讯类应用。
优点:实时的，取决于心跳包的节奏;
缺点: iOS 系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这 种推送机制不可用。
网络七层协议
应用层:
1. 用户接口、应用程序; 2.Application 典型设备:网关;
3. 典型协议、标准和应用: TELNE、T FTP、HTTP
表示层:

 1. 数据表示、压缩和加密 presentation
2. 典型设备:网关
3. 典型协议、标准和应用: ASCLL、PICT、TIFF、JPEG|MPEG
4. 表示层相当于一个东西的表示， 表示的一些协议， 比如图片、声音和视频 MPE。G
会话层:
1. 会话的建立和结束;
2. 典型设备:网关;
3. 典型协议、标准和应用: RPC、SQL、NFS、X WINDOW、SASP
传输层:
1. 主要功能:端到端控制 Transport ;
2. 典型设备:网关;
3. 典型协议、标准和应用: TCP、UDP、SPX
网络层:
1. 主要功能:路由、寻址 Network ; 2. 典型设备:路由器;
3.典型协议、标准和应用: IP、IPX、APPLETAL、KICMP;

 数据链路层:
1. 主要功能:保证无差错的疏忽链路的 data link ;
2. 典型设备:交换机、网桥、网卡;
3. 典型协议、标准和应用: 802.2 、 802.3ATM、HDLC、FRAME RELA;Y
物理层:
1. 主要功能:传输比特流 Physical ;
2. 典型设备:集线器、中继器
3. 典型协议、标准和应用: V.35、EIA/TIA-232.
对 NSUserDefaults 的理解
NSUserDefaults :系统提供的一种存储数据的方式， 数据，默认存储到 library 下的 Preferences 文件夹。
SDWebImage原理
调用类别的方法:
从内存中(字典)找图片(当这个图片在本次程序加载过)，找到直接使 用;
从沙盒中找，找到直接使用，缓存到内存。 从网络上获取，使用，缓存到内存，缓存到沙盒。
主要用于保存少量的

 OC中是否有二维数组，如何实现二维数组?
OC中没有二维数组，可通过嵌套数组实现二维数组。
LayoutSubViews 在什么时候被调用?
当 View 本身的 frame 改变时，会调用这个方法。


对沙盒的理解
每个 iOS 应用都被限制在“沙盒”中， 沙盒相当于一个加了仅主人可见权 限的文件夹， 及时在应用程序安装过程中， 系统为每个单独的应用程序生
成它的主目录和一些关键的子目录。苹果对沙盒有几条限制 :
1. 应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序的沙盒;

 2. 应用之间不能共享数据， 沙盒里的文件不能被复制到其他应用程序的文件夹中， 也不能把其他应用文件夹复制到沙盒中;
3. 苹果禁止任何读写沙盒以外的文件， 禁止应用程序将内容写到沙盒以外的文件 夹中;
4. 沙盒目录里有三个文件夹: Documents——存储;应用程序的数据文件，存储 用户数据或其他定期备份的信息; Library 下有两个文件夹， Caches存储应用程 序再次启动所需的信息， Preferences 包含应用程序的偏好设置文件，不可在这 更改偏好设置; temp存放临时文件即应用程序再次启动不需要的文件。
获取沙盒根目录的方法，有几种方法:用 NSHomeDirectory 获取。 获取 Document路径:
NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserD omainMask,YES).
对瀑布流的理解
首先图片的宽度都是一样的， 1. 将图片等比例压缩，让图片不变形; 2. 计算图片最低应该摆放的位置， 哪一列低就放在哪; 3. 进行最优排列， 在 ScrollView 的基础上添加两个 tableView ，然后将之前所计算的 scrollView 的高度通过 tableView 展示出来。
如何使用两个 TableView 产生联动:将两个 tableView 的滚动事件禁止掉， 最外层 scrollView 滚动时将两个 TableView 跟着滚动，并且更改 contentOffset ，这样产生效果滚动的两个 tableView 。
ViewController 的 loadView 、viewDidLoad 、viewDidUnload 分别是在什么时 候调用的?
viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。
此方法在编程实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用， 在这里实现将 retain 的 view release, 如果是

 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。
关键字 volatile 有什么含意 ?并给出三个不同的例子:
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变， 这样， 编译器就不会去假设这个变量的值了。 精确地说就是， 优化器在用到这个
变量时必须每次都小心地重新读取这个变量的值， 而不是使用保存在寄存 器里的备份。下面是 volatile 变量的几个例子:
1. 并行设备的硬件寄存器(如:状态寄存器);
2. 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables) ; 3. 多线程应用中被几个任务共享的变量。
@synthesize 、@dynamic的理解
@synthesize 是系统自动生成 getter 和 setter 属性声明 ;@synthesize 的意思是， 除非开发人员已经做了， 否则由编译器生成相应的代码， 以满 足属性声明;
@dynamic是开发者自已提供相应的属性声明 ,@dynamic意思是由开发人 员提供相应的代码:对于只读属性需要提供 setter ，对于读写属性需要 提供 setter 和 getter 。查阅了一些资料确定 @dynamic的意思是告诉编 译器 , 属性的获取与赋值方法由用户自己实现 , 不自动生成。

队列和多线程的使用原理
在 iOS 中队列分为以下几种:
   串行队列:队列中的任务只会顺序执行;
dispatch_queue_t q = dispatch_queue_create("...", SERIAL);
并行队列: 队列中的任务通常会并发执行;
DISPATCH_QUEUE_
dispatch_queue_t q = dispatch_queue_create("......",DISPATCH_QUEUE _CONCURRENT);
全局队列:是系统的，直接拿过来( GET)用就可以;与并行队列类似;
dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIO RITY_DEFAULT, 0);
主队列:每一个应用程序对应唯一主队列， 直接 GET即可;在多线程开发 中，使用主队列更新 UI ;
dispatch_queue_t q = dispatch_get_main_queue()

 内存的使用和优化的注意事项
重用问题:如 UITableViewCells 、UICollectionViewCells 、 UITableViewHeaderFooterViews 设置正确的 reuseIdentifier ，充分重用; 尽量把 views 设置为不透明:当 opque 为 NO的时候，图层的半透明取决 于图片和其本身合成的图层为结果，可提高性能;
不要使用太复杂的 XIB/Storyboard :载入时就会将 XIB/storyboard 需要 的所有资源， 包括图片全部载入内存， 即使未来很久才会使用。 那些相比 纯代码写的延迟加载，性能及内存就差了很多;
选择正确的数据结构: 学会选择对业务场景最合适的数组结构是写出高效 代码的基础。 比如，数组: 有序的一组值。 使用索引来查询很快， 使用值 查询很慢，插入 / 删除很慢。字典 : 存储键值对，用键来查找比较快。集
合: 无序的一组值，用值来查找很快，插入 / 删除很快。
gzip/zip 压缩:当从服务端下载相关附件时，可以通过 gzip/zip 压缩后 再下载，使得内存更小，下载速度也更快。
、
数据缓存: 对于 cell 的行高要缓存起来， 使得 reload 数据时， 效率也极 高。而对于那些网络数据， 不需要每次都请求的， 应该缓存起来， 可以写 入数据库，也可以通过 plist 文件存储。
处理内存警告: 一般在基类统一处理内存警告， 将相关不用资源立即释放
掉
重用大开销对象:一些 objects 的初始化很慢，比如 NSDateFormatter
和 NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起 来，防止反复创建。 避免反复处理数据:许多应用需要从服务器加载功能所需的常为 JSON或
者 XML格式的数据。在服务器端和客户端使用相同的数据结构很重要 使用 Autorelease Pool :在某些循环创建临时变量处理数据时，自动释 放池以保证能及时释放内存 ;
正确选择图片加载方式:详情阅读细读 UIImage 加载方式

UIImageView 添加圆角
   最直接的方法就是使用如下属性设置:
imgView.layer.cornerRadius = 10; // 这一行代码是很消耗性能的 imgView.clipsToBounds = YES;
** 这是离屏渲染( off-screen-rendering )，消耗性能的 **
给 UIImage 添加生成圆角图片的扩展 API:这是 on-screen-rendering
- (UIImage *)imageWithCornerRadius:(CGFloat)radius CGRect rect = (CGRect){0.f, 0.f, self.size};
UIGraphicsBeginImageContextWithOptions(self.size, Screen.scale); CGContextAddPath(UIGraphicsGetCurrentContext(),
[UIBezierPath bezierPathWithRoundedRect:rect .CGPath);
CGContextClip(UIGraphicsGetCurrentContext());
{
NO, UIScreen.main
cornerRadius:radius]
[self drawInRect:rect];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
return image; }


16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系，并且 reciever 可以返回值 给sender ，notification 可 以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，
delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。

17什么是 KVC 和KVO ? 答: KVC(Key-Value-Coding) 内部的实现: 一个对象在调用 setValue 的时候，( 1)首先根据方法名找到运行方 法的时候所需要的环 境参数。( 2)他会从自己 isa指针结合环境参 数，找到具体的方法实现的接口。( 3)再直接查找得来的具体的方 法实现。 KVO (Key-Value- Observing ):当观察者为一个对象的属 性进行了注册，被观察对象的 isa 指针被修改的时候， isa 指针就会指 向一个中间类，而不是真实的类。所以 isa 指针其实不需要指向实例 对象真实的类。所以我们的程序最好不要依赖于 isa 指针。在调用类 的方法的时候，最好要明确对象实例的类名

47 HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方
式，适用于分布式超媒体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在进行之中。

http (超文本传输协议)是一个基于请求与响应模式的、无状态的、 应用层的协议， 常基于 TCP 的连接方式， HTTP1.1 版本中给出一种持 续连接的机制，绝大多数的 Web 开发，都是构建在 HTTP 协议之上的 Web应用。 HTTP 协议的主要特点可概括如下: 1.支持客户 /服务 器模式。 2. 简单快速:客户向服务器请求服务时，只需传送请求方 法和路径。请求方法常用的有 GET 、 HEAD 、 POST 。每种方法规定 了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。 3. 灵活: HTTP 允许传 输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器 处理完客户的请求，并收到客户的应答后，即断开连接。 采用这种方
式可以节省传输时间。 5.无状态: HTTP 协议是无状态协议。无状 态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处 理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数 据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客
户和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接， 之后才能传输数据。 TCP 提供超时重发，丢弃重复数据，检验数据，
流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。
UDP 不提供可靠性，它只是把应用程序传给 IP层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在 客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接 的协议，也就是说，在正式收发数据前， 必须和对方建立可靠的连接。 一个 TCP 连接必须要经过三次 ―对话 ‖才能建立起来，我们来看看这三 次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包; 2. 主机 B 向主机 A发送同意连接和要求同步(同步就是两台主机一个在发送， 一个在接收，协调工作)的数据包; 3.主机 A再发出一个数据包确认 主机 B的要求同步: ―我现在就发，你接着吧! ‖，这是第三次对话。 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次 ―对话 ‖之 后，主机 A才向主机 B正式发送数据。

UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协 议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数 据包发送过去! UDP 适用于一次只传送少量数据、 对可靠性要求不 高的应用环境。
tcp 协议和 udp 协议的差别 是否连接 面向连接 面向非连接
传输可靠性 可靠 不可靠 应用场合 传输大量数据 少量数据 速度 慢 快
50socket 连接和http连接的区别
简单说，你浏览的网页(网址以 http:// 开头 )都是 http 协议传输到你的 浏览器的, 而http是基于socket之上的。socket是一套完成 tcp，udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ，HTTP 协议是基于 TCP 连接的
tcp 协议: 对应于传输层
ip协议: 对应于网络层 TCP/IP 是传输层协议，主要解决数据如
何在网络中传输;而 HTTP 是应用层协议，主要解决如何包装数据。
Socket是对TCP/IP协议的封装， Socket本身并不是协议，而是一个 调用接口( API )，通过 Socket ，我们才能使用 TCP/IP 协议。

http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一 次请求，服务器端响应后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器 端一旦建立起连接将不会主动断掉; 但是由于各种环境因素可能会是 连接断开，比如说:服务器端或客户端主机 down 了，网络故障，或 者两者之间长时间没有数据传输， 网络防火墙可能会断开该连接以释 放网络资源。 所以当一个 socket 连接中没有数据的传输，那么为了维 持连接需要发送心跳消息 ~~ 具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的， 那什么是 socket 呢?socket起源于Unix，而Unix/Linux 基本哲学之一就是 ―一切皆文 件‖，都可以用 ―打开open –> 读写write/read –> 关闭close ‖模式来操 作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一种特 殊的文件，一些 socket 函数就是对其进行的操作(读 /写IO、打开、 关闭)，这些函数我们在后面进行介绍。我们在传输数据时，可以只 使用(传输层) TCP/IP协议，但是那样的话，如果没有应用层，便 无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应 用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也 可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议， 以封 装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口，你可以借助它建立

TCP连接等等。而 TCP和UDP协议属于传输层 。 而http是个应用 层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发 动机，提供了网络通信的能力。 )
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是 一个调用接口(API)，通过Socket，我们才能使用 TCP/IP协议。Socket
的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND
状态，等待服务器确认; 第二次握手:服务器收到 syn 包，必须确 认客户的 SYN (ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )， 即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手: 客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务 器才正式开始传送数据。理想状态下， TCP 连接一旦建立，在通信双 方中的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。 断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断

开过程需要经过 ―四次握手 ‖(过程就不细写了，就是服务器和客户端 交互，最终确定断开)
52利用Socket 建立网络连接的步骤 建立Socket连接至少需要一对套接字， 其中一个运行于客户端， 称为
ClientSocket ，另一个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求， 连
接确认。
1。服务器监听:服务器端套接字并不定位具体的客户端套接字，而 是处于等待连接的状态， 实时监控网络状态， 等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是 服务器端的套接字。 为此，客户端的套接字必须首先描述它要连接的 服务器的套接字， 指出服务器端套接字的地址和端口号， 然后就向服 务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字 的连接请求时，就响应客户端套接字的请求， 建立一个新的线程，把 服务器端套接字的描述发给客户端， 一旦客户端确认了此描述， 双方 就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。
53 进程与线程

进程( process )是一块包含了某些资源的内存区域。操作系统利用 进程把它的工作划分为一些功能单元。
进程中所包含的一个或多个执行单元称为线程( thread )。进程还拥 有一个私有的虚拟地址空间，该空间仅能被它所包含的线程访问。
通常在一个进程中可以包含若干个线程， 它们可以利用进程所拥有的
资源。
在引入线程的操作系统中， 通常都是把进程作为分配资源的基本单位， 而把线程作为独立运行和独立调度的基本单位。
由于线程比进程更小， 基本上不拥有系统资源， 故对它的调度所付出 的开销就会小得多， 能更高效的提高系统内多个程序间并发执行的程 度。
简而言之 ,一个程序至少有一个进程 ,一个进程至少有一个线程 .一个 程序就是一个进程，而一个程序中的多个任务则被称为线程。
线程只能归属于一个进程并且它只能访问该进程所拥有的资源。 当操 作系统创建一个进程后， 该进程会自动申请一个名为主线程或首要线
程的线程。应用程序( application )是由一个或多个相互协作的进程 组成的。
另外，进程在执行过程中拥有独立的内存单元， 而多个线程共享内存， 从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是 有区别的。 每个独立的线程有一个程序运行的入口、 顺序执行序列和

程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由 应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义 在于一个应用程序中， 有多个执行部分可以同时执行。 但操作系统并 没有将多个线程看做多个独立的应用， 来实现进程的调度和管理以及 资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活
动 ,进程是系统进行资源分配和调度的一个独立单位 . 线程是进程的 一个实体 ,是CPU 调度和分派的基本单位 ,它是比进程更小的能独立 运行的基本单位 .线程自己基本上不拥有系统资源 ,只拥有一点在运行 中必不可少的资源 (如程序计数器 ,一组寄存器和栈 ),但是它可与同属 一个进程的其他的线程共享进程所拥有的全部资源 . 一个线程可以 创建和撤销另一个线程 ;同一个进程中的多个线程之间可以并发执行 .
54 多线程
多线程编程是防止主线程堵塞， 增加运行效率等等的最佳方法。 而原 始的多线程方法存在很多的毛病，包括线程锁死等。在 Cocoa 中， Apple提供了NSOperation 这个类，提供了一个优秀的多线程编程方 法。
本次介绍 NSOperation 的子集，简易方法的 NSInvocationOperation :

一个 NSOperationQueue 操作队列，就相当于一个线程管理器，而 非一个线程。因为你可以设置这个线程管理器内可以并行运行的的线 程数量等等
55oc 语法里的 @perpoerty 不用写 @synzhesize 了，自动填充了。 并且的 _name;
写方法时候不用提前声明。 llvm 全局方法便利。
枚举类型。 enum hello:Integer{ } 冒号后面直接可以跟类型，以前 是:
enum hello{} 后面在指定为 Integer .
桥接。 ARC 自动 release retain 的时候 CFString CFArray . Core Fountion. 加上桥接 _brige 才能区分 CFString 和NSString 而现在 自动区分了，叫固定桥接。
下拉刷新封装好了。
UICollectionViewController. 可以把表格分成多列。
Social Framework( 社交集成 ) UIActivityViewController 来询问用户的社交行为
缓存:就是存放在临时文件里，比如新浪微博请求的数据，和图片， 下次请求看这里有没有值。


57请写一个 C函数，若处理器是 Big_endian 的，则返回 0;若是 Little_endian 的，则返回 1 int checkCPU( ) {
{
union w {
int a;
char b; } c;
c.a = 1;
return (c.b ==1);
}

}
剖析: 嵌入式系统开发者应该对 Little-endian 和Big-endian 模式非常 了解。采用 Little-endian 模式的 CPU 对操作数的存放方式是从低字节 到高字节， Big-endian 模式的 CPU 对操作数的存放方式是从高字 节到低字节。 在弄清楚这个之前要弄清楚这个问题: 字节从右到坐 为从高到低 ! 假设从地址 0x4000 开始存放 : 0x12345678, 是也个 32 位 四个字节的数据，最高字节是 0x12,最低字节是 0x78:在Little-endian 模式CPU内存中的存放方式为: (高字节在高地址 , 低字节在低地 址)
内存地址 0x4000 0x4001 0x4002 0x4003
存放内容 0x78 0x56 0x34 0x12
大端机则相反。
有的处理器系统采用了小端方式进行数据存放，如 Intel 的奔腾。 有的 处理器系统采用了大端方式进行数据存放，如 IBM 半导体和 Freescale 的PowerPC 处理器。不仅对于处理器，一些外设的设计中 也存在着使用大端或者小端进行数据存放的选择。 因此在一个处理 器系统中， 有可能存在大端和小端模式同时存在的现象。 这一现象为 系统的软硬件设计带来了不小的麻烦， 这要求系统设计工程师， 必须 深入理解大端和小端模式的差别。 大端与小端模式的差别体现在一个 处理器的寄存器，指令集，系统总线等各个层次中。 联合体 union 的存放顺序是所有成员都从低地址开始存放的。 以上是网上的原文。

采用哪种网络协议?该协议的主要层次结构? tcp/ip 应用 层/传输层 /网络层 /数据链路层 /物理层 17. Internet 物理地址 和IP地址转换采用什么协议? ARP (Address Resolution Protocol)(地址解析協議) 18.IP 地址的编码分为哪俩部分?
IP 地址由两部分组成，网络号和主机号。不过是要和 ―子网 掩码 ‖按位与上之后才能区 分哪些是网络位哪些是主机位。
2.用户输入 M,N值，从 1至N开始顺序循环数数，每数到 M 输出该数值，直至全部输出。写 出 C程序。 循环 链表，用取余操作做 3.不能做 switch() 的参数类型是:
switch 的参数不能为实型。 部变量能否和全局变量重名?
要用全局变量，需要使用 "::" 在函数内引用这个变量时，会用到同名的局部变量，而 不 会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多 个同名的局部变 量，比如在两个循环体内都定义一个同名
的局部变量，而那个局部变量的作用域就在那
2 、如何引用一个已经定义过的全局变量?
extern 可以用引用头文件的方式，也可以用 如果用引用头文件方式来引用某个 在头文件中声明的全局 变理，假定你将那个变写错了，那么在编译期间会报错，如果你
用extern方式引用时，假定你犯了同样的错误， 那么在编译 期间不会报错，而在连接期 间报错 3、全局变量
華為 1、局 答:能，局部会屏蔽全局。
局部变量可以与全局变量同名，
个循环体内 答:
extern 关键字，

可不可以定义在可被多个 .C 文件包含的头文件中?为什么? 答:可以，在不同的 C文件中以 static 形式来声明同名全局
变量。 可以在不同的 C文件中声明同名的全局变量， 前提是 其中只能有一个 C文件中对此变量赋 初值，此时连接不会出 错 4、语句for( ;1 ;)有什么问题?它是什么意思?
答:和 while(1) 相同。 while ⋯⋯ do有什么区别?
一个判断以后再循环
661.IP Phone 的原理是什么 ? 通信建立的过程怎样，端口有什么作用?
是哪个应用程序使用该协议 3.1号信令和 7号信令有什么区 别，我国某前广泛使用的是那一种? 4. 列举 5种以上的电话
新业务?
程和线程的差别。
程内的可调度实体 . 作为调度和分配的基本单位，进程作为拥有资源的基本单位
5、do⋯⋯ while 和 答:前一个循环一遍再判断，后
微软亚洲技术中心的面试题! !! 1.进 线程是指进程内的一个执行单元 ,也是进
IPV6 2.TCP/IP
与进程的区别 : (1)调度:线程
(2) 并发性:不仅进程之间可以并发执行，同一个进程的多 个线程之间也可并发执行 (3) 拥有资源:进程是拥有资源的 一个独立单位，线程不拥有系统资源，但可以访问隶属 于 进程的资源 . (4)系统开销:在创建或撤消进程时，由于系统 都要为之分配和回收资源，导致系统的开 销明显大于创建 或撤消线程时的开销。 2. 测试方法 人工测试:个
三次握手，确定

人复查、抽查和会审 机器测试:黑盒测试和白盒测试
2 .Heap 与 stack 的差别。 Heap 是堆，stack 是栈。 Stack 的空间由操作系统自动分配 /释放， Heap 上的空间手
动分配 /释放。 Stack 空间有限， Heap 是很大的自由存储区 C中的 malloc 函数分配的内存空间即在堆上 ,C++ 中对应的
是 new 操作符。 程序在编译期对变量和函数分配内存都在栈 上进行 ,且程序运行过程中函数调用时参数的 传递也在栈上 进行 3.Windows 下的内存是如何管理的? 4.介 绍.Net和.Net的安全性。 5.客户端如何访问 .Net组件实现 Web Service ? 6. C/C++ 编译器中虚表是如何完成的?
7.谈谈 COM 的线程模型。然后讨论进程内 /外组件的差别。
8.谈谈 IA32 下的分页机制 小页 (4K)两级分页模式， 大页 (4M) 一级 9.给两个变量， 如何找出一个带环单链表中
是什么地方出现环的? 向同一个接点时就是环出现的地方 少种办法从用户态跳到内核态?
一个递增一，一个递增二，他们指 10.在 IA32 中一共有多
通过调用门，从 ring3到 ring0 ，中断从 ring3 到 ring0 ，进入 vm86 等等 11.如果只想
让程序有一个实例运行，不能运行两个。像 winamp 一样，只能开一 个窗 口，怎样实现? 用内存映射或全局原子(互 斥变量)、查找窗口句柄 .. FindWindow ，互斥，写标志到文 件或注册表 ,共享内存。

67 如何截取键盘的响应，让所有的 ?a‘变成 ?b‘? 键盘钩 子SetWindowsHookEx 13.Apartment 在COM中有什么用? 为什么要引入? 14.存储过程是什么?有什么用?有什么 优点? 我的理解就是一堆 sql的集合，可以建立非常复杂的 查询，编译运行，所以运行一次后， 以后再运行速度比单 独执行SQL快很多 15.Template有什么特点?什么时候用?
16.谈谈 Windows DNA 结构的特点和优点。 网 络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区 别? 1 ，进程:子进程是父进程的复制品。子进程获得父进 程数据空间、 堆和栈的复制品。 2 ，线程:相对与进程而言， 线程是一个更加接近与执行体的概念，它可以与同进程的其
他线程共享数据，但拥有自己的栈空间，拥有独立的执行 序列。 两者都可以提高程序的并发度，提高程序运行效率 和响应时间。 线程和进程在使用上各有优缺点:线程执行 开销小，但不利于资源管理和保护; 而进程 正相反。同时， 线程适合于在 SMP机器上运行，而进程则可以跨机器迁移。
思科
682.找错题 试题1: void test1() { char
string[10];
str1 ); } str1[10];
char* str1 = "0123456789";
试题 2: void test2() { int i; for(i=0; i<10; i++)
strcpy( string,
strcpy( string, str1 ); } 试题 3:
{
void test3(char* str1)
char string[10], str1 = 'a';
} {

char string[10]; if( strlen( str1 ) <= 10 ) { strcpy( string, str1 ); } } 解答: 试题1字符串 str1需要11个字节才
能存放下(包括末尾的 ‘0‘)，而 string 只有 10 个字节的空间， strcpy 会导致数组越界; 对试题 2，如果面试者指出字符数组 str1不
能在数组内结束可以给 3分;如果面试者指出 strcpy(string, str1) 调用 使得从 str1[url=] 内存 [/url] 起复制到 string 内存起所复制的字节数具有
不确定性可以给 7分，在此基础上指出库函数 strcpy 工作方式的给 10 分; 对试题 3，if(strlen(str1) <= 10) 应改为 if(strlen(str1) < 10) ， 因为strlen的结果未统计 ‘0‘所占用的1个字节。 剖析: 考查对基本功的掌握: (1)字符串以 ‘0‘结尾; (2)对数 组越界把握的敏感度; (3) 库函数 strcpy 的工作方式，如果编 写一个标准 strcpy函数的总分值为 10，下面给出几个不同得分的答案:
2分 void strcpy( char *strDest, char *strSrc ) { while( (*strDest++ = * strSrc++) != ? 0‘ );} 4分 void
strcpy( char *strDest, const char *strSrc ) //将源字符串加 const ，表 明其为输入参数，加 2分 { while( (*strDest++ = * strSrc++) !=
?0‘ );} 7分 void strcpy(char *strDest, const char *strSrc) { //对源地址和目的地址加非 0断言，加 3分
assert( (strDest != NULL) && (strSrc != NULL) );
while( (*strDest++ = * strSrc++) != ? 0‘ );} 10分 //为了实现 链式操作， 将目的地址返回， 加3分! char * strcpy( char *strDest, const char *strSrc ) { assert( (strDest != NULL) && (strSrc !=

NULL) ); char *address = strDest; while( (*strDest++ = * strSrc++) != ? 0‘ ); return address; } 从2分到 10分的几
个答案我们可以清楚的看到，小小的 strcpy 竟然暗藏着这么多玄机， 真不是盖的! 需要多么扎实的基本功才能写一个完美的 strcpy 啊!
(4)对strlen 的掌握，它没有包括字符串末尾的 不同分值的 strcpy版本，应该也可以写出一个
完美的版本为: int strlen( const char *str ) // assert( strt != NULL ); // 断言字符串地址非 0
while( (*str++) != '\0' ) { len++;
试题 4: void GetMemory( char *p )
malloc( 100 ); } void Test( void ) {
GetMemory( str ); strcpy( str, "hello world" ); printf( str ); }
试题 5: char *GetMemory( void )
return p; } void Test( void )
GetMemory(); printf( str );
GetMemory( char **p, int num )
malloc( num ); } void Test( void )
GetMemory( &str, 100 ); strcpy( str, "hello" ); printf( str );
} 试题7: malloc( 100 );
其它语句 } 解答: 试题 4传入中 GetMemory( char *p ) 函数的形参为字符串指针， 在函数内部修改形参并不能真正的改变传
{
} return len; } p = (char *)
'\0'。 读者看了 10分的strlen函数了，
输入参数 const { int len;
char *str = NULL;
{ char p[] = "hello world"; char *str = NULL; str =
{ }
{
void Test( void ) { char *str = (char *) strcpy( str, "hello" ); free( str ); ... //省略的
试题 6: void *p = (char *)
{ char *str = NULL;

入形参的值，执行完 char *str = NULL; GetMemory( str ); 后的 str 仍然为 NULL ; 试题 5 中 char p[] = "hello world";
return p; 的p[]数组为函数内的局部自动变量， 在函数返回后， 内存已经被释放。 这是许多程序员常犯的错误， 其根源在于不理解变 量的生存期。 试题6的GetMemory 避免了试题 4的问题，传入 GetMemory 的参数为字符串指针的指针，但是在 GetMemory 中执行 申请内存及赋值语句 *p = (char *) malloc( num ); 后未判断 内存是否申请成功，应加上: if ( *p == NULL ) { ...//进行申请 内存失败处理 } 试题 7存在与试题 6同样的问题，在执行
char *str = (char *) malloc(100); 后未进行内存是否申请成 功的判断;另外，在 free(str) 后未置 str为空，导致可能变成一个 ―野‖
指针，应加上: str = NULL; 试题 6的Test函数中也未对 malloc
的内存进行释放。 剖析: 试题 4 ~ 7考查面试者对内存
操作的理解程度，基本功扎实的面试者一般都能正确的回答其中
50~60 的错误。但是要完全解答正确，却也绝非易事。 对内 存操作的考查主要集中在: ( 1)指针的理解; ( 2)
变量的生存期及作用范围; (3)良好的动态内存申请和释放 习惯。 再看看下面的一段程序有什么错误: swap( int*
p1,int* p2 ) { int *p; *p = *p1; *p1 = *p2; *p2 = *p; } 在swap函数中， p是一个 ―野‖指针，有可能指向系统区，导致程序运 行的崩溃。 在VC++ 中DEBUG 运行时提示错误 ―Access Violation 。该‖ 程序应该改为: swap( int* p1,int* p2 ) { int p; p = *p1;

 *p1 = *p2; *p2 = p; }[img=12,12]file:///D:/ 鱼鱼软件 /鱼鱼多媒体 日记本 /temp/{56068A28-3D3B-4D8B-9F82-AC1C3E9B128C}_arc_d[1].gif
[/img] 3.内功题
量 与―零值 ‖比较的 if
BOOL 型变量:if(!var)
型变量: const float EPSINON = 0.00001;
((x >= - EPSINON) && (x <= EPSINON) 指针变量: if(var==NULL) 剖析: 考查对 0值判断的 ―内功 ‖，BOOL 型变量的 0判断完全可以写成 if(var==0) ，而int型变量也可以写成 if(!var) ，指针变量的判断也可以写成 if(!var) ，上述写法虽然程序都能 正确运行，但是未能清晰地表达程序的意思。 一般的，如果想 让if判断一个变量的 ―真‖、―假‖，应直接使用 if(var)、if(!var)，表明其 为―逻辑‖判断;如果用 if判断一个数值型变量 (short、int、long等)，应 该用if(var==0) ，表明是与 0进行―数值‖上的比较;而判断指针则适宜 用if(var==NULL) ，这是一种很好的编程习惯。 浮点型变量并 不精确，所以不可将 float变量用―==或‖―!=‖与数字比较，应该设法转 化成 ―>=或‖―<=形‖式。如果写成 if (x == 0.0) ，则判为错，得 0分。
试题 2:以下为 Windows NT 下的 32 位C++ 程序，请计算 sizeof 的值
试题1:分别给出 BOOL，int，float，指针变
语句(假设变量名为 var) int型变量: if(var==0)
解答:
float if
void Func ( char str[100] )
malloc( 100 ); sizeof ( p ) = ?
( p ) = 4 剖析: Func ( char str[100] ) 函数中数组名作为
{ sizeof( str ) = ? } void *p = 解答: sizeof( str ) = 4 sizeof

函数形参时，在函数体内， 数组名失去了本身的内涵， 仅仅只是一个 指针;在失去其内涵的同时，它还失去了其常量特性，可以作自增、
自减等操作， 可以被修改。 数组名的本质如下: 数组名指代一种数据结构，这种数据结构就是数组;
char str[10]; cout << sizeof(str) << endl; 为10，str指代数据结构 char[10] 。 (2)数组名可以转换为指
向其指代实体的指针， 而且是一个指针常量， 不能作自增、自减等操
作，不能被修改; char str[10]; str++; // 编译出错，提示 str不是
左值 ( 3)数组名作为函数形参时，沦为普通指针。
Windows NT 32 位平台下，指针的长度(占用内存的大小) 为4字节， 故 sizeof( str ) 、 sizeof ( p ) 都为 4。 试题 3 :写一个 ―标准 ‖
宏 MIN ，这个宏输入两个参数并返回较小的一个。另外，当你写下面 的代码时会发生什么事? least = MIN(*p++, b); 解答:
#define MIN(A,B) ((A) <= (B) ? (A) : (B)) MIN(*p++, b) 会产 生宏的副作用 剖析: 这个面试题主要考查面试者对宏 定义的使用， 宏定义可以实现类似于函数的功能， 但是它终归不是函 数，而宏定义中括弧中的 ―参数 ‖也不是真的参数，在宏展开的时候对 ―参数 ‖进行的是一对一的替换。 程序员对宏定义的使用要非 常小心， 特别要注意两个问题: ( 1)谨慎地将宏定义中的 ―参 数‖和整个宏用用括弧括起来。 所以，严格地讲，下述解答: #define MIN(A,B) (A) <= (B) ? (A) : (B) #define MIN(A,B) (A <= B ? A : B ) 都应判 0分; (2)防止宏的副作用。 宏定义 #define
( 1) 例如:
输出结果

 MIN(A,B) ((A) <= (B) ? (A) : (B)) 对MIN(*p++, b) 的作用结果是: ((*p++) <= (b) ? (*p++) : (*p++)) 这个表达式会产生副作
用，指针 p会作三次 ++ 自增操作。 除此之外，另一个应该判 0
分的解答是: #define MIN(A,B) ((A) <= (B) ? (A) : (B)); 个解答在宏定义的后面加 ―，; ‖显示编写者对宏的概念模糊不清， 只能 被无情地判 0分并被面试官淘汰。 试题4:为什么标准头文件 都有类似以下的结构? #ifndef __INCvxWorksh #define __INCvxWorksh #ifdef __cplusplus extern "C" { #endif /*...*/
#ifdef __cplusplus } #endif #endif /* __INCvxWorksh */
解答: 头文件中的编译宏 #ifndef
__INCvxWorksh #define __INCvxWorksh #endif 的作用 是防止被重复引用。 作为一种面向对象的语言， C++ 支持函 数重载，而过程式语言 C则不支持。函数被 C++编译后在symbol库中 的名字与 C语言的不同。例如，假设某个函数的原型为: void foo(int x, int y); 该函数被 C编译器编译后在 symbol 库中的名字 为_foo，而C++编译器则会产生像 _foo_int_int 之类的名字。 _foo_int_int 这样的名字包含了函数名和函数参数数量及类型信息， C++就是考这种机制来实现函数重载的。 为了实现 C和C++ 的混合编程，C++ 提供了 C连接交换指定符号 extern "C" 来解决名字匹 配问题，函数声明前加上 extern "C" 后，则编译器就会按照 C语言的 方式将该函数编译为 _foo ，这样 C语言中就可以调用 C++ 的函数了。 [img=12,12]file:///D:/ 鱼鱼软件/鱼鱼多媒体日记本
这

 /temp/{C74A38C4-432E-4799-B54D-73E2CD3C5206}_arc_d[1].gif [/img] 试题 5:编写一个函数， 作用是把一个 char 组成的字符串循环
右移n个。比如原来是 ―abcdefghi如‖果n=2，移位后应该是 ―hiabcdefgh ‖
函数头是这样的: //steps 是要求移动的 n
//pStr 是指向以 '\0' 结尾的字符串的指针 void LoopMove ( char * pStr, int
steps ) { //请填充 ... } LoopMove ( char *pStr, int steps ) steps; char tmp[MAX_LEN]; strcpy ( tmp + steps, pStr);
解答: 正确解答 1: void { int n = strlen( pStr ) -
strcpy ( tmp, pStr + n ); *( tmp + strlen ( pStr ) ) = '\0';
正确解答 2: void LoopMove ( char int n = strlen( pStr ) - steps; char
tmp[MAX_LEN];
memcpy(pStr + steps, pStr, n ); memcpy(pStr, tmp, steps ); } 剖析: 这个试题主要考查面试者对标准库函数的熟练程度， 在需要的时候引用库函数可以很大程度上简化程序编写的工作量。
strcpy( pStr, tmp ); *pStr, int steps ) {
}
memcpy
(3) memset
分享到:
memcpy( tmp, pStr + n, steps );
最频繁被使用的库函数包括:
(1) strcpy (2)




 史上最全的 iOS 面试题及答案 1. 写一个 NSString 类的实现
+ (id)initWithCString:(c*****t char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id) stringWithCString: (c*****t char*)nullTerminatedCString
encoding: (NSStringEncoding)encoding
{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return AUTORELEASE(obj);
}
2static 关键字的作用:
( 1 )函数体内 static 变量的作用范围为该函数体，不同于 分配一次，
因此其值在下次调用时仍维持上次的值;
auto 变量，该变量的内存只被
( 2 )在模块内的 问;
( 3 )在模块内的 制在声明 它的模块内;
( 4 )在类中的
( 5 )在类中的
访问类的 static 成员变量。
3线程与进程的区别和联系 ?
进程和线程都是由操作系统所体会的程序运行的基本单元， 系统利用该基本单元实现系统对 应用的并发性。
程 和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间， 一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进 程中的不同 执行路径。 线程有自己的堆栈和局部变量， 但线程之间没有单独的地址空间， 一个线程死掉 就等于整个进程死掉，所以多进程的程序要比多线程的程序健 壮，但在进程切换时，耗费 资源较大， 效率要差一些。 但对于一些要求同时进行并且又要共享某些变量的并发操作， 只 能用线程，不能用进程。
4堆和栈的区别 管理方式:对于栈来讲，是由编译器自动管理，无需我们手工控制;对于堆来说，释放工作 由程序员控制，容易产生 memory leak 。
static 全局变量可以被模块内所用函数访问， static 函数只可被这一模块内的其它函数调用，
但不能被模块外其它函数访
 这个函数的使用范围被限
static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;
static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能

 申请大小:
栈: 在 Windows 下 , 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的 意思是栈顶的地址和栈的最大容量是系统预先规定好的， 在 WINDOWS 下，栈的大小是 2M (也有的说是 1M ，总之是一个编译时就确定的常数) ，如果申请的空间超过栈的剩余空间时， 将提示 overflow 。因 此，能从栈获得的空间较小。
堆: 堆是向高地址扩展的数据结构， 是不连续的内存区域。 这是由于系统是用链表来存储的 空闲内存地址的， 自然是不连续的， 而链表的遍历方向是由低地址向高地址。 堆的大小受限 于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题:对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量 的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列， 他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式:堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式:静态分配和动态分 配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配， 但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率: 栈是机器系统提供的数据结构， 计算机会在底层对栈提供支持: 分配专门的寄存 器存放栈的地址， 压栈出栈都有专门的指令执行， 这就决定了栈的效率比较高。 堆则是 C/C++ 函数库提供的，它的机制是很复杂的。




17 什么是 KVC 和 KVO ? 答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 setValue 的时候，(1)首先根据方法名找到运行方法的时候所需要的环 境参数。(2)他会 从自己 isa 指针结合环境参数，找到具体的方法实现的接口。 ( 3 )再直接查找得来的具体的 方法实现。 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，被观 察对象的 isa 指针被修改的时候， isa 指针就会指向一个中间类， 而不是真实的类。 所以 isa 指针其实不需要指向实例对象真实的类。 所以我们的程序最好不要依赖于 isa 指针。在调用 类的方法的时候，最好要明确对象实例的类名
18ViewController 的 loadView, viewDidLoad, viewDidUnload 分别是在什么时候调用的? 在自定义 ViewController 的时候这几个函数里面应该做什么工作?答: viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。此方法在编程实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release, 如果
是 retain 的 IBOutlet view 属性则不要在这里 19
"NSMutableString *" 这个数据类型则是代表 的。
release,IBOutlet 会负责 release 。
"NSMutableString" 对象本身，这两者是有区别
而 NSString 只是对象的指针而已。 面向过程就是分析出解决问题所需要的步骤， 时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象， 为了描叙某个事物在整个解决问题的步骤中的行为。 ; 20 类别的作用
类别主要有 3个作用:
(1)将类的实现分散到多个不同文件或多个不同框架中。
(2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。
类别的局限性
有两方面局限性:
(1)无法向类中添加新的实例变量，类别没有位置容纳实例变量。 (2)名称冲突，即当类别中的方法与原始类方法名称冲突时，类别具有更高的优先级。类别 方法将完全取代初始方法从而无法再使用初始方法。 无法添加实例变量的局限可以使用字典对象解决
然后用函数把这些步骤一步一步实现， 使用的
建立对象的目的不是为了完成一个步骤， 而是



类别的作用?继承和类别在实现中有何区别?答案: category 可以在不获 悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类 别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 因为类别具有更高的优先级。

 类别主要有 3个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。继承可以增加，修改或者删除方法，并且可以增加属性。
25 .Difference between categories and extensions?
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须 要实现的。
extensions 可以认为是一个私有的 Category 。
26 .Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?答案: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。 其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也 写在了学习教程里 “非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法， 你 可以使用他们更好的完成工作”。 这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去实现。 然后你在后期可以直接使用这些更好的方法。 这么看， 总觉得类别这玩意儿有点像协议的可选协议。 "现在来看，其实 protocal 已经开始对两者都 统一和规范起来操作，因为资料中说“非正式协议使用 interface 修饰“，现在我们看到协 议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。

27What is purpose of delegates? 代理的作用?答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。 可以减少框架复 杂度。另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
28What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。答案:可修改不可修改的集合类。这个我个人简单理解就 是可动态添加修改和不可动态添加修改一样。 比如 NSArray 和 NSMutableArray 。前者在初 始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动 态运行时语言是什么意思?答案:多态。 主要是将数据类型的确定由编译时，推迟到了运
行时。 这个问题其实浅涉及到两个概念， 运行时和多态。 简单来说，运行时机制使我们直到 运行时才去决定一个对象的类别， 以及调用该类别对象指定方法。 多态: 不同对象以自己的 方式响应相同的消息的能力叫做多态。意思就是假设生物类( life )都用有一个相同的方法 -eat;那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们 只需调用各自的 eat 方法。也就是不同的对象以自己的方式响应了相同的消息(响应了 eat 这个选择器) 。因此也可以说，运行时机制是多态的基础? ~~~
通知和协议的不同之处? (专业术语了 ~ )。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解简
30 what is difference between NSNotification and protocol?
答案:协议有控制链 (has-a) 的关系，通知没有。首先我一开始也不太明白，什么叫控制链

 单来说，通知的话， 它可以一对多， 一条消息可以发送给多个消息接受者。 代理按我们的理 解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候一个经济人负责 好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的， 一一对应， 不可 能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的发布会 了。但是通知就不一样， 他只关心发出通知， 而不关心多少接收到感兴趣要处理。 因此控制 链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。


36 NSOperation queue? 答案:存放 NSOperation 的集合类。操作和操作队列，基本可 以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发的问题。网上部分资料提
到一点是， 虽然是 queue ，但是却并不是带有队列的概念， 放入的操作并非是按照严格的先 进现出。这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行， 因此队列的概念离乱上有点违背了多线程处理这个概念。 但是转念 一想其实可以参考银行的取票和叫号系统。因此对于 A 比 B 先排队取票但是 B 率先执行完 操作， 我们亦然可以感性认为这还是一个队列。 但是后来看到一票关于这操作队列话题的文

 章，其中有一句提到
“因为两个操作提交的时间间隔很近， 线程池中的线程， 谁先启动是不定的。 ”瞬间觉得这 个 queue 名字有点忽悠人了， 还不如 pool~ 综合一点， 我们知道他可以比较大的用处在于可 以帮组多线程编程就好了。
37What is lazy loading? 答案:懒汉模式，只在用到的时候才去初始化。也可以理解成 延时加载。 我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时
载，避免内存过高，一个异步加载，避免线程堵塞。
38 Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制
器中嵌入两个 tableview 控制器?答案:一个视图控制只提供了一个 View 视图，理论上一 个 tableViewController 也不能放吧，只能说可以嵌入一个 tableview 视图。当然，题目本身 也有歧义，如果不是我们定性思维认为的 UIViewController ，而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如
TabbarController 那样的感觉。
39 Can we use one tableview with two different datasources? How you will achieve
this? 一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?答案: 首先我们从代 码来看， 数据源如何关联上的， 其实是在数据源关联的代理方法里实现的。 因此我们并不关 心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的需要去设置如相关的数据源。 因此， 我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢?想让列表如何显 示，不同的数据源分区块显示?
40id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object 的一个指针，这 个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject )类的对象。需 要注意的是 id 是一个指针，所以你在使用 id 的时候不需要加星号。比如 id foo=nil 定义了 一个 nil 指针，这个指针指向 NSObject 的一个任意子类。而 id *foo=nil 则定义了一个指针， 这个指针指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C 语言的 NULL 相同，在 objc/objc.h 中定义。 nil 表示一个 Objctive-C 对象，这个对 象的指针指向空(没有东西就是空) 。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类(是 Class ，而不是对象) 。 SEL 是“ selector ”的一个类型，表示一个方法的名字
Method (我们常说的方法)表示一种类型，这种类型与 selector 和实现 (implementation) 相关
IMP 定义为 id (*IMP ) (id, SEL , , )。这样说来， IMP 是一个指向函数的指针，这个被指向 的函数包括 id( “ self ”指针 ) ，调用的 SEL (方法名) ，再加上一些其他参数 .说白了 IMP 就

 是实现方法。
41 层和 UIView 的区别是什么?
答:两者最大的区别是 ,图层不会直接渲染到屏幕上， UIView 是 iOS 系统中界面元素的基础， 所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图 部分，是由一个 CALayer 类来管理。UIView 本身更像是一个 CALayer 的管理器。一个 UIView 上可以有 n 个 CALayer ，每个 layer 显示一种东西，增强 UIView 的展现能力。
42GCD 为 Grand Central Dispatch 的缩写。 Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的较新的解决方法。在 Mac OS X 10.6 雪豹中首次推出，并在最 近引入到了 iOS4.0 。 GCD 是一个替代诸如 NSThread 等技术的很高效和强大的技术。
GCD 完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。
GCD 可以完成很多事情， 但是这里仅关注在 iOS 应用中实现多线程所需的一些基础知识。 在开始之前，需要理解是要提供给 GCD 队列的是代码块，用于在系统或者用户创建的的队 列上调度运行。 声明一个队列
如下会返回一个用户创建的队列:
dispatch_queue_t myQueue = dispatch_queue_create("com.iphonedevblog.post", NULL); 其中，第一个参数是标识队列的，第二个参数是用来定义队列的参数(目前不支持，
因此传入 NULL )。 执行一个队列
 如下会异步执行传入的代码:
dispatch_async(myQueue, ^{ [self doSomething]; });
其中， 首先传入之前创建的队列， 然
后提供由队列运行的代码块。
声明并执行一个队列 如果不需要保留要运行的队列的引用，可以通过如下代码实现之前的功能:
dispatch_async(dispatch_queue_create ("com.iphonedevblog.post", NULL), ^{ [self
doSomething]; }); 如果需要暂停一个队列，可以调用如下代码。暂停一个队列会阻止和 该队列相关的所有代码运行。 dispatch_suspend(myQueue); 暂停一个队列 如果暂停一个队列不要忘记恢复。 暂停和恢复的操作和内存管理中的 retain 和 release 类似。 调用 dispatch_suspend 会增加暂停计数，而 dispatch_resume 则会减少。队列只有在暂停 计数变成零的情况下才开始运行。 dispatch_resume(myQueue); 恢复一个队列 从队 列中在主线程运行代码 有些操作无法在异步队列运行，因此必须在主线程(每个应用 都有一个)上运行。 UI 绘图以及任何对 NSNotificationCenter 的调用必须在主线程长进行。 在另一个队列中访问主线程并运行代码的示例如下:
dispatch_sync(dispatch_get_main_queue(), ^{ [self dismissLoginWindow]; }); 注意， dispatch_suspend (以及 dispatch_resume )在主线程上不起作用。
使用 GCD ，可以让你的程序不会失去响应 . 多线程不容易使用，用了 GCD ，会让它变得简

 单。你无需专门进行线程管理 , 很棒!
dispatch_queue_t t1=dispatch_queue_create ("1", NULL );
dispatch_queue_t t2= dispatch_queue_create ("2" , NULL ); dispatch_async (t1, ^{
[self print1 ]; });
dispatch_async (t2, ^{ [self print2 ];
});
43Provider 是指某个 iPhone 软件的 Push 服务器，这篇文章我将使用 .net 作为 Provider 。 APNS 是 Apple Push Notification Service ( Apple Push 服务器) 的缩写， 是苹果的服务器。
上图可以分为三个阶段。
第一阶段: .net 应用程序把要发送的消息、目的 iPhone 的标识打包，发给 段: APNS 在自身的已注册 Push 服务的 iPhone 列表中，查找有相应标识的 消息发到 iPhone 。 第三阶段: iPhone 把发来的消息传递给相应的应用程序， 定弹出 Push 通知。
http://blog.csdn.net/zhuqilin0/article/details/6527113 //消息推送机制 看内存泄露时候:在搜索中搜索 run 找到 Run Static Snalyzer .
APNS 。 第二阶 iPhone ，并把
并且按照设
44. 可扩展标记语言 extensible markup language;XML
2. 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一
种允许用户对自己的标记语言进行定义的源语言。
3，数据库提供了更强有力的 数据存储 和分析能力，例如:数据索引、排序、查找、相关一
致性等， XML 仅仅是存储数据。
4.XML 与 HTML 的设计区别是: XML 的核心是数据，其重点是数据的内容。而 HTML 被
设计用来显示数据，其重点是数据的显示。
5.XML 和 HTML 语法区别: HTML 的标记不是所有的都需要成对出现， XML 则要求所有的
标记必须成对出现; HTML 标记不区分大小写， XML 则 大小敏感 ,即区分大小写。 结合
XML 的简单使其易于在任何应用 程序 中读写数据， 这使 XML 很快成为数据交换的唯一 公共语言，虽然不同的 应用软件 也支持其它的数据交换格式，但不久之后他们都将支持
XML ，那就意味着程序可以更容易的与 Windows,Mac OS,Linux 以及其他平台下产生的信 息结合，然后可以很容易加载 XML 数据到程序中并分析他，并以 XML 格式输出结果。
XML 去掉了之前令许多开发人员头疼的 SGML (标准通用标记语言)的随意语法。在 XML 中，采用了如下的语法:

 1 任何的起始标签都必须有一个结束 标签。
2 可以采用另一种简化语法，可以在一个标签中同时表示起始和结束标签。这种语法 是在大于符号之前紧跟一个斜线 (/)，例如 <tag/ > 。XML 解析器会将其翻译成 <tag></tag> 。
3 标签必须按合适的顺序进行 嵌套 ，所以结束标签必须按 镜像 顺序匹配起始标签，例 如 this is a sample string 。这好比是将起始和结束标签看作是数学中的左右括号:在没有 关闭所有的内部括号之前，是不能关闭外面的括号的。
4 所有的特性都必须有值。
5 所有的特性都必须在值的周围加上双引号。 45union u
{
double a;
int b; };
union u2 {
char a[13];
int b; };
union u3 {
char a[13];
char b; };
cout<<sizeof(u)<<endl; // 8 cout<<sizeof(u2)<<endl; // 16 cout<<sizeof(u3)<<endl; // 13
都知道 union 的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以
对于 u 来说， 大小就是最大的 double 类型成员 a 了，所以 sizeof(u)=sizeof(double)=8 。但 是对于 u2 和 u3 ，最大的空间都是 char[13] 类型的数组，为什么 u3 的大小是 13 ，而 u2 是 16 呢?关键在于 u2 中的成员 int b 。由于 int 类型成员的存在， 使 u2 的对齐方式变成 4，也就是 说， u2的大小必须在 4的对界上，所以占用的空间变成了 16(最接近 13 的对界)。 struct s1
{

 char a; double b; int c; char d;
};
struct s2 {
char a; char b; int c; double d;
};
cout<<sizeof(s1)<<endl; // 24 cout<<sizeof(s2)<<endl; // 16
同样是两个 char 类型，一个 int 类型， 一个 double 类型， 但是因为对界问题， 导致他 们的大小不同。计算结构体大小可以采用元素摆放法，我举例子 说明一下:首先， CPU 判 断结构体的对界，根据上一节的结论， s1和 s2 的对界都取最大的元素类型，也就是 double 类型的对界 8。然后开始摆放每个元 素。
对于 s1，首先把 a 放到 8的对界， 假定是 0，此时下一个空闲的地址是 1，但是下一个元 素 d 是 double 类型，要放到 8的对界 上，离 1最接近的地址是 8了，所以 d 被放在了 8，此 时下一个空闲地址变成了 16，下一个元素 c 的对界是 4，16 可以满足，所以 c 放在了 16，此 时下一个空 闲地址变成了 20 ，下一个元素 d 需要对界 1 ，也正好落在对界上，所以 d 放在 了 20 ，结构体在地址 21 处结束。由于 s1 的大小需要是 8 的倍数，所以 21- 23 的空间被保留， s1的大小变成了 24。
对于 s2，首先把 a 放到 8的对界， 假定是 0，此时下一个空闲地址是 1，下一个元素的对 界也 是 1，所以 b 摆放在 1，下一个空闲地址变成了 2 ;下一个元素 c 的对界是 4 ，所以取离
2最近的地址 4摆放 c，下一个空闲地址变成了 8 ，下一个元素 d 的对界是 8 ，所以 d 摆放在 8，所有元素摆放完毕，结构体在 15处结束，占用总空间为 16，正好是 8的倍数。
46 ASIDownloadCache 设置下载缓存
它对 Get 请求的响应数据进行缓存(被缓存的数据必需是成功的 200请求):
[ASIHTTPRequest setDefaultCache:[ASIDownloadCache sharedCache]];

 当设置缓存策略后，所有的请求都被自动的缓存起来。 另外，如果仅仅希望某次请求使用缓存操作，也可以这样使用:
ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url]; [request setDownloadCache:[ASIDownloadCache sharedCache]];
缓存存储方式
你可以设置缓存的数据需要保存多长时间， ASIHTTPRequest 提供了两种策略:
a， ASICacheForSessionDurationCacheStoragePolicy ，默认策略，基于 session 的缓存数 据存储。当下次运行或 [ASIHTTPRequest clearSession] 时，缓存将失效。
b， ASICachePermanentlyCacheStoragePolicy ，把缓存数据永久保存在本地， 如:
ASIHTTPRequest *request = [ ASIHTTPRequest requestWithURL:url ];
[ request setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy ];
47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒 体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基
于 TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制， 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速: 客户向服务器请求服务时， 只需传送请求方法和路径。 HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于 得 HTTP 服务器的程序规模小，因而通信速度很快。
3.灵活: HTTP 允许传输任意类型的数据对象。正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
48 URL
HTTP URL (URL 是一种特殊类型的 URI 是他的子类， 包含了用于查找某个资源的足够的信
息 ) 的格式如下: http://host[":"port][abs_path ]
绝大多数的 Web 开发， 都
请求方法常用的有 GET 、 HTTP 协议简单，使
Content-Type 加以标记。

 http 表示要通过 HTTP 协议来定位网络资源; host 表示合法的 Internet 主机域名或者 IP 地 址; port 指定一个端口号，为空则使用缺省端口 80 ; abs_path 指定请求资源的 URI ;如果
URL 中没有给出 abs_path ，那么当它作为请求 URI 时，必须以“ /”的形式给出，通常这 个工作浏览器自动帮我们完成。
49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才
能建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包; 2. 主机 B 向主机 A 发送同意连接和要求同步(同步就是两台主机一个在发送，一个在接收，
协调工作)的数据包; 3.主机 A 再发出一个数据包确认主机 B 的要求同步:“我现在就发， 你接着吧! ”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步， 经过 三次“对话”之后，主机 A 才向主机 B 正式发送数据。
UDP ( User Data Protocol ，用户数据报协议)是与 TCP 协议，它不与对方建立连接，而是直接就把数据包发送过去! 量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接 面向连接 面向非连接 传输可靠性 可靠 不可靠
应用场合 传输大量数据 少量数据 速度 慢 快
50 socket 连接和 http 连接的区别
简单说，你浏览的网页(网址以 http:// 开头 )都是 http 协议传输到你的浏览器的 基于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层 ip 协议: 对应于网络层
, 而 http 是 连接的
相对应的协议。它是面向非连接的 UDP 适用于一次只传送少

 TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open – > 读写
write/read – > 关闭 close ”模式来操作。我的理解就是 Socket 就是该模式的一个实现，
socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO 、打开、关 闭)，这些函数我们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协 议，但是那样的话， 如果没有应用层， 便无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自 己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使 用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车， 提供了封装或者显示数据的具体形式; Socket 是发动机， 提供了网络通信
的能力。 )
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数
接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;第二次握手:服务器收到 syn 包，必须确认客户的 SYN (ack=j+1 )，同时自己也发送 一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:

 客户端收到服务器的 SYN +ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包发送完毕， 客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过“四次握手” (过程就不细写了， 就是服务器和客户端交互， 最终确定断 开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字， 其中一个运行于客户端， 称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址 和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。
53 进程与线程
进程( process )是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为
一些功能单元。
进程中所包含的一个或多个执行单元称为线程( thread )。进程还拥有一个私有的虚拟地址 空间，该空间仅能被它所包含的线程访问。
通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。 在引入线程的操作系统中， 通常都是把进程作为分配资源的基本单位， 而把线程作为独立运
行和独立调度的基本单位。
由于线程比进程更小， 基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多， 能 更高效的提高系统内多个程序间并发执行的程度。
简而言之 ,一个程序至少有一个进程 , 一个进程至少有一个线程 .一个程序就是一个进程， 而一 个程序中的多个任务则被称为线程。

 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。当操作系统创建一个进程 后，该进程会自动申请一个名为主线程或首要线程的线程。应用程序( application )是由一 个或多个相互协作的进程组成的。
另外， 进程在执行过程中拥有独立的内存单元， 而多个线程共享内存， 从而极大地提高了程 序的运行效率。 线程在执行过程中与进程还是有区别的。 每个独立的线程有一个程序运行的 入口、 顺序执行序列和程序的出口。 但是线程不能够独立执行，必须依存在应用程序中，由 应用程序提供多个线程执行控制。 从逻辑角度来看， 多线程的意义在于一个应用程序中， 有 多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用， 来实现进 程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动 ,进程是系统进行资源 分配和调度的一个独立单位 .线程是进程的一个实体 ,是 CPU 调度和分派的基本单位 ,它是比
进程更小的能独立运行的基本单位 .线程自己基本上不拥有系统资源 ,只拥有一点在运行中 必不可少的资源 ( 如程序计数器 ,一组寄存器和栈 ), 但是它可与同属一个进程的其他的线程共 享进程所拥有的全部资源 .一个线程可以创建和撤销另一个线程 ;同一个进程中的多个线程 之间可以并发执行 .
54 多线程
多线程编程是防止主线程堵塞， 增加运行效率等等的最佳方法。 而原始的多线程方法存在很
多的毛病，包括线程锁死等。在 Cocoa 中， Apple 提供了 NSOperation 这个类，提供了一 个优秀的多线程编程方法。
本次介绍 NSOperation 的子集，简易方法的 NSInvocationOperation :
一个 NSOperationQueue 操作队列，就相当于一个线程管理器，而非一个线程。因为你可 以设置这个线程管理器内可以并行运行的的线程数量等等
55oc 语法里的 @perpoerty 不用写 @synzhesize 了，自动填充了。并且的 _name; 写方法时候不用提前声明。 llvm 全局方法便利。
枚举类型。
下拉刷新封装好了。
UICollectionViewController. 可以把表格分成多列。
Social Framework( 社交集成 )
enum hello:Integer{ } 冒号后面直接可以跟类型，以前是: 后面在指定为 Integer .
自动 release retain 的时候 CFString CFArray . Core Fountion. 加上桥接 _brige 才能区分 CFString 和 NSString 而现在自动区分了，叫固定桥接。
enum hello{} 桥接。 ARC

 UIActivityViewController 来询问用户的社交行为
缓存: 就是存放在临时文件里， 比如新浪微博请求的数据，和图片，下次请求看这里有没有 值。
56Singleton (单例模式)，也叫单子模式，是一种常用的软件设计模式。在应用这个模 式时，单例对象的类必须保证只有一个实例存在。
代码如下:
static ClassA *classA = nil + (ClassA *)sharedManager
{
@synchronized(self) { if (!classA) {
; //静态的该类的实例
classA = [[super allocWithZone:NULL]init]; }
return classA;
}
}
+ (id)allocWithZone:(NSZone *)zone { return [[self sharedManager] retain];
}
- (id)copyWithZone:(NSZone *)zone { return self;
}
- (id)retain {
return self;
}
- (NSUIntger)retainCount { return NSUIntgerMax;
}
- (oneway void)release { }
- (id)autorelease { return self;
}
-(void)dealloc{
}

 57 请写一个 C 函数，若处理器是 返回 1 int checkCPU( ) {
Big_endian
的，则返回
0 ;若是
Little_endian 的，则
} }
{
union w
{
c.a = 1; return (c.b ==1);
a; | |
--------- 如果是小端如何存储
| | -------------------- |A
char b; } c;
------------------- |A |A+1 |A+2
地址 A ----------- |A+3 | int a;
|0x01 |0x00 |0x00
|0x00 | ------------------------------------- |A
|char b; |
| ---------
int a;
剖析: 嵌入式系统开发者应该对
Little-endian 模式的 CPU 对操作数的存放方式是从低字节到高字节， Big-endian 模式的
CPU 对操作数的存放方式是从高字节到低字节。 在弄清楚这个之前要弄清楚这个问题: 字 节从右到坐为从高到低 ! 假设从地址 0x4000 开始存放 : 0x12345678, 是也个 32 位四个字节的 数据，最高字节是 0x12, 最低字节是 0x78 : 在 Little-endian 模式 CPU 内存中的存放方式为:
( 高字节在高地址 , 低字节在低地址 )
内存地址 0x4000 0x4001 0x4002 0x4003 存放内容 0x78 0x56 0x34 0x12 大端机则相反。
有的处理器系统采用了小端方式进行数据存放，如 Intel 的奔腾。有的处理器系统采用了大 端方式进行数据存放，如 IBM 半导体和 Freescale 的 PowerPC 处理器。不仅对于处理器， 一些外设的设计中也存在着使用大端或者小端进行数据存放的选择。 因此在一个处理器系 统中， 有可能存在大端和小端模式同时存在的现象。 这一现象为系统的软硬件设计带来了不 小的麻烦， 这要求系统设计工程师， 必须深入理解大端和小端模式的差别。 大端与小端模式 的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。 联合体 union 的
c.a 的呢?
Little-endian
和 Big-endian
模式非常了解。采用
存放顺序是所有成员都从低地址开始存放的。 以上是网上的原文。让我们看看在
理器上 union 是如何存储的呢 ? 地址 A ---------------- |A
ARM 处 |A+1 |A+2 |A+3 |int
|char b; | |

 地址 A ---------------------
--------- |A |A+1 |A+2 |A+3 |int a; |0x00
|0x01
| ------------------------------------------ |A |char b; | 现在知道为什么 c.b==0 的话是大端， c.b==1 的话就是小端了吧。
58
59 什么是指针的释放 ? 具体来说包括两个概念 .
1 释放该指针指向的内存 ,只有堆上的内存才需要我们手工释放 2 将该指针重定向为 NULL.
,栈上不需要 .
60 数据结构中的指针 ?
其实就是指向一块内存的地址 7 函数指针 ? 指向一块函数的入口地址 .
,通过指针传递 , 可实现复杂的内存访问 .
8 指针作为函数的参数 ? 比如指向一个复杂数据结构的指针作为函数变量 这种方法避免整个复杂数据类型内存的压栈出栈操作 注意 :指针本身不可变 ,但指针指向的数据结构可以改变
9 指向指针的指针 ?
指针指向的变量是一个指针 ,即具体内容为一个指针的值
此时指针指向的变量长度也是 4位 . 61 指针与地址的区别 ?
区别 :
1指针意味着已经有一个指针变量存在 ,他的值是一个地址
如果是大端如何存储
c.a 的呢?
|0x00 |0x00
堆和栈上的指针
指针所指向的这块内存是在哪里分配的 ,在堆上称为堆上的指针 ,在栈上为栈上的指针 . 在堆上的指针 , 可以保存在全局数据结构中 ,供不同函数使用访问同一块内存 . 在栈上的指针 , 在函数退出后 ,该内存即不可访问 .
,指针变量本身也存放在一个长度 为四个字节的地址当中 , 而地址概念本身并不代表有任何变量存在 .
2 指针的值 , 如果没有限制 , 通常是可以变化的 ,也可以指向另外一个地址 . 地址表示内存空间的一个位置点 ,他是用来赋给指针的 ,地址本身是没有大小概念 ,指针指
向变量的大小 , 取决于地址后面存放的变量类型 . 62 指针与数组名的关系 ?
,提高效率 . .
| ---------
,是一个地址 .

 其值都是一个地址 ,但前者是可以移动的 , 后者是不可变的 .
12 怎样防止指针的越界使用问题 ? 必须让指针指向一个有效的内存地址 ,
1 防止数组越界
2 防止向一块内存中拷贝过多的内容 3 防止使用空指针
4 防止改变 const 修改的指针
5 防止改变指向静态存储区的内容
6 防止两次释放一个指针
7 防止使用野指针 .
13 指针的类型转换 ?
指针转换通常是指针类型和 void * 类型之前进行强制转换 数进行正确的交接 .
63static 有什么用途?(请至少说明两种) 1. 限制变量的作用域
,从而与期望或返回
void 指针的函
2. 设置变量的存储域
7. 引用与指针有什么区别?
1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。 2) 不存在指向空值的引用，但是存在指向空值的指针。
8. 描述实时系统的基本特性 在特定时间内完成特定的任务，实时性与可靠性
64 全局变量和局部变量在内存中是否有区别?如果有，是什么区别? 全局变量储存在静态数据库，局部变量在堆栈
10. 什么是平衡二叉树?
左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于
65 堆栈溢出一般是由什么原因导致的? 没有回收垃圾资源
12. 什么函数不能声明为虚函数? constructor
13. 冒泡排序算法的时间复杂度是什么?
O(n^2)
14. 写出 float x 与“零值”比较的 if 语句。
1

 之后才能区
if(x>0.000001&&x<-0.000001)
16. Internet 采用哪种网络协议?该协议的主要层次结构?
tcp/ip 应用层 /传输层 /网络层 / 数据链路层 / 物理层
17. Internet 物理地址和 IP 地址转换采用什么协议?
ARP (Address Resolution Protocol) (地址解析協議)
18.IP 地址的编码分为哪俩部分?
IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上
分哪些是网络位哪些是主机位。
2.用户输入 M,N 值，从 1至 N 开始顺序循环数数，每数到 至全部输出。写
M 输出该数值，直
变量，而
的局部变
域就在那
来引用某个
如果你
而在连接期
会用到同名的局部 不会用到全局变量。 对于有些编译器而言， 在同一个函数内可以定义多个同名
出 C 程序。
循环链表，用取余操作做
3. 不能做 switch() 的参数类型是:
switch 的参数不能为实型。
華為
1 、局部变量能否和全局变量重名? 答:能，局部会屏蔽全局。要用全局变量，需要使用 "::" 局部变量可以与全局变量同名， 在函数内引用这个变量时，
量，比如在两个循环体内都定义一个同名的局部变量，
而那个局部变量的作用
个循环体内
2 、如何引用一个已经定义过的全局变量?
答: extern
可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式
在头文件中声明的全局变理， 假定你将那个变写错了， 那么在编译期间会报错， 用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，
间报错
3、全局变量可不可以定义在可被多个 .C 文件包含的头文件中?为什么? 答:可以，在不同的 C 文件中以 static 形式来声明同名全局变量。

 中对此变量赋
可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件
初值，此时连接不会出错
4 、语句 for( ; 1 ; ) 有什么问题?它是什么意思? 答:和 while(1) 相同。
5、do,, while 和 while ,, do 有什么区别? 答:前一个循环一遍再判断，后一个判断以后再循环
661.IP Phone 的原理是什么 ? IPV6
发执行 以访问隶属
致系统的开
2.TCP/IP 通信建立的过程怎样，端口有什么作用? 三次握手，确定是哪个应用程序使用该协议
3.1号信令和 7号信令有什么区别，我国某前广泛使用的是那一种?
4.列举 5种以上的电话新业务?
微软亚洲技术中心的面试题! !!
1 .进程和线程的差别。
线程是指进程内的一个执行单元 , 也是进程内的可调度实体 . 与进程的区别 :
(1) 调度:线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 (2) 并发性:不仅进程之间可以并发执行，同一个进程的多个线程之间也可并
(3) 拥有资源:进程是拥有资源的一个独立单位，线程不拥有系统资源，但可 于进程的资源 .
(4) 系统开销:在创建或撤消进程时，由于系统都要为之分配和回收资源，导
销明显大于创建或撤消线程时的开销。 2. 测试方法 人工测试:个人复查、抽查和会审 机器测试:黑盒测试和白盒测试 2.Heap 与 stack 的差别。
Heap 是堆， stack 是栈。
Stack 的空间由操作系统自动分配
Stack 空间有限， Heap 是很大的自由存储区
C 中的 malloc 函数分配的内存空间即在堆上 ,C++ 中对应的是 new 操作符。 程序在编译期对变量和函数分配内存都在栈上进行 , 且程序运行过程中函数调
用时参数的
/释放， Heap 上的空间手动分配 /释放。

 开一个窗
传递也在栈上进行
3 . Windows 下的内存是如何管理的?
4.介绍 .Net 和.Net 的安全性。
5.客户端如何访问 .Net 组件实现 Web Service ?
6.C/C++ 编译器中虚表是如何完成的?
7 .谈谈 COM 的线程模型。然后讨论进程内 / 外组件的差别。
8 .谈谈 IA32 下的分页机制
小页 (4K) 两级分页模式，大页 (4M) 一级
9 .给两个变量，如何找出一个带环单链表中是什么地方出现环的? 一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方
10.在 IA32中一共有多少种办法从用户态跳到内核态?
通过调用门，从 ring3 到 ring0 ，中断从 ring3 到 ring0 ，进入 vm86 等等
11.如果只想让程序有一个实例运行，不能运行两个。像
口，怎样实现?
用内存映射或全局原子(互斥变量) 、查找窗口句柄 .. FindWindow ，互斥，写标志到文件或注册表 ,共享内存。
winamp 一样，只能
67如何截取键盘的响应，让所有的‘ a’变成‘ b’? 键盘钩子 SetWindowsHookEx
行一次后，
复制品。 同进程的其
而进程
13 . Apartment 在 COM 中有什么用?为什么要引入?
14 .存储过程是什么?有什么用?有什么优点?
我的理解就是一堆 sql 的集合，可以建立非常复杂的查询，编译运行，所以运
以后再运行速度比单独执行 SQL 快很多
15 . Template 有什么特点?什么时候用?
16 .谈谈 Windows DNA 结构的特点和优点。 网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别? 1 ，进程:子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的
2 ，线程:相对与进程而言，线程是一个更加接近与执行体的概念，它可以与
他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。 线程和进程在使用上各有优缺点: 线程执行开销小， 但不利于资源管理和保护;
正相反。同时，线程适合于在 SMP 机器上运行，而进程则可以跨机器迁移。

 思科 68 2. 找错题
试题 1:
void test1()
{
char string[10];
char* str1 = "0123456789"; strcpy( string, str1 );
}
试题 2:
void test2()
{
char string[10], str1[10]; int i;
for(i=0; i<10; i++)
{
str1 = 'a'; } strcpy( string, str1 ); }
试题 3:
void test3(char* str1) {
char string[10];
if( strlen( str1 ) <= 10 ) {
strcpy( string, str1 ); }
}
试题 1字符串 str1需要11个字节才能存放下 (包括末尾的’ \0’)，而 string 只有 10个字 节的空间， strcpy 会导致数组越界;
解答:

 对试题 2，如果面试者指出字符数组 str1 不能在数组内结束可以给 3分;如果面试者指出 strcpy(string, str1) 调用使得从 str1[url=] 内存 [/url] 起复制到 string 内存起所复制的字节数具
有不确定性可以给 7分，在此基础上指出库函数 strcpy 工作方式的给
对试题 3 ， if(strlen(str1) <= 10) 计’ \0’所占用的 1个字节。
剖析:
考查对基本功的掌握:
(1) 字符串以’ \0 ’结尾;
(2) 对数组越界把握的敏感度;
应改为 if(strlen(str1) < 10)
的结果未统
(3) 库函数 strcpy 的工作方式，如果编写一个标准 strcpy 几个不同得分的答案:
函数的总分值为
10 ，下面给出
2分
void strcpy( char *strDest, char *strSrc ) {
while( (*strDest++ = * strSrc++) !=
}
4分
‘\0’ );
void strcpy( char *strDest, const char *strSrc ) //将源字符串加 const ，表明其为输入参数，加 2分
{
while( (*strDest++ = * strSrc++) != ‘\0’ );
}
7分
void strcpy(char *strDest, const char *strSrc) {
//对源地址和目的地址加非 0断言，加 3分
10 分; ，因为 strlen

 assert( (strDest != NULL) && (strSrc != NULL) ); while( (*strDest++ = * strSrc++) != ‘\0’ );
}
10分
//为了实现链式操作，将目的地址返回，加 3分!
char * strcpy( char *strDest, const char *strSrc ) {
assert( (strDest != NULL) && (strSrc != NULL) ); char *address = strDest;
while( (*strDest++ = * strSrc++) != ‘\0’ );
return address; }
从2分到10分的几个答案我们可以清楚的看到，小小的 真不是盖的!需要多么扎实的基本功才能写一个完美的
strcpy 竟然暗藏着这么多玄机， strcpy 啊!
(4) 对 strlen 的掌握，它没有包括字符串末尾的 '\0' 。
读者看了不同分值的 strcpy 版本，应该也可以写出一个 10 分的 strlen 函数了，完美的
版本为: int strlen( const char *str ) // 输入参数 const
{
len++; }
return len; }
试题 4:
void GetMemory( char *p )
{
p = (char *) malloc( 100 );
断言字符串地址非 0
assert( strt != NULL ); // int len;
while( (*str++) != '\0' )
{

 }
void Test( void )
{
char *str = NULL; GetMemory( str );
strcpy( str, "hello world" ); printf( str );
}
试题 5:
char *GetMemory( void )
{
char p[] = "hello world";
return p; }
void Test( void )
{
char *str = NULL;
str = GetMemory(); printf( str );
}
试题 6:
void GetMemory( char **p, int num )
{
*p = (char *) malloc( num );
}
void Test( void ) {
char *str = NULL; GetMemory( &str, 100 ); strcpy( str, "hello" ); printf( str );

 }
试题 7:
void Test( void ) {
char *str = (char *) malloc( 100 );
strcpy( str, "hello" ); free( str );
... // 省略的其它语句
}
试题 4传入中 GetMemory( char *p ) 函数的形参为字符串指针，在函数内部修改形参并 不能真正的改变传入形参的值，执行完
char *str = NULL; GetMemory( str );
后的 str 仍然为 NULL ; 试题 5中
char p[] = "hello world"; return p;
的 p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序 员常犯的错误，其根源在于不理解变量的生存期。
试题 6的 GetMemory 避免了试题 4 的问题，传入 GetMemory 的参数为字符串指针的指 针，但是在 GetMemory 中执行申请内存及赋值语句
*p = (char *) malloc( num );
  后未判断内存是否申请成功，应加上:
if ( *p == NULL ) {
...// 进行申请内存失败处理 }
解答:

 试题 7存在与试题 6同样的问题，在执行
char *str = (char *) malloc(100);
后未进行内存是否申请成功的判断;另外，在 free(str) 后未置 str 为空，导致可能变成
一个“野”指针，应加上:
str = NULL;
试题 6的 T est 函数中也未对 malloc 的内存进行释放。
剖析:
试题 4~ 7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回
答其中 50~60 的错误。但是要完全解答正确，却也绝非易事。 对内存操作的考查主要集中在:
( 1)指针的理解;
( 2)变量的生存期及作用范围;
( 3)良好的动态内存申请和释放习惯。 再看看下面的一段程序有什么错误:
swap( int* p1,int* p2 ) {
int *p;
*p = *p1; *p1 = *p2; *p2 = *p;
}
在 swap 函数中， p 是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在
VC++ 中 DEBUG 运行时提示错误“ Access Violation ”。该程序应该改为:
swap( int* p1,int* p2 ) {

 int p;
p = *p1; *p1 = *p2; *p2 = p;
} [img=12,12]file:///D:/ 鱼鱼软件 /鱼鱼多媒体日记本 /temp/{56068A28-3D3B-4D8B-9F82-AC1C3E9B128C}_arc_d[1].gif[/img]
题 1 :分别给出 BOOL ，int ，float ，指针变量 解答:
与“零值”比较的
3. 内功题
if 语句(假设变量名为
试 var )
BOOL 型变量: if(!var)
int 型变量: if(var==0)
float 型变量:
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON) 指针变量: if(var==NULL)
剖析:
考查对 0值判断的“内功”， BOOL 型变量的 0判断完全可以写成 if(var==0) ，而 int 型 变量也可以写成 if(!var) ，指针变量的判断也可以写成 if(!var) ，上述写法虽然程序都能正确 运行，但是未能清晰地表达程序的意思。
一般的，如果想让 if 判断一个变量的“真”、“假”，应直接使用 if(var) 、if(!var) ，表明 其为“逻辑”判断; 如果用 if 判断一个数值型变量 (short 、int 、long 等 )，应该用 if(var==0) ， 表明是与 0进行“数值”上的比较;而判断指针则适宜用 if(var==NULL) ，这是一种很好的 编程习惯。
浮点型变量并不精确，所以不可将 float 变量用“ == ”或“! =”与数字比较，应该设 法转化成“ >=”或“ <=”形式。如果写成 if (x == 0.0) ，则判为错，得 0分。
试题 2:以下为 Windows NT 下的 32 位 C++ 程序，请计算 sizeof 的值

 void Func ( char str[100] ) {
sizeof( str ) = ? }
void *p = malloc( 100 ); sizeof ( p ) = ?
解答:
sizeof( str ) = 4 sizeof ( p ) = 4
剖析:
函数中数组名作为函数形参时，在函数体内，数组名失去了本身 的内涵，仅仅只是一个指针;在失去其内涵的同时，它还失去了其常量特性，可以作自增、
自减等操作，可以被修改。 数组名的本质如下:
( 1)数组名指代一种数据结构，这种数据结构就是数组; 例如:
char str[10];
cout << sizeof(str) << endl;
输出结果为 10 ， str 指代数据结构 char[10] 。
( 2)数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、
自减等操作，不能被修改;
char str[10];
str++; // 编译出错，提示 str 不是左值
( 3)数组名作为函数形参时，沦为普通指针。
Windows NT 32 位平台下，指针的长度(占用内存的大小)为 4字节，故 sizeof( str ) 、
Func ( char str[100] )

 sizeof ( p ) 都为 4。
试题 3:写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。另外，当你
写下面的代码时会发生什么事?
least = MIN(*p++, b);
解答:
#define MIN(A,B) ((A) <= (B) ? (A) : (B)) MIN(*p++, b) 会产生宏的副作用
剖析:
这个面试题主要考查面试者对宏定义的使用， 它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参 数”进行的是一对一的替换。
  程序员对宏定义的使用要非常小心，特别要注意两个问题:
( 1)谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述 解答:
#define MIN(A,B) (A) <= (B) ? (A) : (B) #define MIN(A,B) (A <= B ? A : B )
都应判 0分;
( 2)防止宏的副作用。
宏定义 #define MIN(A,B) ((A) <= (B) ? (A) : (B))
((*p++) <= (b) ? (*p++) : (*p++))
对 MIN(*p++, b) 的作用结果是:
这个表达式会产生副作用，指针 p会作三次 ++自增操作。 除此之外，另一个应该判 0分的解答是:
宏定义可以实现类似于函数的功能， 但是

 #define MIN(A,B) ((A) <= (B) ? (A) : (B));
这个解答在宏定义的后面加“ ;”， 显示编写者对宏的概念模糊不清， 只能被无情地判 0
分并被面试官淘汰。
试题 4:为什么标准头文件都有类似以下的结构?
#ifndef __INCvxWorksh #define __INCvxWorksh #ifdef __cplusplus
extern "C" { #endif
/*...*/
#ifdef __cplusplus }
#endif
#endif /* __INCvxWorksh */
解答: 头文件中的编译宏
#ifndef __INCvxWorksh #define __INCvxWorksh #endif
的作用是防止被重复引用。
作为一种面向对象的语言， C++ 支持函数重载， 而过程式语言 C 则不支持。 函数被 C++
编译后在 symbol 库中的名字与 C 语言的不同。例如，假设某个函数的原型为:
void foo(int x, int y);
该函数被 C 编译器编译后在 symbol 库中的名字为 _foo ，而 C++ 编译器则会产生像
_foo_int_int 之类的名字。 _foo_int_int 这样的名字包含了函数名和函数参数数量及类型信 息， C++ 就是考这种机制来实现函数重载的。
为了实现 C 和 C++ 的混合编程， C++ 提供了 C 连接交换指定符号 extern "C" 来解决名

 字匹配问题， 函数声明前加上 extern "C" 后，则编译器就会按照 C 语言的方式将该函数编译 为_foo ，这样 C 语言中就可以调用 C++ 的函数了。 [img=12,12]file:///D:/ 鱼鱼软件 /鱼鱼多媒 体日记本 /temp/{C74A38C4-432E-4799-B54D-73E2CD3C5206}_arc_d[1].gif[/img]
试题 5:编写一个函数，作用是把一个 char 组成的字符串循环右移 n 个。比如原来是 “abcdefghi ”如果 n=2 ，移位后应该是“ hiabcdefgh ”
函数头是这样的:
//pStr 是指向以 '\0'结尾的字符串的指针 //steps 是要求移动的 n
void LoopMove ( char * pStr, int steps ) {
//请填充 ... }
解答:
正确解答 1:
void LoopMove ( char *pStr, int steps )
{
int n = strlen( pStr ) - steps;
char tmp[MAX_LEN];
strcpy ( tmp, pStr + n ); strcpy ( tmp + steps, pStr);
*( tmp + strlen ( pStr ) ) = '\0'; strcpy( pStr, tmp );
}
正确解答 2:
void LoopMove ( char *pStr, int steps ) {
int n = strlen( pStr ) - steps; char tmp[MAX_LEN];
memcpy( tmp, pStr + n, steps ); memcpy(pStr + steps, pStr, n );

 memcpy(pStr, tmp, steps ); }
剖析:
这个试题主要考查面试者对标准库函数的熟练程度， 程度上简化程序编写的工作量。
  最频繁被使用的库函数包括:
在需要的时候引用库函数可以很大
( 1) ( 2) ( 3)
strcpy
memcpy
memset




网讯IOS笔试题
答案是我自己的想法 仅供参考

1 程序在内存中运行时，内存分几个区？各自用途？
答：
栈区 由编译器自动分配释放存放函数的参数值，局部变量的值等。在高级语言中不需要显式的分配和释放
堆区 一般由程序员手动分配释放，如果不释放可有由OS释放。
数据区 存储全局和静态变量。初始化的全局和静态变量在一块区域，未初始化的放在相邻的一块区域，程序结束后由系统释放。
代码区 存放函数体的二进制代码。

2 引用与指针有什么区别？
答
引用是给变量起一个别名 也就是一个变量有两个名字 他们是同一块空间
指针是分配一块内存用来保存变量的地址 间接引用变量

3 int retVal = UIApplicationMain(argc, argv, nil, nil); 是什么意思？
答
对UIApplication对象进行了初始化，这个方法除了argc 和 argv 参数外，另外这个函数还有2个两个字符串参数来识别UIApplication类和UIApplication代理类，在这里默认是2个nil,第一个参数为nil就默认把UIApplication类作为缺省值进行初始化，可以在这里不填nil而是使用自己定义的UIApplication子类。至于第二个参数nil就设置为nil就把模板生成的HelloWorldAppdelegate类作为默认值。

4

5

6 保存一个变量到本地，列举两个简单的方法
答
直接写入writeToFile 支持NSString NSArray NSDictionary
实现NSCoding NSCopy 协议

7 如果UIView *view 已经实例化 在view 仅添加了N个UIButton类的实例，这些button不是全局的，并且button已经用tag区分开，如何快速找出其中指定的一个button改变它的某个属性？
答 view中有一个方法可以根据tag值把他上面的子视图找出来 [view subviewWithTag: ];

8 当A类中的某个方法执行到某处时， 这时想在B类中执行某个方法，如何做，举出一个方法说明？
答 可以用委托方法来实现 在A类中初始化一个成员让他指向B类就可以调用B的方法了

9 下面代码中obj2是否需要dealloc？
ClassA *obj1 = [[ClassA alloc] init];
ClassA *obj2 = obj1;
[obj1 hello];  //输出hello
[obj1 dealloc];
[obj2 hello];  //程序能否执行到这一行?
答：这个要根据hello的方法来定了 如果hello方法分配空间了那个释放再调用以后就会出错。
[obj2 dealloc];
答 一般情况下我们不显式的调用dealloc方法 这个方法系统在对象引用计数为零的时候自动调用
另外obj2和obj1指向的是同一块空间释放一次就可以了

10

11 类方法创造的对象要不要用release释放？
答 任何方法创建的对象对遵从内存管理原则 用alloc方法分配的对象就需要释放
如果用类方法创建对象时候，没有用到alloc，那么分配空间的问题，已经在方法内部做了处理，所以我们就不需要去释放了

12 下面请求数据用了什么协议，请求的数据格式是什么？
UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.frame];
[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:http://pzpromop.s3.amazonaws.com/PromoNeutral.html]]];
[self.view addSubview:webView];
答 使用了http协议请求的是html格式的数据

13 想传输一张图片，可以用什么协议传输？
答 可以用http ftp等协议。

14 用NSURL初始化的NSData对象，用哪个类去解析？

答
这个需要根据NSData数据是什么类型 然后可以用对应的解析工具来解析。

15 OC中加号方法与减号的区别？
答
加号方法是类方法 可以用类名来调用
减号方法是实例方法 必须由类的实例来调用

16 如何修饰私有变量？
答 在OC中默认变量属性都是有私有的 我们可以property关键字来修饰 以便可以不同过接口直接访问

17 建一个工程用到最基本的两个框架是什么？
答 cocoa Touch框架  Function框架

18 一个UITableView的实例，重新加载数据的方法是什么？
答 [tableView reloadData]方法

19 写一个委托的interface
答
@protocol SimpleProtocol
-(void)doSomething:(NSString *)str;
@end
 
@interface SimpleClass:NSObject< SimpleProtocol >{
}
@end
 
@implementation SimpleClass
-(void) doSomething:(NSString *)str{
   NSLog(str);
 }
@end

[单选]以下说法正确的是
A.Object-C支持多重继承
B.Object-C中的类可以实现多个接口
C.Object-C中导入头文件用的是#include
D.@class用于注入A.对象
答案：B
[单选]平铺导航模式是在内容组织上没有层次关系，展示的内容都放置在一个主屏幕上，采用分屏或分页控制器进行导航，可以左右或者上下滑动屏幕查看内容。
A.对
B.错
答案：A
[单选]标签导航模式是在内容被分成几个功能模块，每个功能模块之间没有什么关系。通过标签管理各个功能模块，点击标签切换功能模块。
A.对
B.错
答案：B
[单选]模态视图是在导航过程中，有的时候需要放弃主要任务转而做其他次要任务，完成次要任务之后要再回到主要任务，这个“次要任务”就是在“模态视图”中完成的。
A.对
B.错
答案：B
[单选]在树形结构导航模型中，会有两个根视图控制器：一个是应用程序根视图控制器，它是UINavigationController的实例，通过self.window.rootViewController属性指定；另一个导航控制器根视图控制器，通过UINavigationController的构造方法initWithRootViewController:指定，用于提供和呈现导航控制器的一级视图，即我们看到的第一个界面。
A.对
B.错
答案：B
[单选]有些情况下，我们会将三种导航模式（平铺导航模式、标签导航模式、树形结构导航模式）综合到一起使用，其中还会用到模态视图。
A.对
B.错
答案：A
[单选]本地化目录en-US.lproj中en是语言代号，US是国家代号。
A.对
B.错
答案：A
[单选]genstrings命名的基本语法：genstrings[-a][-q][-o]sourcefile
A.对
B.错
答案：A
[单选]判断：从通讯录数据库查询联系人数据，可通过ABAddressBookCopyArrayOfAllPeople和ABAddressBookCopyPeopleWithName函数获得。
A.对
B.错
答案：A
[单选]单例类NSNotificationCenter提供信息广播通知，它采用的是观察者模式的通知机制。____
A.对
B.错
答案：A
[单选]UISplitViewController控制器可以呈现屏幕分栏视图的效果，MasterView占有320点的固定大小。
A.是
B.否
答案：A
[单选]下面关于线程管理B.错误的是____
A.GCD在后端管理着一个线程池
B.NSOperationQueue是A.对NSthread的更高层的封装
C.NSThread需要自己管理线程的生命周期
D.GCD可以根据不同优先级分配线程
答案：B
[单选]关于Objective-C中属性的说明，以下B.错误的是____
A.readwrite是可读可写特性，需要生成getter方法和setter方法
B.readonly是只读特性，只有getter方法，没有setter方法
C.assign是赋值属性，setter方法将传入参数赋值给实例变量
D.retain表示持有特性，copy属性表示拷贝属性，都会建立一个相同的A.对象
答案：D

[单选]以下哪一段代码不会抛出异常____
A.NSArray*array=@[1，2，3];NSNumber*number=array[3];
B.NSDictionary*dict=@{@"key":nil};
C.NSString*str=nil;NSString*str2=[strsubstringFromIndex:3];
D.NSString*str=@"hi";NSString*str2=[strsubstringFromIndex:3];
答案：C
[单选]floatx与“零值”比较的if语句为？
A.if(x==0)
B.if(x<0.00001f)
C.if(fabs(x)<0.00001f)
D.if(x>-0.00001f)
答案：C

[单选]
1 NSStringa[]={@"abc",@"def"};
2 NSArray*a=@[@"abc",@"def"];
3 NSArray*a=[NSArrayarrayWithObjects:@"abc",@"def"];
4 NSArray*a=[NSMutableArrayarrayWithArray:@[@"abc"]];
上面的定义中，B.错误的个数为：____
A.0
B.1
C.2
D.3
答案：C
[单选]判断是否为iPad设备语句是？
A.if([[UIDevicecurrentDevice]userInterfaceIdiom]==UIUserInterfaceIdiomPhone){...}
B.if([[UIDevicecurrentDevice]userInterfaceIdiom]!=UIUserInterfaceIdiomPhone){...}
C.if([[UIDevicecurrentDevice]userInterfaceIdiom]==UIUserInterfaceIdiomPad){...}
答案：C
多选题
每题分值：2分
是否题目乱序：是
是否选项乱序：是
是否可回溯：是

[多选]关于NSOperationqueue的说法，正确的是？
A.主要用于多线程并发处理
B.它是一个队列，有严格的先进先出
C.它不会遵守严格的先进先出
D.NSOperationQueue可以通过调整权重来调整队列的执行顺序
答案：ACD
[多选]为什么说Object-C是runtimelanguage?
A.将数据类型的确定由编译时，推迟到了运行时
B.运行时机制使我们直到运行时才去决定一个A.对象的类别，以及调用该类别A.对象指定方法。
C.驾驶A继承了B类，那么在编译时就已经生成了A的实例
D.多态是指不同A.对象以自己的方式响应相同的消息的能力
答案：ABD
[多选]下列说法，正确的是?
A.category可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改
B.implement可以增加，修改或者删除方法，并且可以增加属性
C.extensions可以添加属性
D.extensions可以添加方法而不用实现
答案：ABC
[多选]在UIViewController类中与模态相关方法有哪些？
A.presentViewController:animated:completion:
B.dismissViewControllerAnimated:completion:
C.addChildViewController:
D.removeFromParentViewController
答案：AB
[多选]iOS中导航设计模式有几种？
A.平铺导航
B.标签导航
C.树形导航
D.模态视图导航
答案：ABC
[多选]下面与导航相关的视图控制器有哪些？
A.UIViewController
B.UINavigationController
C.UITabBarController
D.UITableViewController
答案：ABC
[多选]NSURL的构造函数有？
A.+requestWithURL:
B.–initWithURL:
C.+URLWithString:
D.–initWithString:
答案：CD
[多选]使用genstring工具可以扫描的宏是有哪些？
A.CFCopyLocalizedString
B.CFCopyLocalizedStringFromTable
C.CFCopyLocalizedStringFromTableInBundle
D.CFCopyLocalizedStringWithDefaultValue
E.NSLocalizedString
F.NSLocalizedStringFromTable
G.NSLocalizedStringFromTableInBundle
H.NSLocalizedStringWithDefaultValue
答案：ABCDEFGH
[多选]表视图的相关类有哪些?
A.UITableView
B.UITableViewController
C.UITableViewDelegate
D.UITableViewDataSource
答案：AB
[多选]表视图的组成有哪些？
A.Cells（单元格）
B.Sections（节）
C.TableHeaderView（表头）
D.TableFooterView（表脚）
答案：ABCD
[多选]下面属于表视图内置的扩展视图常量如下？
A.UITableViewCellAccessoryNone
B.UITableViewCellAccessoryDisclosureIndicator
C.UITableViewCellAccessoryDetailDisclosureButton
D.UITableViewCellAccessoryCheckmark
答案：ABCD
[多选]表视图的数据源协议与委托协议有哪些？
A.UITableView
B.UITableViewController
C.UITableViewDelegate
D.UITableViewDataSource
答案：CD
[多选]NSURLRequest的构造函数有？
A.+requestWithURL:
B.–initWithURL:
C.+requestWithURL:cachePolicy:timeoutInterval:
D.–initWithURL:cachePolicy:timeoutInterval:
答案：ABCD
[多选]Objective-C有哪几种内存管理方法？
A.MRR（ManualRetainRelease）
B.MRC（ManualReferenceCounting）
C.ARC（AutomaticReferenceCounting）
D.GC（GarbageCollection）
答案：ABCD
[多选]AddressBook框架中常用类？
A.ABAddressBook
B.ABPerson
C.ABGroup
D.ABRecord
答案：ABCD
[多选]AddressBookUI框架中的视图控制器？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABNewPersonViewController
D.ABUnknownPersonViewController
答案：ABCD
[多选]创建联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABMultiValueCreateMutable
D.ABAddressBookSave
答案：ABCD
[多选]修改联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABAddressBookGetPersonWithRecordID
D.ABAddressBookAddRecord
答案：CD
[多选]删除联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABAddressBookGetPersonWithRecordID
D.ABAddressBookRemoveRecord
答案：CD
[多选]AddressBook高级API是在AddressBookUI框架中定义的，它为我们访问通讯录数据提供了UI界面。该框架提供了哪些视图控制器和委托协议？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABUnknownPersonViewController
D.ABNewPersonViewController
答案：ABCD
[多选]iOS中持久化方式有哪些？
A.属性列表文件
B.A.对象归档
C.SQLite数据库
D.CoreData
答案：ABCD
[多选]NSURLConnectionDelegate协议中的方法有哪些？
A.connection:didReceiveData:
B.connection:didFailWithError:
C.initWithRequest:delegate:
D.connectionDidFinishLoading:
答案：ABD
[多选]NSAssert类似的宏有哪些？
A.NSAssert1
B.NSAssert2
C.NSAssert3
D.NSAssert4
答案：ABCD
[多选]iOS单元测试框架有哪些？
A.OCUnit
B.GHUnit
C.OCMock
D.NSXML
答案：ABC
[多选]NSXMLParser构造方法有哪些？
A.initWithContentsOfURL
B.initWithData
C.initWithStream
D.initWithContentsOfFile
答案：ABC
[多选]UIPopoverController控制器的常用方法和属性？
A.presentPopoverFromBarButtonItem:permittedArrowDirections:animated:呈现Popover视图方法
B.dismissPopoverAnimated:关闭Popover视图方法
C.popoverVisible，判断Popover视图是否可见
D.popoverArrowDirection，判断Popover视图箭头的方向
答案：ABCD
[多选]模态视图专用属性有哪些？
A.UIModalPresentationFullScreen，全屏状态，是默认呈现样式，iPhone只能全屏呈现。
B.UIModalPresentationPageSheet，它的宽度是固定的768点，在iPad竖屏情况下则全屏呈现。
C.UIModalPresentationFormSheet，它的是固定的540x620点，无论是横屏还是竖屏情况下呈现尺寸都不会变化。
D.UIModalPresentationCurrentContext，它与父视图控制器有相同的呈现方式。
答案：ABCD
[多选]NSXML框架中核心的是NSXMLParser和它的委托协议NSXMLParserDelegate，NSXMLParserDelegate常用方法有哪些？
A.parserDidStartDocument
B.parser:foundCharacters
C.parser:didStartElement:namespaceURI:qualifiedName:attributes
D.parser:didEndElement:namespaceURI:qualifiedName
E.parserDidEndDocument
答案：ABCDE
[多选]（iOS开发选做）实现多线程都有哪几种方法？
A.使用@synchronized(self)
B.使用GCD
C.使用NSOperationQueue
D.使用@thread
答案：ABC
[多选]一次鼠标单击会产生下列哪些事件：_____
A.onmousemove
B.Onmousedown
C.Onmouseup
D.onclick
E.onmouseover
答案：BCD
[多选]UIView的以下哪些属性是Animatable的：_____
A.backgroundColor
B.opaque
C.transform
D.contentStretch
答案：ACD
[多选]应用申明一下哪些权限可以被系统授予后台运行的权限？_____
A.视频播放应用
B.音乐播放应用
C.地理位置应用
D.VolP应用
E.杂志新闻类需要更新内容的应用
答案：BCDE
[多选]在定义属性时，下面哪些数据类型可以使用retain和copy：_____
A.NSArray
B.float
C.int
D.NSString
E.NSNumber
F.NSinteger
答案：ADE
[多选]AddressBook高级API是在AddressBookUI框架中定义的，它为我们访问通讯录数据提供了UI界面。该框架提供了哪些视图控制器和委托协议？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABUnknownPersonViewController
D.ABNewPersonViewController
答案：ABCD

8.Objective-C 如何对内存管理的 ,说说你的看法和解决方法 ? Objective-C 的内存管理主要有三种方式 ARC( 自动内存计数 )、手
动内存计数、内存池。
1. (Garbage Collection) 自动内存计数:这种方式和 java类似，
在你的程序的执行过程中。 始终有一个高人在背后准确地帮你收拾垃 圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我 申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候， 我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是， 那个高人需要消耗一定的资源， 在携带设备里面， 资源是紧俏商品所 以iPhone 不支持这个功能。所以“Garbage Collection ”不是本入门指 南的范围，对“Garbage Collection ”内部机制感兴趣的同学可以参考 一些其他的资料，不过说老实话“ Garbage Collection ”不大适合适初 学者研究。
解决 : 通过 alloc –initial 方式创建的 , 创建后引用计数 +1, 此后 每 retain 一次引用计数 +1, 那么在程序中做相应次数的 release 就好 了.
2. (Reference Counted) 手动内存计数:就是说，从一段内存被 申请之后， 就存在一个变量用于保存这段内存被使用的次数， 我们暂
时把它称为计数器，当计数器变为 0的时候，那么就是释放这段内存 的时候。比如说，当在程序 A里面一段内存被成功申请完成之后，那 么这个计数器就从 0变成 1( 我们把这个过程叫做 alloc) ，然后程序 B也

需要使用这个内存，那么计数器就从 1变成了 2( 我们把这个过程叫做 retain) 。紧接着程序 A不再需要这段内存了，那么程序 A就把这个计 数器减 1(我们把这个过程叫做 release); 程序 B也不再需要这段内存的 时候，那么也把计数器减 1(这个过程还是 release) 。当系统 (也就是 Foundation) 发现这个计数器变成了 0 ，那么就会调用内存回收程序把 这段内存回收 (我们把这个过程叫做 dealloc) 。顺便提一句，如果没有 Foundation ，那么维护计数器，释放内存等等工作需要你手工来完成。
解决 :一般是由类的静态方法创建的 , 函数名中不会出现 alloc 或 init字样, 如[NSString string] 和[NSArray arrayWithObject:], 创建后
引用计数 +0, 在函数出栈后释放 , 即相当于一个栈上的局部变量 . 当 然也可以通过 retain延长对象的生存期 .
3. (NSAutoRealeasePool) 内存池:可以通过创建和释放内存池 控制内存申请和回收的时机 .
解决:是由autorelease 加入系统内存池 , 内存池是可以嵌套的 , 每个内存池都需要有一个创建释放对 , 就像main函数中写的一样 . 使用也很简单 , 比如 [[[NSString alloc]initialWithFormat:@ ”Hey you! ”] autorelease], 即将一个 NSString 对象加入到最内层的系统内存池 , 当我们释放这个内存池时 , 其中的对象都会被释放 .


13. Object C 中创建线程的方法是什么 ?如果在主线程中执行代 码，方法是什么 ? 如果想延时执行代码、方法又是什么 ?
线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch 、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是 performSelectorOnMainThread ，如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone:



16. 类别的作用 ? 继承和类别在实现中有何区别 ?
答案: category 可以在不获悉，不改变原来代码的情况下往里
面添加新的方法，只能添加，不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原 来的方法，因为类别具有更高的优先级。
类别主要有 3个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。

(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
17. 类别和类扩展的区别。
答案:category 和extensions 的不同在于 后者可以添加属性。 另
外后者添加的方法是必须要实现的。
extensions 可以认为是一个私有的 Category 。
18. 什么是KVO和KVC?
答案:kvc:键 –值编码是一种间接访问对象的属性使用字符串
来标识属性， 而不是通过调用存取方法， 直接或通过实例变量访问的 机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的 例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的 简化了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的 的监控。
比如我自定义的一个 button

[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
if ([keyPath isEqualToString:@"highlighted"] ) {
[self setNeedsDisplay];
}
}
对于系统是根据 keypath去取的到相应的值发生改变，理论上来
说是和 kvc机制的道理是一样的。 对于kvc机制如何通过 key寻找到value:
“当通过KVC 调用对象时，比如:[self valueForKey:@ ”someKey ”] 时，程序会自动试图通过几种不同的方式解析这个调用。 首先查找对 象是否带有 someKey 这个方法，如果没找到，会继续查找对象是 否带有 someKey 这个实例变量 (iVar) ，如果还没有找到，程序会继续 试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是 没有被实现的话， 程序会抛出一个 NSUndefinedKeyException 异常错 误。

(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅 仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面 加一个 get，或者_someKey 以及_getsomeKey 这几种形式。 同时，查 找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前， 有最后的机会响应这个请求。 这样做有很多好处， 下面的两个例子说 明了这样做的好处。“
来至 cocoa ，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为 何上面我们只是 add 一个相关的 keypath 就行了，
可以按照 kvc查找的逻辑理解，就说的过去了。
19. 代理的作用 ?
答案:代理的目的是改变或传递控制链。 允许一个类在某些特定
时刻通知到其他类， 而不需要获取到那些类的指针。 可以减少框架复 杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。

20. oc 中可修改和不可以修改类型。 答案:可修改不可修改的集合类。 这个我个人简单理解就是可动
态添加修改和不可动态添加修改一样。
比如NSArray 和NSMutableArray 。前者在初始化后的内存控件就 是固定不可变的，后者可以添加等，可以动态申请新的内存空间。
【面试】 iOS 开发面试题 (二)
1. 我们说的 oc 是动态运行时语言是什么意思 ? 答案:多态。 主要是将数据类型的确定由编译时，推迟到了运
行时。
这个问题其实浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时才去决定一个对象的类
别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。
意思就是假设生物类 (life) 都用有一个相同的方法 -eat;

那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只需调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息 这个选择器 )。
因此也可以说，运行时机制是多态的基础 ?~~~
2. 通知和协议的不同之处 ? 答案:协议有控制链 (has-a) 的关系，通知没有。
(响应了 eat
简单来说，通知的话， 它可以一对多，一条消息可以发送给多个 消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的 明星经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的， 一一对应， 不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的 消息后，别称 B的
发布会了。但是通知就不一样， 他只关心发出通知，而不关心多 少接收到感兴趣要处理。
因此控制链 (has-a 从英语单词大致可以看出， 单一拥有和可控制 的对应关系。

3. 关于多态性
答案:多态，子类指针可以赋值给父类。 这个题目其实可以出到一切面向对象语言中，
因此关于多态， 继承和封装基本最好都有个自我意识的理解， 也
并非一定要把书上资料上写的能背出来。 最重要的是转化成自我理解。

5. NSOperation queue?
答案:存放 NSOperation 的集合类。 操作和操作队列，基本可以看成 java 中的线程和线程池的概念。
用于处理 ios多线程开发的问题。
网上部分资料提到一点是，虽然是 queue ，但是却并不是带有队
列的概念，放入的操作并非是按照严格的先进现出。

这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添 加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，
但是Bfunc是等Afunc完全操作完以后， B才开始启动并且执行， 因此队列的概念离乱上有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A比B先排队取票但是 B率先执行完操作， 我们亦然可以 感性认为这还是一个队列。
但是后来看到一票关于这操作队列话题的文章， 其中有一句提到
“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启 动是不定的。”
瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~
综合一点，我们知道他可以比较大的用处在于可以帮组多线程编 程就好了。


7. 是否在一个视图控制器中嵌入两个 tableview 控制器 ? 答案:一个视图控制只提供了一个 View 视图，理论上一个
tableViewController 也不能放吧，
只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，
如果不是我们定性思维认为的 UIViewController ， 而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图
控制者，它可以控制多个视图控制器，比如 TabbarController 那样的感觉。
8. 一个 tableView 是否可以关联两个不同的数据源 ?你会怎么处 理?
  答案:首先我们从代码来看，数据源如何关联上的，其实是在数
据源关联的代理方法里实现的。
因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我
返回根据自己的需要去设置如相关的数据源。 因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是
想干嘛呢 ?想让列表如何显示，不同的数据源分区块显示 ?


11. 什么是简便构造方法 ?
答案:简便构造方法一般由 CocoaTouch 框架提供，如NSNumber
的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法， 我们可以通过简便构 造方法，获得系统给我们创建好的对象，并且不需要手动释放。
12. 什么是谓词 ?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约
束条件，完成对数据的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n];
a = [customers filteredArrayUsingPredicate:predicate];
13. 谈谈对 Block 的理解 ?并写出一个使用 Block 执行UIVew 动 画?
答案: Block 是可以获取其他函数局部变量的匿名函数，其不但 方便开发，并且可以大幅提高应用的执行效率 (多核心 CPU 可直接处
理Block指令)
[UIView transitionWithView:self.view duration:0.2

options:UIViewAnimationOptionTransitionFlipFromLeft
animations:^{ [[blueViewController view] removeFromSuperview]; [[self view] insertSubview:yellowViewController.view atIndex:0]; }
completion:NULL];
14. 多线程是什么
多线程是个复杂的概念， 按字面意思是同步完成多项任务， 提高
了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看， 多线程被赋予不同的内涵， 对于硬件，现在市面上多数的 CPU都是多 核的，多核的 CPU运算多线程更为出色 ;从操作系统角度，是多任务， 现在用的主流操作系统都是多任务的，可以一边听歌、一边写博客 ; 对于应用来说，多线程可以让应用有更快的回应， 可以在网络下载时， 同时响应用户的触摸操作。在 iOS 应用中，对多线程最初的理解，就 是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成 烧水的同时去摘菜，最后去炒菜。
15. iOS 中的多线程
iOS中的多线程，是Cocoa框架下的多线程， 通过Cocoa的封装，
可以让我们更为方便的使用线程， 做过 C++ 的同学可能会对线程有更 多的理解，比如线程的创立，信号量、共享变量有认识， Cocoa 框架

下会方便很多，它对线程做了封装， 有些封装，可以让我们创建的对 象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工 程，提供程序的健壮性。
GCD 是(Grand Central Dispatch) 的缩写 ，从系统级别提供的一 个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。 GCD的API接口为C语言的函数，函数参数中多数有 Block，关于Block 的使用参看这里， 为我们提供强大的“接口”，对于GCD的使用参见本 文
NSOperation 与Queue
NSOperation 是一个抽象类，它封装了线程的细节实现，我们可 以通过子类化该对象，加上 NSQueue 来同面向对象的思维，管理多 线程程序。具体可参看这里:一个基于 NSOperation 的多线程网络访 问的项目。
NSThread
NSThread 是一个控制线程执行的对象，它不如 NSOperation 抽 象，通过它我们可以方便的得到一个线程，并控制它。但 NSThread 的线程之间的并发控制，是需要我们自己来控制的，可以通过 NSCondition 实现。
参看 iOS 多线程编程之 NSThread 的使用
其他多线程
在Cocoa 的框架下， 通知、Timer 和异步函数等都有使用多线程，
(待补充 ).

16. 在项目什么时候选择使用 GCD ，什么时候选择 NSOperation?
项目中使用 NSOperation 的优点是 NSOperation 是对线程的高度 抽象，在项目中使用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路，是具有面向对象的优点 (复用、封装 )，使 得实现是多线程支持，而接口简单，建议在复杂项目中使用。
项目中使用 GCD 的优点是 GCD 本身非常简单、易用，对于不复 杂的多线程操作，会节省代码量，而 Block 参数的使用，会是代码更
为易读，建议在简单项目中使用。
17. 什么是block
对于闭包 (block), 有很多定义，其中闭包就是能够读取其它函数
内部变量的函数， 这个定义即接近本质又较好理解。 对于刚接触 Block 的同学，会觉得有些绕，因为我们习惯写这样的程序 main(){ funA();} funA(){funB();} funB(){ ⋯..}; 就是函数 main调用函数 A，函数A调用函 数B⋯ 函数们依次顺序执行，但现实中不全是这样的，例如项目经 理M，手下有 3个程序员 A、B、C，当他给程序员 A安排实现功能 F1 时，他并不等着 A完成之后，再去安排 B去实现 F2，而是安排给 A功 能F1，B功能F2，C功能F3，然后可能去写技术文档，而当 A遇到问 题时，他会来找项目经理 M，当 B做完时，会通知 M，这就是一个异 步执行的例子。在这种情形下， Block 便可大显身手，因为在项目经

理 M，给 A 安排工作时，同时会告诉 A 若果遇到困难，如何能找到他 报告问题 (例如打他手机号 )，这就是项目经理 M给A的一个回调接口， 要回掉的操作，比如接到电话，百度查询后，返回网页内容给 A ，这 就是一个 Block ，在 M交待工作时，已经定义好，并且取得了 F1的任 务号 (局部变量 )，却是在当 A遇到问题时，才调用执行，跨函数在项 目经理 M查询百度，获得结果后回调该 block 。
18. OC 的垃圾回收机制 ??
答案: OC2.0 有 Garbage collection ，但是 iOS 平台不提供。 ?
一般我们了解的 objective-c 对于内存管理都是手动操作的， 但是也有 自动释放池。 但是查了大部分资料， 貌似不要和 arc机制搞混就好了。
19. block 实现原理
Objective-C 是对C语言的扩展， block的实现是基于指针和函数
指针。从计算语言的发展，最早的 goto ，高级语言的指针，到面向对 象语言的 block ，从机器的思维，一步步接近人的思维，以方便开发 人员更为高效、直接的描述出现实的逻辑 (需求 )。 下面是两篇 很好的介绍 block 实现的博文 iOS 中block 实现的探究 谈 Objective-C Block 的实现 3 block 的使用 使用实例 cocoaTouch 框架下动画效果的 Block 的调用 使用 typed 声明 block typedef void(^didFinishBlock) (NSObject *ob); 这 就声明了一个 didFinishBlock 类型的 block ， 然后便可用

@property (nonatomic,copy) didFinishBlock finishBlock;
一个 blokc 对象，注意对象属性设置为 copy ，接到 block 会自动复制一份。 __block 是一种特殊类型， 字声明的局部变量，可以被 block 所改变，并且其在原函数中的值会 被改变。 4 常见系列面试题 面试时，面试官会先问一些， 是否了解 block ，是否使用过 block ，这些问题相当于开场白，往往是 下面一系列问题的开始，所以一定要如实根据自己的情况回答。
1 使用 block 和使用 delegate 完成委托模式有什么优点 ? 首先要 了解什么是委托模式，委托模式在 iOS 中大量应用，其在设计模式中
是适配器模式中的对象适配器， Objective-C 中使用 id类型指向一切对 象，使委托模式更为简洁。了解委托模式的细节: iOS 设计模 式— -委托模式 使用 block 实现委托模式，其优点是回调的 block
代码块定义在委托对象函数内部， 使代码更为紧凑 ; 再需要实现具体某个 protocol ，代码更为简洁。
适配对象不
2 多线程与 系列方法，可
block GCD 与 Block
以以指定的方式执行 block
dispatch_async 的完整定义
dispatch_async( dispatch_queue_t queue, dispatch_block_t block); 功能:在指定的队列里提交一个异步执行的 block ，不阻塞当 前线程 通过 queue 来控制 block 执行的线程。 主线程执行前文定义的 finishBlock 对象
使用 dispatch_async GCD 编程实例
void
声明 参数时，便
使用该关键

dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();}) ;
【面试】 iOS 开发面试题 (三)
1、 iOS 数据持久化存储方案有哪些?
参考答案:
plist属性列表存储(如 NSUserDefaults )
文件存储 (如二进制数据写入文件存储， 通过 NSFileManager 来操作 将下载起来的二进制数据写一篇文件中存储)
NSKeydeArchiver 归档存储，常见的是自动化归档 /解档处理，想要 学习如何通过 runtime 实现自动化归档 /解档，可
数据库 SQLite3 存储(如 FMDB 、Core Data ) 2、沙盒的目录结构是怎样的?各自一般用于什么场合?
参考答案:
Application :存放程序源文件，上架前经过数字签名，上架后不可修 改

Documents: 保存应 ? 运行时生成的需要持久化的数据 ,iTunes 同步 设备时会备份该目 录。例如 ,游戏应用可将游戏存档保存在该目录 tmp: 保存应 ?运行时所需的临时数据 ,使?完毕后再将相应的文件从 该目录删除。应用 没有运行时 ,系统也可能会清除该目录下的文件。 iTunes 同步设备时 不会备份该目录
Library/Caches: 保存应用运行时 ? 成的需要持久化的数据 ,iTunes 同 步设备时不会备份 该目录。?一般存储体积大、 不需要备份的非重要 数据，比如网络数据缓存存储到 Caches 下
Library/Preference: 保存应用的所有偏好设置，如 iOS 的Settings( 设 置) 应?会在该目录中查找应 ?的设置信息。iTunes同步设备时会备份 该目录
3、 #define 定义的宏和 const 定义的常量有什么区别?
参考答案:
#define 定义宏的指令，程序在预处理阶段将用 #define 所定义的内容 只是进行了替换。因此程序运行时，常量表中并没有用 #define 所定 义的宏，系统并不为它分配内存，而且在编译时不会检查数据类型， 出错的概率要大一些。
const 定义的常量，在程序运行时是存放在常量表中，系统会为它分 配内存，而且在编译时会进行类型检查。
#define 定义表达式时要注意 “边缘效应 ”，例如如下定义:

1
2 #define N 2 + 3 // 我们预想的 N值是 5，我们这样使用 N
3 int a = N / 2; // 我们预想的 a的值是 2.5，可实际上 a的值是 3.5 4
4、常见的出现内存循环引用的场景有哪些?
参考答案:
定时器( NSTimer ):NSTimer 经常会被作为某个类的成员变量，而 NSTimer初始化时要指定 self为target，容易造成循环引用
( self->timer->self )。 另外，若 timer 一直处于 validate 的状态，则 其引用计数将始终大于 0，因此在不再使用定时器以后，应该先调用 invalidate 方法
block 的使用:block 在copy 时都会对 block 内部用到的对象进行强引用 (ARC) 或者 retainCount 增1(非 ARC) 。在ARC 与非 ARC 环境下对 block 使用不当都会引起循环引用问题， 一般表现为，某个类将 block作为 自己的属性变量， 然后该类在 block的方法体里面又使用了该类本身， 简单说就是 self.someBlock = Type var{[self dosomething]; 或者 self.otherVar = XXX; 或者_otherVar = ⋯};出现循环的原因是: self->block->self 或者self->block->_ivar (成员变量)
代理( delegate ):在委托问题上出现循环引用问题已经是老生常谈 了，规避该问题的杀手锏也是简单到哭，一字诀:声明 delegate 时请

用assign(MRC) 或者weak(ARC) ，千万别手贱玩一下 retain或者 strong ，毕竟这基本逃不掉循环引用了!
5、 block 中的 weak self ，是任何时候都需要加的么?
参考答案: 不是什么任何时候都需要添加的，不过任何时候都添加似乎总是好 的。只要出现像 self->block->self.property/self->_ivar 这样的结构链 时，才会出现循环引用问题。好好分析一下， 就可以推断出是否会有 循环引用问题。
6、 GCD 的 queue 、main queue 中执行的代码一定是在 main thread 么?
参考答案:
对于 queue 中所执行的代码不一定在 main thread 中。如果 queue 是在 主线程中创建的， 那么所执行的代码就是在主线程中执行。 如果是在 子线程中创建的，那么就不会在 main thread 中执行。
对于 main queue 就是在主线程中的，因此一定会在主线程中执行。 获取 main queue 就可以了，不需要我们创建，获取方式通过调用方 法 dispatchgetmain_queue 来获取。 7、头文件中声明的成员变量(不是属性)，外部可直接访问么? 参考答案: 外部不能直接访问头文件所声明的成员变量，需要提供成员变量的 getter 方法才能在外部访问。 而属性已经直接给我们自动生成了 方法，因此外部可以直接访问属性。
getter

8、TCP和UDP 的区别是什么?
参考答案:
TCP:面向连接、传输可靠(保证数据正确性， 保证数据顺序传输) 、 用于传输大量数据 (流模式 )、速度慢，建立连接需要开销较多 (时间， 系统资源 )。
UDP :面向非连接、传输不可靠、用于传输少量数据 (数据包模式 )、 速度快，传输的是报文。
9、MD5 和Base64 的区别是什么，各自使用场景是什么?
参考答案:
做过加密相关的功能的，几乎都会使用到 MD5 和 Base64 ，它们两者 在实际开发中是最常用的。
MD5 :是一种不可逆的摘要算法， 用于生成摘要， 无法逆着破解得到 原文。常用的是生成 32位摘要，用于验证数据的有效性。比如，在网 络请求接口中， 通过将所有的参数生成摘要， 客户端和服务端采用同 样的规则生成摘要，这样可以防篡改。又如，下载文件时，通过生成 文件的摘要，用于验证文件是否损坏。
Base64 :属于加密算法，是可逆的，经过 encode 后，可以 decode 得到原文。在开发中，有的公司上传图片采用的是将图片转换成
base64 字符串，再上传。在做加密相关的功能时，通常会将数据进
行 base64 加密 /解密。
10、发送 10个网络请求，然后再接收到所有回应之后执行后续操作， 如何实现?

参考答案:
从题目分析可知， 10个请求要全部完成后，才执行某一功能。比如， 下载 10 图片后合成一张大图， 就需要异步全部下载完成后， 才能合并 成大图。
做法:通过 dispatch_group_t 来实现，将每个请求放入到 Group 中， 将合并成大图的操作放在 dispatch_group_notify 中实现。
1
2
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PR
3
dispatch_group_t group = dispatch_group_create(); 4
加载图片 1 */ }); 加载图片 2 */ });
加载图片 3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{
8
// 合并图片 9
}); 1
0
11、__block和__weak修饰符的区别? 参考答案:
5 6 7
dispatch_group_async(group, queue, ^{ /* dispatch_group_async(group, queue, ^{ /*
dispatch_group_async(group, queue, ^{ /*

__block 不管是 ARC 还是 MRC 模式下都可以使用，它的作用是标识 block外的变量在 block内使用可以修改变量的值。
__weak 只能在 ARC 模式下使用，表示弱引用，主要是用于防止循环 引用而引入的。


通过协议在 shouldStartRequest 中捕获请求，获取 scheme 来判断预 先定义的功能，然后调用native代码。比如，定义点击图片调用 native 来展示大图，那么 js 接收到点击时，重定向将图片的 url添加上自定义 scheme ，如 HYBImagePreview:// 这样。

16、一个 tableView 是否可以关联两个不同的数据源?
参考答案:
当然是可以关联多个不同的数据源， 但是不同同时使用多个数据源而 已。比如，一个列表有两个筛选功能，一个是筛选城市，一个是筛选 时间， 那么这两个就是两个数据源了。当筛选城市时， 就会使用城市 数据源;当筛选时间时，就会使用时间数据源。 17、对象添加到通知中心中， 当通知中心发通知时， 这个对象却已经 被释放了，可能会出现什么问题?
参考答案:
其实这种只是考查对通知的简单应用。 通知是多对多的关系， 主要使 用场景是跨模块传值。 当某对象加入到通知中心后， 若在对象被销毁 前不将该对象从通知中心中移除，当发送通知时，就会造成崩溃。这 是很常见的。所以，在添加到通知中心后，一定要在释放前移除。
18 、实现过框架或者库以供他人使用么?如果有， 请谈一谈构建框架 或者库时候的经验;如果没有，请设想和设计框架的 public 的 API， 并指出大概需要如何做、 需要注意哪些问题， 以使人人更容易地使用 你的框架。
参考答案:
从以下角度出发来思考和设计公共框架: 确保外部调用简单，且保证有详细的头文件注释说明。
确保 API 编码规范，保证风格统一。
确保 API 易扩展，可以考虑预留参数

确保没有外部依赖或者依赖要尽可能的少， 以保证公共库的纯洁 (原 则上不能有外部依赖)
确保易维护，不存在冗余 API
19、如何自动计算 cell的高度?
参考答案:
笔者喜欢纯代码自动布局， 一直使用 Masonry 这个第三方库来实现纯 代码自动布局的，使用起来非常简单，而且效率也很高。开发起来， 提高了开发效率。
关于 Masonry 自动计算行高，笔者提供了 swift 版和 oc版本的扩展，这 两个版本都提供了自动计算行高的功能， 并且带有缓存功能， 保证永 远只计算一次行高，效率就会很高，一般的应用也就不会卡屏了。 实现原理:通过数据模型的 id作为 key ，以确保唯一，如何才能保证 复用 cell 时不会出现混乱。在配置完数据后，通过更新约束，得到最 后一个控件的 frame，就只可以判断 cell实际需要的高度， 并且缓存下 来，下次再获取时，判断是否存在，若存在则直接返回。因此，只会 计算一遍。
20、UITableView 是如何计算内容高度的?为什么初始化时配置数据 时，获取行高的代理方法会调用数据条数次?
参考答案:
UITableView 是继承于 UIScrollView 的，因此也有 contentSize 。要得 到tableview 的contentsize ，就需要得到所有 cell的高度，从而计算出

总高度，才能得到 contentsize 。因此，在 reloadData 时，就会调用该 代理方法数据条数次。 为了提高效率，笔者写了扩展用于自动计算行高的，并且带有缓存， 以保证只会计算一次， 防止卡屏。做到这一点， 一般的应用就可以解 决卡屏的问题了。 对于富文本比较多的应用， 还可以继续优 化哦。




1 、 objective-c 中是所有对象间的交互是如何实现的 ? (深圳皆凯科技有限公司笔试题) 通过代理去进行通讯，或者通过观察者消息模式 ,Blocks ， appdelegate
2 、如何将产品进行多语言发布，开发?
Xcode对多语言支持比较好，除了 h m 文件之外所有其它东西都可以多语言
3 、 objective-c 中是如何实现线程同步的 ? Mutexlock ， NSCondtion lock ，消息传送
4、 编写函数 _memmove说明如下: 实现 C语言库函数 memmove的功能: 将一块缓冲区中的数据移动 到另一块缓冲区中。可能有重复。
//
5、什么叫数据结构?(面试顺风快递 iphone 开发)
计算机 = 编程 +数据结构 6、编程中，保存数据有哪几种方式?数组、自定义类、文件操作、数据库如: 文件 plist NSUserDefaults sqlite
7、 Sizeof 与 strlen 的区别和联系? 8、什么是抽象类?抽象类有什么作用?能实例化吗?
NSOperation 没有完全实现的类叫抽象类 , C++,java
抽象类不能实例化 , 不能 NSOperation *a =[[NSOperation alloc] init];
9、 用 Objective-C 写冒泡法.
//
10、你对 @interface 和 @property 的理解?
@interface 申明一个类
@property 就是申明 2个函数， getter setter
retain, assign 是什么意思
11、 Iphone 开发中控制类有什么作用?
Controller, UIViewController, UINav, UITabBarController UIImagePickerController, UITableViewController
UIView 和UIViewController 的区别 container 12、线程中有哪些函数?写出来。
[NSThread detachNewXXXXX];
13、有没有写过自定义的控件?
SQLite
，编译器会自动产生 2个函数
2类， 1类比较多的就是类似
UIImageView 和UIImage UILabel
2. 用 CG CoreGraphics drawRect:
--------
|-------| 每个 UIView 都有一个 drawRect: 14、调用一个类的静态方法需不需要 release ?
静态方法就是类方法 , 不需要，类的方法
自己定义控件有
RatingView UIJewels : UIButton
{
int x, y;
int type;
UIImage *image; }
对象放在 autorelease 15、 do-while 与 while-do
16、写出几个死循环? while
中 的区别?
(1)， for (;;)，
和NSString
用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题) #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL

1。assign 和 retain ，copy 的区别
assign 就是和普通语言的赋值一样
retain 在一个对象中保存该对象需要拥有的对象 对该对象进行应用计数 +1
@property (retain) 为了写程序方便
copy 主要是赋值
一般 代理的申明都是 assign 为什么
原因有 2 个，
1 根本就没有必要把代理的计数器 +1
2. 主要是为了避免引用技术嵌套，递归
2 。如何持久保存数据
NSUserDefaults, Plist, SQLite3, file 3。网络方面得 比如如何检测联网 ASIHTTPRequest Reacheable.[hm]
原理是 ifconfig 是不是有 ip 地址 Reachability
来判断是否有网络 3G Wifi
4 。类之间得继承关系 比如 UIview UIResponder ，处理触摸，
touchBegin, touchEnd, nextResponder
5 。异常处理
都是自己判断 错误信息
longjmp
char *p = malloc(100);
if (p == NULL) { }
在同一个类 A中,有方法 a和方法 b,方法b如何调用方法 a? [self a];
有A、B两个类， B类继承于 A类，都实现了方法 xx。创建 B类实例 b,如何让 b调用 A类? [super a];
const 和 Volatile 分别代表什么意思? Volatile 表示每次都从内存取数据
类型 id 代表什么意思?
面向对象包含哪些元素?
继承和分类的区别?
Catogory
Catogory 实现起来麻烦一些，但是使用方便
NSSet 类的作用是什么?
集合
编写一个完整程序，在控制台打印字符串“ HelloWorld! ” 用递归实现计算 n 的阶乘。(用 objective-c 语法实现)
obj-c 有多重继承么 ?不是的话有什么替代方法 ?
cocoa 中所有的类都是 NSObject 的子类，多继承在这里是用 不用去考虑繁琐的多继承，虚基类的概念。多态特性在 obj-c
委托代理来实现的。你 中通过委托来实现。
http xml 等
得父类是哪一个等等?
线程与进程的区别和联系 ?
进程和线程都是由操作系统所体会的程序运行的基本单元， 系统利用该基本单元实现系统对应用
protocol

的并发性。
程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间， 一个进 程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线 程有自己的堆栈和局部变量， 但线程之间没有单独的地址空间， 一个线程死掉就等于整个进程死 掉，所以多进程的程序要比多线程的程序健壮， 但在进程切换时， 耗费资源较大， 效率要差一些。 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
自动释放池是什么 , 如何工作?
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最新的自 动释放池。 它仍然是个正当的对象， 因此自动释放池定义的作用域内的其它对象可以向它发送消 息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。
1. ojc-c 是通过一种 "referring counting"( 引用计数 ) 的方式来管理内存的 , 对象在开始分配 内存 (alloc) 的时候引用计数为一 , 以后每当碰到有 copy,retain 的时候引用计数都会加一 , 每
当碰到 release 和 autorelease 的时候引用计数就会减一 , 如果此对象的计数变为了 0, 就会被 系统销毁 .
2. NSAutoreleasePool 就是用来做引用计数的管理工作的 , 这个东西一般不用你管的
3. autorelease 和 release 没什么区别 , 只是引用计数减一的时机不同而已 ,autorelease
象的使用真正结束的时候才做引用计数减一。
什么是 KVC和 KVO?答:KVC(Key-Value-Coding) 内部的实现: 一个对象在调用 setValue
.
的时候， ( 1 )首先根据方法名找到运行方法的时候所需要的环境参数。 ( 2 )他会从自己 isa 指针结合环
境 参 数 ， 找 到 具 体 的 方 法 实 现 的 接 口 。 ( 3 ) 再 直 接 查 找 得 来 的 具 体 的 方 法 实 现 。 KVO (Key-Value-Observing ):当观察者为一个对象的属性进行了注册，被观察对象的 isa 指针被
修改的时候， isa 指针就会指向一个中间类，而不是真实的类。所以 isa 指针其实不需要指向实
例对象真实的类。所以我们的程序最好不要依赖于 确对象实例的类名。
kvc 就是一种通过字符串去间接操作对象属性的机制。 iphone 中，自定义协议?
Protocol , 看代理 viewController
协议在 oc 中主要用在代理中
绑定的概念? 代理的概念?对它怎么理解? 为了模块之间的松耦合 网络编程中协议的概念。 NetworkDataDelegate;
3 个函数理解 didReceive,
判断是否实现某个方法，是某个类
isa 指针。 在调用类的方法的时候，最好要明
respondsToSelector ,performSelector,conformstoProrocol,isKindofClass,isMemberof Clas s
会在对

网络库 优点 缺点
ASIHTTPRequest 老牌、功能强大、文档丰富 停止更新、新特性少、厚重
AFNetWorking github 上比较火的项目、有稳定的两个主要负责人、能支持比较新的特性、一直
有更新 文档数目一般、有些功能貌似要自己写
MKNetworkKit 支持 ARC、号称要有 ASIHTTPRequest 的功能， AFNetWorking 的轻便 文档数目最 少、只有作者一个主要负责人
1 http 协议， get ， post 区别
get 是简单的 http 协议
post 是从客户端提交复杂的参数，包括文件
2. 如何判断一个 http 包结束
一般在 http 请求投有 content-length oc 中有 connectionDidFinishLoading 当然也可以根据接收多少了
3 http 协议如何实现断点下载的 使用 http Range 字段
可以把当前传输了多少存在文件中， 1. 写一个 NSString 类的实现
是表示后面数据有多长
表示接受完成
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWIthCString: nullTerminatedCString encoding:
encoding];
return AUTORELEASE(obj);
}
2. 写一个委托 Delegate 的 interface 答:
@protocol MyDelegate;
@class MyClass ;
@interface MyClass: NSObject {
id <MyDelegate> delegate; }
// 委托方法 @protocol MyDelegate

- (void)didJobs:(NSArray *)args; @end
3.obj-c 有私有方法么 ?私有变量呢
答:在 Objective-C 中没有私有方法，只有静态方法和实例方法。但是可以用 @private 修饰
私有变量。
用 .m 文件中使用 catogory 来实现私有方法。
4.obj-c 的优缺点 objc 优点:
1) Cateogies
2) Posing
3) 动态识别
4) 指标计算
5 )弹性讯息传递
6) 不是一个过度复杂的
7) Objective-C 与 C++ 可混合编程
缺点:
1) 不支援命名空间
2) 不支持运算符重载
3) 不支持多重继承
4) 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方
法都用不到。(如内联函数等)，性能低劣。 OC 没有多重继承， Java 也没有 C++ 才有
OC使用协议来实现多重继承 OC 冒泡排序
- (NSArray *)bubble_sort:(NSArray *)array {
int tmp;
int count = [array count];
// 申请临时数组，以存放本来在
int *tmpArray = (int *)malloc(sizeof(int)*count); if (tmpArray == NULL) {
printf("malloc error");
return nil; }
// 把 oc 对象数组里的内容暂时存放到临时数组里 for (int i = 0; i < count; i++) {
tmpArray[i] = [[array objectAtIndex:i] intValue]; }
C 衍生语言
oc 对象数组里的内容


6. 引用与指针有什么区别
指针指向一块内存，它的内容是所指内存的地址;
引用是某块内存的别名
1. 指针是一个实体，而引用仅是个别名;
2. 引用使用时无需解引用 (*) ，指针需要解引用;
3. 引用只能在定义时被初始化一次，之后不可变;指针可变;
4. 引用没有 const ，指针有 const ;
5. 引用不能为空，指针可以为空;
6. “ sizeof 引用”得到的是所指向的变量 ( 对象 ) 的大小，而“ sizeof 指
针”得到的是指针本身 ( 所指向的变量或对象的地址 ) 的大小;
7. 指针和引用的自增 (++) 运算意义不一样;
8. 从内存分配上看:程序为指针变量分配内存区域，而引用不需要分配
内存区域。
7.
编程:
1. 请问运行完 Test 函数后，会有什么样的结果。 (1)
voidGetMemory(char *p)
{
p = (char *)malloc(100); }
void Test(void) {
char *str = NULL; GetMemory(str);
strcpy(str, "hello world");
printf(str); }
请问运行 Test 函数会有什么样的结果? 答:程序崩溃。
因为 GetMemory并不能传递动态内存， Test函数中的 str 一直都是 NULL。
strcpy(str, "hello world");
(2)
char *GetMemory(void) {
char p[] = "hello world";
return p; }
void Test(void) {
char *str = NULL;
将使程序崩溃。

str = GetMemory(); printf(str);
}
请问运行 Test 函数会有什么样的结果?
(2) 答:可能是乱码。
因为 GetMemory返回的是指向“栈内存”的指针，该指针的地址不是 其原现的内容已经被清除，新内容不可知。
(3)
void GetMemory2(char **p, intnum) {
*p = (char *)malloc(num); }
void Test(void) {
char *str = NULL; GetMemory(&str, 100);
strcpy(str, "hello");
printf(str); }
请问运行 Test 函数会有什么样的结果? 答:
(1)能够输出 hello
(2)内存泄漏
(4)
void Test(void) {
char *str = (char *) malloc(100);
NULL，但
strcpy(str, free(str);
if(str != NULL) {
strcpy(str, printf(str);
} }
“hello ”);
“world ”);
请问运行 Test 函数会有什么样的结果? 答:篡改动态内存区的内容，后果难以预料，非常危险。 因为free(str); 之后，str 成为野指针，
if(str != NULL) 语句不起作用。
2.编写strcpy 函数(10分)

已知strcpy 函数的原型是
char *strcpy(char *strDest, const char *strSrc);
其中strDest 是目的字符串， strSrc 是源字符串。 (1)不调用 C++/C的字符串库函数，请编写函数 strcpy char *strcpy(char *strDest, const char *strSrc);
{
assert(( str Dest!=NULL) && ( strSrc
char *address = str Dest;
while( (* str Dest++ = * strSrc ++) !=
NULL ;
return address ;
}
(2)strcpy 能把strSrc 的内容复制到 strDest ，为什么还要 char * 值?
答:为了实现链式表达式。
例如 int length = strlen( strcpy( strDest,
3. #include <stdio.h>
int main() {
int a = 0x0101; int b = 0x0202; int c;
c = a&(~b);
c = c|b;
printf ( "%x,%d\n" ,c,c); return 0;
}
“hello world
”) );
答案: 303,771
4. 完成下面函数以实现使用辗转相除法获取两个数(假设两个数都大于
最大公约数
example: gcd(20,5 ) = 5. gcd(3,10 ) = 1. gcd(1620,1280 ) = 20. unsignedintgcd( unsigned int
a,unsignedint b )
{
int c = 0;
0)的
!=NULL)); ‘\0 ’ )
类型的返回

if (m%n==0) c =n; else
c= gcd(n,m%n); return c;
}
5. 用嵌套方式写一个函数，函数返回 int fun(int n)
N的阶层，要求尽量写完整
{
}
if (n == 1)
return n;
return n*(n-1);
6. 请写出下列数据类型的范围
答: char ( -127~128) unsigned char (0~255) short (-2^16-1 ~2^16 ) int(-32768~32767)
7. 请写出下面函数的返回值
char fuc1() {
unsignedint a = 6;
int b = -12;
return(a+b>6)?1:0
}
#define SQP(x)(x*x)
int fuc2()
{
int a = 3;
return SQR(a+2);
}
答:1 11
8. 请计算下列结构所占字节数 TypedefstructYouKnoow
{
int id;
short age; char level;
} 答:8
9. 关键字 const 有什么含义?
char,unsignedchar,short,int

const 修饰谁，谁在整个程序运行过程中不能变
10. 下方代码输出结果为
main()
{
int a[5] = {1, 2, 3, 4, 5};
int *ptr = (int *)(&a+1);
printf( “%d%”d , *(a+1), *(ptr-1)); }
答: D:4, 5
11. 用 c/c++ 实现冒泡排序 voidswap_sort(int *p, int n) {
int I, j;
inttmp;
for(i=0; i<n-1; i++) {
for(j=0; j<n-1-I; j++) { if(p[j]>p[j+1]) {
tmp=p[j]; p[j]=p[j+1]; p[j+1]=tmp;
}
}
12. 用嵌套的方式写一个函数，该函数返回 N 的阶乘( N!=1*2*..*N ) intfunc(int n){if (n==1) return 1; return n * x(n-1);}
} }



心、 kvc/kvo 等。
13. 关于自定义 Cell 中，图片下载用到的方法 ?
如果有添加了第三方库 SDWebImage/AFNetWorkin，g可以使用 UIImageView的 类别方法 setImageWithURL:直接异步加载，如果没有的话可以使用 NSURLConnection发起 request 请求，或者使用 ASI将下载请求添加到下载队 列中，将图片下载之后，在回调方法里，回调主线程，设置图片。
14. UITableViewCell 怎样使用更流畅?
首先 cell 的复用机制节约了系统资源;其次应当注意有些复杂的大数据或网络 数据应采用异步加载的方式进行加载，以免 cell 刷出时发生卡顿。
15. 在 UIWebView上点击回复，如何使用 UITextField 进行回复? UIWebView有一个 stringByEvaluatingJavaScriptFromString 方法可以将 javascript 嵌入页面中，通过这个方法我们可以在 iOS中与 UIWebView中的网 页元素交互。通过 JAVAScript 获取点击时间，弹出 UITextField ，输入字符串 后，可以通过 post 请求发送回复。
16. 关于图文混排是如何排版的? 图文混排应当以图片为起点，首先明确图片的位置，文字可以选择位于图片的
下方，或者是环绕效果。环绕效果可以采用 2 个以上 label 或 textView 来实现; 也可以通过 AttributeString 的属性设置，或者 CoreText 重绘 UIVIew，添加 文字的方式，修改文字间的间隔，达到让出图片的效果。如果图文显示在高度
可变的视图中，如 tableView 的 Cell 中，可以计算文字占位 视图或 cell 的高度。

19. push 推送机制
iOS 在系统级别有一个推送服务程序使用 5223 端口。使用这个端口的协议源 于 Jabber 后来发展为 XMPP，被用于 Gtalk 等 IM 软件中。所以， iOS 的 推送，可以不严谨的理解为:
苹果服务器朝手机后台挂的一个 IM 服务程序发送的消息。
然后，系统根据该 IM 消息识别告诉哪个 Apps 具体发生了什么事。 然后，系统分别通知这些 Apps 。
20. iOS 播放音频的几种方法 ?
iPhone OS 主要提供以下了几种播放音频的方法: System Sound Services
AVAudioPlayer 类
Audio Queue Services
OpenAL
21. 代理的作用 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，
而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
22. int retVal=UIApplication(argc,argv,nil,nil): 是什么意思
对 UIApplication 对象进行了初始化，这个方法除了 argc 和 argv 参数外，另 外这个函数还有 2 个两个字符串参数来识别 UIApplication 类和
UIApplication 代理类，在这里默认是 2 个 nil, 第一个参数为 nil 就默认把 UIApplication 类作为缺省值进行初始化，可以在这里不填 nil 而是使用自己 定义的 UIApplication 子类。至于第二个参数 nil 就设置为 nil 就把模板生成 的 HelloWorldAppdelegate 类作为默认值。
23. 保存一个变量到本地，列举两个简单的方法 1，用 NSUserDefaults 存储小量数据 2，直接 writeTofF ile
3，存数据库
4，归档
24. 如果 UIView * view 已经实例化，在 view 仅添加了 n 个UIButton 类的实例， 这些 button 不是全局的，并且 button 已经用 tag 区分开，如何快速找出指定的一 个button 改变他的属性?
button=(UIButton*)[view viewWithTag:tag]

25.当A类 中的某个方法执行到某处时，这时想在 B类中执行某个方法，如何做? 并做简单说明
用代理执行代理方法
说明:在 b类中实现协议方法，设置
的协议方法
26.oc 中加号方法与减号方法的区别
a的代理为 b，在指定方法内 调用代理
加号方法是类方法，用类名直接调用 减号方法为实例方法，需要创建一个实例对象调用
27. 建一个工程用到的最基本的两个框架是?
Foundation UIKit
28，一个 UITableview 的实例，重新加载数据的方法是什么?
reloadData 刷新整个表格 和 reloadSections: withRowAnimation 刷新一组数据
29. XML有哪几种解析方式，他们各有什么优点
答:有 Sax和 Dom两种解析方式， 然后解析
29.iOS 平台怎么做数据持久化 有以下方式做
1、 NSUserDefaults
2、Plist
3、数据库 4、文件保存 5、归档与反归档
sax 是逐行解析。
dom是一次性全部加载
xml 文件，
是什么意思
对UIApplication 对象进行了初始化，这个方法除了
这个函数还有 2个两个字符串参数来识别 UIApplication 类和 UIApplication 代理 类，在这里默认是 2个nil, 第一个参数为 nil 就默认把 UIApplication 类作为缺省 值进行初始化，可以在这里不填 nil 而是使用自己定义的 UIApplication 子类。 至于第二个参数 nil 就设置为 nil 就把模板生成的 HelloWorldAppdelegate 类作为 默认值。
31.iOS 平台怎么做数据的持久化 ?Core Data 和 SQLite 有无必然联系? Core Data 是一个关系型数据库吗 ?
答: iOS中可以有四种持久化数据的方式: 属性列表、对象归档、 SQLite3 和
30.int retVal=UIApplication(argc,argv,nil,nil):
argc 和argv 参数外，另外

Core Data
Core data 与sqlite 还是有联系的， core data 是对sqlite 的封装，因为
sqlite 是c语言的 api ，然而有人也需要 obj-c 的api ，所以有了 core data 另 外， core data 不仅仅是把 c的api 翻译成 oc 的api ，还提供了一些管理的功能， 使用更加方便
Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS。) 虽 然 Core Dta 支持 SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据 库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支持对一、对 多的关系


34. 简述以下在 iOS 中使用 SQLIte
_fmdb = [[ FMDatabasealloc ] initWithPath :path];
[_fmdb open];
[ _fmdbexecuteUpdate : @"create table Article(ArticleId integer primary
key autoincrement,ArticleTitle text,ArticleContent text)" ];
[ _fmdbclose ];
35. 设计一个新闻浏览需要用到哪些技术
网络下载，数据解析，表单控件等
36. 谈谈你对多线程的理解
iOS 多线程分为三种 NSThread，NSOperation，GCD，NSThread以线程为导向， NSOperation 以任务为导向， GCD是 Block 模式的 NSOperation
36. ViewController 的loadView ，viewDidLoad ， viewDidUnload 分别是在什么 时候调用的?在自定义 ViewController 的时候这几个函数里面应该做做什么工 作?
loadView :
每次访问 UIViewController 的view( 比如controller.view 、self.view) 而且 view为nil ，loadView方法就会被调用。
自定义 UIViewController 的view 用的
viewDidLoad :
无论你是通过 xib 文件还是重写 loadView 方法创建 UIViewController 的view ，在 view 创建完毕后，最终都会调用 viewDidLoad 方法
一般我们会在这里做界面上的初始化操作，比如往 view 中添加一些子视图、从 数据库或者网络加载模型数据装配到子视图中。
viewDidUnload :
发出内存警告且 view 被释放的时候就会调用 viewDidUnload 方法

一般在此释放资源，主要是释放界面元素相关的资源，将相关的实例都赋值为
nil
37. 你用过 NSOperationQueue么?如果用过或者了解的话，你为什么要使用 NSOperationQueue，实现了什么?请描述它和 GCD的区别和类似的地方(提示:可以从两 者的实现机制和适用范围来描述)。
使用 NSOperationQueue用来管理子类化的 NSOperation 对象，控制其线程并发数目。 GCD和NSOperation都可以实现对线程的管理，区别是 NSOperation 和NSOperationQueue 是多线程的面向对象抽象。项目中使用 NSOperation 的优点是 NSOperation 是对线程的高 度抽象，在项目中使用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路， 是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在 复杂项目中使用。
项目中使用 GCD的优点是 GCD本身非常简单、易用，对于不复杂的多线程操作， 会节省代码量，而 Block参数的使用，会是代码更为易读，建议在简单项目中使 用。
38. 谈谈对 swift 的看法
Swift 作为 Apple 钦定的 objc 的继承者，作为 iOS/Mac 开发者的话，是觉
得必须和值得学习和使用的。现在 Swift 可以和原来的 objc 或者 c 系的代 码混用。因为在很多语法特性上 Swift 确实和一些脚本非常相似。但是首先需 要明确的是，至少在 Apple 开发中， Swift 不是以一种脚本语言来运行的，所 有的 Swift 代码都将被 LLVM 编译为 native code ，以极高的效率运行。按照 官方今天给出的 benchmark 数据，运行时比 Python 快 3.9 倍，比 objc 快 1.4 倍左右。我相信官方数据肯定是有些水分，但是即使这样， Swift 也给人 带来很多遐想和期待。 Swift 和原来的 objc 一样，是类型安全的语言，变量 和方法都有明确的返回，并且变量在使用前需要进行初始化。而在语法方面，
Swift 迁移到了业界公认的非常先进的语法体系，其中包含了闭包，多返回， 泛型和大量的函数式编程的理念，函数也终于成为一等公民可以作为变量保存 了(虽然具体实现和用法上来看和 js 那种传统意义的好像不太一样)。初步 看下来语法上借鉴了很多 Ruby 的人性化的设计，但是借助于 Apple 自己手中 强大的 LLVM，性能上必须要甩开 Ruby 不止一两个量级。
另一方面， Swift 的代码又是可以 Interactive 来“解释”执行的。新的
Xcode 中加入了所谓的 Playground 来对开发者输入的 Swift 代码进行交互式 的相应，开发者也可是使用 swift 的命令行工具来交互式地执行 swift 语句。 细心的朋友可能注意到了，我在这里把“解释”两个字打上了双引号。这是因 为即使在命令行中， Swift 其实也不是被解释执行的，而是在每个指令后进对 从开始以来的 swift 代码行了一遍编译，然后执行的。这样的做法下依然可以 让人“感到”是在做交互解释执行，这门语言的编译速度和优化水平，可见一 斑。同时 Playground 还顺便记录了每条语句的执行时候的各种情况，叫做一
组 timeline 。可以使用 timeline 对代码的执行逐步检查，省去了断点 debug 的时间，也非常方便。
39. 简述一下 IOS 中线程同步机制

1:原子操作不同线程如果通过原子操作函数对同一变量进行操作，可以保证一 个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是原子
式的。因为原子操作只能对内置类型进行操作，所以原子操作能够同步的线程 只能位于同一个进程的地址空间内。 2:锁 iOS 平台下的锁对象为 NSLock对象， 进入锁通过调用 lock 函数，解锁调用 unlock 函数(因为 iOS 中大部分的线程 同步类都继承自 NSLocking 协议，所以其加锁 / 解锁的操作基本都为
lock/unlock 函数)，同一个 NSLock对象成功调用 lock 函数后，在其显式 unlock 之前任何线程都不能再对此 NSLock 对象加锁，以达到互斥访问的目的。 3:事件 NSConditon 类型提供了 wait 与 signal 函数，分别代表了等待事件的 操作以及触发事件的操作。除了 wait 函数， NSCondition 还提供了 waitUntilDate 函数，其功能与 NSLock中的 lockBeforeDate 大致相同，简要 来说就是提供了一个带超时的 wait 函数。
40. 启动一个线程，在子线程中如何刷新界面。 可以跳转到主线程中进行界面的刷新，如 [self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:YES];

42. UIViewController 中的
viewDidLoad,viewWillAppear,viewDidUnload,dealloc 分别是在什么时候调用? viewDidLoad: 方法
在视图加载后被调用:
如果是在代码中创建的视图加载器，他将会在 loadView 方法后被调用; 如果是从 nib 视图页面输出，他将会在视图设置好后后被调用。 重载重写该方法以进一步定制 view

在 iPhone OS 3.0 及之后的版本中，还应该重载重写 viewDidUnload 来释放对 view 的任何索引
viewDidLoad 后调用数据 Model viewWillAppear: 方法
Called when the view is about to made visible. Default does nothing 视图即将可见时调用。默认情况下不执行任何操作 viewDidUnload: 方法 当系统内存吃紧的时候会调用该方法(注: viewController 没有被 dealloc ) 内存吃紧时，在 iPhone OS 3.0 之前 didReceiveMemoryWarning 是释放无用内 存的唯一方式，但是 OS 3.0 及以后 viewDidUnload 方法是更好的方式 在该方法中将所有 IBOutlet (无论是 property 还是实例变量)置为 nil (系统 release view 时已经将其 release 掉了)
在该方法中释放其他与 view 有关的对象、其他在运行时创建(但非系统必须) 的对象、在 viewDidLoad 中被创建的对象、缓存数据等 release 对象后，将对 象置为 nil (IBOutlet 只需要将其置为 nil ，系统 release view 时已经将其 release 掉了)
一般认为 viewDidUnload 是 viewDidLoad 的镜像，因为当 view 被重新请求时， viewDidLoad 还会重新被执行
viewDidUnload 中被 release 的对象必须是很容易被重新创建的对象(比如在 viewDidLoad 或其他方法中创建的对象)，不要 release 用户数据或其他很难 被重新创建的对象
dealloc: 方法
viewDidUnload 和 dealloc 方法没有关联， dealloc 还是继续做它该做的事情
43.navigationbar 的背景颜色设置
UINavigationController* nav = [[UINavigationController alloc] init];
self.nav.navigationBar.tintColor = [UIColor blackColor];
44.tableviewcell 的那几个函数
// Designated initializer. If the cell can be reused, you must pass
in a reuse identifier. You should use the same reuse identifier for
all cells of the same form.
- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
- (void)prepareForReuse;
// if the cell is reusable (has a reuse identifier), this is called
just before the cell is returned from the table view method dequeueReusableCellWithIdentifier:. If you override, you MUST call super.

- (void)setSelected:(BOOL)selected animated:(BOOL)animated; // animate between regular and selected state
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; // animate between regular and highlighted state
- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
45. 还有动画
在 iOS 中动画实现技术主要是: Core Animation 。
Core Animation 负责所有的滚动、旋转、缩小和放大以及所有的 iOS 动画效果。 其中 UIKit 类通常都有 animated :参数部分，它可以允许是否使用动画。
Core Animation 主要是使用
我们知道每个 UIView 都关联到一个 CALayer 对象， CALayer 是 Core Animation
中的图层。
Core Animation 主要就是通过修改图层来改变 UI 的大小，位置，从而实现动 画效果。
可以说，任何一个应用程序都离不开动画!
就连苹果各个 UI 控件中的切换操作，都有它内在的动画。
了解一下，关于动画的一些知识。
任何知识点，都会迁出一系列的知识点。
[UIView beginAnimations:@"dropDownloadLabel"
context:UIGraphicsGetCurrentContext()];
[UIView setAnimationDuration: 0.5];
[UIView setAnimationBeginsFromCurrentState: NO];
// 执行的动画 code [UIView commitAnimations];
就将这段段代码作为知识的切入点，开始了解吧。
[UIView beginAnimations:@"dropDownloadLabel" context:UIGraphicsGetCurrentContext()];
[UIView commitAnimations];

这两句代码，标记了一个动画的开始和结束。在中间我们可以写我们的一些动 画操作!
beginAnimations 方法
+ (void)beginAnimations:(NSString *)animationID context:(void *)context
用来，表示动画的开始。
animationID :作为动画的标识
context :自定义的一些动画数据，这些数据将发送给动画的代理方法: setAnimationWillStartSelector: 方法和 setAnimationDidStopSelector: 方法。
这个，参数，通常为 nil 。我们可以直接设置为 nil 。
这里，我们使用 UIGraphicsGetCurrentContext() ;因为此方法默认也会返回 nil 。
该方法告诉系统，我们将开始动画。并且，在该方法后，我们可以通过 setAnimationXXX (一系列方法)来设置我们进行的动画的一些参数。
完成动画后，调用 commitAnimations 方法来通知系统，动画结束。
至此，我们知道，就是设置动画的一些列参数的方法即
[UIView setAnimationDuration: 0.5];
[UIView setAnimationBeginsFromCurrentState: NO];
动画是可以嵌套的。
[UIView beginAnimations:@"animation_1" context:UIGraphicsGetCurrentContext()]; // code1
[UIView beginAnimations:@"animation_2" context:UIGraphicsGetCurrentContext()]; // code2
[UIView commitAnimations]; [UIView commitAnimations];
如果我们为动画设置了， setAnimationWillStartSelector: setAnimationDidStopSelector: 方法。
setAnimationXXX 方法。
方法和 那么当动画开始或者停止的时候，动画的 animationID 参数和 context 参数，
会传递给 setAnimationWillStartSelector: 方法和 setAnimationDidStopSelector: 方法。

悲剧总是要发生的!
苹果 API 在最后的描述中，给了这么一句话:
Use of this method is discouraged in iOS 4.0 and later. You should use the block-based animation methods to specify your animations instead.
可见，在 iOS 4.0 后， block 语法，大大增多了。这种方式，是不建议的，需 要我们使用 block 的方式。
于是，动画的 block 方式:
[UIView animateWithDuration:0.3f delay:0.0f options:UIViewAnimationOptionCurveLinear
执行的动画 // 完成后执行 code
code}
animations:^{ // completion:^(BOOL finished){
}];
在尽量用 block 来完成动画，因为说不定啥时候，老的动画方式，将被废除。 到此，可以告一段落。但是，我想将这简单的动画代码，一查到底!
commitAnimations 方法: + (void)commitAnimations
标记动画结束。与 beginAnimations 方法成对使用。 例如:
[UIView commitAnimations];
一系列的 setAnimationXXX 方法: setAnimationDuration 方法:
+ (void)setAnimationDuration:(NSTimeInterval)duration
设置动画持续时间(秒)
例如:
[UIView setAnimationDuration: 0.5];

setAnimationBeginsFromCurrentState 方法
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState
设置动画开始时的状态。 我们构想一个场景:一般，我们按下一个按钮，将会执行动画一次。
当 YES时:当上一次动画正在执行中，那么当下一个动画开始时，上一次动画 的当前状态将成为下一次动画的开始状态。
当 NO时:当上一个动画正在执行中，那么当下一个动画开始时，上一次动画需 要先恢复到完成时的状态，然后在开始执行下一次动画。
setAnimationStartDate 方法
+ (void)setAnimationStartDate:(NSDate *)startTime
设置动画开始时间。 setAnimationDelay 方法
+ (void)setAnimationDelay:(NSTimeInterval)delay
设置画开始的延迟时间(秒)。
setAnimationCurve 方法
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve
设置动画的曲线方式(就是动画的总体变化的时间曲线:开始快最后慢，开始 慢最后快，最后慢，均匀线性)。
curve 参数如下:
typedef NS_ENUM(NSInteger, UIViewAnimationCurve) {
UIViewAnimationCurveEaseInOut, and end
UIViewAnimationCurveEaseIn, UIViewAnimationCurveEaseOut, UIViewAnimationCurveLinear
};
// slow at beginning
// slow at beginning // slow at end

setAnimationRepeatCount 方法
+ (void)setAnimationRepeatCount:(float)repeatCount
设置 动画重复次数
setAnimationRepeatAutoreverses 方法
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses
设置动画是否做一次反向的执行。
如果设置为 YES:动画将执行:动画初始状态》动画》动画完成状态》动画》 动画初始状态。
如果设置为 NO:默认值
setAnimationsEnabled 方法
+ (void)setAnimationsEnabled:(BOOL)enabled
设置动画是否可用!
YES:默认值。
NO:动画效果被禁用 注意:仅仅是动画是否可用，在动画中被改变的 是动画效果被禁用了。
areAnimationsEnabled 方法
+ (BOOL)areAnimationsEnabled 返回动画效果是否被禁用。
46. 还有一个按着导航栏颜色变亮的
UI 对象依然是起作用的。仅仅
_myNav.navigationBar.translucent = YES; _myNav.navigationBar.barStyle = UIBarStyleBlack;
47. 还有个版本的问题 一、配置 SVN服务器

1、创建 Svn服务工作路径同时新建我们的 App工程，入下图所示， SVN_Project 是 SVN服务的工作路径， MyProject 是我们的 iOS 工程
2，在 Mac下有自带的 svn 服务功能( Windows下是没有的)，直接在终端打开 svn 的服务即可，在打开服务的同时指定 svn 的工作路径
(1)启动 svn 服务命令: svnserve -d -r 工作路径: ( 2)终端截图如下:
3、svn 服务启动后，要创建 svn 管理文件，管理文件有关于 svn 的各种配置 (1) 在工作目录中创建管理文件命令: svnadmin create MySVNProject
(2) 管理文件创建成功后，其目录结构如下:
(3) 接下来要配置我们的 svn, 打开 conf 文件夹如下:
(4) 配置 svnserve.conf 文件，把带一个 #的临时注释去掉即可:
(5)在 passwd中添加用户 名和密码
(6)authz 中是用户组的管理
二.把工程导入 SVN
1. 想把我们的工程导入 svn 的话，需要用到一个工具 svnx，svnx 连接 svn 服务
器，后面跟的文件是 SVN的管理文件 , 用户名和密码就是在配置文件中添加的用 户名和密码

2. 登陆成功以后，导入我们的 iOS 工程。
三、在 Xcode中 check out 工程(下面用的时 Xcode6.1 的测试版本)
1. 在 Welcome Xcode 中选中 Check out an existing Project,
2. 连接 svn 服务器( ip 后面的仍然是 svn 管理文件):
3、check out 工程
4. 在本地打开工程，在 Source Control 中进行项目的管理 有自己的产品也有外包
编程: 1、给定字符串的长度，还有换行方式算出高度。
UIFont *font = [UIFont systemFontOfSize:14]; CGSize size = [text sizeWithFont:font constrainedToSize:CGSizeMake(140, 1000) lineBreakMode:UILineBreakModeCharacterWrap];
入下图所示:
2. 写一个发送同步 http 请求，并获得返回结果的方法。 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
[request setURL:[NSURL URLWithString:urlStr]]; [request setHTTPMethod:@"GET"];
NSData *returnData = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
[request release];

6. pch 文件的作用
.pch 表示 "precompiled header", 这是一个你工程要用到的来自于外部框架的 头文件列表。 xcode 将编译这些头到文件，这将减少你在选择 Build 或 Build and Go 时编译项目的时间。通常用到的头文件已经自动包含了 pch，系统编译 每个 cpp 文件前，都会先 include 这个文件。这样就节省了添加 include 的时 间，相当于加速编译
还有就是可以再这里面放入宏，在整个工程中都可以用
7. 怎样解决重复编译 #ifndef _DEBUG #ifdef USE_MYLIB ................
#endif
8. awakeFromNib 与 viewDidLoad 区别 awakeFromNib
当.nib 文件被加载的时候，会发送一个 每个对象，每个对象都可以定义自己的
awakeFromNib的消息到 .nib 文件中的 awakeFromNib 函数来响应这个消息，
执行一些必要的操作。也就是说通过 awakeFromNib 。
viewDidLoad
当 view 对象被加载到内存是就会执行 是代码的方式创建对象都会执行 viewDidLoad 。
9. LayoutSubviews 何时会被调用
当要调整 subViews 时候，需要重写 layoutSubviews 方法。
1: 初始化 init 方法时候不会触发。
2: 滚动 UIScrollView 时会触发
3: 旋转 UIScreen 时会触发
4: 当改变 view 的值时候会触发，前提是 frame 前后值发生了变化 5: 当改变 UIview 的大小时候会触发
10. public/private/protected 的具体区别
public 公共，加上这个修饰的类或属性，可以在同一个包或者别的包里面访问 private 私有的，加上这个修饰的类或属性，只能在同类里访问，同包和别的 包不能访问
nib 文件创建 view 对象是执行
viewDidLoad ，所以不管通过
nib 文件还

protected 保护，加上这个修饰的类或属性，只能在类和同包访问，别的包不 能访问
11. ARC 是什么
ARC是 iOS 5 推出的新功能，全称叫 ARC(Automatic Reference Counting) 。
简单地说，就是代码中自动加入了 retain/release ，原先需要手动添加的用来 处理内存管理的引用计数的代码可以自动地由编译器完成了。
该机能在 iOS 5/ Mac OS X 10.7 开始导入，利用 Xcode4.2 可以使用该机能。 简单地理解 ARC，就是通过指定的语法，让编译器 (LLVM 3.0) 在编译代码时， 自动生成实例的引用计数管理部分代码。有一点， ARC并不是 GC，它只是一种 代码静态分析( Static Analyzer )工具。
12. 写一个“标准”宏，这个宏输入两个参数并返回较小的 #define MIN(X,Y) ((X)>(Y)?(Y):(X))
13. Objective-c 中有多重继承么?不是的话有声明替代方式 ? 没有多继承，可以通过协议模拟多继承
14. Objective-c 中有私有方法吗?私有变量呢? 没有私有方法，但可以将方法直接实现在 .m 文件中不在 .h 文件中声明时，外部
也不能访问。 有私有变量
15.iPhone OS 中有没有垃圾回收? 没有
16. 常见的 object-c 的数据类型有哪些，和 c 的基本类型有什么区别
答:常见的 object-c 的数据类型有 NSInteger 、 CGFloat 、 NSString 、
NSNumbe、r NSArray、 NSData，NSInteger 会根据系统是 32 位还是 64 位来决定 是本身是 int 还是 Long,
CGFloat 会根据系统是 32 位还是 64 位来决定是本身是 float 还是 double,NSString 、NSNumbe、r NSArray、NSData都是指针类型的对象 , 在堆中 分配空间，而 c 语言中的 char ， [] 等都是在栈中分配空间
17. id 声明的对象有什么特性?
id 声明的对象具有运行时的特性，即可以指向任意类型的 objcetive-c 的对象; 18. 想 nil 对象发送消息会发生什么?
答:在 Objective-C 中向 nil 发送消息是完全有效的，只是在运行时不会有任 何作用。
19. 什么是 block ? block 实现原理?
答: block 是一个特殊的 OC对象 , 它建立在栈上 , 而不是堆上 , 这么做一个是
为性能考虑 , 还有就是方便访问局部变量。默认情况下 block 使用到的局部变量 都会被复制 , 而不是保留。所以它无法改变局部变量的值。如果在变量面前加上

__block, 那么编译器回去不会复制变量 , 而是去找变量的地址 , 通过地址来访 问变量 , 实际上就是直接操作变量。另外 block 是在栈上分配的 , 所以一旦离
开作用域 , 就会释放 , 因此如果你要把快用在别的地方 , 必须要复制一份。 block 是不能保留的 , retain 对块没有意义。
20. C++ 和 OC，JAVA和 OC之间的区别? C++是功能强大，丰富的面向对象编程语言，具有私有、公有、保护权限的三种 成员变量和成员方法，具有私有、公有、保护三种继承方式，具有重写，重载， 虚函数，虚基类等多态方式，通过虚基类实现代理回调。自定义类可以没有父 类。另外具备向量，模板，友元，重载运算符等多种独特语法
Obj-C 是针对 mac OS和 iOS 设备应用程序开发的专属编程语言，采用动态继承， 消息方法机制，没有真正的重写机制，没有私有方法，继承方式为公有，具备 协议，类别， Block 等独有的语法，万用父类为 NSObject JAVA是老牌的面向对象语言，编写的程序在 JAVA虚拟机上运行，真正实现了 一次编译到处运行，具有复杂的内存回收机制，单继承模式，接口语法类似
Obj-C 的协议
21. 抽象与接口的区别?
声明方法的存在而不去实现它的类被叫做抽象类( abstract class )，它用于 要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现 该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其类型 是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象 静态方法。 Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它 们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以 在类中实现这些方法。
接口( interface )是抽象类的变体。在接口中，所有方法都是抽象的。多继承 性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有 程序体。接口只可以定义 static final 成员变量。接口的实现与子类相似，除 了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义(即将 程序体给予)所有这种接口的方法。然后，它可以在实现了该接口的类的任何 对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类 型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换， instanceof 运算符可以用来决定某对象的类是否实现了接口。
22. nil 与 NULL的区别?
从 Objective-C 语言的官方说法上看， nil 表示指向对象的指针即所谓对象的 引用为空， NULL表示指向基础类型变量即 C语言变量的指针为空。如果在非 ARC程序的编写过程中，两个空是可以互换的，但是在 ARC环境下，普通指针 和对象引用被严格限制，不能交换使用，因此也应尽量不互换使用 nil 与 NULL
23. BOOL 与 bool 的区别?
bool 是 C 语言 C99标准中增添的变量类型， Object-C 仅仅是从 C 语言继承了这
种类型，该类型有 true 和 false 两个值，表示真和假。 BOOL是 Obj-C 独有的

布尔类型，有 YES和 NO两个值，分别是 1 和 0 的宏。 Obj-C 中同时认为所有非 0 的值都是真值， 0 为假值
26. NSString 和 NSMutableString 的区别
NSString 是一个不可变的字符串对象。这不是表示这个对象声明的变量的值不 可变，而是表示它初始化以后，你不能改变该变量所分配的内存中的值，但你 可以重新分配该变量所处的内存空间。而 NSMutableString 是可变的，意味着 你可以追加它的内存空间，或者修改它所分配的内存空间中的值。

27. . 关于语句 NSString * str= [NSData alloc]init, 编译和运行分别 str 代表什么对象 ?
首先，声明 NSString *str 是告诉编译器， str 是一个指向某个 Objective-C 对象的指针。因为不管指向的是什么类型的对象，一个指针所占的内存空间都 是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有 区别的。这里限定了 NSString 只不过是告诉编译器，请把 str 当做一个 NSString 来检查，如果后面调用了非 NSString 的方法，会产生警告。 接着，你创建了一个 NSData 对象，然后把这个对象所在的内存地址保存在 str 里。那么运行时， str 指向的内存空间就是一个 NSData对象。你可以把 str 当 做一个 NSData对象来用。
28. socket 通信的几个关键步骤
面向连接的 socket 通信就像与对方打电话，首先需要通过电话建立一个连接， 连接建立好之后，彼此才能双向通信。它有几个关键步骤 服务器端通常以守护进程的方式实现 :
1: 创建守护进程
2:获取或注册服务
3:创建 socket 并绑定地址
4:开始监听
5:接收客户端连接请求
6:进行数据传输
客户端
1:获取或注册服务
2:创建 socket
3:发送连接请求
29. 类别意义?与继承的区别 当我们添加头文件以后，对已知的类，会自动提示你对这个类添加的方法 主要用途，对于原生不会造成破坏，使用原生就可以提示出你的方法
30. Core Foundation 中提供了哪几种操作 Socket 的方法? CFNetwork、CFSocket和 BSD Socket
31. 用 id 声明的对象有什么特性? ?没有* 号
? 动态数据类型
? 可以指向任何类的对象 ( 设置是 nil) ，而不关心其具体类型
? 在运行时检查其具体类型
? 可以对其发送任何(存在的)消息

32， self.name= “ object ” name=“ object ”有什么区别? 前者实际上是调用了 set 方法给变量赋值 而后者是直接给变量赋值
33.shell 中，将command的1输出作为command的2输出应该使用的命令是? 重定向命令 >
command1>command2
34. 下面的数据结构中不属于线性结构的是:栈，链表，二叉树，线性表
  线性结构:栈，链表，线性表
  非线性结构:二叉树
35， oc中有没有多继承，如果没有用什么方法替代? 没有 用协议代替多继承
36. 常见的O bjective-C 的数据类型有哪些，和C的基本数据类型有什么区别 OC中常用数据类型有
NSArray,NSDictionary,NSData,NSString,NSMutbleString 等等，和C的最大区 别为 OC中的类型是类类型，需要实例化对象才能用。 C中是一般数据类型直接操 作内存空间
37.self.name=@ “ aa”和 _name=@“ aa”的区别
答: self.name=@“aa”是通过 set 方法进行赋值， _name=@“aa”是直接复制给 成员变量
38.C 语言中指针与数组的区别 答:指针是变量可以修改指向的方向，数组名是地址常量，不能被修改 39.new delete malloc free 的含义
c++:new 申请内存， delete 释放掉指针指向的内存 c:malloc 动态申请内存， free 释放指针指向的内存
40. 常引用什么时候使用 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函
数中被改变，就要使用常引用 41.c/oc/c++ 有什么区别和联系
C相对于 C++和 OC而言更偏重于逻辑算法，这是因为 C是面向过程， C++ 和 OC都是面向对象。 C和 C++的联系: C是 C++的一个自洽子集， C++是 C的超
集， OC是 C的扩展， C++和 OC基本兼容 C的语法。 42.const 的用法
const 修饰变量表示该变量是只读变量(有些人管它叫常量)，即只能 引用而不能修改

改
const int *p; int *const p;
P 指向的数据不能改
P 的值不能该，或者说是指针 P 的指向不能
43.[pool release] drain
有什么区别
 表示指针变量
 表示指针变量
和[pool drain]
和 release 都会促使自动释放池对象向池内的每一个对
象发送 release 消息来释放池内对象的引用计数，但是 release 触发的这个操作， 不会考虑对象是否需要 release ，而 drain 会在自动释放池向池内对象发送
release 消息的时候，考虑对象是否需要 release
44. 自动释放池和 GC一样吗， iphone 有没有 GC 在引用计数环境下，
ios 是没有垃圾回收的，自动释放池是 oc 中管理内存的一种方式，它和 gc 是 本质区别的，自动释放池管理内存的前提是，必须把要管理内存的对象加入池 内，才会生效。而 gc 是不断检测当前程序中是否有不再使用的内存进而释放。 45.当A类 中的某个方法执行到某处时，这时想在 B类中执行某个方法，如何做? 并做简单说明
用代理执行代理方法
说明:在 b类中实现协议方法，设置 a的代理为 b，在指定方法内 调用代理 的协议方法
46. 类别的作用 ?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的
方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，
因为类别具有更高的优先级。
类别主要有 3个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。 (2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。
47. 简述 extern C 的作用
可以在 C++中使用 C的已编译好的函数模块 , 在 c++中么用到 c 语言写的函数， 声明一下 , 在 DLL 中经常看到 , 避免 C++ name mangling ，主要用于动态链接库， 使得导出函数名称与 C 语言规则一致(不改变)，方便不同的编译器甚至是不 同的开发语言调用。
extern "C" 是告诉 C++编译器以 C Linkage 方式编译，也就是抑制 C++的name mangling 机制。
编程:
1. 写出@proerty(nonatomic,retain)Person *person;@synthesize person 具 体实现。
- (void)setPerson:(Person *)person {

if(_person != person){ [_person release];
[_person = person retain]; }
}
- (Person *)person {
return _person; }
2. 从普通 id 类型对象转换成数字对象，因为配置了限定词 五入，并保留一位小数
NSDictionary* rowData = [NSDictionarydictionaryWithObjectsAndKeys:@"46.95",@"price",nil]; NSLog(@"a double value:%.1f",[(NSNumber*)[rowData objectForKey:@"price"] doubleValue]);
输出:
a double value:47.0 3，写一个委托的 interface
#import
@protocol MyDelegate;// 声明 @interface MyClass:NSobject
{
id delegate; }
@end
@protocol MyDelegate// 委托方法 -(void) selector:(NSString *) args; @end
4: 请看下面一段代码 static int a=1;
int main(){
int b=2;
char* c=NUll; c=(char*)malloc(100*sizeof(char)); return 0;
}
问: 1，访问 abc三者的效率从高到低依次是 :
bca
.1f ，所以结果四舍

2，在最坏情况下排序速度最快的是:归并排序 复杂度最高的是:快排，冒泡，堆，归并



8、类别( category )的作用?继承和类别在实现中有何区 别?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能 删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类
别具有更高的优先级。 类别主要有 3 个作用: (1) 将类的实现分散到多个不同文件或多个不同 框架中。 (2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。 继承可以增加，修改 或者删除方法，并且可以增加属性。
9 、类别 (category) 和类扩展 (extension) 的区别
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须要实现
的。 extensions 可以认为是一个私有的 Category。
10、Object -c 的类可以多重继承么?可以实现多个接口 么?重写一个类的方式用继承好
答案: Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现， cocoa 中所有的类都是 NSObject 的子类，多继承在这里是用 protocol 委托代理 来实现的。

11 、代理的作用? 什么时候可以用代理
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获 取到那些类的指针。可以减少框架复杂度。另外一点，代理可以理解为 java 中的回调监听机制 的一种类似。
12、delegate 和 notification 区别 答案: Delegate:
消息的发送者 (sender)告知接收者 (receiver) 某个事件将要发生， delegate 同意然然后发送者响应事 件， delegate 机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对 多的关系。
Notification:
消息的发送者告知接收者事件已经发生或者将要发送， 仅此而已， 接收者并不能反过来影响发送 者的行为。通常发送者和接收者的关系是间接的多对多关系。
13 、UITableView 的简单描述及功能介绍，如何实现一个 简单的列表?
答案: UITableView 继承自 UIScrollView ，可以表现为 Plain 和 Grouped 两种风格 UITableView 有两个 Delegate 分别为: dataSource 和 delegate
dataSource 是 UITableViewDataSource 类型，主要为 UITableView 提供显示用的数据 (UITableViewCell) ，指定 UITableViewCell 支持的编辑操作类型 (insert ， delete 和 reordering) ，并 根据用户的操作进行相应的数据更新操作， 如果数据没有更具操作进行正确的更新， 可能会导致 显示异常，甚至 crush 。
delegate 是 UITableViewDelegate 类型，主要提供一些可选的方法， 用来控制 tableView 的选 择、指定 section 的头和尾的显示以及协助完成 cell 的删除和排序等功能。

14 、 tableView 的重用机制?
答案: 查看 UITableView 头文件，会找到 NSMutableArray* visiableCells ，和 NSMutableDictnery* reusableTableCells 两个结构。 visiableCells 内保存当前显示的 cells ， reusableTableCells 保存可重用的 cells 。
TableView 显示之初， reusableTableCells 为空，那么
tableView dequeueReusableCellWithIdentifier:CellIdentifier 返回 nil 。开始的 cell 都 是通过
[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 来创建，而且 cellForRowAtIndexPath 只是调用最大显示 cell 数的次数。
比如:有 100 条数据， iPhone 一屏最多显示 10 个 cell 。程序最开始显示 TableView 的情况是:
1.用
[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]
创建 10 次 cell ，并给 cell 指定同样的重用标识 ( 当然，可以为不同显示类型的 cell 指定不同的标 识)。并且 10 个 cell 全部都加入到 visiableCells 数组， reusableTableCells 为空。
2.向下拖动 tableView ，当 cell1 完全移出屏幕，并且 cell11( 它也是 alloc 出来的，原因同上 )完全 显示出来的时候。 cell11 加入到 visiableCells ，cell1 移出 visiableCells ，cell1 加入到
reusableTableCells 。
3.接着向下拖动 tableView ，因为 reusableTableCells 中已经有值，所以，当需要显示新的 cell ，
cellForRowAtIndexPath 再次被调用的时 候，
tableView dequeueReusableCellWithIdentifier:CellIdentifier ，返回 cell1 。 cell1 加入到 visiableCells ，
cell1 移出 reusableTableCells ; cell2 移出 visiableCells ， cell2 加入到 reusableTableCells 。之后再 需要显示的 Cell 就可以正常重用了。


17 、 自动释放池是什么 ,如何工作
答案: 当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最 新的自动释放池。 它仍然是个正当的对象， 因此自动释放池定义的作用域内的其它对象可以向它 发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象也就被 释放。
1. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到有 copy,retain 的时候引用计数都会加一 , 每当碰到
release 和 autorelease 的时候引用计数就会减一 ,如果此对象的计数变为了 0, 就会被系统销毁 . 2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease 和 release 没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的使 用真正结束的时候才做引用计数减一 .

18 、对单例模式的理解
答案: 单例模式的意思就是只有一个实例。 单例模式确保某一个类只有一个实例， 而且自行实例
化并向整个系统提供这个实例。这个类称为单例类
19 、什么是 TCP 连接的三次握手
答案:第一次握手:客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器 确认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN ( ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包 发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理 想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接都将被 一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需 要经过 ―四次握手 ‖(过程就不细写了，就是服务器和客户端交互，最终确定断开)
20 、 TCP/UDP 区别联系
答案: TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换
数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢弃 重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是 把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输 数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快
TCP(Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在正式收 发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能建立起来，我 们来看看这三次对话的简单过程: 1. 主机 A 向主机 B发出连接请求数据包; 2.主机 B 向主机 A 发送 同意连接和要求同步(同步就是两台主机一个在发送，一个在接收，协调工作)的数据包; 3. 主机 A再发出一个数据包确认主机 B的要求同步: ―我现在就发，你接着吧! ‖，这是第三次对话。 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次 ―对话 ‖之后，主机 A 才向主机 B 正式 发送数据。

UDP ( User Data Protocol ，用户数据报协议)是与 它不与对方建立连接，而是直接就把数据包发送过去!
靠性要求不高的应用环境。
tcp协议和 udp协议的差别 是否连接面向连接面向非连接
传输可靠性可靠不可靠
应用场合传输大量数据少量数据
速度慢快
21 、 socket 连接和 http 答案:简单说，你浏览的网页(网址以
基于 socket 之上的。 socket 是一套完成
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP 连接的
tcp 协议: 对应于传输层
TCP 相对应的协议。它是面向非连接的协议， UDP 适用于一次只传送少量数据、对可
连接的区别
http:// 开头 )都是 http 协议传输到你的浏览器的
, 而 http 是
tcp，udp 协议的接口。
ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解决如 何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，通过 Socket ， 我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连 接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主 动断掉;但是由于各种环境因素可能会是连接断开，比如说:服务器端或客户端主机 down 了，
网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。 所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心跳消息 ~~具体心跳消 息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ， 而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read –> 关闭
close 模‖式来操作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一种特殊的文件， 一些 socket 函数就是对其进行的操作(读 / 写 IO 、打开、关闭) ，这些函数我们在后面进行介绍。
我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样的话，如果没有应用层，便 无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应用层协议， 应用层协议有很 多，比如 HTTP 、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用 层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。

(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信的能 力。)
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通过
Socket，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数接口。
22、利用 Socket 建立网络连接的步骤
答案:建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为
一个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
TCP/IP 协议栈
ClientSocket ，另
1。服务器监听:服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实 时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此， 客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口 号，然后就向服务器端套接字提出连接请求。
3。 连接确认: 当服务器端套接字监听到或者说接收到客户端套接字的连接请求时， 端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认
了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其他客户端套 接字的连接请求。
23、简单描述下 同步请求、异步请求、 GET 请求、 POST 请求
答案:
1、同步请求可以从因特网请求数据，一旦发送同步请求，程序将停止用户交互，直至服务器返 回数据完成，才可以进行下一步操作，
2、异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以 对UI 进行操作，程序可以继续运行
3、 GET 请求，将参数直接写在访问路径上。操作简单，不过容易被外界看到，安全性不高，地 址最多 255字节;
4、POST请求，将参数放到 body里面。 POST请求操作相对复杂，需要将参数和地址分开，不过 安全性高，参数放在 body 里面，不易被捕获。
就响应客户

24、JSON与 XML 的区别比较 答案: 1.定义介绍
(1).XML 定义 扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有 结构性的标记语言， 可以用来标记数据、 定义数据类型， 是一种允许用户对自己的标记语言进行
定义的源语言。 XML 使用 DTD(document type definition) 文档类型定义来组织数据 ;格式统一， 跨 平台和语言，早已成为业界公认的标准。 XML 是标准通用标记语言 (SGML) 的子集，非常适 合 Web 传输。 XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。
(2).JSON 定义 JSON(JavaScript Object Notation) 一种轻量级的数据交换格式，具有良好的可读和 便于快速编写的特性。可在不同平台之间进行数据交换。 JSON采用兼容性很高的、完全独立于 语言文本格式，同时也具备类似于 C语言的习惯 (包括 C, C++, C#, Java, JavaScript, Perl, Python 等 ) 体系的行为。这些特性使 JSON成为理想的数据交换语言。 JSON基于 JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。
2.XML 和 JSON优缺点
(1).XML 的优缺点 <1>.XML 的优点 A.格式统一， 符合标准; B.容易与其他系统进行
远程交互，数据共享比较方便。 <2>.XML 的缺点 A.XML 文件庞大，文件格式复杂，传输 占带宽; B.服务器端和客户端都需要花费大量代码来解析 XML ，导致服务器端和客户端代 码变得异常复杂且不易维护; C. 客户端不同浏览器之间解析 XML 的方式不一致， 需要重复
编写很多代码;
Ruby 等服务器端语言， 便于服务器端的解析; D. 在 PHP世界，已经有 PHP-JSON 和 JSON-PHP 出现了，偏于 PHP 序列化后的程序直接调用， PHP 服务器端的对象、数组等能直接生成 JSON 格
式，便于客户端的访问提取; E.因为 JSON格式能直接为服务器端代码使用，大大简化了 服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。 <2>.JSON 的缺点 A. 没有XML 格式这么推广的深入人心和喜用广泛，没有 XML 那么通用性; B.JSON格式目前 在Web Service 中推广还属于初级阶段。
3.XML 和 JSON的优缺点对比
(1). 可读性方面。 JSON 和 XML 的数据可读性基本相同， JSON和 XML 的可读性可谓不相上下，
一边是建议的语法，一边是规范的标签形式， XML 可读性较好些。 (2).可扩展性方面。 XML 天生有很好的扩展性， JSON 当然也有，没有什么是 XML 能扩展， JSON不能的。 (3). 编码难度 方面。 XML 有丰富的编码工具， 比如 Dom4j 、JDom等，JSON也有 json.org提供的工具， 但是 JSON 的编码明显比 XML 容易许多， 即使不借助工具也能写出 JSON的代码， 可是要写好 XML 就不太容 易了。 (4). 解码难度方面。 XML 的解析得考虑子节点父节点，让人头昏眼花，而 JSON的解析 难度几乎为 0。这一点 XML 输的真是没话说。 (5). 流行度方面。 XML 已经被业界广泛的使用， 而JSON才刚刚开始，但是在 Ajax这个特定的领域，未来的发展一定是 XML 让位于 JSON。到时 Ajax 应该变成 Ajaj(Asynchronous Javascript and JSON) 了。 (6). 解析手段方面。 JSON和 XML 同
D.服务器端和客户端解析 XML 花费较多的资源和时间。
<1>.JSON 的优点: A. 数据格式比较简单， 易于读写， 格式都是压缩的，
B.易于解析，客户端 JavaScript可以简单的通过 eval()进行 JSON数据的读取; C.支持多种语言，包括 ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python,
(2).JSON 的优缺点 占用带宽小;

样拥有丰富的解析手段。 (7).数据体积方面。 JSON相对于 XML 来讲，数据的体积小，传递的 速度更快些。 (8).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好 的数据交互。 (9).数据描述方面。 JSON对数据的描述性比 XML 较差。 (10). 传输速度方面。
JSON 的速度要远远快于 XML 。 4.XML 与 JSON数据格式比较
(1).关于轻量级和重量级 轻量级和重量级是相对来说的， 那么 XML 相对于 JSON的重量级体现在 哪呢 ?应该体现在解析上， XML 目前设计了两种解析方式: DOM 和 SAX 。 <1>.DOM DOM 是
把一个数据交换格式 XML 看成一个 DOM 对象，需要把 XML 文件整个读入内存，这一点上 JSON 和 XML 的原理是一样的， 但是 XML 要考虑父节点和子节点， 这一点上 JSON 的解析难度要小很多， 因为 JSON 构建于两种结构: key/value ，键值对的集合 ;值的有序集合，可理解为数组;
<2>.SAX SAX 不需要整个读入文档就可以对解析出的内容进行处理， 是一种逐步解析的方法。 程序也可以随时终止解析。这样，一个大的文档就可以逐步的、 一点一点的展现出来， 所以 SAX 适合于大规模的解析。这一点， JSON目前是做不到得。 所以， JSON和XML 的轻 /重量级的区 别在于: JSON 只提供整体解析方案，而这种方法只在解析较少的数据时才能起到良好的效果;
XML 提供了对大规模数据的逐步解析方案，这种方案很适合于对大量数据的处理。 (2).关于数据格式编码及解析难度 <1>.在编码方面。 虽然 XML 和JSON都有各自的编码工具，
但是 JSON 的编码要比 XML 简单，即使不借助工具，也可以写出 JSON 代码，但要写出好的 XML 代码就有点困难 ;与XML 一样， JSON也是基于文本的，且它们都使用 Unicode 编码，且其与数据 交换格式 XML 一样具有可读性。 主观上来看， JSON 更为清晰且冗余更少些。 JSON网站提供了 对JSON语法的严格描述，只是描述较简短。从总体来看， XML 比较适合于标记文档，而 JSON 却更适于进行数据交换处理。 <2>.在解析方面。 在普通的 web应用领域，开发者经常为 XML 的解析伤脑筋，无论是服务器端生成或处理 XML ，还是客户端用 JavaScript 解析 XML ，都常常 导致复杂的代码，极低的开发效率。 实际上，对于大多数 Web 应用来说，他们根本不需要复杂 的XML 来传输数据， XML 宣称的扩展性在此就很少具有优势 ,许多 Ajax 应用甚至直接返回 HTML 片段来构建动态 Web 页面。和返回 XML 并解析它相比， 返回 HTML 片段大大降低了系统的复杂性， 但同时缺少了一定的灵活性。同 XML 或 HTML 片段相比，数据交换格式 JSON 提供了更好的简 单性和灵活性。在 Web Serivice 应用中，至少就目前来说 XML 仍有不可动摇的地位。
(3). 实例比较 XML 和 JSON都使用结构化方法来标记数据，下面来做一个简单的比较。 <1>. 用 XML 表示中国部分省市数据如下:
<?xml version="1.0" encoding="utf-8" ?> <country>
<name>中国 </name> <city >哈尔滨</city >
<province > <city >大庆
<name>黑龙江</name> </ city > </ citys
>
<citys >
</ province
<name>广东
</ name> <citys <city >珠海 </ city >
>
<city
> <province >
>广州</ city > <city >深圳</ city >
台湾</ name> </ city >
< citys >
</ citys > <citys >
</ province > <city >台北</ city >
</ citys > </ province > <province > <city > 乌鲁木齐 </ city > </ citys >
<province > <city >高雄
<name >
</
<name >新疆 </ name > province > </ country >

<2>. 用JSON 表示中国部分省市数据如下:
var country = { name: " 中国 ", provinces:
", " 大庆 "]} },
{ name:
name: "新疆", citys:
如果有:简单
{ name: " 黑龙江 ", citys: { city: [" 哈尔滨
[
{ name: "广东", citys: { city: [" 广州", "深圳", "珠海"]} }, "台湾", citys: { city: [" 台北", "高雄"]} }, {
{ city: [" 乌鲁木齐 "]} } ] }
25 、曾经是否发布过 IOS 应用到 App store? 描述下发布流程
答案:还得实际操作

3 info.plist 和 Prefix.pch 的用处 info.plist
项目的配置属性
Prefix.pch
1.存放一些全局的宏 (整个项目中都用得上的宏 )

2. 用来包含一些全部的头文件 (整个项目中都用得上的头文件 ) 3.能自动打开或者关闭日志输出功能
4iOS中是否有多继承?怎么实现多态? 没有
分类和协议
5 多线程有哪些?主线程和次线程有什么区别?怎么通信? NSThread GCD NSOperation 主线程不需要创建就存在，子线程需要创建，初始时候不存在 更新 UI必须在主线程 而进行延时操作一般都在子线程
-(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait
dispatch_async(dispatch_get_main_queue(), <#^(void)block#>) 6 数据存储的方式

1 plist
2 归档
3 SOLite
4CoreData
7jason 解析遇到大量数据解析过程时，在内存上的优化办法
利用 json 的反序列话的几个代理方法， 实现大数据的分割， 解析， 拼接，保存，从而降低内存的消耗。
优化后台接口，使后台返回的数据大小更合理
在APP 中，一般不会出现大数据，因此注意接口的优化，尽量不 要使用数据分割的方式，因为可能引起数据解析错误

9iOS中的文件目录以及常保存的数据内容

1、 Documents 目录:您应该将所有 de 应用程序数据文件写入到 这个目录下。这个目录用于存储用户数据或其它应该定期备份的 信息。
2、AppName.app 目录:这是应用程序的程序包目录，包含应用 程序的本身。由于应用程序必须经过签名，所以您在运行时不能 对这个目录中的内容进行修改， 否则可能会使应用程序无法启动。
3、 Library 目录:这个目录下有两个子目录: Caches 和 Preferences
Preferences 目录:包含应用程序的偏好设置文件。您不应该直 接创建偏好设置文件，而是应该使用 NSUserDefaults 类来取得和 设置应用程序的偏好 .
Caches 目录:用于存放应用程序专用的支持文件，保存应用程 序再次启动过程中需要的信息。
4、 tmp 目录:这个目录用于存放临时文件，保存应用程序再次 启动过程中不需要的信息。
10查找 table 中 id<10 和随机 10条的 sql 语句 select top 10* from Table where id < 10 select top 10* from Table order by newid(



27. 重载和覆盖的区别。重载的 ?方法是否可以改变返回值的类型? 18
28.UIView的圆?角属性设置 ?方法 19 29. 请解释以下两种设计模式: ?工 ?厂模式，单例模式 19

31.在.m?文件Class Extension 中声明的私有 ?方法，其他类能否调 ?用?若强 ?行调 ?用会发 ?生什
19 么?
32.在调?用?支付宝接 ?口?支付p时ar，tner，seller，private分别是什么意思 ? 20 33.谈谈如何在 MVC模式中减轻 ViewController 的重量(减少代码) 20
34.为什么很多内置的类，如 TableViewController 的delegate的属性是assign不v是retain? 20
35.列举?几个你曾经 ?用过的第三 ?方库? 20 36. ?用宏定义来写出 ?一个判断系统是否是iOS7 以上的版本的例 ?子 21
37. Objective-C 的动态性体现在哪些 ?方?面 38. 下 ?面的代码会造成什么问题
21 21
39. ios 平台怎么做数据的持久化 数据库吗?
和 sqlite 有 ?无必然联系?coredata 是 ?一个关系型
?coredata
40. 多线程中堆与栈分别是共有的还是私有的?(记住) 22
41.Objective-C 声明 ?一个类所有要 ?用到的编译指令是? 22 42.?用预编译指令#de?ne 声明?一个常数， ?用以表1?年示中有多少秒(忽略闰年问题) 22 43.解析XML?文件有哪 ?几种?方式? 22 44.下?面哪个 ?方法不属于NSObject 的内省( Introspection )?方法 22 45.iOS 开发中，开发证书根据 ?用途划分可以分为哪两 ?大类，分别作 ?用是什么?22?用途 46. 关键字 const 有什么含义? static 的作 ?用?还有extem C 的作 ?用? 23
47. 让 ?一个物体从界 ?面中的 ?一点运动到另外 ?一点，有哪些 ?方法? 23
48. 什么是多继承?
23
49.ViewController 的loadView,viewDidLoad,didReceiverMemoryWarning 分别是什么时候 调?用的,在初始化 ViewController 时在这 ?几个函数中应该做什么 ?工作? 23
50. 对于语句 NSString * obj = [[NSData alloc] init];obj 象?
51.什么时候 ?用delegate, 什么时候 ?用Noti?cation? 52. 浅赋值和深赋值的区别。
53. 介绍下 KVC 和 KVO
在编译时是和运
?行时分别是什么对 24

54. 多线程实现的三种 ?方式 25
55. 谈谈对 Block 的理解 ? 25
56. 看下 ?面的程序,第 ?一个NSLog 会输出什么 ?这时 str的 retainCount 是多少 ?第 ?二个和第三个
呢?为什么 ?

58. 常 ?见的数据持久化 ?方法有哪?些
59. 简述 tableView 的重 ?用机制。

61. 描述 ?一下runtime 的概念 ,message send 理?

62.什么是 method swizzling? (了解)
63.Cocoa Touch 包含什么 ? 不包含什么 ?
64. 响应链 (Responder chain) 是什么 ? 它是如何发挥作 ?用的?
65. 如何获取项 ??目根路,径并在其下创建 ?一个名称为userData 66.iPhone5,6,6+ 以及iPad Air 2 的屏幕分辨率分别是多少 ? 67. 分辨率的计算单位是什么 ?
68.UIButton 的?父类是什么?
69. 请解释 ?一下Interface Bulder 的作 ?用以及NIB ?文件的概念
的 ??目录
70.选项卡 (Tab Bar)和?工具栏(Toolbar) 分别是什么
?两者之间
71. 数据库中索引的作 ?用?和它的优缺点是什么 72.UIImageView 如何响应点击事件 ?
?
有何共同点和不同点 29 29 29 29 30 30 31 ?用? 31
73.如何实现 UIScrollView ?无限滚动?
74.多线程中 ,访问同 ?一变量,如何加锁 ?
75. 写 ?一个委托的 interface
76.UITableview 的执 ?行流程是怎么样的?
77. 简述 XMPP 中有哪些节点，各个节点分别有什么作
78.使?用AVPlayer 播放视频时，视频监听的 AVPlayerItem 状态有 ?几种，分别是什么及作
?用?
79. 简述使 ?用CLLocationManager 定位时，如何停
80.iOS 中有 ?几种消息机制，区别以及各种机制的使
?止定位?
?用场(很景全 ?面哦)
31 31 31 31
?方 32 32
81.UI布局的?几种?方式，各种 ?方式的利弊谈谈您的看法
82. 你 ?用过NSOperationQueue 吗?请描述它和 GCD 的区别和类似的地
83.HTTP 和 Socket 的区别 ?
84.Core Foundation 中提供了哪
85. 请描述 Xcode 打包签名机制中 系?
?几种操作Socket 的 ?方法?
Certi?cates & Identi?ers & Provisioning Pro?les 三者的关
86.iCloud 包含了哪些技术与服务?
1.int a = -45; a 答: ?二进制:-101101 ?八进制:-55
第?一部分C语?言?面试试题选集 的?二进制值是??八进制?
2.堆和栈的区别? 答:
a. 堆栈空间分配区别:
栈:由操作系统 ?自动分配释放，存放函数的参数值，局部变量的值等。
其操作 ?方式类似于数据结构中的栈，先进后出。
堆: ?一般由开发 ?人员分配释放，若开发 ?人员不释放，程序结束时由系统
回收，分配 ?方式类似于链表，堆区 ?用来开辟的空间和回收空间的操作分别是 malloc 和free。
b. 内存分配和读取效率区别:
栈:栈由系统 ?自动分配，速度快，但是程序员 ?无法控制。
堆:堆是由程序员 ?自?己分配，速度较慢，容易产 ?生碎 ?片，不过 ?用起来 ?方
便， ?非常灵活。
c.申请 ?大?小不同:
栈:栈是向低地址扩展的数据结构，是 ?一块连续的内存区域，栈顶的地
址和栈的最 ?大容量是系统预先规定好的，能从栈获得的空间较 ?小。
堆:堆是向 ?高地址扩展的数据结构，是不连续的内存区域，这是由于系 统是由链表在存储空闲内存地址， ?自然堆就是不连续的内存区域，且链表的遍
历也是从低地址向 ?高地址遍历的，堆得 ?大?小受限于计算机系统的有效虚拟内存 空间，由此空间，堆获得的空间 ?比较灵活，也 ?比较?大。
3.请简述 ?文字编码:gb2312.Unicode.utf-8 的编码 ?方式? 答:
GB2312 :编码适 ?用于汉字处理、汉字通信等系统之间的信息交换，通 ?行于中 国?大陆;新加坡等地也采 ?用此编码。中国 ?大陆 ?几乎所有的中 ?文系统和国际化的
软件都 ?支持GB2312 。
Unicode (统 ?一码、万国码、单 ?一码)是 ?一种在计算机上使 ?用的字符编码。
Unicode 是为了解决传统的字符编码 ?方案的局限 ?而产 ?生的，它为每种语 ?言中的 每个字符设定了统 ?一并且唯 ?一的 ?二进制编码，以满 ?足跨语 ?言、跨平台进 ?行?文本 转换、处理的要求。
UTF-8 ( 8-bit Unicode Transformation Format )是 ?一种针对Unicode 的可变 ?长 度字符编码。
6

 千锋教育 12/29
4.static 关键字的作 ?用?
答:
(1)设置变量的存储域，函数体内 static 变量的作 ?用范围为该函数体，该变量 的内存只被分配 ?一次，因此其值在下次调 ?用时仍保存上次的值; (2)限制变量的作 ?用域，在模块内的static 全局变量可以被模块内所 ?用函数访 问，但不能被模块外其它函数访问;
(3)限制函数的作 ?用域，在模块内的static函数只可被这 ?一模块内的其它函数 调?用，这个函数的使 ?用范围被限制在声明它的模块内;
5.解释下列变量 a的定义? a. int *a[10];
b.
c. int (*a)(int);
d. int (*a[10])(int);
答案:
a. 定义 ?一个存放10个整型指针变量的数组。
int (*a)[10];
b. 定义 ?一个 ?用来存放包含10个元素的整型数组的
c. 定义 ?一个 ?用来指向返回值是int，并且有 ?一个参数，参数类型为int的函数
指针。
d. 定义 ?一个 ?用来存放10个指向返回值是
int 的函数指针的指针数组。 6.以下程序输出的结果是什么 ?
main() {
int a[5] = {1,2,3,4,5};
int *ptr = (int *)(&a+1);
printf( “%d,%d”,*(a+1),*(ptr - 1));
}
答:2 和5。&a 为取数组名的地址，即为整个数组的地址，它的类型为数组类
型，(int*)(&a+1) 将其强制转换成整型指针赋值给 *ptr，并指向了数组界外，最 后?用*(ptr-1) ?又指向了界内的最后 ?一个元素5。&a + 1 增加的是整个数组的 ?大?小
(20)，?而a + 1 增加的是 ?一个元素的 ?大?小4()。
7.找出下三段代码的错误 : void test()
{
char string[10];
char * str1 = *0123456789; strcpy(string,str1);
}
7
?首地址的指针变量。
int ，并且有 ?一个参数，参数类型为

 千锋教育 12/29
void test2()
{
char string[10],str1[10];
int i;
for(i = 0;i < 10,i++) {
str1 = ‘a’; }
strcpy(string,str1); }
答:
void test() {
char string[10];
char * str1 = *0123456789;
strcpy(string,str1); //注意strcpy特点，后 ?面\0字符串11位越界
}
void test2() {
char string[10],str1[10]; int i;
for(i = 0;i < 10,i++) {
str1 = ‘//数a’组;名是常量地址，不允许赋值。
}
strcpy(string,str1); }
8.写?一算法进 ?行排序。排序数字为{9，6，3，5，8，7} 答:
void bubbleSort(int a[], int n) {
BOOL ?ag = YES;
for (int i = 0; i < n - 1 && ?ag; i++) {
?ag = NO;
for (int j = 0; j < n - 1 - i; j++) { if (a[j] > a[j + 1]) {
int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; ?ag = YES;
} }
//此处字符串定义错误，应使
?用双引号
8

 千锋教育 12/29 }
}
9.有?一块 ?木头，3?0长?米，短的 ?一截是 ?长的 ?一3/截5，的?长的 ?一截有多 少?米?
答: 30 / 8 * 5 = 18.75
10. 选择题
有三个数 的是( )
a, b, c ，其中满 ?足a + b > c, b + c > a, a + c > b,
那么下列式 ?子正确 ， 得出 2a + 2b + 2c
B. a + b + c > 0 C.bc > ab D. c < a < b < 0 三个式 ?子相加， a + b > c, b + c > a, a + c > b
a > b > 0
答案: B,
> a + b + c ， 再得出 2a + 2b + 2c - a- b- c > 0 ， 最终得出 a + b + c > 0 。
11.链表与数组的区别
答:链表和数组都可 ?用来存放指定的数据类型。 链表的特性是在中间任意位置添加删除元素的都 ?非常的快，不需要移动其它的 元素。通常链表每 ?一个元素都要保存 ?一个指向下 ?一个元素的指针(单链表)。 双链表的话每个元素即要保存到下 ?一个元素的指针，还要保存 ?一个上 ?一个元素
的指针。循环链表则把最后 ?一个元素中保存下 ?一个元素指针指向第 ?一个元素。 数组是 ?一组具有相同类型和名称的变量的集合。这些变量称为数组的元素 ,每个
数组元素都有 ?一个编号,这个编号叫做下标 ,我们可以通过下标来区别这些元 素。数组元素的个数有时也称之为数组的 ?长度。
第?二部分Objective-C 与UI?面试试题选集
1.类别和类扩展的区别 ?
答:
类别 (Category) 和类扩展 (Extensions) 都可 ?用来为类扩充功能。
类别:可以为有源代码的类和 ?无源代码的类扩充功能， ?而且只能添加 ?方法， ?方 法必须实现。 ?子类可继承，可直接访问。 类扩展:只能为有源代码的类扩充功能。不光可以扩充实例变量，也可以扩充 ?方法，但是 ?方法和实例变量都是私有的。 ?子类可继承，但是不可直接访问。
2.Objective-C 的类可以多重继承吗 ? 可以实现多个接 ?口?吗category 是什么?
答:
Objective-c 的类不可以多重继承，只允许单根继承。
可以实现多个接 ?口，通过实现多个接 ?口可以完成多重继承;
Category 是类别，可以为有源代码的类和 ?无源代码的类扩充功能， ?而且只能添
加?方法，?方法必须实现。 ?子类可继承，可直接访问。
9

 千锋教育 12/29
3.Objective-C 属性特性 (assign ，retain ，copy ，readonly ，
readwrite ，atonmic ，nonatomic) 答:
assign : ?用于基本数据类型，直接赋值。也可以 ?用于对象，只不过s当etter ?方法 赋值时，只是简单存储地址，不会造成引 ?用计数的改变，可以解决循环引 ?用问 题。
retain : ?用于对象类型，当赋值时，先将旧值释放，对新值 retain 引 ?用计数加1 copy:?用于对象类型，根据实现的 NSCopying 协议的copyWithZone :?方法的
不同，可以实现伪拷 ?贝，浅拷 ?贝，深拷 ?贝。
readwrite : 可读可写特性。 当属性 ?生成 ?方法时，既 ?生se成tter ?方法，也 ?生成
getter ?方法。
readonly :只读特性 。当属性 ?生成 ?方法时，只会 ?g生e成tter ?方法，不会 ?生成
setter ?方法。
nonatomic :?非原?子性访问，当调 s?e用tter以及getter?方法访问实例变量时，不 会保证线程安全，但是访问效率 ?高。
atomic :原 ?子性访问，当调 ?s用etter 以及 getter ?方法访问实例变量时，会加多线 程处理，访问时加锁，访问结束解锁，安全性 ?高，但是访问效率低。
4.?自动释放池是什么,如何 ?工作?
答:?自动释放池提供了 ?一个对象容器，每次对象发送autorelease 消息时，对象
的引 ?用计数并不真正变化， ?而是向 ?自动释放池中添加 ?一条记录，记下对象的这 种要求。直到当 ?自动释放池发送drain 或release 消息时，即当池被销毁前会通
知池中的所有对象，全部发送 release 消息才会真正将引 ?用计数减少。简单说 ?自 动释放池可以 ?自动管理对象释放问题，这些语句必须要放在下 ?面语句之间，直 到池被释放， ?一个对象要想纳 ?入内存释放池对象，必须要发送autorelease 。
5.写代码，完成下列内容
写?一个setter ?方法 ?用于完成@property (nonatomic,retain) NSString * name ;
写?一个setter ?方法 ?用于完成@property (nonatominc,copy) NSString * name; 答:
@property (nonatomic, retain) NSString * name - (void)setName:(NSString *)name {
if (_name != name) { [_name release]; _name = [name retain];
} }
@property (nonatominc, copy) NSString * name;
- (void)setName:(NSString *)name { if (_name != name) {
[_name release];
_name = [name copy]; }
10


7.介绍 ?一下协议与类别
答:协议( Protocol ):声明 ?一系列的 ?方法，没有 ?方法的实现，可由任何类实 现，只需要让该类服从该协议即可。简单的说，协议就是定义了 ?一个接 ?口，其
他类负责来实现这些接 ?口。如果你的类实现了 ?一个协议的 ?方法时，则说该类遵 循此协议。
类别( category ):类别是 Objective-C 的?一项功能，可扩展类的接 ?口， ?而?无需 对类进 ?行?子类化。category 可以为已经存在的类增加 ?方法， ?而不需要增加 ?一个 ?子类。 ?而且，我们可以在不知道某个类内部实现的情况下，为该类增加 ?方法。 如果我们想增加某个框架( framework )中的类的 ?方法，category 就?非常有 效。但是类别只能扩充 ?方法，不能扩充实例变量。
8.委托(代理)有什么作 ?用?代理怎么实现 ,请简单代码举例 ?
答: 委托就是 ?一个对象让另 ?一个对象替他执 ?行?一定的动作， ?而代理所执 ?行所有
的任务来 ?自于委托 ?方指定的协议，代理需要服从协议，实现协议中的 成任务。
1定义两个类 A类和 B类。
2 A 中定义协议 ADelegate ，协议中存放代理需要执 ?行的任务。
3在 A类中添加代理属性， @property (nonatomic, assign) id<ADelegate> delegate;
4创建对象 A *a = [[A alloc] init], B *b = [[B alloc] init]; 并且指定代理 a.delegate = b;
5B类服从协议，并且实现协议中的 ?方法。B<ADelegate> 6 A 类在合适时机让代理执 ?行协议中的任务。
9.描述 ?一个你遇到过得retain cycle 例 ?子 答:
?方法来完
1在该类中定义了 block属性，并且在该 block块中使?用了self，实例变量，属 性，就会造成循环引 ?用。
11


2在该类定义了代理属性，但是代理属性的语义特性为 retain 。 在代理对象类
中也定义了属性来存储该类的对象，语义特性也是 retain ，就会造成互相保 有，循环引 ?用。
3在 A中定义了 B类对象的属性，语义特性为 retain 。 并在 B类中定义了 A类对 象的属性，语义特性为 retain 。 当属性都存储对应的对象时，就产生的循环引用。

12.请简述 self.name = nil 的机制 ,以及与 [_name release] 的区别 ?
答:
self.name = nil; 是调 ?用属性 ?生成s的etter ?方法，会先将原有对象释放 release ，
然后将实例变量的值置为 nil，以后在访问该实例变量不会出现任何内存问题。 ?而[_name release]; 只是简单的将对象的引 ?用计数减1,?而指针变量中依然存储
该对象的地址，如果此时该对象空间被系统回收了，再访问实例变量，就会产 ?生野指针异常。
13.协议标准宏 MIN, 这个宏输 ?入两个参数并返回较 ?小的 ?一个 答:
简单版: #de?ne MIN(A,B) ((A) <= (B) ? (A) : (B))
升级版: #de?ne MIN(A,B) ({__typeof__(A) a = A; __typeof__(B) b = B; a
< b ? a :b } ) ?牛逼版:
#de?ne __NSX_PASTE__(A,B) A##B
12

 千锋教育 12/29
#de?ne __NSMIN_IMPL__(A,B,L) ({ __typeof__(A) __NSX_PASTE__(__a,L) = (A); __typeof__(B) __NSX_PASTE__(__b,L) = (B); (__NSX_PASTE__(__a,L) < __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__a,L) : __NSX_PASTE__(__b,L); })
#de?ne MIN(A,B) __NSMIN_IMPL__(A,B,__COUNTER__)
(2) 资源拥有:进程是资源分配和拥有的单位，同 资源。
(3) 线程是处理器调度的基本单位，但进程不是。 (4) ?二者均可并发执 ?行。
15.请解释 ?一下iOS应?用的沙盒机制?
答: iOS 中的沙盒机制( SandBox )是 ?一种安全体系，它规定了应 ?用程序只能 在为该应 ?用创建的 ?文件夹内读取 ?文件，不可以访问其他地 ?方的内容。所有的 ?非 代码?文件都保存在这个地 ?方，?比如图?片、声?音、属性列表和 ?文本?文件等。
1.每个应 ?用程序都在 ?自?己的沙盒内
2. 不能随意跨越 ?自 ?己的沙盒去访问别的应 ?用程序沙盒的内容 3. 应 ?用程序向外请求或接收数据都需要经过权限认证
16.Objective-C 中的数字对象有哪些 ,简述他们与基本数据类型的区
别?
答:
OC中的数字对象 NSNumber ，NSValue 。
NSNumber 是OC中的对象类型，能够实现将基本数据类型 int，?oat转成OC的 对象。
NSValue 是OC 中的对象类型，能够实现将结构体类型 CGPoint,NSRange 转成 OC 的对象。
17.Swift 和Object-C 分别是什么 ?两者 ?比有什么不同之处,?又有何联 系?
答:参考链接: http://www.imooc.com/wenda/detail/4752
18. 类的定义及声明 ?文件以什么为后缀名? 答:
类的定义分为声明和实现部分。
声明部分即为声明 ?文件，以.h为后缀。 类的实现以 .m为后缀。
14. 线程与进程的区别和联系 ?
线程是指进程内的 ?一块执 ?行单元,也是执 ?行任务的基本单位。 与进程的区别:
(1) 地址空间:进程内的 ?一个执 ?行单元;进程
地址空间 ;?而进程有 ?自?己独 ?立的地址空间。
13
?至少有 ?一个线程;它们共享进程的 ?一个进程内的线程共享进程的


19.iOS UI 的图像存储类型是什么 ? 答: UIImage


22. 同步调 ?用和异步调 ?用分别是什?么
答:
同步:我们把异步环境下的 ?一组并发进程因直接制约 ?而互相发送消息、进 ?行互 相合作、互相等待，使得各进程按 ?一定的顺序执 ?行的过程称为进程间的同步， 往往这种情况，任务与任务之间存在依赖关系，后 ?一个任务的执 ?行依赖于前 ?一 个任务的结束。
异步:任务与任务之间不存在任何依赖关系，任务并发执 ?行，最后执 ?行的任务 可能第 ?一个执 ?行结束。
23.NSString 和NSMutableString 有什么区别 ? 答:
NSString 是?一个不可变的字符串对象。这不是表 ?示这个对象声明的变量的值不 可变， ?而是表 ?示它初始化以后，你不能改变该变量所分配的内存中的值，但你 可以重新分配该变量所处的内存空间。
?而NSMutableString 是可变的，意味着你可以追加它的内存空间，或者修改它 所分配的内存空间中的值。


25.UIViewController 的?生命周期 ?方法调 ?用顺序
答:
当?一个视图控制器被创建，并在屏幕上显 ?示的时候。?方法的调 ?用顺序
(1) alloc ，创建对象，分配空间
(2) init (initWithNibName :bundle :)，初始化对象，初始化数据
(3)
loadView ，加载视图控制器根视图 . 幕上了
当?一个视图被移除屏幕并且销毁的时候的执 ?行顺序，这个顺序差不多和上 ?面的 相反
(1) viewWillDisappear: 视图将被从屏幕上移除之前执 ?行
(2) viewDidDisappear: 视图已经被从屏幕上移除， ?用户看不到这个视图了
(3) dealloc ，视图被销毁，此处需要对你在 init和viewDidLoad 中创建的对象
进?行释放
当收到内存警告时
didReceiveMemeoryWarning: 释放临时空闲资源。
26.介绍 ?一下你对 ?面向对象概念的理解?
答:
?面向对象:以事物为中 ?心，关 ?心参与事件的所有的事物都具备什么功能，针对 于每 ?一个事物单独设计。
?面向对象语 ?言三?大特性:继承、封装、多态。
类的继承性是指从已有的 ?一个类来extends ?子类， ?子类具有了 ?父类的所有特 征，同时， ?子类也可以有新的特性。 ?比如: ?人是 ?一个类，男 ?人具有了 ?人类的所 有的特性，?比如思考，?比如劳动。同时，男 ?人也有新的特性， ?比如男?人会?长胡
?子。
类的封装是指类把所有的操作都封闭起来，仅仅提供接 ?口出来让其他 ?人使?用，
使?用的 ?人没有必要懂得类 ?里?面的操作，只需要懂得操作接 ?口就可以了。 ?比如开 汽?车，我们只需要懂得 ?方向盘、刹 ?车、油 ?门等等的使 ?用就可以了，没有必要知 道刹 ?车是如何构成的封闭好的操作。同时，封装也提 ?高了程序的可替换性。 ?比 如两个汽 ?车公司实现刹 ?车的 ?方式不 ?一样，但是，只要我们学会了使 ?用刹 ?车，那 么，开两个汽 ?车公司的 ?车就都没有问题了，我们不需要考虑他们怎样实现刹 ?车 这?门技术的。
类的多态性是 ?一个对象的某项功能可以处理不同类型的问题，或者 ?一个?子类可 以将 ?父类的某个功能替换成新的功能，具体到编程的 ?方?面来说实现类的多态有
override 和overload ，也就是覆写和重载。
同时?面向对象还有 ?一个很重要的概念:抽象。抽象就是 ?一个事物的本质。当然
对于本质，不同的 ?角度却会有不同的理解。男 ?人，在和 ?女?人?一起的时候，它的 本质是?人。在和所有的 ?生物?一起的时候，它的本质是动物。
?行 ?自定义数据以及动态创建其他控件 (6) viewDidAppear: 视图已在屏幕上渲染完成
(4) viewDidLoad ，载 ?入完成，可以进
(5) viewWillAppear: 视图将出现在屏幕之前， ?马上这个视图就会被展现在屏
15

 千锋教育 12/29
27. 重载和覆盖的区别。重载的 ?方法是否可以改变返回值的类型?
答: 重载与覆盖的区别:
1 、 ?方法的覆盖是 ?子类和 ?父类之间的关系，当 ?子类不满 ?足 ?父类对 ?方法的实现 时，?子类可以覆盖重写从 ?父类继承过来的 ?方法，是垂直关系; ?方法的重载是同 ?一个类中 ?方法之间的关系，是 ?水平关系。
2 、覆盖只能由 ?一个 ?方法产 ?生关系; ?方法的重载是多个 ?方法之间的关系。
3 、覆盖要求 ?方法必须是同 ?一个;重载要求参数个数不同，返回值类型不同， 参数类型不同。
28.UIView 的圆 ?角属性设置 ?方法 答:
view1.layer.cornerRadius = 圆?角半径;
view1.layer.masksToBounds = YES;
29. 请解释以下两种设计模式: ?工 ?厂模式，单例模式
答:
?工?厂模式: ?工?厂模式根据抽象程度的不同分为三种:
1?工?厂?方法: ?用来快速加 ?工对象?比。如:便利构造器。
2抽象 ?工?厂:抽象出 ?一个公共的 ?父类，提 ?高?子类公共的功能。 ?子类继承即可， 但是不会使 ?用该?父类去创建对象使 ?用。?比:?手如势,UIControl 3对象?工?厂:?用来根据需求 ?生成不同类型的对象?。比如:cell?工?厂。
?工?厂模式对调 ?用者屏蔽具体的产品类。如果使 ?用?工?厂模式，调 ?用者只关 ?心产品 的接 ?口就可以了， ?至于具体的实现，调 ?用者根本 ?无需关 ?心。即使变更了具体的 实现，对调 ?用者来说没有任何影响。

31.在.m?文件Class Extension 中声明的私有 ?方法，其他类能否调
?用?若强 ?行调 ?用会发 ?生什么? 答:
延展中声明的是私有 ?方法，在其他类中 ?无法直接调 ?用。 内存环境区别:
MRC :在其他类中可直接调 ?用，只不过会提 ?示警告。 ARC :在其他类中 ?无法直接调 ?用，编译器报错。
32.在调 ?用?支付宝接 ?口?支付p时art，ner ，seller ，private 分别是什么
意思?
答:
partner :商户合作者 ?身份ID，签约的 ?支付宝账号对应的 ?支付宝唯 ?一?用户号。以 2088开头的16位纯数字组成。 seller:商户收款账号; private:?支付宝私钥;

34.为什么很多内置的类，如 TableViewController 的delegate 的属性
是assign 不v是retain ?
答:
如果是 retain 会引起循环引 ?用。所有的引 ?用计数系统，都存在循环引 ?用的问 题。例如下 ?面的引 ?用关系:对象a创建并引 ?用了对象b,对象 b创建并引 ?用了对象
c,对象c创建并引 ?用了对象b.这时候 b和c的引 ?用计数分别是2和1。当a不再使 ?用
b，调 ?用release 释放对 b的所有权，因为 c还引 ?用了b，所以 b的引 ?用计数为1，b
不会被释放。 b不释放， c的引?用计数就是1，c也不会被释放。从此， b和c永远 留在内存中。
35.列举 ?几个你曾经 ?用过的第三 ?方库? 答:
AFN, SDWebImage, FMDB ，MBProgressHUD ，LORefresh ，ZBar， MagicRecord 等
36.?用宏定义来写出 ?一个判断系统是否i是OS7 以上的版本的例 ?子 答:
#de?ne IsIOS7 ([[[UIDevice currentDevice] systemVersion] ?oatValue] >=7.0 ? YES : NO)
37. Objective-C 的动态性体现在哪些 ?方 ?面 答:
17

39. ios 平台怎么做数据的持久化 ?coredata 和sqlite 有?无必然联系?
coredata 是?一个关系型数据库吗?
答: iOS 中可以有四种持久化数据的 ?方式:属性列表(plist) 、对象写 ?入本地(所
谓归档 )、 SQLite3 和 Core Data ; core data 可以使你以图形界 ?面的 ?方式快速 的定义 app 的数据模型，同时在你的代码中容易获取到它。 coredata 提供了 基础结构去处理常 ?用的功能，例如保存，恢复，撤销和重做，允许你在 app 中 继续创建新的任务。在使 ?用core data 的时候，你不 ?用安装额外的数据库系 统，因为 core data 使?用内置的sqlite 数据库。 core data 将你 app 的模型层 放?入到?一组定义在内存中的数据对象。coredata 会追踪这些对象的改变，同 时可以根据需要做相反的改变，例如 ?用户执 ?行撤销命令。当core data 在对你 app 数据的改变进 ?行保存的时候，core data 会把这些数据归档，并永久性保
存。 mac os x 中sqlite 库，它是 ?一个轻量级功能强 ?大的关系数据引擎，也很容 易嵌 ?入到应 ?用程序。可以在多个平台使 ?用s，qlite 是?一个轻量级的嵌 ?入式sql
数据库编程。与 core data 框架不同的是， sqlite 是使 ?用程序式的， sql 的主 要的 API 来直接操作数据表。 Core Data 不是 ?一个关系型数据库，也不是关系
型数据库管理系统 (RDBMS) 。虽然 Core Dta ?支持SQLite 作为 ?一种存储类 型，但它不能使 ?用任意的SQLite 数据库。 Core Data 在使 ?用的过程种 ?自?己创
建这个数据库。 Core Data ?支持对 ?一、对多的关系。
40. 多线程中堆与栈分别是共有的还是私有的?(记住)
答:
在多线程环境下，每个线程拥有 ?一个栈和 ?一个程序计数器。栈和程序计数器 ?用 来保存线程的执 ?行历史和线程的执 ?行状态，是线程私有的资源。
其他的资源( ?比如堆、地址空间、全局变量)是由同 ?一个进程内的多个线程共 享。
41.Objective-C 声明 ?一个类所有要 ?用到的编译指令?是 答:
@interface ⋯ @end @implementation ⋯@end
18

 千锋教育 12/29
42.?用预编译指令#de?ne 声明 ?一个常数， ?用以表1年?示中有多少秒
(忽略闰年问题)
答: #de?ne SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
1). #de?ne 语法的基本知识(例如:不能以分号结束，括号的使 ?用，等等) 2). 意识到这个表达式将使 ?一个16 位机的整型数溢出 -因此要 ?用到 ?长整型符号L,
告诉编译器这个常数是的 ?长整型数。
3). 如果你在你的表达式中 ?用到UL (表 ?示 ?无符号 ?长整型)，那么你有了 ?一个好
的起点。
43.解析 XML ?文件有哪 ?几种 ?方式?
答:以 DOM ?方式解析XML ?文件;以SAX ?方式解析XML ?文件;
44.下?面哪个 ?方法不属N于SObject 的内省( Introspection )?方法 A.init B. isKindOfClass C. responseToSelector D.isMemberOfClass
答: A, NSObject 内省 ?方法是通过分类形式添加的 ?方法， ?in而it ?方法是该类定义 时添加的 ?方法。
45.iOS 开发中，开发证书根据 ?用途划分可以分为哪两 ?大类，分别作 ?用是什么 ?用途?
答:
1development :开发证书， ?用于真机测试，不能上传项 ??目A到ppStore 。 2distribution :发布证书， ?用于发布应 ?用到AppStore 。
46.关键字 const 有什么含义? static 的作 ?用?还有extem C 的作 ?用? 答:
const 是在编译器控制代码的安全性，只在编译期起作 可更改。
static 标记的变量叫做静态变量，会存储到全局变量区， extem 的作 ?用是引 ?用在其他 ?文件中定义的全局变量。
47. 让 ?一个物体从界 ?面中的 ?一点运动到另外 答:
1修改 ?自?身视图的中 ?心点。 2修改 ?自?身视图的frame 。 3修改 ?父视图的bounds 。
48. 什么是多继承? 答:
?用c，onst 修饰的变量不 ?生命周期和程序相同。
?一点，有哪些 ?方法?
Objective C 不能像 C++ ， Java ?一样 ?支持多继承，但是在OC 的使 ?用经常会碰到 需要使 ?用多继承的情况。例如， ClassA 中有 methodA ， ClassB 中 methodB ，?而
现在需要使 ?用这两个类中的 ?方法。如何按照C++ 的编程思路，毫 ?无疑问采 ?用多 继承就搞定了，在 OC就需要动动脑 ?子了。其实我们在学习设计模式的时候知
道，多继承的效率不 ?高，?而且采?用组合的模式可以完全代替继承模式。 19

 千锋教育 12/29
OC 实现多继承的 ?方式:协议，分类， ?子类化，延展。
49.ViewController 的 loadView,viewDidLoad,didReceiverMemoryWarning 分别是什么 时候调 ?用的,在初始化 ViewController 时在这 ?几个函数中应该做什么 ?工作?
答:
loadView ?方法:
当view需要被展 ?示?而它却是nil时，viewController 会调?用该?方法。不要直接调 ?用 该?方法。如果?手?工维护views，必须重载重写该 ?方法如果使?用IB维护views， 必须不能重载重写该 ?方法。该?方法会为当前视图控制器加载根视图。
viewDidLoad ?方法:
该?方法是当视图控制器的 loadView ?方法调 ?用结束之后调 ?用，该 ?方法的作 ?用是告 诉视图控制器，此时根视图已经加载，在此刻完成 ?子控件的创建和添加即可。
didReceiverMemoryWarning ?方法: 该?方法是当视图控制器收到内存警告时触发， ?用来回收当前视图控制器的空闲 空间以及可重建对象的空间。
50.对于语句 NSString * obj = [[NSData alloc] init];obj
和运 ?行时分别是什么对象 ?
答:
声明时是 NSString 所以编译时是 NSString 类型 在运 ?行时是NSData 类型
51.什么时候 ?用delegate, 什么时候 ?用Noti?cation? 答:
delegate 针对 one-to-one 关系，并且 reciever 可以返回值给
可以针对 one-to-one/many/none,reciever ?无法返回值给sender. 所以， delegate ?用于sender 希望接收到 reciever 的某个功能反馈值， noti?cation ?用于通知多个
object 某个事件。
52. 浅赋值和深赋值的区别。
答:
浅拷 ?贝就是对内存地址的复制，让 ??目标对象指针和源对象指向同 ?一?片内存空间。
深拷 ?贝是指拷 ?贝对象的具体内容， ?而内存地址是 ?自主分配的，拷 ?贝结束之后， 两个对象虽然存的值是相同的，但是内存地址不 ?一样，两个对象也互不影响， 互不干涉。
53.介绍下 KVC 和KVO 答:
20
在编译时是
sender ， noti?cation

KVC: 是 Key-Value- Coding 的简称，它是 ?一种可以直接通过字符串的名字 (key)
来访问类属性的机制。 ?而不是直接通过调 ?用Setter 、Getter ?方法访问。是 ?一种 间接给实例变量赋值的 ?方式。
KVO是Cocoa 的?一个重要机制，他提供了观察某 ?一属性变化的 ?方法，极 ?大的简 化了代码。这种观察-被观察模型适 ?用于这样的情况， ?比 ?方说根A据(数 据 类)的某个属性值变化， B(view 类)中的某个属性做出相应变化。对于推崇
MVC 的 Cocoa ?而 ?言，KVO 应 ?用的地 ?方 ?非常 ??广泛。(这样的机制听起来似类 Noti?cation ，但是 noti?cation 是需要 ?一个发送noti?cation 的对象， ?一般是 noti?cationCenter ，来通知观察者。 ?而kvo 是直接通知到观察对象。)
54. 多线程实现的三种 ?方式
1. NSThread
2. NSOperationQueue
3. GCD( ?比较常 ?用，多核CPU 的情况下建议使
55.谈谈对 Block 的理解 ? 答:
?用此 ?方)式
block 是对象，它封装了 ?一段代码，这段代码可以在任何时候执 ?b行lo。ck 可以 作为函数参数或者函数的返回值，经常 ?用于回调以及传值。 ?而其本 ?身?又可以带
输?入参数或返回值。它和传统的函数指针很类似，但是有区别: block 是inline 的，并且它对局部变量是只读的。

第?一个:test 3 这时str的retainCount 是3. 第?二个:test 2
第三 ?方:test 1
“test ”];
21

 千锋教育 12/29 57.写?一个单例(任意语 ?言编写)
答:
+ (Singleton *)mainSingleton {
static Singleton *singleton = nil;
@synchronized(self) { if (singleton == nil) {
singleton = [[Singleton alloc] init]; }
}
return singleton; }
+ (Singleton *)mainSingleton {
static Singleton *singleton = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{
singleton = [[Singleton alloc] init]; });
return singleton; }
58. 常 ?见的数据持久化 ?方法有哪?些 答:
1.NSUserDefaults: ?用来保存应 ?用程序设置和属性、 ?用户保存的数据。 ?用户再次 打开程序或开机后这些数据仍然存在。 NSUserDefaults 可以存储的数据类型包
括:NSData 、NSString 、NSNumber 、NSDate 、NSArray 、NSDictionary 。
如果要存储其他类型，则需要转换为前 储。
?面的类型，才能 ?用NSUserDefaults 存
2.归档,反归档 3. ?文件读写 4.SQLite 5.CoreData
59.简述 tableView 答:
的重 ?用机制。
UITableView 上?面可能要展 ?示很多条数据，如果每 ?一条数据都创建 ce?l一l ，个空 间开销?非常?大，?而且屏幕上只展 ?示有限ce的ll，所以cell重?用能够合理的利 ?用系 统空间，达到空间利 ?用的最?大化。
UITableView 有?一个重 ?用队列，该队列的实现形式就是字典套集合， 每?一个cell 标识?一个重?用标识符作为字典的key，?而cell对象存储到该 key对应的集合中。
当每次需要 cell 时，先根据重 ?用标识符从表视图的重 ?用队列中查看是否有可重 ?用的cell，使?用dequeueReusableCellWithIdenti?er:CellIdenti?er : 也就是把重
22

 千锋教育 12/29
?用标识符作为字典的 key 查看对应的集合中是否有元素。如果有可重 ?用的cell ，
则直接从集合中取出返回，如果没有，则返回 nil。 当?一旦没有取到可重 ?用的
cell 时，就创建 ?一个新的cell 对象，并且添加重 ?用标识符， ?方便下次重 ?用。当表
视图拖动， cell 滑出屏幕时，超出屏幕的 cell 会?自动放到表视图的重 ?用队列中， 也就是放到对应的集合中。
60.实例化 ?一个UITableView 对象 ,要求写出关键语句 ? 答:
UITableView *tableView = [[UITableView alloc]initWithFrame:<(CGRect)frame> style:<(UITableViewStyle)style>];
tableView.dataSource = self;
tableView.delegate = self;
[superview addSubview:tableView];
?首先需要分配空间设置 表视图的样式
象,会如何进 ?行后续处理? 答:
运?行时刻是指 ?一个程序在运 ?行(或者在被执 ?行)的状态。也就是说，当你打开 ?一个程序使它在电脑上运 ?行的时候，那个程序就是处于运 ?行时刻。在 ?一些编程
语?言中，把某些可以重 ?用的程序或者实例打包或者重建成为“运?行库”。这些实 例可以在它们运 ?行的时候被连接或者被任何程序调 ?用。
如果 message send 如果寻找不到相应的对象
1该对象为空，则该消息失效。
2该对象不为空， ?而该类中没有该 ?方法，则程序异常，找不到对应的 ?方法执 ?行 3该对象不为空， ?而该类中有该 ?方法，调 ?用?方法。
62.什么是 method swizzling? (了解) 答:
Method swizzling 指的是改变 ?一个已存在的选择器对应的实现的过程，它依赖 于Objectvie-C 中?方法的调 ?用能够在运 ?行时进改—变— 通过改变类的调度表
(dispatch table )中选择器到最终函数间的映射关系。 63.Cocoa Touch 包含什么 ? 不包含什么 ?
答:
参考链接: http://blog.csdn.net/iukey/article/details/7666430
64.响应链 (Responder chain) 是什么 ?它是如何发挥作 ?用?的 答:
dataSource 提供数据源， delegate 处理交 61.描述 ?一下runtime 的概念 ,message send 如果寻找不到相应的对
然后需要设置两个必须的委托对象， 互和界 ?面设置。
23

 千锋教育 12/29
响应者 :凡是直接或者间接继承 ?自UIResponder 的类创建的对象都是响应者 . ?比
如(UIView,UIViewController,UIApplication). 由响应者对象组成的链叫响应者 链。
当触摸视图时 ,系统会有碰撞检测过程 ,查找该触摸发 ?生到哪个视图上. UIApplication -> window -> 视图控制器 -> 根视图 -> 视图 1 -> 视图 2 -> 视图 3
碰撞检测结束之后 ,接下来对触摸事件作出处理， ?首先查看视图3 是否对触摸事 件作出处理,如果视图3不处理,则把事件漏给视图 2,直到有?一个对象处理了.如果 都没处理 ,则事件丢弃 .
65. 如何获取项 ??目根路,径并在其下创建 ?一个名称为userData 的 ??目录 答:
NSString *sandboxPath = NSHomeDirectory();
// 创建 ?文件系统管理器
NSFileManager *manager = [NSFileManager defaultManager]; NSString *?lePath = [sandboxPath stringByAppendingPathComponent:@ “ userData"];
if (![manager ?leExistsAtPath:?lePath]) {
BOOL isSuccess = [manager createDirectoryAtPath:?lePath
withIntermediateDirectories:YES attributes:nil error:nil] ; NSLog(@"%@", isSuccess ? @" 创建成功 " : @"创建失败 ");
}
66.iPhone5,6,6+ 以及 iPad Air 2 的屏幕分辨率分别是多少 ?
答:
iPhone5 : 640 像素 *1136 像素;
iPhone6 : 750 像素 x1334 像素; iPhone6 Plus 像素 1242x2208;
iPad Air 2 分辨率是 2048 ×1536 分辨率。 67. 分辨率的计算单位是什么 ?
答:
px:pixel，像素，屏幕上显 ?示的最 ?小单.位
68.UIButton 的 ?父类是什么? 答: UIControl
69.请解释 ?一下Interface Bulder 的作 ?用以及NIB ?文件的概念 答:
Interface Builder (IB)是Mac OS X 平台下 ?用于设计和测试 ?用户界 ?G面U(I) 的应 ?用程序。为了 ?生成图形界 ?面IB，并不是必需的，实际上 Mac OS X 下所有 的?用户界 ?面元素都可以使 ?用代码直接 ?生成;IB但能够使开发者简单快捷的开发 出符合 Mac OS X human-interface guidelines 的 GUI 。通常你只需要通过简单 的拖拽( drag-n-drop )操作来构建图形界 ?面就可以了。
24

 千锋教育 12/29
?工程中的可视化 ?文件的后缀是.xib，但是当程序编译之后，存储到包中， XIB?文
件后缀编程 .nib 。简称 NIB ?文件。
70.选项卡 (Tab Bar) 和?工具栏(Toolbar) 分别是什么 ?两者之间 有何共 同点和不同点
答:
Toolbar:提供 ?一种机制来显 ?示?一个 ?工具栏，在屏幕的底部和 ?支持显 ?示和选择的 ?工具栏项?U?目IBarButtonItem 的实例)。
Tab Bar: 提供 ?一种机制来显 ?示?一个选项, 位卡于屏幕底部的 ?工具栏和 ?支持显 ?示 和选择的选项卡栏项 (UIBarButtonItem 的实例)。
71. 数据库中索引的作 ??用和它的优缺点是什么 ? 答:
参考链接 http://blog.chinaunix.net/uid-20556037-id-2810995.html 72.UIImageView 如何响应点击事件 ?
答:
userInteractionEnabled 交互属性 ?至为YES ，再给 UIImageView 加
UITapGestureRecognizer 点击 ?手势。 73.如何实现 UIScrollView ?无限滚动?
答:
默认的UIScrollView 滑动到底之后(假设往右)，就 ?无法继续往右滑了，但为 了更好的 ?用户体验，我们继续往右滑是 ?自动回到第 ?一?页。这 ?里提供 ?一个 ?方案。 假设有 5?页，其中分别放着1.jpg 2.jpg 3.jpg 4.jpg 5.jpg 五张图，为 ?支持 ?无限滚 动，我们把最后 ?一张图复制 ?一份追加到第 ?一张左边，把第 ?一张图复制 ?一份追加 到最后?一张图右边，即新的UIScrollView 有7?页，分别是
[1 号: 5.jpg][2 号: 1.jpg][3 号: 2.jpg][4 号: 3.jpg][5 号: 4.jpg][6 号: 5.jpg][7
号: 1.jpg]
然后把初始的位置移动到 2号。接下来，如果 ?用户滑动到7号位置，则 ?立刻把位
置更换到 2号，此时 ?用户并没有发现位置发 ?生了改变，从 ?而实现了 ?无限往右
滚。同理，如果 ?用户滑动到1号位置，则 ?立刻把位置更换到6号，实现 ?无限往左 滚。?至此，实现了 ?无限滚动。
74.多线程中 ,访问同 ?一变量,如何加锁 ? 答: ?方法 ?一，
@synchronized(id anObject),( 最简单的 ?方法) @synchronized(self) {
// 这段代码对其他 @synchronized(self) 都是互斥的 // self 指向同 ?一个对象
}
?方法 ?二，NSLock
NSLock 对象实现了 NSLocking protocol ，包含 ?几个 ?方法: 25

 千锋教育 12/29
lock ，加锁
unlock ，解锁
tryLock ，尝试加锁，如果失败了，并不会阻塞线程，只是 ?立即返N回O
lockBeforeDate: ，在指定的 date之前暂时阻塞线程(如果没有获取锁的话)， 如果到期还没有获取锁，则线程被唤醒，函数 ?立即返回NO
?方法三，NSRecursiveLock ，递归锁
NSRecursiveLock ，多次调 ?用不会阻塞已获取该锁的线程。
?方法四，NSConditionLock ，条件锁
NSConditionLock ，条件锁，可以设置条件
?方法五，NSDistributedLock ，分布锁
NSDistributedLock ，分布锁， ?文件?方式实现，可以跨进程
?用tryLock ?方法获取锁。
?用unlock ?方法释放锁。
如果 ?一个获取锁的进程在释放锁之前挂了，那么锁就
可以通过 breakLock 强?行获取锁。 75. 写 ?一个委托的 interface
答:
@protocol MarryDelegate<NSObject> @required
- (void)earnMoney;
- (void)makeFood:(NSString *)foodName;
@end
76.UITableview 的执 ?行流程是怎么样的? 答:
1、numberOfSectionsInTableView:
?一直得不到释放了，此时
2、heightForHeaderInSection 3、heightForFooterInSection
4、numberOfRowsInSection 5、heightForRowAtIndexPath ，?行?高， 6、cellForRowAtIndexPath : 7、willDisplayCell
，section 次数 ，section 次数
，?行数
77.简述 XMPP 中有哪些节点，各个节点分别有什么作 ?用? 答:
常?用的节点有IQ, Message, Presence;
IQ: Info/Query( 信息与查询 ), 它为 XMPP 通信提供请求与响应机制。
Message: 消息节点 , ?一种基本推送消息 ?方法，它不要求响应。 Presence: ?用来表明 ?用户的状态，如:online 、 away 、 dnd( 请勿打扰 )等。
26

 千锋教育 12/29
78.使?用AVPlayer 播放视频时，视频监听的 AVPlayerItem 状态有 ?几
种，分别是什么及作 ?用? 答:
AVPlayerStatusUnknown, 代表视频未知的 AVPlayerStatusReadyToPlay: 代表视频已经可以播放了 AVPlayerStatusFailed, 代表视频播放错误的
79.简述使 ?用CLLocationManager 定位时，如何停 答: stopUpdatingLocation
?止定位?
?用(场很景全 ?面哦)
80.iOS 中有 ?几种消息机制，区别以及各种机制的使 答:参考链接: http://www.cocoachina.com/industry/20131216/7543.html
81.UI 布局的 ?几种 ?方式，各种 ?方式的利弊谈谈您的看法 答:
a.纯代码 , 通过代码 ?手动更改, ?比较 ?麻烦, 但是代码相对集中
b.可视化编程 , 通过 IB?工具, 使?用autolayout+sizeclasses 技术做布局 , 适配多种 屏幕 , 但是控件过多是约束会 ?比较多, 难以维护 .
82. 你 ?用过NSOperationQueue 吗?请描述它和 GCD 的区别和类似的 地?方
答:
使?用NSOperationQueue ?用来管理 ?子类化的NSOperation 对象，控制其线程并
发数??目。GCD和NSOperation 都可以实现对线程的管理，区别是 NSOperation 和NSOperationQueue 是多线程的 ?面向对象抽象。项 ??目中使N?S用Operation 的 优点是 NSOperation 是对线程的 ?高度抽象，在项 ??目中使 ?用它，会使项 ??目的程序
结构更好， ?子类化NSOperation 的设计思路，是具有 ?面向对象的优点(复 ?用、 封装)，使得实现是多线程 ?支持， ?而接 ?口简单，建议在复杂项 ??目中使 ?用。 项??目中使 ?G用CD 的优点是 GCD 本?身?非常简单、易 ?用，对于不复杂的多线程操
作，会节省代码量， ?而Block参数的使?用，会是代码更为易读，建议在简单项 ??目中使 ?用。
83.HTTP 和Socket 的区别 ? 答:
Socket 连接和 HTTP 连接的区别
HTTP协议:超 ?文本传输协议，是基于请求和响应模式的应 ?用层协。议
Socket :不是协议，是套接字，由 IP和端 ?口两部分标识，是封装在传输层之上 的。
HTTP 连接: http 连接就是所谓的短连接，即客户端向服务器端发送 ?一次请求， 服务器端响应后连接即会断掉;
Socket 连接: socket 连接就是所谓的 ?长连接，理论上客户端和服务器端 ?一旦建 ?立起连接将不会主动断掉;但是由于各种环境因素可能会是连接断开， ?比如说: 服务器端或客户端主机 down 了， ??网络故障，或者两者之间 ?长时间没有数据传 输， ??网络防 ?火墙可能会断开该连接以释放 ??网络资源。
27

 千锋教育 12/29
84.Core Foundation 中提供了哪 ?几种操作Socket 的 ?方法? 答: CFNetwork 、 CFSocket 和 BSD Socket 。
85.请描述 Xcode 打包签名机制中 Certi?cates & Identi?ers & Provisioning Pro?les 三者的关系?
答:
Certi?cates :证书，分为开发证书和发布证书，是 ?一个开发者账号 ?身份的标 识，也是是否账号是否可 ?用的标识。
Identi?ers: 应 ?用程序唯 ?一标识识。如果是发布的项
起到唯 ?一标识的作 ?用。 ?而测试的标识可以是通配的。
Provisioning Pro?les :描述 ?文件是对证书和项 ??目标识的描述 ?文档。
86.iCloud 包含了哪些技术与服务? 答:
iCloud是苹果公司所提供的云端服务，使 ?用者可以免费储存 5GB的资料。 可以 备份存放照 ?片、 ?音乐、通讯录、短信、 ?文档等内容，在你需要的时候以 ?无线 ?方 式将他们推送到你所有的设备上。 ?自?行执 ?行。轻松 ?自如、运作流畅，它就是这
么管 ?用。可与亲朋好友共享体验的完整平台。它不仅安全， ?而且可提供丰富的 社交体验，从任何计算机或设备均可随时 ?方便地进 ?行访问。iCloud 上所提供的
应?用程序包括办公 ?生产率、开发 ?工具、媒体和窗 ?口?小部件等。随着时间的推 移，还将通过易于使 ?用的市场空间和应 ?用程序开发 ?工具箱提供范围更 ??广的应 ?用 程序。
87.UITableView 需要实现那些代理?请列出 UITableVIew 代理中必须
实现的与其他 ?一些常 ?用函数? 答:
必须实现 :
- ( NSInteger )tableView:( UITableView *)tableView numberOfRowsInSection:( NSInteger )section;
?一组有多少 ?行
- ( UITableViewCell *)tableView:( UITableView *)tableView
cellForRowAtIndexPath:( NSIndexPath *)indexPath; 常?用(当然也可以多罗列 ?一些):
- ( void )tableView:( UITableView *)tableView didSelectRowAtIndexPath: ( NSIndexPath *)indexPath
选中以后事件设置
- ( CGFloat )tableView:( UITableView *)tableView heightForRowAtIndexPath:( NSIndexPath *)indexPath
88.Objective-c 有私有 ?方法没，有私有变量吗? 答:
28
??目，标识必须唯
?一，对项 ??目

 千锋教育 12/29
只在.m?文件实现，未在.h?文件声明的 ?方法叫做类的私有 ?方法，只能在本类中访
问。但是 OC中没有绝对的私有， ?一旦知道了 ?方法的名字，就可调 ?用，前提是 MRC 环境。有私有变量。
89.UITableView 重新加载数据有 ?几种 ?方式?那种更好?如何对
UITableView 优化? 答:
三种 ?方式加载数据:
1reloadData 2reloadRowsAtIndexPaths:withRowAnimation:
3reloadSections:withRowAnimation: 如果要全部刷新，1更好 ?一些。
如果只想刷新某些 ?行，则2更好 ?一些。 如果要刷新某个分区内的数据，则3更好 ?一些。 根据需求场景选择对应的刷新 ?方式。
UITableView 优化: 1使 ?用不透明视图。
2不要重复创建不必要的 table cell 。
3减少视图的数 ??目。 4不要做多余的绘制 ?工作。 5预渲染图像。 6不要阻塞主线程。
90.App crash 后,有哪些调试 ?方法? 答:
1断点单步调试
2全局断点确定崩溃位置 3僵?尸调试查看崩溃 ?日志原因
暴力调试

92.?自动布局(Auto layout) 的作 ?用是什么? 请概括 ?一下它是如何运 ?行 的;
答:
AutoLayout 为开发者提供了 ?一种不同于传统对于UI元素位置指定的布局 ?方法。
以前，不论是在 IB?里拖放，还是在代码中写，每个 UIView都会有?自?己的frame 属性，来定义其在当前视图中的位置和尺 ?寸。使 ?用AutoLayout 的话，就变为了 使?用约束条件来定义view 的位置和尺 ?寸。这样的最 ?大好处是 ?一举解决了不同分 辨率和屏幕尺 ?寸下view的适配问题。
sizeclass 的作 ?用:ios8 中为了解决屏幕适配，引 ?入了 ?一个全新的概念， sizeclass ?而这个使 ?用的时候不需要判断屏幕的尺 ?寸，也没有横屏和竖屏的概
念，只有( Compact 、Any，Regular )的概念!在 Xcode新建的项 ??目中，看到
的storyboard界?面下?面栏??目中，有?一w个A(ny,hAny)点击之后会出现 ?一个可 选择的类似九宫格的表格，这个就是 ?一个屏幕选择器，可以对不同屏幕进 ?行选 择!
93.UILabel 是否可以显 ?示html ?文本,如果可以怎么显 ??示 答:可以
NSString * htmlString = @"<html><body> Some html string \n <font size= \"13\" color=\"red\">This is some text!</font> </body></html>";
NSAttributedString * attrStr = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@{ NSDo cumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttri butes:nil error:nil];
UILabel * myLabel = [[UILabel alloc] initWithFrame:self.view.bounds];
myLabel.attributedText = attrStr; [self.view addSubview:myLabel];
94.如果现在需要让 UILabel 进?行交互,(可以点击响应事件 ),有哪些 ?方
式?
答:
1.userInteractionEnabled 属性设置为 YES ;
2.添加?手势识别器
UITapGestureRecognizer *tapGestureTel = [[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(teleButtonEvent:)]autorelease];
[telephoneLabel addGestureRecognizer:tapGestureTel]; 95. 数据库中有三张表
分别为:
Goods( 商品表 ):ID商品编号、 NAME 商品名称、 MANEFACTURER ?生产商
SID 规格编号
30

 千锋教育 12/29
Spec(规格表):ID规格编号、 COLOR 颜?色、SIZE尺?寸
Sales_record( 销售记录表 ):ID 销售记录流 ?水号、GID销售商品编号、 COUNT 销售量
(1)请设计查询语句查出规格号为 1销售量最多的商品编号、商品名称、颜 ?色、尺 ?寸;
答:
select TOP 1 GID from Sales_record where GID in (select ID from Goods where SID = ‘1’) order by count de。sc
select ID,NAME,COLOR,SIZE from Goods,Spec where Goods.SID = GID and Spec.ID = GID.
(2)请设计查询语句查询 ?生产商在上海(以上海开头 )的商品的销售总和。 答: select sum(count) from Sales_record where GID in (select ID from
Goods where ?生产商like 上海“”% )
96. 举例说明如何在多台机器上共享开发证书
答:
由?一个 ?人在开发者账号管理中 ?心创建 ?一个证书，创建时和本地C的SR ?文件进 ?行
签名，创建好之后，从钥匙串中找到创建的整数，导出 p12?文件，发给他 ?人。 97.举例说明，当需要将 ?一个从未配置的过签名的APP 发布到
APPStore 上时，配置签名过程。 答:参考应 ?用程序发布流程。
98.如何设计 ?一个可变 ?高度(根据内容适应 ?高度)的 UITableViewCell ?
答:参考课程 cell?自定义?高度。
99.?一瓶啤酒 ?一块,钱两瓶空瓶 ?子可以换 ?一瓶啤,现酒在你有20块钱,问 你总共能喝多少瓶啤酒 ?
答: 39
100. UIView 与CLayer 有什么区别? 答:
1).UIView 是 iOS 系统中界 ?面元素的基础，所有的界 ?面元素都是继承 ?自它。它 本?身完全是由 CoreAnimation 来实现的。它真正的绘图部分，是由 ?一个
CALayer 类来管理。 UIView 本?身更像是 ?一个CALayer 的管理器，访问它的跟 绘图和跟坐标有关的属性。
2).UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。
3).UIView 的 CALayer 类似 UIView 的?子View 树形结构，也可以向它的 layer
上添加 ?子layer ，来完成某些特殊的表 ?示。即CALayer 层是可以嵌套的。
31

 千锋教育 12/29
4).UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻辑树，这 ?里是代码可以操纵的;动画树，是 ?一个中间层，系统就在这 ?一层上更改属性， 进?行各种渲染操作;显 ?示树，其内容就是当前正被显 ?示在屏幕上得内容。
5). 动画的运作:对 UIView 的 subLayer ( ?非主Layer )属性进 ?行更改，系统 将?自动进?行动画?生成，动画持续时间的缺省值似乎是0.5 秒。
6). 坐标系统: CALayer 的坐标系统 ?比UIView 多了 ?一个anchorPoint 属性，使 ?用CGPoint 结构表 ?示，值域是 0~1 ，是个 ?比例值。这个点是各种图形变换的坐
标原点，同时会更改 layer 的 position 的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。
7).渲染:当更新层，改变不能 ?立即显 ?示在屏幕上。当所有的层都准备好时，可 以调 ?用setNeedsDisplay ?方法来重绘显 ?示。
8). 变换:要在 ?一个层中添加 ?一3个D 或仿射变换，可以分别设置层的 transform 或af?neTransform 属性。
9). 变形: Quartz Core 的渲染能 ?力，使 ?二维图像可以被 ?自由操纵，就好像是三 维的。图像可以在 ?一个三维坐标系中以任意 ?角度被旋转，缩放和倾斜。 CATransform3D 的?一套 ?方法提供了 ?一些魔术般的变换效果。
101. What is push noti?cation? (什么是推送通知) 答:
a. 本地推送:程序内部弹出通知到 ?用户设备
b. 远程推送:由推送服务器推送通知到 ?用户设.备过程为
1、?首先是应 ?用程序注册消息推送。
2、 IOS 跟 APNS Server 要deviceToken 。应 ?用程序接受deviceToken 。 3、应 ?用程序将deviceToken 发送给 PUSH 服务端程序。
4、 服务端程序向 APNS服务发送消息。
5 、APNS服务将消息发送给 iPhone应?用程序。 102.What is Polymorphism ?

10.类的定义及声明文件以什么为后缀名? 11.怎样自动生成属性的获取方法和设置方法 12.声明一个静态方法和一个实例方法 13.写一个发送同步 http 请求，并获得返回结果的方法 14.怎样启动一个新线程，子线程怎样刷新主 UI 15.什么是 MVC ，你工作时怎样运用它
第 3 题:
NSRange range = [responseString rangeOfString:@"|"];
int location = range.location;
NSString *str1 = [responseString substringToIndex:location];
NSString *str2 = [responseString substringFromIndex:location+1];
第 4 题:
NSDictionary NSMutableDictionary
NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"value1",@"key1",@"value2",@"key2",nil];
[dic setObject:@"value3" forKey:@"key3"];

 [dic removeObjectForKey:@"key3"]; [dic objectForKey:@"key1"];
第 5 题:
// 获取根路径 NSArray
=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, NSString *documentsDirectory = [paths objectAtIndex:];
// 创建文件系统管理器
NSFileManager *fileManager = [[NSFileManager alloc] init];
*paths YES);
// 判断 userData目录是否存在
if(![fileManager fileExistsAtPath:[NSString
documentsDirectory]]) {
// 不存在 ,创建一个 userData 目录
[fileManager createDirectoryAtPath:[NSString documentsDirectory]withIntermediateDirectories:false
}






17.cocoa touch 框架
iPhone OS 应用程序的基础 Cocoa Touch 框架重用了许多 Mac 系统的成熟模式， 但是它更 多地专注于触摸的接口和优化。
UIKit 为您提供了在 iPhone OS 上实现图形，事件驱动程序的基本工具，其建立在和 Mac OS X 中一样的 Foundation 框架上，
包括文件处理，网络，字符串操作等。
obj-c 的东
mm 。

 Cocoa Touch 具有和 iPhone 用户接口一致的特殊设计。 有了 UIKit ，您可以使用 iPhone OS 上的独特的图形接口控件，按钮，
以及全屏视图的功能，您还可以使用加速仪和多点触摸手势来控制您的应用。
各色俱全的框架 除了 UIKit 外， Cocoa Touch 包含了创建世界一流 iPhone 应用程序需要 的所有框架，从三维图形，到专业音效，
甚至提供设备访问 API 以控制摄像头，或通过 GPS 获知当前位置。
Cocoa Touch 既包含只需要几行代码就可以完成全部任务的强大的 Objective-C 框架，也在
需要时提供基础的 C 语言 API 来直接访问系统。这些框架包括:
Core Animation :通过 Core Animation ，您就可以通过一个基于组合独立图层的简单的编程
模型来创建丰富的用户体验。
Core Audio :Core Audio 是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添 加强大的音频功能。
Core Data:提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任 何应用或大或小的数据模型。
功能列表:框架分类
下面是 Cocoa Touch 中一小部分可用的框架:
音频和视频: Core Audio ， OpenAL ， Media Library ， AV Foundation 数据管理 : Core Data ， SQLite
图形和动画 : Core Animation ，OpenGL ES ， Quartz 2D
网络: Bonjour ， WebKit ， BSD Sockets
用户应用: Address Book ， Core Location ， Map Kit ，Store Kit
18.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease消息时， Cocoa 就会将该对象的一个引用放入到最新
的自动释放池。 它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象也就被释放。

 1. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在开始分配 内存 (alloc) 的时候引用计数为一 ,
以后每当碰到有 copy,retain 的时候引用计数都会加一 , 每当碰到 release和 autorelease 的时候引用计数就会减一 ,如果此
对象的计数变为了 0, 就会被系统销毁 .
2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease 和 release 没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象 的使用真正结束的时候才做引用计数减一 .
19.objc 优点: 1) Cateogies
2) Posing
3) 动态识别
4) 指标计算
5)弹性讯息传递
6) 不是一个过度复杂的
7) Objective-C 与 C++ 可混合编程
objc 缺点 :
1) 不支援命名空間
2) 不支持运算符重载 3) 不支持多重继承
4)使用动态运行时类型， 所有的方法都是函数调用， 所以很多编译时优化方法都用不到。 (如内联函数等)，性能低劣。
20.sprintf,strcpy,memcpy 使用上有什么要注意的地方
strcpy 是一个字符串拷贝的函数，它的函数原型为 strcpy(char *dst, const char *src);
将 src 开始的一段字符串拷贝到 dst 开始的内存中去， 结束的标志符号为 '\0'，由于拷贝的长
度不是由我们自己控制的，
所以这个字符串拷贝很容易出错。具备字符串拷贝功能的函数有 memcpy ，这是一个内存拷 贝函数，它的函数原型
为 memcpy(char *dst, const char* src, unsigned int len);
将长度为 len 的一段内存， 从 src 拷贝到 dst 中去， 这个函数的长度可控。 但是会有内存叠加
C 衍生语言 的问题。
sprintf 是格式化函数。 将一段数据通过特定的格式， 格式化到一个字符串缓冲区中去。 sprintf 格式化的函数的长度不可控，
有可能格式化后的字符串会超出缓冲区的大小，造成溢出。 21. 用变量 a 给出下面的定义
a) 一个整型数( An integer ) b)一个指向整型数的指针( A pointer to an integer)
c)一个指向指针的的指针，它指向的指针是指向一个整型数( intege) r
A pointer to a pointer to an
d)一个有 10 个整型数的数组( An array of 10 integers)
e) 一个有 10 个指针的数组， 该指针是指向一个整型数的。 ( An array of 10 pointers to integers)
f) 一个指向有 10 个整型数数组的指针( A pointer to an array of 10 integers)
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数( A pointer to a function that takes an integer as an argument
and returns an integer)
h) 一个有 10 个指针的数组， 该指针指向一个函数， 该函数有一个整型参数并返回一个整型 数( An array of ten pointers to functions t
hattakeanintegerargumentandreturnaninteger )
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions return an integer
22.readwrite ， readonly ， assign， retain ， copy ， nonatomic
that take an integer argument and
属性的作用
@property 是一个属性访问声明，扩号内支持以下几个属性:
1， getter=getterName ， setter=setterName，设置 setter 与
2，readwrite,readonly ，设置可供访问级别
2，assign，setter 方法直接赋值，不进行任何 retain 操作，为了解决原类型与环循引用问题 3，retain，setter方法对参数进行 release旧值再 retain 新值，所有实现都是这个顺序 (CC 上 有相关资料 )
getter 的方法名

 4，copy，setter 方法进行 Copy 操作，与 retain 处理流程一样，先旧值 release，再 Copy 出 新的对象， retainCount 为 1。
这是为了减少对上下文的依赖而引入的机制。
5， nonatomic ，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此 属性，则默认是两个访问方法
都为原子型事务访问。锁被加到所属对象实例级 (我是这么理解的 ...) 。
23.http 和 scoket 通信的区别。
http 是客户端用 http 协议进行请求， 发送请求时候需要封装 http 请求头，并绑定请求的数据，
服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发起请求， 服务器才能给响应， 一次请求完毕后则断开连接， 以节省资源。 服务器不能主动给客户端响 应(除非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket“套接字”进行连接，并没有规定连接后断开，所 以客户端和服务器可以保持连接通道， 双方都可以主动发送数据。 一般在游戏开发或股票开 发这种要求即时性很强并且保持发送数据量比较大的场合使用。 主要使用类是 CFSocketRef 。
TCP 全称是 Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、面 向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能:
* 确保 IP 数据报的成功传递。
* 对程序发送的大块数据进行分段和重组。
* 确保正确排序及按顺序传递分段的数据。
* 通过计算校验和，进行传输数据的完整性检查。
6、TCP 和 UDP 的区别
TCP 提供的是面向连接的、可靠的数据流传输，而 靠的数据流传输。
UDP 提供的是非面向连接的、不可 简单的说， TCP 注重数据安全，而 UDP 数据传输快点，但安全性一般

25.你了解 svn,cvs 等版本控制工具么?
版本控制 svn,cvs 是两种版控制的器 ,需要配套相关的 svn，cvs 服务器。
scm 是 xcode 里配置版本控制的地方。版本控制的原理就是 完当天的代码之后把代码提交给服务器，
b 要做的时候先从服务器得到最新版本，就可以接着做。 并且同时修改了同一个方法，就会产生代码冲突，
如果 a 先提交，那么 b 提交时，服务器可以提示冲突的代码， 应的修改或融合后再提交到服务器。
a 和 b 同时开发一个项目，
a 写
26.什么是 push(了解一下)。 客户端程序留下后门端口，客户端总是监听针对这个后门的请求，于是 服务器可以主动像
这个端口推送消息。
27.静态链接库 (了解一下)
(此为 .a 文件，相当于 java 里的 jar 包，把一些类编译到一个包中，在不同的工程中如果导
入此文件就可以使用里面的类， 具体使用依然是 #import “ xx.h ”)。
28.fmmpeg 框架 (了解一下)
(音视频编解码框架，内部使用 UDP 协议针对流媒体开发，内部开辟了六个端口来接受流
媒体数据，完成快速接受之目的) .
29.fmdb 框架 (了解一下 )
(数据库框架，对 sqllite 的数据操作进行了封装，使用着可把精力都放在 sql 语句上面)。
如果 a 和 b 都要提交给服务器，
b 可以清晰的看到，并做出相

 30.320 框架(了解一下)
(ui 框架，导入 320 工程作为框架包如同添加一个普通框架一样)。
cover(open) flower 框架 (2d 仿射技术 )，内部核心类是 CATransform3D.
31.什么是沙箱模型?哪些操作是属于私有 api 范畴 ?
某个 iphone 工程进行文件操作有此工程对应的指定的位置，不能逾越。
iphone 沙箱模型的有四个文件夹， 分别是什么， 永久数据存储一般放在什么位置， 得到模拟
器的路径的简单方式是什么 . documents，tmp，app，Library 。
(NSHomeDirectory() )， 手动保存的文件在 documents 文件里
Nsuserdefaults 保存的文件在 tmp 文件夹里
Documents 目录:您应该将所有 de应用程序数据文件写入到这个目录下。这个目录用于存 储用户数据或其它应该定期备份的信息。
AppName.app 目录:这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必 须经过签名，
所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。
Library 目录:这个目录下有两个子目录: Caches 和 Preferences
Preferences 目录包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应 该使用 NSUserDefaults 类来取得和设置应用程序的偏好 .
Caches 目录用于存放应用程序专用的支持文件， 保存应用程序再次启动过程中需要的信息。
tmp 目录:这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。 获取这些目录路径的方法:
1，获取家目录路径的函数:
NSString *homeDir = NSHomeDirectory(); 2，获取 Documents 目录路径的方法:

 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
3，获取 Caches 目录路径的方法:
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];
4，获取 tmp 目录路径的方法:
NSString *tmpDir = NSTemporaryDirectory();
5，获取应用程序程序包中资源文件路径的方法:
例如获取程序包中一个图片资源( apple.png)路径的方法:
NSString *imagePath = [[NSBundle mainBundle] pathForResource:@”apple” ofType:@ ”png”]; UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath];
代码中的 mainBundle 类方法用于返回一个代表应用程序包的对象。
文件 IO 写入
1，将数据写到 Documents 目录:
- (BOOL)writeApplicationData:(NSData *)data toFile:(NSString *)fileName {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0]; if (!docDir) {
NSLog(@ ” Documents directory not found! ” ); return NO; }
NSString *filePath = [docDir stringByAppendingPathComponent:fileName]; return [data writeToFile:filePath atomically:YES];
}
2，从 Documents 目录读取数据:
- (NSData *)applicationDataFromFile:(NSString *)fileName {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];

 NSString *filePath = [docDir stringByAppendingPathComponent:fileName]; NSData *data = [[[NSData alloc] initWithContentsOfFile:filePath] autorelease]; return data;
}
NSSearchPathForDirectoriesInDomains 这个主要就是返回一个绝对路径用来存放我们需要储 存的文件。
- (NSString *)dataFilePath {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
return [documentsDirectory stringByAppendingPathComponent:@"shoppingCar.plist"]; }
NSFileManager* fm=[NSFileManager defaultManager]; if(![fm fileExistsAtPath:[self dataFilePath]]){
//下面是对该文件进行制定路径的保存
[fm createDirectoryAtPath:[self dataFilePath] withIntermediateDirectories:YES attributes:nil
error:nil];
//取得一个目录下得所有文件名
NSArray *files = [fm subpathsAtPath: [self dataFilePath] ];
//读取某个文件
NSData *data = [fm contentsAtPath:[self dataFilePath]];
//或者
NSData *data = [NSData dataWithContentOfPath:[self dataFilePath]];
}
iphone 常见私有 api 的应用(比如直接发送短信，访问沙箱之外的磁盘文件) .

 32.你在开发项目中时，用到了哪些数据存储方式， iphone 中常见的方式有哪些，各有什么 区别?
数据存储五种形式的应用范围和性能区别
(core data, sqllite, 对象序列化， 文件直接读写， NSUserDefault( 保存数据到
文件直接读写 >core data> 对象序列化 > sqllite>NSUserDefault.
33.线程的常见方法有哪些，你是如何处理多线程的，多线程同步问题你了解么? 线程创建的几种方式，线程的加锁，休眠，唤醒，解锁，退出，
temp 文件夹中 ))
多线程要考虑同步问题 ,解决同步问题的方式就是对某一资源加锁，当一个线程操作本资源 时，其他线程不能操作 。
系统自带线程池( NSOpertionQueue )的作用:
凡是需要启动多个线程的地方都可以使用 NSOpertionQueue ，加入到 NSOpertionQueue 中的 对象都需要继承 NSOpertion 。 NSOpertionQueue 会在系统内部启动一个独立线程去执行这 个被加入对象的 main 方法。
常用的地方是用 nsoprationqueue 下载图片，文件。如果是自己创建一个线程池，无非就是 启动多个线程的时候，
把这些线程对象放到一个大数组中， 如果需要启动线程的时候， 先从数组中找空闲线程来使 用。
自己管理线程池最大的难题是不好处理当启动多个线程后，用户在多个界面的跳转的时候， 对线程方法的回调管理。
而 NSOpertionQueue 可以很好的处理他。
34.init 和 initwithobject 区别(语法)? init 创建的对象不带自动释放

 35.你连接服务器用的是什么方法，如果请求过程中，网络出了问题这么办? NSUrlConnection 连接后，有一系列委托方法来接受来自服务器的响应和数据，
其中接受相应的方法回得到服务器要传回的数据有多大， 接受数据的方法会反复调用来不断 接受服务器数据，
如果网络出了问题了，会调用一个方法让你来做相关处理。
36.你使用过 json 解析方式么，他们的底层是如何处理的你了解么?
json 解析的用法，用框架的用法简单介绍: 底层原理遍历字符串中的字符，最终根据格式规定的特殊字符，比如
{} 号， [] 号 , : 号 等进
行区分，
{} 号是一个字典的开始， []号是一个数组的开始 ,: 号是字典的键和值的分水岭，最终乃是
将 json 数据转化为字典， 字典中值可能是字典，数组，或字符串而已。
37.xml 解析的原理是什么，你还用过其他解析方式么?
NSXMLParser, 其他解析方式有自定义二进制解析， 就是按字节去解析， 电话会谈就是如此，
还可以是字符串之间用特殊符号连接的数据，将此数据用特殊符号可以分割成所用数据。
38.协议是什么，有什么作用 .?
协议很像 java 中的接口，某个类实现协议后，就必须实现协议中规定的 @require 的方法， 比如一个类 A, 一个类 B 都实现某“协议”后，
这个类 A 的对象和 B 的对象都可以赋值给这个协议的类型变量， 比如 id<协议 > 变量名 = A 类或 B 类的对象，
于是这个变量就完成了能够指向多个不同的类的对象并调用对象中的实现协议的方法。 39.类别有什么作用?

 类别的使用 。 类别有三大作用，
1. 可以使本来需要在 .h 中声明的方法放到 .m 文件中声明，达到了可以使方法不对外公开。
2. 可以方便的扩展类，甚至系统类都可以轻易扩展，维护了代码原本的结构不受影响。
3. 类别可以写到不同的 .h 或.m 文件中，可以分散代码到跟类别的扩展功能想关联的地方，
方便查看。 40.分线程回调主线程方法是什么，有什么作用?
[self performSelectorOnMainThread:@selector(buttonGo2) withObject:nil waitUntilDone:YES];
[self performSelector:@selector(buttonGo2) onThread:[NSThread mainThread] withObject:nil waitUntilDone:YES];
需要即时刷新 ui 控件的时候，经常使用。
41.iphone 阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的?另外像 pdf 格式的文件，你如何读取。 ?
iphone 手机阅读器中对于 PDF 格式的阅读，可以直接用 UIWebView 控件显示，也可以从网 上下到很多直接读取 pdf 格式的代码
直接从 pdf 中得到数据。 复杂表格动画
- (void)insertRowsAtIndexPaths:(NSArray withRowAnimation:(UITableViewRowAnimation)animation; -(void)deleteRowsAtIndexPaths:(NSArray withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadRowsAtIndexPaths:(NSArray withRowAnimation:(UITableViewRowAnimation)animation;
*)indexPaths *)indexPaths *)indexPaths
42.你在开发大型项目的时候，如何进行内存泄露检测的 ?
可以通过 xcode 的自带工具 run---start with performance tool 里有 instruments 下有个 leaks
工具，
启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以 帮助进行内存泄露的处理。

 43.你做 iphone 开发时候，有哪些传值方式， view 和 view 之间是如何传值的? 压栈。
44.让一个物体从界面中的一点运动到另外一点，有哪些方法? 四种方式: 1. beginAnimation
45.你了解哪些加密方式?
Base64, MD5, 循环右移位等 .
46.地图定位
CLLocationManager 位置管理器
基站三角网， wps 三种方式)
使用 Core Location
框架来确定
iphone 的位置 ( GPS，蜂窝
2. 线程
3. NSTimer
4. 图层动画(路径)
MKMapView 提供了一套可植入的地图接口， 可以让我们在应用中展示地图， 并对其进行相 关的操作。一般来说，我们可以指定一个展示区域，放一些标记在上面，还可以加盖一些层
在上面。
MKMapView 依赖 Google map 里面相关服务(如 Google Earth API 等)，所以地图的左下角 会有 Google 字样。
47.打开 url
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://8004664411"]];mailto:// sms://

 48. http 网络通信
ASIHTTPRequest 是一个直接在 CFNetwork 上做的开源项目:提供直接提交 (HTTP POST)
文件的 API ，异步请求与队列，自动管理上传与下载队列管理机 适合上传文件，图片数据。
49. 图片浏览
UIImagePickerController 可以从相册，相机，胶卷里获得图片。
50. 对像序列化
NSCoding encodeWithCoder initWithCoder
NSKeyedUnarchiver NSKeyedArchiver
53.线程 ?
a. 线程的创建和使用规则 ?
答: NSThread
,ASIFormDataRequest 用于

 三种方法
- (id)init; // designated initializer
- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;
+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget
withObject:(id)anArgument
- (void)start;
b. 主分线程
答:启动分线程，上面已提到!加到主线程方法 performSelector !
// 加到主线程 addData()是主线程的方法! 只有加到主线程后， 才能调用主线程的
方法
[target performSelector:@selector(addData:) onThread:[NSThread mainThread] withObject:item waitUntilDone:YES];
//[target addData:item];// 没有加到主线程后，调用主线程的方法!一定会崩!
c.线程锁
答: NSCondition
方法:
[thread lock];// 加锁
sleep(n);// 线程休眠
[thread singnal];// 相当于通知，线程启动 [thread unlock];// 解锁
[thread exit];// 线程退出

 54.各种 排序算法? 希尔排序、快速排序、冒泡排序、
55.通信底层原理
答: OSI 七层模型
7 应用层: 发送到网络中!)
ftp,smtp,http,telnet,tftp (通过各种协议，最终还是包装成
TCP 数据包，
6 表现层:
5 会话层:
4 传输层:
3 网络层:
2 数据链路层: STP,VT 1 物理层:
tcpudp ip,ICMP,IGRP,EIGRP,OSPF,ARP
56. 为什么很多内置类如 UITableViewController 的 delegate属性都是 assign而不是 retain的? 答:
会引起循环引用 所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系:
* 对象 a创建并引用到了对象 * 对象 b 创建并引用到了对象
* 对象 c 创建并引用到了对象
这时候 b和 c的引用计数分别是
b.
c. b.
2和 1。

 当 a 不再使用 b，调用 release 释放对 b 的所有权，因为 c 还引用了 b，所以 b 的引用 计数为 1，b 不会被释放。
b 不释放， c 的引用计数就是 1，c 也不会被释放。从此， b 和 c 永远留在内存中。 这种情况，必须打断循环引用，通过其他规则来维护引用关系。我们常见的 delegate 往往是
assign 方式的属性而不是 retain 方式 的属性， 赋值不会增加引用计数，就是为了防止 delegation 两端产生不必要的循环引用。
如果一个 UITableViewController 对象 a 通过 retain 获取了 UITableView 对象 b 的所有权， 这 个 UITableView 对象 b 的 delegate 又是 a，
如果这个 delegate 是 retain 方式的，那基本上就没有机会释放这两个对象了。自己在设计使 用 delegate模式时，也要注意这点。
57. 以下每行代码执行后， person 对象的 retain count 分别是多少? Person*person = [[Person alloc] init]; count 1
[person retain]; retain count 2
[person release];retain count 1
[person release];retain count = 0
58.在一个对象的方法里面 : self.name = “ object ” ;
和
name =”object”
有什么不同吗 ?
答:self.name="object"会调用对象的 setName()方法,会使object引用计数加 1，name="object" 会直接把 object 赋值给当前对象的 name 属性，引用计数不增加。

 59.readwrite，readonly，assign，retain，copy，nonatomic 属性的作用?
@property 是一个属性访问声明，扩号内支持以下几个属性: 1，getter=getterName， setter=setterName，设置 setter 与 getter 的方法名 2，readwrite,readonly ，设置可供访问级别
3，assign， setter 方法直接赋值，不进行任何 retain 操作，为了解决原类型与环循引用问题
4， retain ， setter 方法对参数进行 release 旧值再 retain 新值，所有实现都是这个顺序 (CC
上有相关资料 )
5，copy，setter 方法进行 Copy 操作，与 retain 处理流程一样，先旧值 release，再 Copy 出新
的对象， retainCount 为 1。这是为了减少对上下文的依赖而引入的机制。
6， nonatomic ，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此
属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级 解的⋯ )。
7， @synthesize xxx; 来实现实际代码
60.1.main() {
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1));
}
答: 2,5
( 我是这么理
*(a+1 )就是 a[1]， *(ptr-1) 就是 a[4],执行结果是 2， 5
&a+1 不是首地址 +1 ，系统会认为加一个 a 数组的偏移，是偏移了一个数组的大小(本
例是 5个int)
int *ptr=(int *)(&a+1);
则 ptr 实际是 &(a[5]), 也就是 a+5 原因如下:

 &a 是数组指针，其类型为 int (*)[5];
而指针加 1 要根据指针类型加上一定的值，不同类型的指针
a 是长度为 5 的 int 数组指针，所以要加 5*sizeof(int) 所以 ptr 实际是 a[5]
但是 prt 与 (&a+1) 类型是不一样的 ( 这点很重要 ) 所以 prt-1 只会减去 sizeof(int*)
+1 之后增加的大小不同。
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0] 的地址， &a 是对象(数组)首地址，
a+1 是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].


⽬目录:
基础

5、下⾯面的代码输出什什么?
8、Category(类别)、 Extension(扩展)和继承的区别 9、为什什么代理理要⽤用weak?代理理的delegate和dataSource有什什么区别?block和代理理 的区别?
10、id和NSObject*的区别
14、UIView和 CALayer是什什么关系?
17、KVO基本原理理?
18、Swift 下的如何使⽤用 KVC?
19、:Swift有哪些模式匹配?


37、 不不要阻塞主线程 38、谈谈你对多线程开发的理理解?ios中有⼏几种实现多线程的⽅方法? 39、进程和线程的区别?同步异步的区别?并⾏行行和并发的区别? 40、ViewController⽣生命周期
41、iOS 中的多线程 42、内存管理理的⼏几条原则时什什么?按照默认法则.那些关键字⽣生成的对象 需要⼿手动释放?在和property结合的时候怎样有效的避免内存泄露露?
谁申请，谁释放

48、1.什什么⽅方式可以看到上架App的头⽂文件? 2.阅读过哪些框架的源码?能说说它的架构⽅方式吗 49、iOS iAP内购审核可能失败的问题 50、IAP内购中虚拟货币导致审核⽆无法通过的问题?

基础:
1、如何令⾃自⼰己所写的对象具有拷⻉贝功能? 如果想让⾃自⼰己的类具备copy⽅方法，并返回不不可边类型，必须遵循nscopying协议，并 且实现
- (id)copyWithZone:(NSZone *)zone 如果让⾃自⼰己的类具备mutableCopy⽅方法，并且放回可变类型，必须遵守 NSMutableCopying，并实现- (id)mutableCopyWithZone:(nullable NSZone *)zone 注意:再此说的copy对应不不可边类型和mutableCopy对应不不可边类型⽅方法，都是遵从 系统规则⽽而已。如果你想实现⾃自⼰己的规则，也是可以的。
2、 释放时，调⽤用clearDeallocating函数。clearDeallocating函数⾸首先根据对象地址 获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个 entry从weak表中删除，最后清理理对象的记录。
追问的问题⼀一: 1.实现weak后，为什什么对象释放后会⾃自动为nil?
runtime?对注册的类， 会进⾏行行布局，对于?weak?对象会放⼊入⼀一个?hash?表中。 ⽤用?weak?指向的对象内存地址作为?key，当此对象的引⽤用计数为?0?的时候会? dealloc，假如?weak?指向的对象内存地址是?a?，那么就会以?a?为键， 在这个? weak?表中搜索，找到所有以?a?为键的?weak?对象，从⽽而设置为?nil?。
追问的问题⼆二: 2.当weak引⽤用指向的对象被释放时，⼜又是如何去处理理weak指针的呢? 1、调⽤用objc_release
2、因为对象的引⽤用计数为0，所以执⾏行行dealloc 3、在dealloc中，调⽤用了了_objc_rootDealloc函数 4、在_objc_rootDealloc中，调⽤用了了object_dispose函数 5、调⽤用objc_destructInstance 6、最后调⽤用objc_clear_deallocating,详细过程如下:

a. 从weak表中获取废弃对象的地址为键值的记录
b. 将包含在记录中的所有附有 weak修饰符变量量的地址，赋值为 nil c. 将weak表中该记录删除
d. 从引⽤用计数表中删除废弃对象的地址为键值的记录
3、题⽬目:Swift mutating关键字的使⽤用? 答案:在Swift中，包含三种类型(type): structure,enumeration,class
其中structure和enumeration是值类型(value type),class是引⽤用类型(reference type)
但是与Objective-C不不同的是，structure和enumeration也可以拥有⽅方法(method)， 其中⽅方法可以为实例例⽅方法(instance method)，也可以为类⽅方法(type method)，实例例 ⽅方法是和类型的⼀一个实例例绑定的。
在swift官⽅方教程中有这样⼀一句句话:
“Structures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods.”
⼤大致意思就是说，虽然结构体和枚举可以定义⾃自⼰己的⽅方法，但是默认情况下，实例例⽅方 法中是不不可以修改值类型的属性。
//// 1. 在结构体的实例例⽅方法⾥里里⾯面修改属性 struct Persion {
var name = ""
mutating func modify(name:String) {
self.name = name }
}
/// 2. 在协议⾥里里⾯面， 如何继承的结构体或枚举类型，想要改遍属性值， 必须添加 mutating
protocol Persionprotocol {
var name : String {get}
mutating func modify(name:String)

}
struct Persion : Persionprotocol {
var name = ""
mutating func modify(name:String) {
self.name = name }
}
/// 3. 在枚举中直接修改self属性 enum Switch {
case On, Off
mutating func operatorTion() { switch self {
case .On:
self = .Off default:
self = .On }
} }
= Switch.On print(a)
4、UIView和 CALayer是什什么关系?
UIView 显示在屏幕上归功于 CALayer，通过调⽤用 drawRect ⽅方法来渲染⾃自身的内容， 调节 CALayer 属性可以调整 UIView 的外观，UIView 继承⾃自 UIResponder，⽐比起 CALayer 可以响应⽤用户事件，Xcode6 之后可以⽅方便便的通过视图调试功能查看图层之 间的关系。
UIView 是 iOS 系统中界⾯面元素的基础，所有的界⾯面元素都继承⾃自它。它内部是由 Core Animation 来实现的，它真正的绘图部分，是由⼀一个叫 CALayer(Core Animation Layer)的类来管理理。UIView 本身，更更像是⼀一个 CALayer 的管理理器器，访问它的跟绘图 和坐标有关的属性，如 frame，bounds 等，实际上内部都是访问它所在 CALayer 的 相关属性。
UIView 有个 layer 属性，可以返回它的主 CALayer 实例例，UIView 有⼀一个layerClass
var a a.operatorTion()

⽅方法，返回主 layer所使⽤用的类，UIView 的⼦子类，可以通过重载这个⽅方法，来让 UIView 使⽤用不不同的 CALayer 来显示，如:
- (class) layerClass {
// 使某个 UIView的⼦子类使⽤用 GL来进⾏行行绘制
return ([CAEAGLLayer class]); }
UIView 的 CALayer 类似 UIView 的⼦子 View 树形结构，也可以向它的 layer 上添加⼦子 layer，来完成某些特殊的显示。例例如下⾯面的代码会在⽬目标 View 上敷上⼀一层⿊黑⾊色的透 明薄膜。
grayCover = [[CALayer alloc]init]; grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor; [self.layer addSubLayer:grayCover];
补充部分:这部分有深度了了，⼤大致了了解⼀一下吧，UIView 的 layer 树形在系统内部被系 统维护着三份 copy
1.逻辑树，就是代码⾥里里可以操纵的，例例如更更改 layer 的属性等等就在这⼀一份 2.动画树，这是⼀一个中间层，系统正是在这⼀一层上更更改属性，进⾏行行各种渲染操作。 3.显示树，这棵树的内容是当前正被显示在屏幕上的内容。这三棵树的逻辑结构都是 ⼀一样的，区别只有各⾃自的属性
5、下⾯面的代码输出什什么?
@implementation Son : Father - (id)init
{
self = [super init];
if (self) {
NSLog(@"%@", NSStringFromClass([self class]));
NSLog(@"%@", NSStringFromClass([super class]));
}
return self;
}
@end
答案:都输出 Son
这个题⽬目主要是考察关于 objc 中对 self 和 super 的理理解:
self 是类的隐藏参数，指向当前调⽤用⽅方法的这个类的实例例。⽽而 super 本质是⼀一个编译 器器标示符，和 self 是指向的同⼀一个消息接受者，当使⽤用 self 调⽤用⽅方法时，会从当前 类的⽅方法列列表中开始找，如果没有，就从⽗父类中再找;⽽而当使⽤用 super 时，则从⽗父类 的⽅方法列列表中开始找。然后调⽤用⽗父类的这个⽅方法调⽤用[self class] 时，会转化成

objc_msgSend 函数id objc_msgSend(id self, SELop, ...)。 调⽤用[super class] 时 ，会转化成objc_msgSendSuper函数id objc_msgSendSuper(struct objc_super *super, SEL op, ...)。 第⼀一个参数是objc_super 这样⼀一个结构体，其定义如下
struct objc_super {
__unsafe_unretained id receiver;
__unsafe_unretained Class super_class;
};
第⼀一个成员是 receiver, 类似于上⾯面的 objc_msgSend 函数第⼀一个参数 self. 第⼆二个成员是记录当前类的⽗父类是什什么，告诉程序从⽗父类中开始找⽅方法，找到⽅方法 后，最后内部是使⽤用 objc_msgSend(objc_super->receiver, @selector(class))去调 ⽤用，此时已经和[self class]调⽤用相同了了，故上述输出结果仍然返回 Son objc Runtime 开源代码对- (Class)class ⽅方法的实现
-(Class)class {
return object_getClass(self); }
6、@synthesize 和 @dynamic 分别有什什么作⽤用? @property有两个对应的词，⼀一个是@synthesize(合成实例例变量量)，⼀一个是 @dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var; // 在类的实现代码⾥里里通过 @synthesize 语法可以来指定实例例变量量的名字。


8、、Category(类别)、 Extension(扩展)和继承的区别
区别:
1. 分类有名字，类扩展没有分类名字，是⼀一种特殊的分类。
2. 分类只能扩展⽅方法(属性仅仅是声明，并没真正实现)，类扩展可以扩展属性、成 员变量量和⽅方法。
3. 继承可以增加，修改或者删除⽅方法，并且可以增加属性。
9、为什什么代理理要⽤用weak?代理理的delegate和dataSource有什什么区别?block和代理理 的区别?
通过weak打破循环引⽤用。 delegate是⼀一个类委托另⼀一个类实现某个⽅方法，协议⾥里里⾯面的⽅方法主要是与操作相关 的。 datasource⼀一个类通过datasource将数据发送给需要接受委托的类，协议⾥里里⾯面的⽅方法 主要是跟内容有关的。 代理理和block的区别:代理理和block的共同特性是回调机制。不不同的是代理理的⽅方法⽐比较 多，block代码⽐比较集中;代理理的运⾏行行成本要低于block的运⾏行行成本，block的出站需要 从栈内存拷⻉贝到堆内存。公共接⼝口⽐比较多时，⽤用代理理解耦;简单回调和异步线程中使 ⽤用block。
10、id和NSObject*的区别
id是⼀一个 objc_object 结构体指针，定义是 typedef struct objc_object *id
id可以理理解为指向对象的指针。所有oc的对象 id都可以指向，编译器器不不会做类型检 查，id调⽤用任何存在的⽅方法都不不会在编译阶段报错，当然如果这个id指向的对象没有 这个⽅方法，该崩溃还是会崩溃的。
NSObject *指向的必须是NSObject的⼦子类，调⽤用的也只能是NSObjec⾥里里⾯面的⽅方法 否则就要做强制类型转换。
不不是所有的OC对象都是NSObject的⼦子类，还有⼀一些继承⾃自NSProxy。NSObject * 可指向的类型是id的⼦子集。

11、如何令⾃自⼰己所写的对象具有拷⻉贝功能?
如果想让⾃自⼰己的类具备copy⽅方法，并返回不不可边类型，必须遵循nscopying协议，并 且实现
- (id)copyWithZone:(NSZone *)zone
如果让⾃自⼰己的类具备mutableCopy⽅方法，并且放回可变类型，必须遵守 NSMutableCopying，并实现- (id)mutableCopyWithZone:(nullable NSZone *)zone
注意:再此说的copy对应不不可边类型和mutableCopy对应不不可边类型⽅方法，都是遵从 系统规则⽽而已。如果你想实现⾃自⼰己的规则，也是可以的。
12、使⽤用系统的某些block api(如UIView的block版本写动画时)，是否也考虑引⽤用 循环问题?
系统的某些block api中，UIView的block版本写动画时不不需要考虑，但也有⼀一些api 需要考虑:
所谓“引⽤用循环”是指双向的强引⽤用，所以那些“单向的强引⽤用”(block 强引⽤用 self ) 没有问题，⽐比如这些:
[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];
[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification"
object:nil queue:[NSOperationQueue mainQueue]
usingBlock:^(NSNotification * notification) { self.someProperty = xyz; }];
这些情况不不需要考虑“引⽤用循环”。
但如果你使⽤用⼀一些参数中可能含有 ivar 的系统 api ，如 GCD 、 NSNotificationCenter就要⼩小⼼心⼀一点:⽐比如GCD 内部如果引⽤用了了 self，⽽而且 GCD 的 其他参数是 ivar，则要考虑到循环引⽤用:
__weak __typeof__(self) weakSelf = self; dispatch_group_async(_operationsGroup, _operationsQueue, ^ {

__typeof__(self) strongSelf = weakSelf; [strongSelf doSomething];
[strongSelf doSomethingElse];
} );
类似的:
__weak __typeof__(self) weakSelf = self;
_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey"
object:nil queue:nil
usingBlock:^(NSNotification *note) { __typeof__(self) strongSelf = weakSelf;
[strongSelf dismissModalViewControllerAnimated:YES]; }];
self --> _observer --> block --> self 显然这也是⼀一个循环引⽤用。


14、UIView和 CALayer是什什么关系?
UIView 显示在屏幕上归功于 CALayer，通过调⽤用 drawRect ⽅方法来渲染⾃自身的内 容，调节 CALayer 属性可以调整 UIView 的外观，UIView 继承⾃自 UIResponder，⽐比 起CALayer 可以响应⽤用户事件，Xcode6 之后可以⽅方便便的通过视图调试功能查看图层 之间的关系。UIView 是 iOS 系统中界⾯面元素的基础，所有的界⾯面元素都继承⾃自它。 它内部是由Core Animation 来实现的，它真正的绘图部分，是由⼀一个叫 CALayer(Core Animation Layer)的类来管理理。UIView 本身，更更像是⼀一个 CALayer 的管理理器器，访问它的跟绘图和坐标有关的属性，如 frame，bounds 等，实际上内部 都是访问它所在 CALayer 的相关属性。UIView 有个 layer 属性，可以返回它的主 CALayer 实例例，UIView 有⼀一个layerClass⽅方法，返回主 layer所使⽤用的类，UIView 的 ⼦子类，可以通过重载这个⽅方法，来让 UIView 使⽤用不不同的 CALayer 来显示，如:
- (class) layerClass {
// 使某个 UIView的⼦子类使⽤用 GL来进⾏行行绘制 return ([CAEAGLLayer class]);
}
UIView 的 CALayer 类似 UIView 的⼦子 View 树形结构，也可以向它的 layer 上添加 ⼦子layer，来完成某些特殊的显示。例例如下⾯面的代码会在⽬目标 View 上敷上⼀一层⿊黑⾊色的 透明薄膜。
grayCover = [[CALayer alloc]init]; grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor; [self.layer addSubLayer:grayCover];
补充部分:这部分有深度了了，⼤大致了了解⼀一下吧，UIView 的 layer 树形在系统内部被系 统维护着三份 copy1.逻辑树，就是代码⾥里里可以操纵的，例例如更更改 layer 的属性等等就 在这⼀一份2.动画树，这是⼀一个中间层，系统正是在这⼀一层上更更改属性，进⾏行行各种渲染 操作。3.显示树，这棵树的内容是当前正被显示在屏幕上的内容。这三棵树的逻辑结 构都是⼀一样的，区别只有各⾃自的属性
15、static有什什么作⽤用?

答案:
1)函数体内 static 变量量的作⽤用范围为该函数体,不不同于 auto 变量量,该变量量的内存只被分 配⼀一次,因此其值在下次调⽤用时仍维持上次的值;
2)在模块内的 static 全局变量量可以被模块内所⽤用函数访问,但不不能被模块外其它函数访 问;
3)在模块内的 static 函数只可被这⼀一模块内的其它函数调⽤用,这个函数的使⽤用范围被限 制在声明它的模块内;
4)在类中的 static 成员变量量属于整个类所拥有,对类的所有对象只有⼀一份拷⻉贝; 5)在类中的 static 成员函数属于整个类所拥有,这个函数不不接收 this 指针,因⽽而只能访 问类的static 成员变量量。
底层
16、main()之前的过程有哪些?
1)dyld 开始将程序⼆二进制⽂文件初始化
2)交由ImageLoader 读取 image，其中包含了了我们的类，⽅方法等各种符号 (Class、Protocol 、Selector、 IMP)
3)由于runtime 向dyld 绑定了了回调，当image加载到内存后，dyld会通知runtime进 ⾏行行处理理
4)runtime 接⼿手后调⽤用map_images做解析和处理理
5)接下来load_images 中调⽤用call_load_methods⽅方法，遍历所有加载进来的 Class，按继承层次依次调⽤用Class的+load和其他Category的+load⽅方法
6)⾄至此 所有的信息都被加载到内存中
7)最后dyld调⽤用真正的main函数
注意:dyld会缓存上⼀一次把信息加载内存的缓存，所以第⼆二次⽐比第⼀一次启动快⼀一点
17、KVO基本原理理? 答:
1.KVO是基于runtime机制实现的
2.当某个类的属性对象第⼀一次被观察时，系统就会在运⾏行行期动态地创建该类的⼀一个 派⽣生类，在这个派⽣生类中重写基类中任何被观察属性的setter ⽅方法。派⽣生类在被重写 的setter⽅方法内实现真正的通知机制
3.如果原类为Person，那么⽣生成的派⽣生类名为NSKVONotifying_Person 4.每个类对象中都有⼀一个isa指针指向当前类，当⼀一个类对象的第⼀一次被观察，那么

系统会偷偷将isa指针指向动态⽣生成的派⽣生类，从⽽而在给被监控属性赋值时执⾏行行的是派 ⽣生类的setter⽅方法
5.键值观察通知依赖于NSObject 的两个⽅方法: willChangeValueForKey: 和 didChangevlueForKey:;在⼀一个被观察属性发⽣生改变之前， willChangeValueForKey:⼀一定会被调⽤用，这就 会记录旧的值。⽽而当改变发⽣生后， didChangeValueForKey:会被调⽤用，继⽽而 observeValueForKey:ofObject:change:context: 也会被调⽤用。
18、:Swift 下的如何使⽤用 KVC? 答:
/// 1. 定义⼀一个类 class Animal {
var name = "Animal" }
/// 2. 我们想使⽤用kvc的⽅方式改变实例例的名字的时候，发现并没有setValue这个⽅方法 let anim = Animal()
//anim.setValue 发现并没有setValue这个⽅方法
/// 3. 怎么像oc⼀一样可以使⽤用kvc的⽅方式来访问控制 // 步骤1: 继承NSObject
class Animal1 : NSObject {
var name = "Animal1" }
// 步骤2:调⽤用, 运⾏行行后发现报错 原因:swift4.0之前，这种⽅方式是可以的，4.0的 时候，减少隐式 @objc ⾃自动推断， 也就是说，如果你要调⽤用，必须显式声明，在⽅方 法前添加@objc, 或者在类前添加@objcMembers(这种情况会给所有的实例例变量量和⽅方 法都隐式的添加了了@objc)
Animal1().setValue("Dog", forKey: "name")
/// 4. 除了了这种可以实现KVC, 还有其它⽅方法么，答案肯定是有的， 如下 let anim = Animal()
let key = \Animal.name
anim[keyPath:key] = "Dog"
print("\(anim.name)")

20、objc在向⼀一个对象发送消息时，发⽣生了了什什么? 答案:objc在向⼀一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实 际所属的类，然后在该类中的⽅方法列列表以及其⽗父类⽅方法列列表中寻找⽅方法运⾏行行，然后在 发送消息的时候，objc_msgSend⽅方法不不会返回值，所谓的返回内容都是具体调⽤用时 执⾏行行的。

27、如何⼿手动触发⼀一个value的KVO 所谓的“⼿手动触发”是区别于“⾃自动触发”:
⾃自动触发是指类似这种场景:在注册 KVO 之前设置⼀一个初始值，注册之后，设置⼀一 个不不⼀一样的值，就可以触发了了。
想知道如何⼿手动触发，必须知道⾃自动触发 KVO 的原理理:
键值观察通知依赖于 NSObject 的两个⽅方法: willChangeValueForKey: 和 didChangevlueForKey: 。在⼀一个被观察属性发⽣生改变之前， willChangeValueForKey: ⼀一定会被调⽤用，这就 会记录旧的值。⽽而当改变发⽣生后， observeValueForKey:ofObject:change:context: 会被调⽤用，继⽽而 didChangeValueForKey: 也会被调⽤用。如果可以⼿手动实现这些调⽤用，就可以实现“⼿手 动触发”了了。
那么“⼿手动触发”的使⽤用场景是什什么?⼀一般我们只在希望能控制“回调的调⽤用时机”时才 会这么做。
具体做法如下:
如果这个 value 是 表示时间的 self.now ，那么代码如下:最后两⾏行行代码缺⼀一不不可。 相关代码已放在仓库⾥里里。

// .m⽂文件
// ⼿手动触发 value 的KVO，最后两⾏行行代码缺⼀一不不可。
//@property (nonatomic, strong) NSDate *now; - (void)viewDidLoad {
[super viewDidLoad];
_now = [NSDate date];
[self addObserver:self forKeyPath:@"now"
options:NSKeyValueObservingOptionNew context:nil];
NSLog(@"1");
[self willChangeValueForKey:@"now"]; // “⼿手动触发self.now的KVO”，必写。 NSLog(@"2");
[self didChangeValueForKey:@"now"]; // “⼿手动触发self.now的KVO”，必写。 NSLog(@"4");
} 但是平时我们⼀一般不不会这么⼲干，我们都是等系统去“⾃自动触发”。“⾃自动触发”的实现原 理理:
⽐比如调⽤用 setNow: 时，系统还会以某种⽅方式在中间插⼊入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的 调⽤用。
⼤大家可能以为这是因为 setNow: 是合成⽅方法，有时候我们也能看到有⼈人这么写代码:
- (void)setNow:(NSDate *)aDate {
[self willChangeValueForKey:@"now"]; // 没有必要 _now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
} 这完全没有必要，不不要这么做，这样的话，KVO代码会被调⽤用两次。KVO在调⽤用存取 ⽅方法之前总是调⽤用 willChangeValueForKey: ，之后总是调⽤用 didChangeValueForkey: 。怎么做到的呢?答案是通过 isa 混写(isa-swizzling)。 下⽂文《apple⽤用什什么⽅方式实现对⼀一个对象的KVO?》会有详述。
参考链接: Manual Change Notification—Apple 官⽅方⽂文档 https:// developer.apple.com/library/content/documentation/Cocoa/Conceptual/ KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/ 20002178-SW3

28、如何对定位和分析项⽬目中影响性能的地⽅方?以及如何进⾏行行性能优化? 定位⽅方法:
instruments   在iOS上进⾏行行性能分析的时候，⾸首先考虑借助instruments这个利利器器分析出问题出 在哪，不不要凭空想象，不不然你可能把精⼒力力花在了了1%的问题上，最后发现其实啥都没优 化，⽐比如要查看程序哪些部分最耗时，可以使⽤用Time Profiler，要查看内存是否泄漏漏 了了，可以使⽤用Leaks等。关于instruments⽹网上有很多资料料，作为⼀一个合格iOS开发 者，熟悉这个⼯工具还是很有必要的。
优化建议:
1.⽤用ARC管理理内存
* ARC(Automatic Reference Counting, ⾃自动引⽤用计数)和iOS5⼀一起发布，它避免了了 最常⻅见的也就是经常是由于我们忘记释放内存所造成的内存泄露露。它⾃自动为你管理理 retain和release的过程，所以你就不不必去⼿手动⼲干预了了。下⾯面是你会经常⽤用来去创建⼀一 个View的代码段: UIView *view = [[UIView alloc] init];
* // ...
* [self.view addSubview:view];
* [view release];
* 忘掉代码段结尾的release简直像记得吃饭⼀一样简单。⽽而ARC会⾃自动在底层为你做这 些⼯工作。除了了帮你避免内存泄露露，ARC还可以帮你提⾼高性能，它能保证释放掉不不再需 要的对象的内存。这都啥年年代了了，你应该在你的所有项⽬目⾥里里使⽤用ARC! 2.在正确的地⽅方使⽤用 reuseIdentifier
* ⼀一个开发中常⻅见的错误就是没有给UITableViewCells， UICollectionViewCells，甚 ⾄至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。
* 为了了性能最优化，table view⽤用 tableView:cellForRowAtIndexPath: 为rows分配 cells的时候，它的数据应该重⽤用⾃自UITableViewCell。 ⼀一个table view维持⼀一个队列列的 数据可重⽤用的UITableViewCell对象。不不使⽤用reuseIdentifier的话，每显示⼀一⾏行行table view就不不得不不设置全新的cell。这对性能的影响可是相当⼤大的，尤其会使app的滚动体 验⼤大打折扣。
* ⾃自iOS6起，除了了UICollectionView的cells和补充views，你也应该在header和footer views中使⽤用reuseIdentifiers
3.尽量量把views设置为完全不不透明
* 如果你有透明的Views你应该设置它们的opaque(不不透明)属性为YES。例例如⼀一个⿊黑⾊色 半透明的可以设置为⼀一个灰⾊色不不透明的View替代.原因是这会使系统⽤用⼀一个最优的⽅方式 渲染这些views。这个简单的属性在IB或者代码⾥里里都可以设定。
* Apple的⽂文档对于为图⽚片设置透明属性的描述是:
* (opaque)这个属性给渲染系统提供了了⼀一个如何处理理这个view的提示。如果设为
YES， 渲染系统就认为这个view是完全不不透明的，这使得渲染系统优化⼀一些渲染过程 和提⾼高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是 YES。

* 在相对⽐比较静⽌止的画⾯面中，设置这个属性不不会有太⼤大影响。然⽽而当这个view嵌在 scroll view⾥里里边，或者是⼀一个复杂动画的⼀一部分，不不设置这个属性的话会在很⼤大程度 上影响app的性能。
* 换种说法，⼤大家可能更更好理理解:只要⼀一个视图的不不透明度⼩小于1,就会导致 blending.blending操作在iOS的图形处理理器器(GPU)中完成的,blending主要指的是混 合像素颜⾊色的计算。举个例例⼦子,我们把两个图层叠加在⼀一起,如果第⼀一个图层的有透明效 果,则最终像素的颜⾊色计算需要将第⼆二个图层也考虑进来。这⼀一过程即为Blending。为 什什么Blending会导致性能的损失?原因是很直观的,如果⼀一个图层是完全不不透明的,则系 统直接显示该图层的颜⾊色即可。⽽而如果图层是带透明效果的,则会引⼊入更更多的计算,因为 需要把下⾯面的图层也包括进来,进⾏行行混合后颜⾊色的计算。
4. 避免过于庞⼤大的XIB
* iOS5中加⼊入的Storyboards(分镜)正在快速取代XIB。然⽽而XIB在⼀一些场景中仍然很有 ⽤用。⽐比如你的app需要适应iOS5之前的设备，或者你有⼀一个⾃自定义的可重⽤用的view,你 就不不可避免地要⽤用到他们。
* 如果你不不得不不XIB的话，使他们尽量量简单。尝试为每个Controller配置⼀一个单独的 XIB，尽可能把⼀一个View Controller的view层次结构分散到单独的XIB中去。
* 需要注意的是，当你加载⼀一个XIB的时候所有内容都被放在了了内存⾥里里，包括任何图 ⽚片。如果有⼀一个不不会即刻⽤用到的view，你这就是在浪费宝贵的内存资源了了。 Storyboards就是另⼀一码事⼉儿了了，storyboard仅在需要时实例例化⼀一个view controller.
* 当你加载⼀一个引⽤用了了图⽚片或者声⾳音资源的nib时，nib加载代码会把图⽚片和声⾳音⽂文件 写进内存。在OS X中，图⽚片和声⾳音资源被缓存在named cache中以便便将来⽤用到时获 取。在iOS中，仅图⽚片资源会被存进named caches。取决于你所在的平台，使⽤用 NSImage 或UIImage 的imageNamed:⽅方法来获取图⽚片资源。
5. 不不要阻塞主线程
* 永远不不要使主线程承担过多。因为UIKit在主线程上做所有⼯工作，渲染，管理理触摸反 应，回应输⼊入等都需要在它上⾯面完成。⼀一直使⽤用主线程的⻛风险就是如果你的代码真的 block了了主线程，你的app会失去反应
* ⼤大部分阻碍主进程的情形是你的app在做⼀一些牵涉到读写外部资源的I/O操作，⽐比如 存储或者⽹网络。或者使⽤用像 AFNetworking这样的框架来异步地做这些操作。如果你 需要做其它类型的需要耗费巨⼤大资源的操作(⽐比如时间敏敏感的计算或者存储读写)那就 ⽤用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.你可以使 ⽤用NSURLConnection异步地做⽹网络操作: + (void)sendAsynchronousRequest: (NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
6. 在Image Views中调整图⽚片⼤大⼩小
* 如果要在UIImageView中显示⼀一个来⾃自bundle的图⽚片，你应保证图⽚片的⼤大⼩小和

UIImageView的⼤大⼩小相同。在运⾏行行中缩放图⽚片是很耗费资源的，特别是UIImageView 嵌套在UIScrollView中的情况下。
* 如果图⽚片是从远端服务加载的你不不能控制图⽚片⼤大⼩小，⽐比如在下载前调整到合适⼤大⼩小 的话，你可以在下载完成后，最好是⽤用background thread，缩放⼀一次，然后在 UIImageView中使⽤用缩放后的图⽚片。
7. 选择正确的Collection 学会选择对业务场景最合适的类或者对象是写出能效⾼高的代码的基础。当处理理 collections时这句句话尤其正确。
Apple有⼀一个 Collections Programming Topics 的⽂文档详尽介绍了了可⽤用的classes间 的差别和你该在哪些场景中使⽤用它们。这对于任何使⽤用collections的⼈人来说是⼀一个必 读的⽂文档。
呵呵，我就知道你因为太⻓长没看...这是⼀一些常⻅见collection的总结:
* Arrays: 有序的⼀一组值。使⽤用index来lookup很快，使⽤用value lookup很慢， 插⼊入/删 除很慢。
* Dictionaries: 存储键值对。 ⽤用键来查找⽐比较快。
* Sets: ⽆无序的⼀一组值。⽤用值来查找很快，插⼊入/删除很快。
8. 打开gzip压缩
* ⼤大量量app依赖于远端资源和第三⽅方API，你可能会开发⼀一个需要从远端下载XML, JSON, HTML或者其它格式的app。
* 问题是我们的⽬目标是移动设备，因此你就不不能指望⽹网络状况有多好。⼀一个⽤用户现在 还在edge⽹网络，下⼀一分钟可能就切换到了了3G。不不论什什么场景，你肯定不不想让你的⽤用 户等太⻓长时间。
* 减⼩小⽂文档的⼀一个⽅方式就是在服务端和你的app中打开gzip。这对于⽂文字这种能有更更⾼高 压缩率的数据来说会有更更显著的效⽤用。好消息是，iOS已经在NSURLConnection中默 认⽀支持了了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经⽀支持了了压缩输出。
29、串串⾏行行并⾏行行，异步同步的区别?
先来说⼀一个队列列和任务:
队列列分为串串⾏行行和并⾏行行
任务的执⾏行行分为同步和异步 这两两组合就成为了了串串⾏行行队列列同步执⾏行行，串串⾏行行队列列异步执⾏行行，并⾏行行队列列同步执⾏行行，并 ⾏行行队列列异步执⾏行行 ⽽而异步是多线程的代名词，异步在实际引⽤用中会开启新的线程，执⾏行行耗时操作。
那我们先来知道⼀一个⾮非常重要的事情:
------- 队列列只是负责任务的调度，⽽而不不负责任务的执⾏行行 ---------

------- 任务是在线程中执⾏行行的 ---------
队列列和任务的特点:
队列列的特点:先进先出，排在前⾯面的任务最先执⾏行行， 串串⾏行行队列列:任务按照顺序被调度，前⼀一个任务不不执⾏行行完毕，队列列不不会调度 并⾏行行队列列:只要有空闲的线程，队列列就会调度当前任务，交给线程去执⾏行行，不不需要考 虑前⾯面是都有任务在执⾏行行，只要有线程可以利利⽤用，队列列就会调度任务。 主队列列:专⻔门⽤用来在主线程调度任务的队列列，所以主队列列的任务都要在主线程来执 ⾏行行，主队列列会随着程序的启动⼀一起创建，我们只需get即可 全局队列列:是系统为了了⽅方便便程序员开发提供的，其⼯工作表现与并发队列列⼀一致，那么全 局队列列跟并发队列列的区别是什什么呢? 1.全局队列列:⽆无论ARC还是MRC都不不需要考录释放，因为系统提供的我们只需要get就 可以了了 2.并发队列列:再MRC下，并发队列列创建出来后，需要⼿手动释放dispatch_release() 同步执⾏行行:不不会开启新的线程，任务按顺序执⾏行行 异步执⾏行行:会开启新的线程，任务可以并发的执⾏行行
30、线程是什什么?进程是什什么?⼆二者有什什么区别和联系? 答案:⼀一个程序⾄至少有⼀一个进程,⼀一个进程⾄至少有⼀一个线程: 进程:⼀一个程序的⼀一次运⾏行行，在执⾏行行过程中拥有独⽴立的内存单元，⽽而多个线程共享⼀一 块内存
线程:线程是指进程内的⼀一个执⾏行行单元。
联系:线程是进程的基本组成单位 区别:(1)调度:线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 (2)并发性:不不仅进程之间可以并发执⾏行行，同⼀一个进程的多个线程之间也可并发执⾏行行 (3)拥有资源:进程是拥有资源的⼀一个独⽴立单位，线程不不拥有系统资源，但可以访问⾪隶 属于进程的资源. (4)系统开销:在创建或撤消进程时，由于系统都要为之分配 和回收资源，导致系统的开销明显⼤大于创建或撤消线程时的开销。 举例例说明:操作系统有多个软件在运⾏行行(QQ、office、⾳音乐等)，这些都是⼀一个个进 程，⽽而每个进程⾥里里⼜又有好多线程(⽐比如QQ，你可以同时聊天，发送⽂文件等)

32、假设有⼀一个字符串串aabcad，请写⼀一段程序，去掉字符串串中不不相邻的重复字符 串串，即上述字符串串处理理之后的输出结果为:aabcd
答案:NSMutableString * str = [[NSMutableString alloc]initWithFormat;@“aabcad”];
for (int i = 0 ,i < str.length - 1 ;i++){ unsigned char a = [str characterAtIndex:i]; for (int j = i + 1 ,j < str.length ,j++){
unsigned char b = [str characterAtIndex:j]; if (a == b ){
if (j == i + 1){ }else{
[str deleteCharactersInRange:NSMakeRange(j, 1)];
} }
} }
NSLog(@“%@”,str);
33、@autoclosure(⾃自动闭包)
1:⾃自动闭包，顾名思义是⼀一种⾃自动创建的闭包，⽤用于包装函数参数的表达式，可以说 是⼀一种简便便语法.
2:⾃自动闭包不不接受任何参数，被调⽤用时会返回被包装在其中的表达式的值。
3:⾃自动闭包的好处之⼆二是让你能够延迟求值,因为代码段不不会被执⾏行行直到你调⽤用这个闭 包，这样你就可以控制代码什什么时候执⾏行行。
4:含有autoclosure特性的声明同时也具有noescape的特性，及默认是⾮非逃逸闭 包，除⾮非传递可选参数escaping.如果传递了了该参数，那么将可以在闭包之外进⾏行行操作 闭包,形式为:请使⽤用@autoclosure(escaping)。
实战操作理理解:

/// 我们定义有⼀一个⽅方法接受⼀一个闭包，当闭包执⾏行行的结果为true的时候进⾏行行打印: func method(result:() -> Bool) {
if result() { print("method")
} }
/// 1. 直接挑⽤用⽅方法 method { () -> Bool in
return true }
/// 2. 闭包在园括号⾥里里 method(result: {return true})
/// 3. 使⽤用尾部闭包⽅方式，闭包体在圆括号之外 method(){return true}
/// 4. 在 Swift 中对闭包的⽤用法可以进⾏行行⼀一些简化，在这种情况下我们可以省略略掉 return，写成:
method(){true}
/// 5:还可以更更近⼀一步，因为这个闭包是最后⼀一个参数，所以可以使⽤用尾随闭包 (trailing closure) 的⽅方式把⼤大括号拿出来，然后省略略括号，变成:
method {true}
//===========================================//
/// 但是不不管哪种⽅方式，表达上不不太清晰，看起来不不舒服。于是@autoclosure就登场 了了。我们可以改换⽅方法参数，在参数名前⾯面加上@autoclosure关键字:
func method1( result:@autoclosure ()->Bool) {
if result() { print("method1")
} }
/// 调⽤用下，我们看⼀一下
method1(result: true)
/// 上⾯面调⽤用是不不是舒服多了了，直接进⾏行行调⽤用了了，Swift 将会把 true 这个表达式⾃自动 转换为 () -> Bool。这样我们就得到了了⼀一个写法简单，表意清楚的式⼦子。

/// 1个闭包优势可能不不是那么的明显，如果有多个闭包，那么优势就明显了了，⽽而 @autoclosure是可以修饰任何位置的参数:
/// 我们先看看不不加@autoclosure，使⽤用时是什什么样⼦子
func method3(result1: ()->Bool, result2: ()->Bool) {
if result1() && result2() { print("method3 ... 0") return
}
print("method3 ... 1") }
method3(result1: {5 > 1}, result2: {4 > 3})
/// 我们加上@autoclosure之后对⽐比下:
func method4(result1: @autoclosure ()->Bool, result2: @autoclosure ()->Bool) {
if result1() && result2() { print("method4 ... 0") return
}
print("method4 ... 1") }
method4(result1: 5 > 1, result2: 4 > 3)
34、iOS app启动如何优化?
1. 我们可以通过在 Xcode 中 Edit scheme -> Run -> Auguments 将环境变量量 DYLD_PRINT_STATISTICS 设为 1,在控制台看到main()函数之前的启动时间。
2. 分解优化⽬目标 分步达到优化⽬目的 1). 耗时操作异步处理理
2). 如果启动流程依赖⽹网络请求回来才能继续,那么需要考虑⽹网络极差情况下的启
动速度
3). 如果APP有loading⼴广告⻚页并且对分辨率的要求较⾼高,请尝试做缓存吧
4). 主⻚页⾯面Controller中的viewDidLoad和viewWillAppear⽅方法中尽量量少做事情 5). 排查清理理项⽬目中未使⽤用到的类库以及Framework
6). 删减合并⼀一些OC类,删减没有⽤用到或者可以不不⽤用的静态变量量、⽅方法等
7). 轻量量化+load⽅方法中的内容,可延迟到+initialize中
1. 实现⼀一个函数，输⼊入是任⼀一整数，输出要返回输⼊入的整数 乘以 2
这道题很多⼈人上来就这样写: func mult(_ num: Int) -> Int {
return num * 2

}
接下来⾯面试官会说，那假如我要实现乘以4 呢?程序员想了了⼀一想，⼜又定义了了另⼀一个⽅方 法:
func mult(_ num: Int) -> Int {
return num * 4 }
这时⾯面试官会问，假如我要实现返回 乘以 6, 乘以 8 的操作呢?能不不能只定义⼀一次⽅方 法呢?正确的写法是利利⽤用 Swift 的 柯⾥里里化特性:
func mult(_ num: Int) -> (Int) -> Int { return { val in
return num * val }
}
let multTwo = mult(2), multFour = mult(4), multSix = mult(6), multEight = mult(8)
35、swift⾯面试题:
教育类的app, 显示分数的地⽅方，统计平均分的时候需要显示⼩小数位，并且不不能四舍五 ⼊入，同时为了了界⾯面美观，不不能出现⼩小数点后⾯面都为0的情况。
题⽬目:Float类型，转换成字符串串输出，要求保留留N位⼩小数, 特殊情况，如果转换之后 结果为XX.00(0的个数=保留留的⼩小数的个数), 则返回XX
例例⼦子: 11.11保留留1位 = "11.1" 11.01保留留1位 = "11" 11.001保留留2位 = "11"
36、怎样防⽌止反编译?
本地数据加密 对NSUserDefaults，sqlite存储⽂文件数据加密，保护帐号和关键信息 URL编码加密
对程序中出现的URL进⾏行行编码加密，防⽌止URL被静态分析 ⽹网络传输数据加密 对客户端传输数据提供加密⽅方案，有效防⽌止通过⽹网络接⼝口的拦截获取数据
 
⽅方法体，⽅方法名⾼高级混淆 对应⽤用程序的⽅方法名和⽅方法体进⾏行行混淆，保证源码被逆向后⽆无法解析代码 程序结构混排加密 对应⽤用程序逻辑结构进⾏行行打乱混排，保证源码可读性降到最低
37、UITableView性能优化，超实⽤用
1. Cell重⽤用 1.1>数据源⽅方法优化
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
在可⻅见的⻚页⾯面会重复绘制⻚页⾯面，每次刷新显示都会去创建新的Cell，⾮非常耗费性 能。
解决⽅方案:⾸首先创建⼀一个静态变量量reuseID(代理理⽅方法返回Cell会调⽤用很多次，防⽌止 重复创建，static保证只会被创建⼀一次，提⾼高性能)，然后，从缓存池中取相应 identifier的Cell并更更新数据，如果没有，才开始alloc新的Cell，并⽤用identifier标识 Cell。每个Cell都会注册⼀一个identifier(重⽤用标识符)放⼊入缓存池，当需要调⽤用的时 候就直接从缓存池⾥里里找对应的id，当不不需要时就放⼊入缓存池等待调⽤用。(移出屏幕的 Cell才会放⼊入缓存池中，并不不会被release)所以在数据源⽅方法中做出如下优化:
// 调⽤用次数太多，static 保证只创建⼀一次reuseID，提⾼高性能
static NSString *reuseID = “reuseCellID”;
// 缓存池中取已经创建的cell
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];
1.2>缓存池的实现
当Cell要alloc时，UITableView会在堆中开辟⼀一段内存以供Cell缓存之⽤用。Cell的重 ⽤用通过identifier标识不不同类型的Cell，由此可以推断出，缓存池外层可能是⼀一个可变 字典，通过key来取出内部的Cell，⽽而缓存池为存储不不同⾼高度、不不同类型(包含图⽚片、 Label等)的Cell，可以推断出缓存池的字典内部可能是⼀一个可变数组，⽤用来存放不不同 类型的Cell，缓存池中只会保存已经被移出屏幕的不不同类型的Cell。
1.3>缓存池获取可重⽤用Cell两个⽅方法的区别
-(nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier: (NSString *)identifier;
这个⽅方法会查询可重⽤用Cell，如果注册了了原型Cell，能够查询到，否则，返回nil;⽽而 且需要判断if(cell == nil)，才会创建Cell，不不推荐
-(__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
使⽤用这个⽅方法之前，必须通过xib(storyboard)或是Class(纯代码)注册可重⽤用 Cell，⽽而且这个⽅方法⼀一定会返回⼀一个Cell
注册Cell
- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString

*)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
好处:如果缓冲区 Cell 不不存在，会使⽤用原型 Cell 实例例化⼀一个新的 Cell，不不需要再判 断，同时代码结构更更清晰。
2. 定义⼀一种(尽量量少)类型的Cell及善⽤用hidden隐藏(显示)subviews
2.1>⼀一种类型的Cell
分析Cell结构，尽可能的将 相同内容的抽取到⼀一种样式Cell中，前⾯面已经提到了了
Cell的重⽤用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能 只⽐比屏幕显示的Cell多⼀一点。虽然Cell的’体积’可能会⼤大点，但是因为Cell的数量量不不会 很多，完全可以接受的。好处:
* 减少代码量量，减少Nib⽂文件的数量量，统⼀一⼀一个Nib⽂文件定义Cell，容易易修改、维护
* 基于Cell的重⽤用，真正运⾏行行时铺满屏幕所需的Cell数量量⼤大致是固定的，设为N个。所 以如果如果只有⼀一种Cell，那就是只有N个Cell的实例例;但是如果有M种Cell，那么运 ⾏行行时最多可能会是“M x N = MN”个Cell的实例例，虽然可能并不不会占⽤用太多内存，但是 能少点不不是更更好吗。
2.2>善⽤用hidden隐藏(显示)subviews
只定义⼀一种Cell，那该如何显示不不同类型的内容呢?答案就是，把所有不不同类型的 view都定义好，放在cell⾥里里⾯面，通过hidden显示、隐藏，来显示不不同类型的内容。毕 竟，在⽤用户快速滑动中，只是单纯的显示、隐藏subview⽐比实时创建要快得多。
3. 提前计算并缓存Cell的⾼高度 在iOS中，不不设UITableViewCell的预估⾏行行⾼高的情况下，会优先调
⽤用”tableView:heightForRowAtIndexPath:”⽅方法，获取每个Cell的即将显示的⾼高度， 从⽽而确定UITableView的布局，实际就是要获取contentSize(UITableView继承⾃自 UIScrollView,只有获取滚动区域，才能实现滚动),然后才调 ⽤用”tableView:cellForRowAtIndexPath”,获取每个Cell，进⾏行行赋值。如果项⽬目中模块有 10000个Cell需要显示，可想⽽而知...
解决⽅方案:我个⼈人认为，可以创建⼀一个frame模型，提前计算每个Cell的⾼高度。参考 其中⼀一篇博客的时候，在解决这个问题的时候，可以将计算Cell的⾼高度放⼊入数据模 型，但这与MVC设计模式可能稍微有点冲突，这个时候我就想到MVVM这种设计模 式，这个时候才能稍微有点MVVM这种设计模式的优点(其实还是很不不理理解的)，可 以讲计算Cell⾼高度放⼊入ViewModel(视图模型)中，让Model(数据模型)只负责处 理理数据。
4.异步绘制(⾃自定义Cell绘制) 遇到⽐比较复杂的界⾯面的时候，如复杂点的图⽂文混排，上⾯面的那种优化⾏行行⾼高的⽅方式可
能就不不能满⾜足要求了了，当然了了，由于我的开发经验尚短，说实话，还没遇到要将⾃自定 义的Cell重新绘制
5.滑动时，按需加载 开发的过程中，⾃自定义Cell的种类千奇百怪，但Cell本来就是⽤用来显示数据的，不不说

100%带有图⽚片，也差不不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其 ⽹网络不不好的时候，异步加载图⽚片是个程序员都会想到，但是如果给每个循环对象都加 上异步加载，开启的线程太多，⼀一样会卡顿，我记得好像线程条数⼀一般3-5条，最多 也就6条吧。这个时候利利⽤用UIScrollViewDelegate两个代理理⽅方法就能很好地解决这个问 题。
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate: (BOOL)decelerate
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
6.缓存View
当Cell中的部分View是⾮非常独⽴立的，并且不不便便于重⽤用的，⽽而且“体积”⾮非常⼩小，在内 存可控的前提下，我们完全可以将这些view缓存起来。当然也是缓存在模型中。
7.避免⼤大量量的图⽚片缩放、颜⾊色渐变等，尽量量显示“⼤大⼩小刚好合适的图⽚片资源” 8.避免同步的从⽹网络、⽂文件获取数据，Cell内实现的内容来⾃自web，使⽤用异步加载，缓 存请求结果
9.渲染
9.1>减少subviews的个数和层级 ⼦子控件的层级越深，渲染到屏幕上所需要的计算量量就越⼤大;如多⽤用drawRect绘制
元素，替代⽤用view显示 9.2>少⽤用subviews的透明图层
对于不不透明的View，设置opaque为YES，这样在绘制该View时，就不不需要考虑 被View覆盖的其他内容(尽量量设置Cell的view为opaque，避免GPU对Cell下⾯面的内容 也进⾏行行绘制)
9.3>避免CALayer特效(shadowPath) 给Cell中View加阴影会引起性能问题，如下⾯面代码会导致滚动时有明显的卡顿:
view.layer.shadowColor = color.CGColor; view.layer.shadowOffset = offset; view.layer.shadowOpacity = 1; view.layer.shadowRadius = radius;
线程:
37、 不不要阻塞主线程
* 永远不不要使主线程承担过多。因为UIKit在主线程上做所有⼯工作，渲染，管理理触摸反 应，回应输⼊入等都需要在它上⾯面完成。⼀一直使⽤用主线程的⻛风险就是如果你的代码真的 block了了主线程，你的app会失去反应
* ⼤大部分阻碍主进程的情形是你的app在做⼀一些牵涉到读写外部资源的I/O操作，⽐比如 存储或者⽹网络。或者使⽤用像 AFNetworking这样的框架来异步地做这些操作。如果你 需要做其它类型的需要耗费巨⼤大资源的操作(⽐比如时间敏敏感的计算或者存储读写)那就 ⽤用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.你可以使 ⽤用NSURLConnection异步地做⽹网络操作: + (void)sendAsynchronousRequest:

(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
6. 在Image Views中调整图⽚片⼤大⼩小
* 如果要在UIImageView中显示⼀一个来⾃自bundle的图⽚片，你应保证图⽚片的⼤大⼩小和 UIImageView的⼤大⼩小相同。在运⾏行行中缩放图⽚片是很耗费资源的，特别是UIImageView 嵌套在UIScrollView中的情况下。
* 如果图⽚片是从远端服务加载的你不不能控制图⽚片⼤大⼩小，⽐比如在下载前调整到合适⼤大⼩小 的话，你可以在下载完成后，最好是⽤用background thread，缩放⼀一次，然后在 UIImageView中使⽤用缩放后的图⽚片。
38、谈谈你对多线程开发的理理解?ios中有⼏几种实现多线程的⽅方法?
答案:
好处:
1.使⽤用线程可以把占据时间⻓长的程序中的任务放到后台去处理理 2.⽤用户界⾯面可以更更加吸引⼈人，这样⽐比如⽤用户点击了了⼀一个按钮去触发某些事件的处理理， 可以弹出⼀一个进度条来显示处理理的进度
3.程序的运⾏行行速度可能加快 4·在⼀一些等待的任务实现上如⽤用户输⼊入、⽂文件读写和⽹网络收发数据等，线程就⽐比较有 ⽤用了了。
缺点:
1.如果有⼤大量量的线程,会影响性能,因为操作系统需要在它们之间切换。 2.更更多的线程需要更更多的内存空间。
3.线程的中⽌止需要考虑其对程序运⾏行行的影响。 4.通常块模型数据是在多个线程间共享的，需要防⽌止线程死锁情况的发⽣生。 实现多线程的⽅方法:
NSObject类⽅方法
NSThread
NSOperation
GCD
39、进程和线程的区别?同步异步的区别?并⾏行行和并发的区别?
参考答案: 进程:是具有⼀一定独⽴立功能的程序关于某个数据集合上的⼀一次运⾏行行活动,进程是系统进 ⾏行行资源分配和调度的⼀一个独⽴立单位. 线程:是进程的⼀一个实体,是CPU调度和分派的基本单位,它是⽐比进程更更⼩小的能独⽴立运 ⾏行行的基本单位.线程⾃自⼰己基本上不不拥有系统资源,只拥有⼀一点在运⾏行行中必不不可少的资源 (如程序计数器器,⼀一组寄存器器和栈),但是它可与同属⼀一个进程的其他的线程共享进程所拥 有的全部资源.

同步:阻塞当前线程操作，不不能开辟线程。 异步:不不阻碍线程继续操作，可以开辟线程来执⾏行行任务。 并发:当有多个线程在操作时,如果系统只有⼀一个CPU,则它根本不不可能真正同时进⾏行行 ⼀一个以上的线程，它只能把CPU运⾏行行时间划分成若⼲干个时间段,再将时间 段分配给各 个线程执⾏行行，在⼀一个时间段的线程代码运⾏行行时，其它线程处于挂起状。.这种⽅方式我们 称之为并发(Concurrent)。 并⾏行行:当系统有⼀一个以上CPU时,则线程的操作有可能⾮非并发。当⼀一个CPU执⾏行行⼀一个线 程时，另⼀一个CPU可以执⾏行行另⼀一个线程，两个线程互不不抢占CPU资源，可以同时进 ⾏行行，这种⽅方式我们称之为并⾏行行(Parallel)。 区别:并发和并⾏行行是即相似⼜又有区别的两个概念，并⾏行行是指两个或者多个事件在同⼀一 时刻发⽣生;⽽而并发是指两个或多个事件在同⼀一时间间隔内发⽣生。在多道程序环境下， 并发性是指在⼀一段时间内宏观上有多个程序在同时运⾏行行，但在单处理理机系统中，每⼀一 时刻却仅能有⼀一道程序执⾏行行，故微观上这些程序只能是分时地交替执⾏行行。倘若在计算 机系统中有多个处理理机，则这些可以并发执⾏行行的程序便便可被分配到多个处理理机上，实 现并⾏行行执⾏行行，即利利⽤用每个处理理机来处理理⼀一个可并发执⾏行行的程序，这样，多个程序便便可 以同时执⾏行行。
40、ViewController⽣生命周期
按照执⾏行行顺序排列列:
1. initWithCoder:通过nib⽂文件初始化时触发。
2. awakeFromNib:nib⽂文件被加载的时候，会发⽣生⼀一个awakeFromNib的消息到nib ⽂文件中的每个对象。
3. loadView:开始加载视图控制器器⾃自带的view。
4. viewDidLoad:视图控制器器的view被加载完成。
5. viewWillAppear:视图控制器器的view将要显示在window上。
6. updateViewConstraints:视图控制器器的view开始更更新AutoLayout约束。
7. viewWillLayoutSubviews:视图控制器器的view将要更更新内容视图的位置。
8. viewDidLayoutSubviews:视图控制器器的view已经更更新视图的位置。
9. viewDidAppear:视图控制器器的view已经展示到window上。
10. viewWillDisappear:视图控制器器的view将要从window上消失。
11. viewDidDisappear:视图控制器器的view已经从window上消失。
41、iOS 中的多线程 iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更更为⽅方 便便的使⽤用线程，做过C++的同学可能会对线程有更更多的理理解，⽐比如线程的创⽴立，信号 量量、共享变量量有认识，Cocoa框架下会⽅方便便很多，它对线程做了了封装，有些封装，可 以让我们创建的对象，本身便便拥有线程，也就是线程的对象化抽象，从⽽而减少我们的 ⼯工程，提供程序的健壮性。
* GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的⼀一个易易⽤用地多线程类

库，具有运⾏行行时的特点，能充分利利⽤用多核⼼心硬件。GCD的API接⼝口为C语⾔言的函数，函 数参数中多数有Block，关于Block的使⽤用参看这⾥里里，为我们提供强⼤大的“接⼝口”，对于 GCD的使⽤用参⻅见本⽂文
* NSOperation与Queue NSOperation是⼀一个抽象类，它封装了了线程的细节实现，我们可以通过⼦子类化该对 象，加上NSQueue来同⾯面向对象的思维，管理理多线程程序。具体可参看这⾥里里:⼀一个基 于NSOperation的多线程⽹网络访问的项⽬目。
* NSThread NSThread是⼀一个控制线程执⾏行行的对象，它不不如NSOperation抽象，通过它我们可以⽅方 便便的得到⼀一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们⾃自 ⼰己来控制的，可以通过NSCondition实现。
参看 iOS多线程编程之NSThread的使⽤用
42、内存管理理的⼏几条原则时什什么?按照默认法则.那些关键字⽣生成的对象 需要⼿手动释放?在和property结合的时候怎样有效的避免内存泄露露? 谁申请，谁释放
遵循Cocoa Touch的使⽤用原则; 内存管理理主要要避免“过早释放”和“内存泄漏漏”，对于“过早释放”需要注意@property 设置特性时，⼀一定要⽤用对特性关键字，对于“内存泄漏漏”，⼀一定要申请了了要负责释放， 要细⼼心。
关键字alloc 或new ⽣生成的对象需要⼿手动释放; 设置正确的property属性，对于retain需要在合适的地⽅方释放，

44、如何⽤用GCD同步若⼲干个异步调⽤用?(如根据若⼲干个url异步加载多张图⽚片，然后在 都下载完成后合成⼀一张整图)
使⽤用Dispatch Group追加block到Global Group Queue,这些block如果全部执⾏行行完 毕，就会执⾏行行Main Dispatch Queue中的结束处理理的block。
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ /*加载图⽚片1 */ }); dispatch_group_async(group, queue, ^{ /*加载图⽚片2 */ }); dispatch_group_async(group, queue, ^{ /*加载图⽚片3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{
// 合并图⽚片 });

47、服务器器能否知道APNS推送后有没有到达客户端的⽅方法? APNS是苹果提供的远程推送的服务，APP开发此功能之后，⽤用户允许推送之后，服务端可以向安 装了了此app的⽤用户推送信息。但是APNS推送⽆无法保证100%到达。

⽬目前关于APNS苹果更更新了了新的策略略，即 APNS/HTTP2.
 如果服务器器像APNS服务器器推送信息之后，服务器器能够接收到APNS是否真的成功像客户端推送成 功了了某个信息。这样在⼀一定程度上提⾼高了了APNS的成功概率。
app: 48、1.什什么⽅方式可以看到上架App的头⽂文件? 2.阅读过哪些框架的源码?能说说它的架构⽅方式吗
  49、iOS iAP内购审核可能失败的问题

Guideline 3.1.1 - Business - Payments - In-App Purchase
We noticed that your app uses in-app purchase products to purchase credits or
currencies that are not consumed within the app, which is not appropriate for the App Store.
苹果提交iAP内购审核的时候，可能出现上⾯面的问题。出现这个问题有可能的原因 是因为你的app中在iAP内购中购买的商品，能够通过其他的渠道或者⽅方式购买。此处 在AppStore是不不允许的。⽐比如，你在安卓充值100元⼈人⺠民币，那么如果商品⼀一样能够 使⽤用在iOS设备上，苹果不不会允许你上线的。当然这⾥里里指的是虚拟类商品。
另外就是在审核的时候不不能以任何⽅方式，通过活动或者兑换码的形式，能够获取 到iAP内购中能够获取到的商品。
App上架后，如何修改app上显示的公司名称? 1.先修改开发者账号中填写的公司名称。
2.再提交更更新版本。
如何修改开发者账号中的公司名称:
登陆到Apple developer上⾯面，在people⾥里里⾯面的开发者列列表中找到agent，让agent的这 个⼈人直接拨打苹果开发部咨询电话，修改开发者账号上的公司名或者⽤用你注册的账号 的邮箱直接写邮件:“我需要更更改公司名称”到chinadev@asia.apple.com，让苹果开发 部客服来处理理。
50、IAP内购中虚拟货币导致审核⽆无法通过的问题?
有的时候需要在app中使⽤用虚拟货币，在我们的app中可以使⽤用虚拟货币进⾏行行购买道具 等，⽐比如直播中的礼物，游戏中的道具等。
苹果对于虚拟货币是需要提成的，提成的额度为30%。所以对于这块的审核⽐比较严 格。⾸首先你们的购买的道具在ios端和安卓端是需要分开的。如果⼤大家玩游戏的就会发 现游戏的数据在两端是分开的。 ⽤用户在安卓⼿手机上购买的道具在ios上不不能使⽤用。因为这样也间接的影响了了苹果的收 ⼊入。
另外就是在审核期间不不能有可以兑换在appStore可购买的商品，的任意活动或者兑 换码，这个也是苹果不不允许的。因为这个也会影响苹果的收⼊入。
另外就是可能有⼈人会在苹果审核之后隐藏ipa⽀支付，此处提醒下，苹果会扫描你的 app代码中是否有⽀支付宝，微信等关于⽀支付的字段。使⽤用开关加h5的⽅方式可以通过审 核，但是此处也有⻛风险，⻛风险就是⼀一旦被发现，可能的结果就是苹果直接封掉账号。 app⽆无法使⽤用。





北风网 iOS 面试题库(五)
写在前面 :“分享”看似在输出，但实际上是获得更多。用我们北风网的口号就是 “不懂得分 享的人，不会很快乐;不懂得分享的机构，不是好机构 ”。所以，我们北风网不定期会给大
家分享一些干货，所有的内容仅供学习之用，也希望大家能将
“分享的精神 ”传递下去。
一、 用一个属性引用 UI 控件的时候为什么可以用 weak?
controller 是被系统用强指针引用者， 只要它存在， 那么里面的子控件也就存在， controller
强引用着它的 view controller ，又强引用着它的数组对象 subviews ，数组对象又强引用着 它所包含的数组内容，那么创建出来的一个 UI 控件将其加入 subviews 的时候，那么就会 被一个强指针所引着它
对于内存的合理使用， 当我们需要控件的时候就已经有一个强引用在引用着它， 我们就不必 再弄一个强指针来强引用它;当我们不需要的时候， weak 直接释放掉，用 strong 的话就 还会保留它，这就占着内存了 .
二、 UITableView 性能优化的原理
iOS 设备内存有限，如果使用 UIT ableView 显示非常多的数据，就需要非常多的 UI TableViewcell
那么设备的内存就会耗尽，解决该问题就需重用 UITableView 对象。 当滚动出列表的时候，部分 UIT ableViewCell 会移出窗口， UITableView 会将窗口外的 UITableVIewcell 放入一个对象缓存池中;
当 UITableView 要求 dataSource 返回 UITableView 时， dataSource 会先查看缓存池 中是否有未使用的 UITableViewCell ，有就用新的数据配置这个 UITableViewCell 重新使 用到窗口，这就避免了重新创建对象。
三、什么是抽象类?有什么作用 ?能实例化吗 ?
1 、抽象类: abstract 修饰，它只能用来作父类，本身并没有生成实例的能力
它将一类最公有的属性和方法抽取出来抽象类是将类共有的方法抽取出来， 声明为抽象方法 , 抽象方法只有声明没有具体的实现 , 拥有抽象方法的类就是抽象类 ; 这样新增一种类型时候 只需要继承抽象类，实现抽象方法就可以了，降低了实现新类的难度。
抽象方法修饰符 abstract 抽象类不能被实现 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类
2 、抽象类作用:
(1 )用于类型隐藏在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个

固定的一组行为的抽象描述， 但是这组行为却能够有任意个可能的具体实现方式。 这个抽象 描述就是抽象类。
(2 )用于拓展对象的行为功能
这一组任意个可能的具体实现则表现为所有可能的派生类(子类) ，模块可以操作一个抽象 体。由于模块依赖于一个固定的抽象体， 因此它可以是不允许修改的; 同时，通过从这个抽 象体派生，也可扩展此模块的行为功能。
四、 objc 中向一个 nil 对象发送消息会发生什么 ? 如果没有返回值， nothing will happen ;
如果有返回值，基本数据类型返回 0/0.0/NO 个假的东西。
等，对象类型返回
nil ，总的来说就是返回一


九. 是否使用过 CoreText 或者 CoreImage 等?如果使用过，请谈谈你使用 CoreText 或 者 CoreImage 的体验?
用过CoreText 是用于处理文字和字体的底层技术。 Quartz 能够直接处理字体( font )和字形 (glyphs )，将文字渲染到界面上， 它是基础库中唯一能够处理字形的模块。 因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz 。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。
coreImage 是 IOS5 中新加入的一个
用来对基于像素的图像进行操作与分析
有 48 种，而到了最新的 IOS6 Filter
这些 Filter 提供了各种各样的效果，并且还可以通过滤镜链将各种效果的 Filter 叠加起来， 形成强大的自定义效果，如果你对该效果很满意，还可以子类化滤镜

十一、 有网络链接的应用中 ,在取得数据后将 json 字符串通过框架转为 NSDictionary 或 NSArray, 很多人直接使用这些数据来更新 UI, 说说这样做的缺点 ,并给出解决办法 ?
(1 )在书写的时候有可能写错 Key 值或者数组角标;
(2 )扩展性不好 ,且不符合 MVC 思想;
(3 )会造成数据的重复下载 ,消耗用户的流量 ,降低用户体验;
(4 )如果没有网络或者网络堵塞 ,那么 UI 界面接受不到任何数据 ,显示不了任何内容 ,用户体
Objective-c 的框架，提供了强大高效的图像处理功能，
. iOS 提供了很多强大的滤镜 (Filter) ，其中 IOS5 中
已经增加到了 93 种之多，并且这一数字会继续增加。

验糟糕。 解决的办法:
(1 )通过框架转换为字典或者数组后 中取 ;
(2 )利用框架字典转模型重写命名
,在转化模型 ,并进行二级缓存
,需要显示的时候从沙盒
十二、 id 声明的对象有什么特征 ?
(1 )id 声明的对象具有运行时的特性
void* 的万能指针相似 .
(2 )在编译阶段不知道它的真实类型 用点语法是编译时特性 ,而且 id 是运行时特性
十三、你碰到那些导致程序闪退的原因 1 、程序闪退的原因 ?
,即可用指向任意类型的 Objcetive-c
的对象
,与 C 中
,运行时才能知道它的真实类型
?如何定位闪退的位置 ?
,所以 id
类型也不能使
(1 )函数无线递归
(2)运行时 ,找不到方法 (没实现 )
(3 )访问了某个已经被释放的对象
(4)程序占用内存或 CPU 过高
(5)子线程阻塞主 UI 线程过久
(6 )从 Bundle 加载了不存在或者不支持的对象
2 、如何定位闪退的位置 ?
(1 )在设置断点的地方 ,选 Add Exception Breakpoint. 之后 crash 就会停在出错的位置 . (2)如果是在测试阶段报错的话 ,可以在 (设置 - 通用 -关于本机 -诊断与用量 )里面看到崩 溃的堆栈信息 .
(3 )如果用 RAC 的话 ,访问到已经释放了的内存 ,和内存警告这
十四、 如何实现圆角矩形 ?有哪些方法可以实现扇形 View? 直接修改 view 的样式，系统提供好的了 view.layer.cornerRadius = 6;
view.layer.masksToBounds = YES;
用 layer 做就可以了 , 十分简单 . 需要库 QuartzCore.framework 画矩形直接利用 UIBezierPath 给我们封装好的路径方法
(x,y) 点决定了矩形左上角的点在哪个位置
2 种粗出错的几率高一些
;

(width,height) 是矩形的宽度高度 bezierPathWithOvalInRect:CGRectMake(x, y, width, height)
[UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 50, 100, 100)]; 圆角矩形的画法多了一个参数 ,cornerRadius
cornerRadius 它是矩形的圆角半径 .
通过圆角矩形可以画一个圆 .当矩形是正方形的时候 ,把圆角半径设为宽度的一半 ,就是一个 圆。
UIBezierPath*path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50,50,100,100) cornerRadius:50]; 扇形 :
画扇形的方法为 : 先画一个圆孤再添加一个一根线到圆心 ,然后关闭路径 . 关闭路径就会自动从路径的终点到路径的起点封闭起下
用填充的话 ,它会默认做一个封闭路径 ,从路径的终点到起点 .
[path fill];
十五、 Cocoa Touch 提供了哪几种 CoreAnimation 过渡类型 ?
Cocoa Touch 提供了 4 中 Core Animation 分别是交叉淡化 推挤 显示和覆盖 .
十六、 能否向编译后得到的类中增加实例变量 ?能否向运行时创建的类中添加实例变量 ,为什 么?
不能向编译后得到的类中增加实例变量
因为编译后的类以及注册在 runtime 中 ,类结构同中 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定
同时 runtime 会调用 class_setlvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量 能向运行时创建的的类添加实例变量运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。
十七、 请写出你调试解决 crash 问题的思路及步骤 ?1 )把问题拆分成多个小问题，一步步 检验，直到找到问题的根源点
2 )程序运行后，查看 log 信息，找到错误的地方
3 )在错误的地方设置断点进行调试，可以加条件断点

4 )查看断点运行的信息，进行修改
5) 如果是在测试阶段报错的话，可以在(设置 - 通用 - 关于本机
的堆栈信息。
6) 如果用 rac 的话，访问到已经释放了的内存，和内存警告这
十八、 NSDictionary 类使用了哪些数据结构和算法 ? NSDictionary 使用 Hash 表实现 Key / Object 存储 ;
- 诊断与用量)里面看到崩溃
2 种出错几率要高些。
Hash 表是一种访问速度很快的数据结构，前提是 Hash 函数设计合理，能够使数据在各个 子节点均匀分布，这一点使用 NSString 对象可以保证，这是文档中的说明:
Classes such as NSString that are part of Foundation have a good hash function.
十九、 iOS 和 iPhone 做了哪些设计来降低功耗 ,延长续航时间 ?作为应用的开发者 ,又如何 避免费电 ?
1、iOS 的省电机制主要有以下几种:
(1 )强化的后台机制
(2 )墓碑式:伪多任务，应用推至后台后，虽然没有被关闭，但是所有活动都被冻结，只 能通过苹果服务器转发的推送来与用户交互
(3 )智能调度后台:在一些指定类别的 APP ，比如社交、新闻类的应 用中， iOS 系统会 根据应用启动频率、 时间和当前网络和电量的状况来智能分配每个应用的后台数据获取频率 和启动时长，开发者自己不能设置数据具体什么时候更新
(4 )真后台:苹果也提供一些有诸多限制的接口来保证真后台，只供特定应用行为调用， 比如后台音频，定位，上传下载等。
2 、作为开发者如何省电
(1 )首先当然优化代码，积极合理地使用 runloop ，多线程等技术。
(2 )其次是尽量少地调用一些费电的接口，比如频繁的定位，频繁的后台更新数据，如无 必要，尽量不用。



2.XML有哪几种解析方式，他们各有什么优点?
有Sax和Dom两种解析方式， sax是逐行解析。 dom是一次性全部加载 xml文件，然后解析
3. 本地储存方式有哪些
数据库， NSUserDefaults,File,Plist,Archieve
NSUserDefaults :储存比较小的数据，用户信息，配置信息 数据库:适合存储一条条的数据，存储大的数据。
File: 一般普通文件，图片，视频，音频等
Plist: 存放比NSUserDefaults 大一些的数据、 归档:可以存储一些对象，
4. 什么是通知中心? 通知中心是多对多的平等的通讯模式。主要用在多个对象之间松耦合的通讯模式，对象和对
象之间通过通知的名字就可以关联通讯。

10.KVO and KVC?
答: kvc: 键 - 值编码是一种间接访问对象的属性，使用字符串来标识属性，而不
是通过调用存取方法，直接或通过实例变量访问的机制。? 很多情况下可以简化程 序代码。 apple 文档其实给了一个很好的例子。?kvo:键值观察机制，他提供了观察
某一属性变化的方法，极大的简化了代码。? 具 体用看到用到过的一个地方是对于 按钮点击变化状态的的监控。
11.Object -c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式用 继承好还是分类好?为什么?
答:Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的 方式来实现，

12.AFI 和 AFN?
ASI 已经停止更新 AFN 持续更新中 , 目前已更新至 2.0 版
ASI操作对象是ASIHTTPReques，t是一个实现了了NSCopying协议的NSOperation子类。

AFN的直接操作对象 AFHTTPClient，是一个实现了 NSCoding和 NSCopying协议的 NSObject 子类。
13.SDWebImage如何实现图片缓存，
首先对图片进行下载由 SDImagerCache这个类检查内存中是否有图片缓存，如果有图片 缓存，回调Block将图片传递给SDWebImageMange类r，回调block将图片数据传递给 UIImageView+WebCache显示图片。如果没有就去请求网络下载
14.XML
os 中已有的 NSXMLParse 类,NSXMLParser 实现的是 sax 方法解析 xml 文件。

15. 什么是委托代理?
委托代理是 2 个对象之间的一种通讯方式，委托方 使用协议，声明自己的代理，代理方遵 守协议实现协议里的方法，类似于 blocks 等语法，目的是为了使软件设计低耦合便于维护
16. 通知中心 通知中心是多对多的平等的通讯模式，主要在多个对象之间松耦合的通讯模式。对象和对象 之间通过通知的名字就可以进行关联通讯。
17.KVC是路径访问的规范、 KVC是键值编码，即是指 NSKeyValueCoding，一个非正式的 Protocol ，提供一种机制来间接访问对象的属性。 ,它是一种使用字符串标识符，间接访问 对象属性的机制， KVO就是基于 KVC 实现的关键技术之一。
18.KVO, 即:Key-Value Observing ，它提供一种机制，当指定的对象的属性被修改后， 则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后， KVO就会 自动通知相应的观察者了。
19.http 协议 get post 的区别 POST是安全的 ,GET是不安全的。
GET 请求地址和参数全放在请求头中 ,POST请求地址和请求参数分离，地址放在请求头中， 参数拼接放入请求体。

GET和POST都是和服务器提交参数 / 通讯的一种方式。 GET参数不能太长 <1024B POST 没 有限制 <4G
GET不能上传文件 , POST可以上传文件。
20. 如何避免在 Block 里用 self 造成循环引用
分类: iOS 开发 Swift 开发 2014-07-29 18:59 3852 人阅读评论 (0) 收藏举报 iOSObjCSwift
一般来说我们总会在设置 Block 之后，在合适的时间回调 Block ，而不希望回调 Block 的时 候 Block 已经被释放了，所以我们需要对 Block 进行 copy，copy 到堆中，以便后用。
当一个 Block 被 Copy 的时候，如果你在 Block 里进行了一些调用，那么将会有一个强引用 指向这些调用方法的调用者，有两个规则: 如果你是通过引用来访问一个实例变量，那么将强引用至 self 如果你是通过值来访问一个实例变量，那么将直接强引用至这个“值”变量 苹果官方文档里有两个例子来说明这两种情况:
上面第一种情况相当于用 self.xxx 来访问实例变量，所以强引用指向了 self ;第二种情况 把实例变量变成了本地临时变量，强引用将直接指向这个本地的临时变量。大多数情况下，
我们只用处理第一种情况就行了，因为第二种情况虽然会造成循环引用，但是临时变量很快 就被释放了，不会造成真正的循环引用。要避免强引用到 self 的话，用 __weak把 self 重 新引用一下就行了，像这样:
__weakViewController *weakSelf = self;
21.block 实现原理?
block 是一个特殊的 OC对象 , 它建立在栈上 , 而不是堆上 , 这么做一个是为性能考虑 , 还有 就是方便访问局部变量。默认情况下 block 使用到的局部变量都会被复制 , 而不是保留。所 以它无法改变局部变量的值。如果在变量面前加上 __block, 那么编译器回去不会复制变量 , 而是去找变量的地址 , 通过地址来访问变量 , 实际上就是直接操作变量。另外 block 是在栈 上分配的 , 所以一旦离开作用域 , 就会释放 , 因此如果你要把快用在别的地方 , 必须要复制 一份。 block 是不能保留的 , retain 对块没有意义。
22.Object -c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式 用继承好还是分类好?为什么?
Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，
cocoa 中所有的类都是 NSObject 的子类，多继承在这里是用 protocol 委托代理 来实现的。
23. 多线程? NSThread:
优点: NSThread 比其他两个轻量级

缺点:需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开 销
Cocoa operation
优点:不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。
Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation 是个抽象 类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类:
NSInvocationOperation 和 NSBlockOperation 。创建 NSOperation 子类的对象，把对象添 加到 NSOperationQueue队列里执行。
GCD
Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的解决方法。在 iOS4.0 开始 之后才能使用。 GCD是一个替代诸如 NSThread, NSOperationQueue,
NSInvocationOperation 等技术的很高效和强大的技术。现在的 IOS 系统都升级到 6 了，所 以不用担心该技术不能使用。
24.APNS
第一阶段: net 应用程序把要发送的消息，目的 iPhone 打包，发给 APNS. 第二阶段: APNS在自身已注册的 Push 服务的 iPhone 列表中查找相应标识的 iPhone ，并把消息发送到 iPhone.
第三阶段: iPhone 把发来的消息传递给相应的应用程序，并按照设定弹出 push 通知
】 }}}}}}}}}}}}}
25. 图片轮番滚动?
我告诉你思路:比如你有 3 张图片，那么在 scrollView 上加 5 个 imageView，第一个放最 后一张图片，最后一个放第一张图片，中间三个依次放这三张图片，初始化时显示第二个 imageView，也就是第一张图片，这样，当用户浏览到最后一张图片，其实是你的第四个 imageview ，再次向后滑动，显示的是第一张图片，其实是第五个 imageView，当检测到偏 移量到第五个 imageView 的时候，你把 scrollView 滚动到第二个 imageView 的地方，并且 不要动画效果，这样从视觉上没有任何变化，其实你已经偷偷的回到了第一张图片的位置， 倒着翻道理一样。这样的效果就是，无论用户正着翻还是倒着翻，都是可以循环显示图片。
26. 属性 readwrite ，readonly ，assign ，retain ，copy，nonatomic 各是什么 作用，在那种情况下用?

 答: readwrite 是可读可写特性;需要生成 getter 方法和 setter 方法时
readonly 是只读特性 只会生成 getter 方法 不会生成 setter 方法 ; 不希望属性在类外改 变
assign 是赋值特性， setter 方法将传入参数赋值给实例变量;仅设置变量时;
retain 表示持有特性， setter 方法将传入参数先保留，再赋值，传入参数的 retaincount 会 +1;
copy 表示赋值特性， setter 方法将传入对象复制一份;需要完全一份新的变量时。
nonatomic 非原子操作，决定编译器生成的 多线程安全，一般使用 nonatomic

28. 内存泄露?
1、运行 Demo 直接找到 Crash 的地方
setter getter
是否是原子操作， atomic 表示
2、设置 NSZombieEnabled
这是一个 “EXC_BAD_ACCE”SS 错误。我们打开 XCode 的选项: “NSZombieEnabled” 。在 crash 时可
能会给你更多的一些提示信息。
3，分析内存泄露 (shift+command+b)
app 不 crash 了，那看看有没有内存泄露。用 XCode 的 Analyze 就能分析到哪里有内存泄露
4、使用 Instruments 的leaks 工具
分析内存泄露不能把所有的内存泄露查出来，有的内存泄露是在运行时，用户操作时才产生的。那就需 要用到 Instruments 了。

2. 断点续传(了解原理)
要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来 打开文件。该函数取回一个顺序号，即文件句柄( file handle )，该文件句柄对于打开的文件是唯一的识 别依据在程序设计中，句柄是一种特殊的智能指针。当一个应用程序要引用其他系统(如数据库、操作 系统)所管理的内存块或对象时，就要使用句柄。句柄与普通指针的区别在于，指针包含的是引用对象
finished))completion
操作的函数执行部分

 的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这 种间接访问对象的模式增强了系统对引用对象的控制。下载文件时，我们首先要为文件找一个容纳的内
存空间。创建文件的句柄。在请求过程中，我们请求的大小是不断增加的，下载文件只不过是连续性请 求数据，我们可以把文件指针始终指向请求下来的文件的结束，设置每次的请求范围即每次求数据的大 小。每次我们通过文件指针指向文件结束可以记录出文件请求文件的大小。可以知道当前文件的下载进 度。当文件的大小等于请求文件的大小时，说明下载已经完成，当我们中途暂停下载时，我们可以记录 当前本次下载文件的大小，和文件指针指向的结尾位置空间。如果再点击下载时，我们可以从指针指向 的位置开始，根据当文件的已经下载大小，从网络中接着上次下载请求的位置，继续请求下载数据。
3. 数据请求策略下载管理类(了解原理)
就是当我们每个页面都有很多的数据请求时，当我们需要跳转的页面需要用到前边页面请求回来的数据
时，例如 TableView , 点击 cell 跳转到详情，需要向详情页面传一个新闻详情的 ID 然后下一页面需要拼 接这个 iD 进行详情数据的请求，或者需要传输其他的参数。但是当前我们用属性传递，或者其他方法传 输时，其原理都是用指针指向下一页面的一个属性变量空间，然后把值传过去。但是很多时候，网速条 件不好，当我们 TabLeView 页面时，数据还没请求完，就点击 cell 跳转到详情，然后接着有返回到 TableView 的页面这时候当我们用指针指向下一页面的属性变量时，还没来得及获取下一页面的指针空 间，下一页面就释放掉了。所以指针变成了野指针。就会出现崩溃，这种崩溃你很难找到问题。 境下是将我们的变量在适当的时候自动释放，但是这个适当的时候是不确定的，所有有时候就会处理不 了，就会崩溃。所以一般我们的请求不写在每一个页面里，这样不好管理，所以一般都要封装下载类， 和下载管理类。这样我们可以把每次请求都统一交给下载管理类管理。当我们请求未完成，页面返回销 毁时，我们就把他的请求的对象置为 nil
4. 清除缓存 ( 了解原理 )
我们我们软件很多的设置里边会有，缓存大小，和清除缓存的功能，计算缓存大小:如果我们的软件用 了缓存机制，缓存的文件数据会储存在沙河目录下的 Cache 的文件夹里，我们可以用系统的文件管理 NSFileManager 这个单例，深层便利文件缓存路径 Library/Caches 文件夹下的所有文件，一切的文件类 型，然后累计相加计算出缓存字节的大小。然后进行缓存大小的显示。清除缓存数据:可以用系统的文
件管理 NSFileManager 这个单例，对缓存区 Library/Caches 文件夹下的所有文件，进行浅层便利，浅层 便利就是只便利 Caches 这一层下的文件和文件夹，然后进行删除。
5.Http (了解)
http 是一个基于请求与响应模式的，无状态，应用层的协议，基于
1， 支持客户端 /服务器模式
2， 简单快捷:客户端向服务器请求时只需传送请求方式和路径，有
TCP 的连接方式，
GET/POST 每种方式规定了与服务
器连接的类型不同，因为简单通讯速度快。
3， 灵活: HTTP 允许传输任意类型的数据对象，
4， 无连接:限制每次连接只处理一个请求，处理完客户端请求，收到客户端应答，即断开连接，
5， 无状态:协议对事务处理没有记忆能力、
6. 说说 Objective-C, 有哪些优点哪些不足(两三点即可)? 1) Cateogies
2) Posing
3) 动态识别
4) 指标计算
ARC 环

 5)弹性讯息传递
6) 不是一个过度复杂的 C 衍生语言
7) Objective-C 与 C++ 可混合编程 不足 :
1) 不支援命名空间
2) 不支持运算符重载
3)不支持多重继承 4)使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。(如内联函数 等)，性能低劣。
7. 瀑布流怎么理解和实现的
1. 如果简单的来说 , 用 3 个 tableview 就可以实现瀑布流 ,3 个
tableview 实现联动滚动。
2. 其实最好的做法在 scrollview 上使用 3 个复用队列 ,如果一种一个 cell 超过屏幕 ,不能 release, 而是把它 回收到复用队列中 , 如果要创建一个 cell, 首先从复用队列中取一个 , 然后使用。
8. 做过的项目是否涉及网络访问功能，使用什么对象完成网络功能? 答案: ASIHTTPRequest 与 NSURLConnection
9. 写出上面代码的 Block 的定义。
答案:
typedef void(^animations) (void);
typedef void(^completion) (BOOL finished);
10.谈谈对 Block 的理解?并写出一个使用
Block 执行 UIVew 动画?
答案: Block 是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以效率(多核心 CPU 可直接处理 Block 指令)大幅提高应用的执行
[cpp]
view plaincopyprint?
1. 2. 3.
4.
[UIView transitionWithView:self.view duration:0.2
options:UIViewAnimationOptionTransitionFl
ipFromLeft
animations:^{ [[blueViewController view] rem
oveFromSuperview]; [[self view] insertSubview:yellowViewCont roller.view atIndex:0]; }

 5. completion:NULL];
11.What kind of persistence store we can use with coredata?
coredata 有哪几种持久化存储机制?
答案: coredatat 提供以下几种存储机制: XML (iOS 系统不支持) ,自动存储 ,SQLite, 内存存储。
补充说明:这个问题问的是， coredate 框架的存储机制，平时使用 coredata 时，更多关注的是 managed 的对象，这里是 coerdata 框架的存储实现细节。 BTW: 其他常用的持久化存储方法:存入到文
件、 存入到 NSUserDefaults (系统 plist 文件中)。
12.What is predicate?
什么是谓词?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。
predicate = [NSPredicatepredicateWithFormat:@"customerID == %d",n];
a = [customers filteredArrayUsingPredicate:predicate];


在应用中可以创建多少 autorelease 对象，是否有限制? 答案:无
16.If we don ’t create any autorelease pool in our application then is there any autorelease pool already provided to us?
如果我们不创建内存池，是否有内存池提供给我们?
答案 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
17.When you will create an autorelease pool in your application?
什么时候需要在程序中创建内存池? 答案:用户自己创建的数据线程，则需要创建该线程的内存池 18.When retain count increase? 什么时候内存计数会增加?
答案:见 iOS 面试题(一)
19.What are commonly used NSObject class methods?
类 NSObject 的那些方法经常被使用?

 答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。
其中类方法 alloc 、 class 、 description 对象方法 init 、 dealloc 、 –performSelector:withObject:afterDelay:
等经常被使用
20.What is convenience constructor?
什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber
的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithI nt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象， 并且不需要手动释放。


UIView 的动画效果有那些? 答案:有很多，
xib 文件设计时，其设置其为
如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimatio nOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTrans itionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDo wn


24.How can you store data in iPhone applications? 在 iPhone 应用中如何保存数据? 答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中 3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.What is coredata?
25. 什么是 coredata ?
答案: coredata 框架是 apple 提供的一套通用自动的解决方案，包括了对象生存周期、对象关系图、持 久化机制。
补充答案:上面是翻译的，按我个人理解 coredata 提供一种一机制，让我们可以方便的把内存中对象， 及对象间的关系，映射到 coredata ，然后由它为我们持久化数据。相比普通的文件数据库 SQlite ，它的 功能更强大，不需要我们先将对象数据 format 成 SQL 语句，存入数据库，再用 select 语句读出，而现在 是从内存到 coredata 的数据管理，我们只需管理 coredata 的 managed 对象。
是苹果提供一套数据保存
26.What is NSManagedObject model? 什么是 NSManagedObject模型?
答案: NSManagedObject 是 NSObject 的子类，也是 coredata 的重要组成部分，它是一个通用的类 ,实 现了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。
15.What is NSManagedobjectContext?
什么是 NSManagedobjectContext?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。


委托是什么？委托和委托方双方的property声明用什么属性？为什么？
委托：一个对象保存另外一个对象的引用，被引用的对象实现了事先确定的协议，该协议用于将引用对象中的变化通知给被引用对象。
委托和委托方双方的property声明属性都是assign而不是retain
为了避免循环引用造成的内存泄露。
      循环引用的问题这样理解：
    比如在main函数中创建了两个类的对象A和B，现在引用计数都是1。现在让A和B互相引用(A有一个属性是B对象，属性说明是retain；B有一个属性是A对象，属性说明是retain)，现在两个对象的引用计数都增加了1，都变成了2。
  现在执行[A release]; [B release]; 此时创建对象的main函数已经释放了自己对对象的所有权，但是此时A和B的引用计数都还是1，因为他们互相引用了。
  这时你发现A和B将无法释放，因为要想释放A必须先释放B，在B的dealloc方法中再释放A。同理，要想释放B必须先释放A，在A的dealloc方法中再释放B。所以这两个对象将一直存在在内存中而不释放。这就是所谓的循环引用的问题。要想解决这个问题，一般的方法可以将引用的属性设置为assign,而不是retain来处理。
4、延展是什么？作用是什么？
答：延展（extension）:在自己类的实现文件中添加类目来声明私有方法。
延展（Extension）“匿名”的类目，延展定义类的私有方法，一般是在类的实现文件@implementation之上定义如：Person（） 和类目的区别在于括号里面是空的，没有名字的，暂时性的存在，只能本类调用方法，子类也无法调用父类的延展
另外在本类的实现文件@implementation之上也可以定义私有方法，私有的静态变量
延展的特点就是定义私有方法
9、内存管理的几条原则是什么？按照默认法则，哪些关键字生成的对象需要手动释放？哪些情况下不需要手动释放，会直接进入自动释放池？
•       当使用new、alloc或copy方法创建一个对象时，该对象引用计数器为1。如果不需要使用该对象，可以向其发送release或autorelease消息，在其使用完毕时被销毁。
•       如果通过其他方法获取一个对象，则可以假设这个对象引用计数为1，并且被设置为autorelease，不需要对该对象进行清理，如果确实需要retain这个对象，则需要使用完毕后release。
•       如果retain了某个对象，需要release或autorelease该对象，保持retain方法和release方法使用次数相等。
 
使用new、alloc、copy关键字生成的对象和retain了的对象需要手动释放。设置为autorelease的对象不需要手动释放，会直接进入自动释放池。
 
10、怎样实现一个单例模式的类，给出思路，不写代码。
•       首先必须创建一个全局实例，通常存放在一个全局变量中,此全局变量设置为nil
•       提供工厂方法对该全局实例进行访问，检查该变量是否为nil，如果nil就创建一个新的实例，最后返回全局实例
•       全局变量的初始化在第一次调用工厂方法时会在+allocWithZone:中进行，所以需要重写该方法，防止通过标准的alloc方式创建新的实例
•       为了防止通过copy方法得到新的实例，需要实现-copyWithZone方法
•       只需在此方法中返回本身对象即可，引用计数也不需要进行改变，因为单例模式下的对象是不允许销毁的，所以也就不用保留
•       因为全局实例不允许释放，所以retain,release,autorelease方法均需重写

12、KVC是什么?KVO是什么?有什么特点？
KVC是键值编码，特点是通过指定表示要访问的属性名字的字符串标识符，可以进行类的属性读取和设置
KVO是键值观察，特点是利用键值观察可以注册成为一个对象的观察者，在该对象的某个属性变化时收到通知

16.id 声明的对象有什么特性？
答：Id声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象；

27、struct strA {
   int a;
   float b;
   char c;
 } expA;
   printf("%ld",sizeof(expA));     输出结果为  12  ？
该问题涉及编译器的“内存对齐”问题：
现代计算机中内存空间都是按照byte（字节）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况， 但是最常见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低 字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。
通常，我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法。
但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是struct数据结构的sizeof结果，出乎意料。
       对于结构体来说，按成员中所占字节最大的是float类型，占用4个字节，一共有3个成员，所以总的占用字节为：4＊ 3 ＝ 12.
       可通过编译器命令来设定：
      #progma pack (2)
  
29、OSI（Open System Interconnection）开放式系统互联参考模型 把网络协议从逻辑上分为了7层，试列举常见的应用层协议。
       注意问的是应用层协议，有些同学直接答了七层模型。
       在开放系统互连(OSI)模型中的最高层，为应用程序提供服务以保证通信，但不是进行通信的应用程序本身。
Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
FTP文件传输协议是TCP/IP网络上两台计算机传送文件的协议，FTP是在TCP/IP网络和INTERNET上最早使用的协议之一，它属于网络协议组的应用层。
 
超 文本传输协议 (HTTP-Hypertext transfer protocol) 是 分布式，协作式，超媒体系统应用之间的通信协议。是万维网（world wide web）交换信息 的基础。
SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式，它帮助每台计算机在发送或中转信件时找到下一个目的地。
时间协议(TIME protocol)是一个在RFC 868内定义的网络协议。它用作提供机器可读的日期时间资讯。
DNS 是 域名系统 (Domain Name System) 的缩写 ，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射 的一个分布式数据库。
SNMP(Simple Network Management Protocol ,简单网络管理协议 )的前身是简单网关监控协议(SGMP)，用来对通信 线路进行管理。
TFTP（Trivial FileTransfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。
 
30、网络传输层协议中，基于TCP/IP协议和UDP/IP的连接有什么区别？
TCP：TransmissionControl Protocol 传输控制协议TCP是一种面向连接 （连接导向）的、可靠的、基于字节流的运输层（Transport layer）通信协议， 由IETF的RFC 793说明（specified）。
UDP 是User Datagram Protocol的简称， 中文名是用户数据包协议，是OSI 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。
 
面向连接：是指通信双方在通信时，要事先建立一条通信线路，其有三个过程：建立连接、使用连接和释放连接。电话系统是一个面向连接的模式，拨号、通话、挂机；TCP协议就是一种面向连接的协议。
面向无连接：是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输。邮政系统是一个无连接的模式，天罗地网式的选择路线，天女散花式的传播形式；IP、UDP协议就是一种无连接协议。
 

33、iOS中有哪些回调机制，并作简单的比较。
各种回调机制的比较：
1）目标动作对：当两个对象之间有比较紧密的关系时，如视图控制器与其下的某个视图。
2）代理：也叫委托，当某个对象收到多个事件，并要求同一个对象来处理所有事件时。委托机制依赖于某个协议定义的方法来发送消息。
3）通告机制：当需要多个对象或两个无关对象处理同一个事件时。
4）Block：适用于回调只发生一次的简单任务。

34、列出在编码中哪些编码习惯有助于提高代码质量、软件性能和健壮性，减少程序崩溃。
＃使用严格的命名规则（如匈牙利命名法）能够避免不必要的类型转换错误。
＃在编码前先设计好流程图或使用伪代码，清晰化整个设计意图。
＃对自己的代码进行严格的单元测试（unit testing）。
单元测试是指对软件中的最小可测试单元进行检查和验证。如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。
＃异常的处理
首先不要轻易使用异常的捕获，其次要尽可能捕获具体的异常。对于异常的处理最好能够采用封装的方式，大家统一使用。这样可以保证异常处理的一致性也可以保证当异常出现时性能的稳定。
# 使用内省的方法检查方法的输入
＃采用增量式的编程方式。
采用增量式编程和测试，会倾向于创建更小的方法和更具内聚性的类。你应该经常评估代码质量，并不时的进行许多小调整，而不是一次修改许多东西。在写了几行代码之后，就应该进行一次构建/测试。在没有得到反馈时，你不要走的太远。
 
＃使用工具（如Instrument）来帮助检查内存泄漏、过早释放内存、CPU使用效率等问题。
＃消除所有的编译警告，警告就是错误。
＃写防御性的代码，使用内省的方法检查传入的参数。
 
35、JSON中{ }代表_____，[ ]代表_____，试将下面的JSON串用OC对象表示出来：
{ "people": [
{ "firstName": "Brett","lastName":"McLaughlin", "email":"aaaa" },
{ "firstName": "Jason","lastName":"Hunter", "email": "bbbb"},
{ "firstName": "Elliotte","lastName":"Harold", "email": "cccc" }
]，
 “location”:”中华人民共和国”
}
 
JSON中{ }代表对象，数据结构为｛key1:value1, key2:value2, key3:…… ｝
[ ]代表数组，与其他语言中的数组类似。
//
@interface People: NSObject
 
@property(nonatomic, copy) NSString* strFirstName;
@property(nonatomic, copy) NSString* strLastName;
@property(nonatomic, copy) NSString* strEmail;
 
@end
 
//
@interfaceJSonData : NSObject
 
@property(nonatomic, retain) NSMutableArray* arrPeople;  // 存放People对象
@property(nonatomic, copy) NSString* strLocation;
 
@end

37．object-C有私有方法吗？私有变量呢？
objective-c – 类里面的方法只有两种, 静态方法和实例方法.
在类里面声名一个私有方法 @interface Controller : NSObject
{ NSString *something;
} + (void)thisIsAStaticMethod; –(void)thisIsAnInstanceMethod; @end @interface Controller
(private)
-(void)thisIsAPrivateMethod; @end
@private可以用来修饰私有变量 在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的
 
38.  堆和栈的区别？
管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
申请大小：栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域
     堆：是向高地址扩展的数据结构，是不连续的内存区域。
分配方式：堆都是动态分配的 ，动态分配由alloca函数进行分配
     栈的动态分配由编译器进行释放，无需我们手工实现
39. kvc和kvo的区别？
kvc：键值编码，是一种间接访问对象的属性，使用字符串来标示属性
kvo：键值观察机制，提供了观察某一属性变化的方法
  
42. 类别的作用？
答：有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。可以使用类别对该类扩充新的方法。
注意：类别只能扩充方法，而不能扩充成员变量。
代理的作用
委托代理（degegate），目的是改变和传递控制链
    顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。
委托机制是一种设计模式。
多态：子类的指针可以赋值给父类
 
43．链表和数组的区别在哪里?
二者都属于一种数据结构
从逻辑结构来看
1. 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。
2. 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素
从内存存储来看
1. (静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小
2. 链表从堆中分配空间, 自由度大但是申请管理比较麻烦

从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反， 如果需要经常插入和删除元素就需要用链表数据结构了。
 
 
44. main()
 { int a[5]={1,2,3,4,5};
   int *ptr=(int *)(&a+1);
  printf("%d,%d",*(a+1),*(ptr-1));
}
答：2,5   *(a+1)就是a[1]，*(ptr-1)就是a[4],执行结果是2，5
&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
    int *ptr=(int *)(&a+1);则ptr实际是&(a[5]),也就是a+5
原因如下：&a是数组指针，其类型为 int (*)[5];
   而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。
   a是长度为5的int数组指针，所以要加 5*sizeof(int)，所以ptr实际是a[5]，
   但是prt与(&a+1)类型是不一样的(这点很重要)，所以prt-1只会减去sizeof(int*)
   a,&a的地址是一样的，但意思不一样
   a是数组首地址, 也就是a[0]的地址，&a是对象（数组）首地址，         a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].
 
45. 写一个委托的interface
@protocol MyDelegate;
@interface MyClass: NSObject
{
 id < MyDelegate > delegate; }
//委托方法@protocol MyDelegate- (void)didJobs:(NSArray *)args;
@end
 
46. 写一个NSString类的实现
+(id)initWithCString:(const char *)nullTerminatedCStringencoding:(NSStringEncoding)encoding;
+ (id)stringWithCString: (const char*)nullTerminatedCString             encoding: (NSStringEncoding)encoding
 {   NSString *obj;
     obj = [selfallocWithZone: NSDefaultMallocZone()];
     obj = [objinitWithCString: nullTerminatedCString encoding: encoding];
     returnAUTORELEASE(obj);
}
 
47. 关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用
const意味着"只读"，下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。
结论：·;关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果 你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清 理的。）  ·; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。  ·; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
（1）欲阻止一个变量被改变，可以使用 const 关键字。在定义该 const 变量时，通常需要对它进行初 始化，因为以后就没有机会再去改变它了；（2）对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指 定为 const；
（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； （4）对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量； （5）对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。
关键字volatile有什么含意?并给出三个不同的例子。一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
· ;并行设备的硬件寄存器（如：状态寄存器）
· ; 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
· ; 多线程应用中被几个任务共享的变量
· ;一个参数既可以是const还可以是volatile吗？解释为什么。
· ; 一个指针可以是volatile 吗？解释为什么。
下面是答案：
· ; 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
·; 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
static关键字的作用：
（1）函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
（2）在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
（3）在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内；
（4）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
（5）在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。
 
extern "C"的作用：
（1）被 extern "C"限定的函数或变量是 extern 类型的；
extern是 C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
（2）被 extern "C"修饰的变量和函数是按照 C 语言方式编译和连接的；
 
extern "C"的惯用法
（1）在 C++中引用 C 语言中的函数和变量，在包含 C 语言头文件（假设为 cExample.h）时，需进 行下列处理：
 extern "C"  { #include "cExample.h"   }
而在 C语言的头文件中，对其外部函数只能指定为 extern 类型，C语言中不支持 extern "C"声明， 在.c 文件中包含了 extern "C"时会出现编译语法错误。
（2）在 C 中引用 C++语言中的函数和变量时，C++的头文件需添加 extern "C"，但是在 C 语言中不 能直接引用声明了 extern "C"的该头文件，应该仅将 C 文件中将 C++中定义的extern "C"函数声明为 extern 类型。
 

  

 
55. cocoa touch框架
这些框架包括：
Core Animation
通过Core Animation，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。
Core Audio
Core Audio是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添加强大的音频功能。
Core Data提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任何应用或大或小的数据模型。
   功能列表：框架分类
   下面是 Cocoa Touch 中一小部分可用的框架：
     音频和视频
       CoreAudio
       OpenAL
       MediaLibrary
       AVFoundation
     数据管理
       Core Data
       SQLite
     图形和动画
       CoreAnimation
       OpenGL ES
       Quartz 2D
      网络/li>
        Bonjour
        WebKit
        BSDSockets
      用户应用
        AddressBook
        CoreLocation
        MapKit
        StoreKit
 
56.objc的内存管理
答：如果您通过分配和初始化（比如[[MyClass alloc] init]）的方式来创建对象，您就拥有这个对象，需要负责该对象的释放。这个规则在使用NSObject的便利方法new 时也同样适用。
如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放。如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。反过来，如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它（这个规则有少数的例外，在参考文档中有显式的说明）。
 
57.自动释放池是什么,如何工作？
答：当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。
1）ojc-c是通过一种"referring counting"(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁.
2） NSAutoreleasePool就是用来做引用计数的管理工作的,这个东西一般不用你管的.
3）autorelease 和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一。
 
 
61.obj-c的优缺点objc
优点：
1) Cateogies   2) Posing   3) 动态识别   4) 指标计算   5）弹性讯息传递   6) 不是一个过度复杂的 C 衍生语言   7) Objective-C 与 C++ 可混合编程
缺点:
1) 不支援命名空间   2)  不支持运算符重载  3） 不支持多重继承  4） 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。
 
62.sprintf,strcpy,memcpy使用上有什么要注意的地方？
答：strcpy是一个字符串拷贝的函数，它的函数原型为strcpy(char *dst, const char *src);将src开始的一段字符串拷贝到dst开始的内存中去，结束的标志符号为'\0'，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。
具备字符串拷贝功能的函数有memcpy，这是一个内存拷贝函数，它的函数原型为memcpy(char *dst,const char* src, unsigned int len);将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存叠加的问题。
sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。

一、自我介绍；（稍微写一下，1、突出自己技术方面的优势，突出自己有开发ios的经验，围绕着岗位，突出自身在ios中开发层面的经验和优势；
2、性格优势，学习能力比较强，自身优势，夸自己没有不好意思，责任，学习能力）

二、面试题
1、协议：相当于一个方法列表，多个类可以共享的方法的列表
 代理：它是一个设计模式，本质就是两个对象之间的调用  id的范型



3、内存管理
arc  和 mrc， xcode5.0后都是自动的
arc原理和自动释放池原理，retain,copy,assgin，一个完整操作都会有一个自动释放池
weak不能修饰基本数据类型，只能修饰对象（assgin  和 weak 类似，但上面有两个不同，weak修饰的对象销毁后，会自动置空 ,所以更安全）
-fno-objc-arc   /  fobjc-arc
问题：arc 中批量创建对象，无法做到及时对象（for循环）
细节：xib 中的控件是weak修饰的，因为它们是添加到view上，防止强强引用
内存查的工具，真机的情况下，  instruments （专门的例子）

4、试图控制器的生面周期（view 的生命周期）（内存优化的意识）
内存告急的处理（手动释放不可见视图的内存和成员变量），将没有释放的，手动去释放
这样之后会重新调用loadView  viewDidLoad


6、多线程的东西
异步加载数据，相当于与应用多线程，UI主线程（分配的资源是最多的），分开了一段
什么场景的时候应用 多线程－－－－－－耗时操作（数据库中的读取，图片的处理（滤镜））

8、kvc  kvo （点语法是kvc的一种，一种特殊的kvc）
kvc ： 内部批量调用  数组的名称  setValueForUnder
kvo ： 对符合kvc进行键值观察


9、多线程 NSThread（系统的基本类）   NSOperation、 GCD（结合着block 去应用）
AFNetworking    code   2.0
效率： block  delegate  通知中心
block 是一个匿名函数，

10、为了防止多个线程同时来使用     ，线程锁、syscn...


11、FMDB 有一个线程安全，做了线程安全（FMDBQ）
sqlite3 事物：try-catch，能提高效率    ，增加        可以看一下啊
如果我们的app需要多线程操作数据库，那么就需要使用FMDatabaseQueue来保证线程安全了。切记不能在多个线程中共同一个FMDatabase对象并且在多个线程中同时使用，这个类本身不是线程安全的，这样使用会造成数据混乱等问题。
使用FMDatabaseQueue很简单，首先用一个数据库文件地址来初使化FMDatabaseQueue，然后就可以将一个闭包(block)传入inDatabase方法中。在闭包中操作数据库，而不直接参与FMDatabase的管理。

12、HTTP 协议，TCP,UDP
http： 请求头、相应头、请求体、相应体





 




8.Objective-C 如何对内存管理的
手动内存计数、内存池。
1. (Garbage Collection) 自动内存计数:这种方式和 java 类似，在你的程序的执
行过程中。始终有一个高人在背后准确地帮你收拾垃圾， 你不用考虑它什么时候开始工 作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成 为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那

 个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以 iPhone 不支持这 个功能。 所以“ Garbage Collection ”不是本入门指南的范围， 对“ Garbage Collection ” 内部机制感兴趣的同学可以参考一些其他的资料， 不过说老实话 “ Garbage Collection ” 不大适合适初学者研究。
解决 : 通过 alloc – initial 方式创建的 , 创建后引用计数 +1, 此后每 retain 一 次引用计数 +1, 那么在程序中做相应次数的 release 就好了 .
2. (Reference Counted) 手动内存计数:就是说，从一段内存被申请之后，就存在 一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为 0 的时候，那么就是释放这段内存的时候。比如说，当在程序 A 里面一段内存被成功申请 完成之后，那么这个计数器就从 0 变成 1( 我们把这个过程叫做 alloc) ，然后程序 B 也 需要使用这个内存， 那么计数器就从 1 变成了 2( 我们把这个过程叫做 retain) 。紧接着 程序 A 不再需要这段内存了，那么程序 A 就把这个计数器减 1( 我们把这个过程叫做 release); 程序 B也不再需要这段内存的时候，那么也把计数器减 1(这个过程还是 release) 。当系统 ( 也就是 Foundation) 发现这个计数器变成了 0，那么就会调用内存回 收程序把这段内存回收 ( 我们把这个过程叫做 dealloc) 。顺便提一句，如果没有 Foundation ，那么维护计数器，释放内存等等工作需要你手工来完成。
解决 : 一般是由类的静态方法创建的 , 函数名中不会出现 alloc 或 init 字样 , 如 [NSString string] 和 [NSArray arrayWithObject:], 创建后引用计数 +0, 在函数出栈 后释放, 即相当于一个栈上的局部变量 . 当然也可以通过 retain 延长对象的生存期 .
3. (NSAutoRealeasePool) 内存池:可以通过创建和释放内存池控制内存申请和回 收的时机 .
解决 : 是由 autorelease 加入系统内存池 , 内存池是可以嵌套的 , 每个内存池都需 要有一个创建释放对 , 就像 main 函数中写的一样 . 使用也很简单 , 比如 [[[NSString alloc]initialWithFormat:@ ”Hey you! ”] autorelease], 即将一个 NSString 对象加 入到最内层的系统内存池 , 当我们释放这个内存池时 , 其中的对象都会被释放 .


16. 类别的作用 ?继承和类别在实现中有何区别 ?
A 引用的对象同样 , 内存中存在了
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法， 只能添加，不能删除修改。
并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类 别具有更高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。

 (2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
17. 类别和类扩展的区别。
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方 法是必须要实现的。
extensions 可以认为是一个私有的 Category 。
18. oc 中的协议和 java 中的接口概念有何不同 ?
答案: OC中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者 和 Java 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果 有实现，就会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学 习教程里
“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的 方法，你可以使用他们更好的完成工作”。
这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样 的类别去实现。然后你在后期可以直接使用这些更好的方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。”
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 “非正式协议使用 interface 修饰“，
现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
19. 什么是 KVO和 KVC?
答案: kvc: 键 – 值编码是一种间接访问对象的属性使用字符串来标识属性， 而不 是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。 kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个 button
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object

 change:(NSDictionary *)change context:(void *)context {
if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
}
}
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的 道理是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
“当通过 KVC调用对象时，比如: [self valueForKey:@ ”someKey”] 时，程序会 自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方 法，如果没找到，会继续查找对象是否带有 someKey这个实例变量 (iVar) ，如果还没有 找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还 是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变 量，也会查找 _someKey这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从 对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多 好处，下面的两个例子说明了这样做的好处。“
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted add 一个相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
20. 代理的作用 ?
实例变量 . 因此为何上面我们只是
答案:代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。


 22. 我们说的 oc 是动态运行时语言是什么意思 ?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类
别对象指定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物
类 (life) 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物， 都继承了 life
我们只需调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息 因此也可以说，运行时机制是多态的基础 ?~~~
后，实现各自的 eat ，但是调用是 (响应了 eat 这个选择器 )。
23. 通知和协议的不同之处 ?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链 (专业术语了 ~)。但是简单分析下通知和
代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，
很多时候一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要
处理 A明星要一个发布会，代理人发出处理发布会的消息后，别称 B的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要
处理。
因此控制链 (has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
24. 是推送消息 ?
首先是应用程序注册消息推送。
IOS 跟 APNS Server 要 deviceToken 。应用程序接受 deviceToken 。 应用程序将 deviceToken 发送给 PUSH服务端程序。
服务端程序向 APNS服务发送消息。
APNS服务将消息发送给 iPhone 应用程序
25. 关于多态性 答案:多态，子类指针可以赋值给父类。

 这个题目其实可以出到一切面向对象语言中，
因此关于多态， 继承和封装基本最好都有个自我意识的理解，也并非一定要把书上 资料上写的能背出来。
最重要的是转化成自我理解。

30. OC 的垃圾回收机制 ?
答案: OC2.0 有 Garbage collection
一般我们了解的 objective-c 对于内存管理都是手动操作的， 但是也有自动释放池。 但是差了大部分资料，貌似不要和 arc 机制搞混就好了。
method 是一个组合体，包含了名字和实现 .
，但是 iOS 平台不提供。

 31. NSOperation queue?
答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多
线程开发的问题。
网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概念，放入的
操作并非是按照严格的先进现出。
这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc
紧跟着也进入队列， Afunc 先执行这个是必然的，
但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概念
离乱上有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作， 我们亦然可以感性认为这还是
一个队列。
但是后来看到一票关于这操作队列话题的文章，其中有一句提到 “因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。” 瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。



38. 如果我们不创建内存池，是否有内存池提供给我们 ?
答案 : 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线 程的内存池

 39. 什么时候需要在程序中创建内存池 ? 答案:用户自己创建的数据线程，则需要创建该线程的内存池
40. 类 NSObject 的那些方法经常被使用 ?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。 其中类方法 alloc 、 class 、 description 对象方法 init 、 dealloc 、–
performSelector:withObject:afterDelay: 等经常被使用
41. 什么是简便构造方法 ?
答案:简便构造方法一般由 CocoaTouch框架提供，如 NSNumbe的r + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法， 我们可以通过简便构造方法， 获得系统 给我们创建好的对象，并且不需要手动释放。

43. UIView 的动画效果有那些 ?
答案:有很多，如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDow n
44. 在 iPhone 应用中如何保存数据 ? 答案:有以下几种保存机制:
1. 通过 web服务，保存在服务器上
2. 通过 NSCoder固化机制，将对象保存在文件中 3. 通过 SQlite 或 CoreData 保存在文件数据库中

 45. 什么是 coredata?
答案: coredata 是苹果提供一套数据保存框架，其基于 SQlite
46. 什么是 NSManagedObject 模型 ?
答案: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成部分， 它 是一个通用的类 , 实现了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject，建立自己的数据模型。
47. 什么是 NSManagedobjectContext?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
48. 什么是谓词 ?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对数 据的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n]; a = [customers filteredArrayUsingPredicate:predicate];
49. 和 coredata 一起有哪几种持久化存储机制 ?
答案:存入到文件、 存入到 NSUserDefaults( 系统 plist 文件中 ) 、存入到 Sqlite 文件数据库
50. 谈谈对 Block 的理解 ?并写出一个使用 Block 执行 UIVew动画 ?
答案: Block 是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可 以大幅提高应用的执行效率 ( 多核心 CPU可直接处理 Block 指令 )
[UIView transitionWithView:self.view
duration:0.2
options:UIViewAnimationOptionTransitionFlipFromLeft
animations:^{ [[blueViewController view] removeFromSuperview]; [[self view]
insertSubview:yellowViewController.view atIndex:0]; } completion:NULL];

59. block 实现原理
Objective-C 是对 C 语言的扩展， block 的实现是基于指针和函数指针。 从计算语言的发展，最早的 goto ，高级语言的指针，到面向对象语言的 block ，从
机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻 辑( 需求 ) 。
下面是两篇很好的介绍 block 实现的博文 iOS 中 block 实现的探究
谈 Objective-C Block 的实现
3 block 的使用
使用实例
cocoaTouch 框架下动画效果的
使用 typed 声明 block
typedef void(^didFinishBlock) (NSObject *ob);
这就声明了一个 didFinishBlock 类型的 block ，
然后便可用
@property (nonatomic,copy) didFinishBlock finishBlock;
声明一个 blokc 对象，注意对象属性设置为 copy ，接到 block 参数时，便会自动
Block 的调用
复制一份。
__block 是一种特殊类型， 使用该关键字声明的局部变量，可以被
改变。
4 常见系列面试题
面试时，面试官会先问一些，是否了解 于开场白，往往是下面一系列问题的开始，所以一定要如实根据自己的情况回答。
1 使用 block 和使用 delegate 完成委托模式有什么优点 ?
首先要了解什么是委托模式， 委托模式在 iOS 中大量应用， 其在设计模式中是适配 器模式中的对象适配器， Objective-C 中使用 id 类型指向一切对象， 使委托模式更为简 洁。了解委托模式的细节:
iOS设计模式— -委托模式
使用 block 实现委托模式， 其优点是回调的 block 代码块定义在委托对象函数内部， 使代码更为紧凑 ;
适配对象不再需要实现具体某个 protocol ，代码更为简洁。
block 所改变，并且其在原函数中的值会被
block ，是否使用过 block ，这些问题相当

 2 多线程与 block
GCD与 Block
使用 dispatch_async 系列方法，可以以指定的方式执行 block
GCD编程实例
dispatch_async 的完整定义
void dispatch_async(
dispatch_queue_t queue,
dispatch_block_t block);
功能:在指定的队列里提交一个异步执行的
通过 queue 来控制 block 执行的线程。主线程执行前文定义的 finishBlock 对象 dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();});
委托是什么?委托和委托方双方的 property 声明用什么属性?为什么? 委托:一个对象保存另外一个对象的引用，被引用的对象实现了事先确定的协议，该协
议用于将引用对象中的变化通知给被引用对象。
委托和委托方双方的 property 声明属性都是 assign 而不是 retain 为了避免循环引用造成的内存泄露。
      循环引用的问题这样理解:
比如在 main函数中创建了两个类的对象 A和B，现在引用计数都是 1。现在 让A和B互相引用 (A有一个属性是 B对象，属性说明是 retain ;B有一个属性是 A对象，属 性说明是 retain) ，现在两个对象的引用计数都增加了 1，都变成了 2。
现在执行 [A release]; [B release]; 此时创建对象的 main函数已经释放了自己对 对象的所有权，但是此时 A和 B的引用计数都还是 1，因为他们互相引用了。
这时你发现 A和 B将无法释放，因为要想释放 A必须先释放 B，在B的 dealloc 方法中再 释放 A。同理，要想释放 B必须先释放 A，在 A的 dealloc 方法中再释放 B。所以这两个对象 将一直存在在内存中而不释放。这就是所谓的循环引用的问题。要想解决这个问题，一 般的方法可以将引用的属性设置为 assign, 而不是 retain 来处理。
4、延展是什么?作用是什么?
答: 延展( extension ): 在自己类的实现文件中添加类目来声明私有方法。
block ，不阻塞当前线程

 延展( Extension )“匿名”的类目，延展定义类的私有方法，一般是在类的实现文件 @implementation 之上定义如: Person()和类目的区别在于括号里面是空的， 没有名字的， 暂时性的存在，只能本类调用方法，子类也无法调用父类的延展
另外在本类的实现文件 @implementation 之上也可以定义私有方法，私有的静态变量 延展的特点就是定义私有方法
9、内存管理的几条原则是什么?按照默认法则， 哪些关键字生成的对象需要手动释放? 哪些情况下不需要手动释放，会直接进入自动释放池?
? 当使用 new、alloc 或copy方法创建一个对象时， 该对象引用计数器为 1。 如果不需要使用该对象， 可以向其发送 release 或 autorelease 消息，在其使用完毕时被 销毁。
? 如果通过其他方法获取一个对象，则可以假设这个对象引用计数为 1， 并且被设置为 autorelease ，不需要对该对象进行清理， 如果确实需要 retain 这个对象， 则需要使用完毕后 release 。
? 如果 retain 了某个对象，需要 release 或 autorelease 该对象，保持 retain 方法和 release 方法使用次数相等。
使用 new、 alloc 、 copy 关键字生成的对象和 retain 了的对象需要手动释放。设置为 autorelease 的对象不需要手动释放，会直接进入自动释放池。
10、怎样实现一个单例模式的类，给出思路，不写代码。
? 首先必须创建一个全局实例，通常存放在一个全局变量中
设置为 nil
? 提供工厂方法对该全局实例进行访问，检查该变量是否为
, 此全局变量
nil ，如果nil
就创建一个新的实例，最后返回全局实例
? 全局变量的初始化在第一次调用工厂方法时会在 +allocWithZone: 中进
行，所以需要重写该方法，防止通过标准的 alloc 方式创建新的实例
? 为了防止通过 copy方法得到新的实例，需要实现 -copyWithZone 方法
? 只需在此方法中返回本身对象即可，引用计数也不需要进行改变， 因为 单例模式下的对象是不允许销毁的，所以也就不用保留

? 因为全局实例不允许释放，所以 retain,release,autorelease 方法均 需重写

12、 KVC是什么 ?KVO是什么 ?有什么特点?
? KVC是键值编码，特点是通过指定表示要访问的属性名字的字符串标识 符，可以进行类的属性读取和设置
? KVO是键值观察， 特点是利用键值观察可以注册成为一个对象的观察者， 在该对象的某个属性变化时收到通知

14、定义属性时，什么情况使用 copy 、 assign 、 retain ?
使用 assign: 对基础数据类型(NSInteger ，CGFloat)和C数据类型(int, float,double,
char, 等等)
使用 copy:希望获得源对象的副本而不改变源对象内容时，对 NSString 使用 retain :希望获得源对象的所有权时，对其他 NSObject 和其子类

 15. 属性 readwrite ， readonly ， assign ， retain ， copy ， nonatomic 在那种情况下用?
assign 用于简单数据类型，如 NSInteger,double,bool,
retain 和 copy 用于对象，
readwrite 是可读可写特性;需要生成 getter 方法和 setter 方法时
readonly 是只读特性 只会生成 getter 方法不会生成 setter 方法 外改变
各是什么作用，
; 不希望属性在类
assign 是赋值特性， setter 方法将传入参数赋值给实例变量;仅设置变量时; retain 表示持有特性， setter 方法将传入参数先保留，再赋值，传入参数的
retaincount 会 +1;
copy 表示赋值特性， setter 方法将传入对象复制一份;需要完全一份新的变量时。
nonatomic 非原子操作，决定编译器生成的 setter getter 是否是原子操作， atomic 表示 多线程安全，一般使用 nonatomic
16.id 声明的对象有什么特性?
答: Id 声明的对象具有运行时的特性，即可以指向任意类型的 objcetive-c 的对象;
26、 iPhone5 的屏幕分辨率大小为 1136 * 640 ?
答:屏幕分辨率:用于量度位图图像内数据量多少的一个参数。通常表示成 ppi (每英 寸像素 Pixel per inch )。屏幕物理尺寸不变，分辨率越高，每单位面积内包含的细节 (像素点)越多。
27、 struct strA { expA;
输出结果为 12 ? 该问题涉及编译器的“内存对齐”问题:
现代计算机中内存空间都是按照 byte (字节)划分的，从理论上讲似乎对任何类型的变 量的访问可以从任何地址开始， 但实际情况是在访问特定变量的时候经常在特定的内存
printf("%ld",sizeof(expA));
int a; float b; char c; }

地址访问， 这就需要各类型数据按照一定的规则在空间上排列， 而不是顺序的一个接一 个的排放，这就是对齐。
对齐的作用和原因: 各个硬件平台对存储空间的处理上有很大的不同。 一些平台对某些 特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常 见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。 比如有些平台每次读都是从偶地址开始，如果一个 int 型(假设为 32 位)如果存放在偶 地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可 能会需要 2个读周期， 并对两次读出的结果的高低字节进行拼凑才能得到该 int 数据。显 然在读取效率上下降很多。这也是空间和时间的博弈。
通常，我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的 对齐策略。 当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方 法。
但是，正因为我们一般不需要关心这个问题，所以因为编辑器对数据存放做了对齐，而
我们不了解的话， 常常会对一些问题感到迷惑。最常见的就是 结果，出乎意料。
对于结构体来说， 按成员中所占字节最大的是 一共有 3个成员，所以总的占用字节为: 4* 3 = 12.
       可通过编译器命令来设定:
#progma pack (2)
struct 数据结构的 sizeof
float 类型，占用 4个字节，
29、 OSI( Open System Interconnection )开放式系统互联参考模型把网络协议从逻辑 上分为了 7层，试列举常见的应用层协议。
注意问的是应用层协议，有些同学直接答了七层模型。
在开放系统互连 (OSI) 模型中的最高层， 为应用程序提供服务以保证通信， 但不是进行通信的应用程序本身。
Telnet 协议是 TCP/IP协议族中的一员， 是 Internet 远程登陆服务的标准协议和主要方式。 它为用户提供了在本地计算机上完成远程主机工作的能力。
FTP文件传输协议是 TCP/IP网络上两台计算机传送文件的协议， FTP是在 TCP/IP网络和 INTERNET上最早使用的协议之一，它属于网络协议组的应用层。

超文本传输协议 (HTTP-Hypertext transfer protocol) 是分布式，协作式，超媒体系 统应用之间的通信协议。是万维网( world wide web )交换信息的基础。
SMTP(Simple MailTransfer Protocol )即简单邮件传输协议 , 它是一组用于由源地址 到目的地址传送邮件的规则，由它来控制信件的中转方式，它帮助每台计算机在发送 或中转信件时找到下一个目的地。
时间协议 (TIME protocol) 是一个在 RFC868内定义的网络协议。它用作提供机器可读的 日期时间资讯。
DNS 是域名系统 (Domain NameSystem) 的缩写，是因特网的一项核心服务，它作为可 以将域名和 IP 地址相互映射的一个分布式数据库。
SNMP(Simple Network ManagementProtocol, 简单网络管理协议 ) 的前身是简单网关监控 协议 (SGMP，) 用来对通信线路进行管理。
TFTP(Trivial FileTransfer Protocol, 简单文件传输协议)是 TCP/IP协议族中的一个 用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传 输服务。端口号为 69。
30、网络传输层协议中，基于 TCP/IP 协议和 UDP/IP的连接有什么区别?
TCP: TransmissionControl Protocol 传输控制协议 TCP是一种面向连接(连接导向)
的、可靠的、基于字节流的运输层( Transport layer )通信协议，由 明( specified )。
UDP 是User DatagramProtocol 的简称，中文名是用户数据包协议，是 一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务， UDP的正式规范。
IETF的RFC 793说
OSI 参考模型中 IETF RFC768是
面向连接:是指通信双方在通信时，要事先建立一条通信线路，其有三个过程:建立连 接、使用连接和释放连接。电话系统是一个面向连接的模式，拨号、通话、挂机; TCP 协议就是一种面向连接的协议。
面向无连接: 是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的 包(报文分组)送到线路上，由系统自主选定路线进行传输。邮政系统是一个无连接的 模式，天罗地网式的选择路线，天女散花式的传播形式; IP 、UDP协议就是一种无连接 协议。

33、 iOS中有哪些回调机制，并作简单的比较。 各种回调机制的比较:
1)目标动作对:当两个对象之间有比较紧密的关系时，如视图控制器与其下的某个视 图。
2)代理:也叫委托， 当某个对象收到多个事件， 并要求同一个对象来处理所有事件时。 委托机制依赖于某个协议定义的方法来发送消息。
3)通告机制:当需要多个对象或两个无关对象处理同一个事件时。 4)Block :适用于回调只发生一次的简单任务。
34、列出在编码中哪些编码习惯有助于提高代码质量、软件性能和健壮性，减少程序崩 溃。
#使用严格的命名规则(如匈牙利命名法)能够避免不必要的类型转换错误。 #在编码前先设计好流程图或使用伪代码，清晰化整个设计意图。 #对自己的代码进行严格的单元测试( unit testing )。
copy];
单元测试是指对软件中的最小可测试单元进行检查和验证。
Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元 就是人为规定的最小的被测功能模块。 单元测试是在软件开发过程中要进行的最低级别 的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。
#异常的处理
如 C语言中单元指一个函数，

首先不要轻易使用异常的捕获， 其次要尽可能捕获具体的异常。 对于异常的处理最好能 够采用封装的方式， 大家统一使用。这样可以保证异常处理的一致性也可以保证当异常 出现时性能的稳定。
# 使用内省的方法检查方法的输入 #采用增量式的编程方式。
采用增量式编程和测试， 会倾向于创建更小的方法和更具内聚性的类。 你应该经常评估 代码质量， 并不时的进行许多小调整， 而不是一次修改许多东西。 在写了几行代码之后， 就应该进行一次构建 / 测试。在没有得到反馈时，你不要走的太远。
#使用工具(如 Instrument )来帮助检查内存泄漏、过早释放内存、 CPU使用效率等问 题。
#消除所有的编译警告，警告就是错误。 #写防御性的代码，使用内省的方法检查传入的参数。
35、 JSON中{ } 代表 _____， [ ] 代表 _____，试将下面的 JSON串用 OC对象表示出来: { "people": [
{ "firstName": "Brett","lastName":"McLaughlin", "email":"aaaa" },
{ "firstName": "Jason","lastName":"Hunter", "email": "bbbb"},
{ "firstName": "Elliotte","lastName":"Harold", "email": "cccc" } ]，
“location ”: ”中华人民共和国” }
JSON中{ } 代表对象，数据结构为{ key1:value1, key2:value2, key3:,, } [ ] 代表数组，与其他语言中的数组类似。
//
@interface People: NSObject

@property(nonatomic, copy) NSString* strFirstName; @property(nonatomic, copy) NSString* strLastName; @property(nonatomic, copy) NSString* strEmail;
@end
//
@interfaceJSonData : NSObject
@property(nonatomic, retain) NSMutableArray* arrPeople; // @property(nonatomic, copy) NSString* strLocation;
@end
37.bject-C 有私有方法吗?私有变量呢?
objective-c – 类里面的方法只有两种 , 静态方法和实例方法 .
在类里面声名一个私有方法 ?@interface Controller : NSObject
存放 People 对象
{ NSString *something;
} ?+ (void)thisIsAStaticMethod; @interface Controller
(private) -(void)thisIsAPrivateMethod;
@private 可以用来修饰私有变量 所有实例方法默认都是公有的
?– (void)thisIsAnInstanceMethod;
?@end?
?@end
?在 Objective ‐ C中，所有实例变量默认都是私有的，

38. 堆和栈的区别? 管理方式:对于栈来讲，是由编译器自动管理，无需我们手工控制;对于堆来说，释放
工作由程序员控制，容易产生 memory leak 。 申请大小:栈:栈是向低地址扩展的数据结构，是一块连续的内存的区域
的内存区域。 分配方式:堆都是动态分配的，动态分配由
堆:是向高地址扩展的数据结构，是不连续
alloca 函数进行分配 栈的动态分配由编译器进行释放， 无需我们
手工实现
39. kvc 和 kvo 的区别?
kvc :键值编码，是一种间接访问对象的属性，使用字符串来标示属性 kvo :键值观察机制，提供了观察某一属性变化的方法
42. 类别的作用? 答:有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。可以使
用类别对该类扩充新的方法。 注意:类别只能扩充方法，而不能扩充成员变量。
代理的作用
委托代理( degegate )，目的是改变和传递控制链
顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这 个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方 是哪个对象，委托所做的内容是什么。
委托机制是一种设计模式。 多态:子类的指针可以赋值给父类
43.链表和数组的区别在哪里 ? 二者都属于一种数据结构

从逻辑结构来看
1. 数组必须事先定义固定的长度(元素个数)，不能适应数据动态地增减的情况。当 数据增加时，可能超出原先定义的元素个数;当数据减少时，造成内存浪费;数组可以 根据下标直接存取。
2. 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、 删除数据项。(数组中插入、删除数据项时，需要移动其它数据项，非常繁琐)链表必 须根据 next 指针找到下一个元素
从内存存储来看
1. ( 静态 ) 数组从栈中分配空间 , 对于程序员方便快速 , 但是自由度小 2. 链表从堆中分配空间 , 自由度大但是申请管理比较麻烦
从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用 数组;相反，如果需要经常插入和删除元素就需要用链表数据结构了。
44. main()
{ int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1));
}
答: 2,5 *(a+1) 就是 a[1] ， *(ptr-1) 就是 a[4], 执行结果是 2 ， 5
&a+1不是首地址 +1，系统会认为加一个 a数组的偏移，是偏移了一个数组的大小(本例 是5个int )
int *ptr=(int *)(&a+1); 则 ptr 实际是 &(a[5]), 也就是 a+5 原因如下: &a是数组指针，其类型为 int (*)[5];
而指针加 1要根据指针类型加上一定的值，不同类型的指针 +1之后增加的大小不 同。

a 是长度为 5的 int 数组指针，所以要加 5*sizeof(int) ，所以 ptr 实际是 a[5] ， 但是 prt 与(&a+1) 类型是不一样的 ( 这点很重要 ) ，所以 prt-1 只会减去
sizeof(int*)
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0] 的地址， &a是对象(数组)首地
址， a+1是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址， 即 a[5].
45. 写一个委托的 interface
@protocol MyDelegate;
@interface MyClass: NSObject
{ id <MyDelegate> delegate; }
// 委托方法 @protocol MyDelegate- (void)didJobs:(NSArray *)args; @end
46. 写一个 NSString 类的实现 +(id)initWithCString:(const char
*)nullTerminatedCStringencoding:(NSStringEncoding)encoding;
+ (id)stringWithCString: (const
char*)nullTerminatedCString encoding: (NSStringEncoding)encoding
{ NSString *obj;
obj = [selfallocWithZone: NSDefaultMallocZone()];
obj = [objinitWithCString: nullTerminatedCString encoding: encoding];
}
returnAUTORELEASE(obj);


55. cocoa touch 框架 这些框架包括:
Core Animation
- 动作
mm文件可以

通过 Core Animation ，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰 富的用户体验。
Core Audio
Core Audio 是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添加强大的
音频功能。
Core Data 提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理 任何应用或大或小的数据模型。
功能列表:框架分类 下面是 Cocoa Touch
音频和视频
CoreAudio OpenAL MediaLibrary AVFoundation
数据管理
Core Data
SQLite
图形和动画
中一小部分可用的框架:
CoreAnimation OpenGL ES Quartz 2D
网络 /li> Bonjour
WebKit
BSDSockets
用户应用

AddressBook CoreLocation MapKit StoreKit
56.objc 的内存管理
答:如果您通过分配和初始化(比如 [[MyClass alloc] init] )的方式来创建对象，您 就拥有这个对象，需要负责该对象的释放。这个规则在使用 NSObject的便利方法 new 时也同样适用。
如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放。如果您保持 一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。反过来，如果您从 其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它(这个规则有少数 的例外，在参考文档中有显式的说明)。
57. 自动释放池是什么 , 如何工作?
答:当您向一个对象发送一个 autorelease 消息时， Cocoa就会将该对象的一个引用放入 到最新的自动释放池。 它仍然是个正当的对象，因此自动释放池定义的作用域内的其它 对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放， 池中的所有对象也就被释放。
1)ojc-c 是通过一种 "referring counting"( 引用计数 ) 的方式来管理内存的 , 对象在开 始分配内存 (alloc) 的时候引用计数为一 , 以后每当碰到有 copy,retain 的时候引用计数 都会加一 , 每当碰到 release 和autorelease 的时候引用计数就会减一 , 如果此对象的计 数变为了 0, 就会被系统销毁 .
2) NSAutoreleasePool 就是用来做引用计数的管理工作的 , 这个东西一般不用你管的 . 3)autorelease 和 release 没什么区别 , 只是引用计数减一的时机不同而已 ,autorelease
会在对象的使用真正结束的时候才做引用计数减一。

61.obj-c 的优缺点 objc 优点:
1) Cateogies 2) Posing 3) 动态识别 4) 指标计算 5 )弹性讯息传 递 6) 不是一个过度复杂的 C 衍生语言 7) Objective-C 与 C++ 可混合编程
缺点 :

1) 不支援命名空间 2) 不支持运算符重载 3 )不支持多重继承 4 )使用动 态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。 (如内 联函数等)，性能低劣。
62.sprintf,strcpy,memcpy 使用上有什么要注意的地方?
答: strcpy 是一个字符串拷贝的函数，它的函数原型为 strcpy(char *dst, const char
*src); 将src 开始的一段字符串拷贝到 dst 开始的内存中去，结束的标志符号为 '\0' ，由 于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。
具备字符串拷贝功能的函数有 memcpy，这是一个内存拷贝函数，它的函数原型为 memcpy(char *dst,const char* src, unsigned int len); 将长度为 len 的一段内存， 从src 拷贝到 dst 中去，这个函数的长度可控。但是会有内存叠加的问题。
sprintf 是格式化函数。 将一段数据通过特定的格式， 格式化到一个字符串缓冲区中去。 sprintf 格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小， 造成溢出。
一、自我介绍;(稍微写一下， 1、突出自己技术方面的优势，突出自己有开发 验，围绕着岗位，突出自身在 ios 中开发层面的经验和优势;
2、性格优势，学习能力比较强，自身优势，夸自己没有不好意思，责任，学习能力)

1、协议:相当于一个方法列表，多个类可以共享的方法的列表 代理:它是一个设计模式，本质就 是两个对象之间的调用 id 的范型

8、 kvc kvo (点语法是 kvc 的一种，一种特殊的 kvc ) kvc :内部批量调用数组的名称 setValueForUnder
kvo :对符合 kvc 进行键值观察
9、多线程 NSThread(系统的基本类) NSOperation 、 GCD(结合着 block 去应用) AFNetworking code 2.0
效率: block delegate 通知中心
block 是一个匿名函数，
10、为了防止多个线程同时来使用，线程锁、
11、 FMDB有一个线程安全，做了线程安全( sqlite3 事物: try-catch ，能提高效率，
syscn...
FMDB)Q 增加可以看一下啊
如果我们的 app 需要多线程操作数据库， 那么就需要使用 FMDatabaseQueue来保证线程安全 了。切记不能在多个线程中共同一个 FMDatabase 对象并且在多个线程中同时使用，这个类 本身不是线程安全的，这样使用会造成数据混乱等问题。

 使用 FMDatabaseQueue很简单，首先用一个数据库文件地址来初使化 FMDatabaseQueue，然 后就可以将一个闭包 (block) 传入 inDatabase 方法中。在闭包中操作数据库，而不直接参
与 FMDatabase 的管理。
12、 HTTP 协议， TCP,UDP
http :请求头、相应头、请求体、相应体


27. 什么是安全释放?
28.为什么有些 4.0独有的objective-c 函数在3.1上运行时会报错 .而 4.0独有的类在 3.1上分配内存时不会报错?分配的结果是什么?
29.为什么 4.0独有的 c函数在 3.1的机器上运行不会报错(在没有调用 的情况下?)而 4.0独有的类名在 3.1的机器上一运行就报错?
30.异常exception 怎么捕获?不同的 CPU结构上开销怎样? C中又 什么类似的方法?
31.property 中属性 retain,copy,assgin 的含义分别是什么?有什么区 别?将其转换成 get/set方法怎么做?有什么注意事项?
32.委托是什么?委托的 property 声明用什么属性?为什么? 34.Cocoa 中有虚基类的概念么?怎么简洁的实现?
35.自动释放池跟 GC(垃圾回收)有什么区别? iPhone 上有GC么? [pool release ]和[pool drain ]有什么区别? iPhone 上没有 GC。 iPhone 开发的时候没有垃圾回收机制。 在垃圾回收环境中， release 是一个空操作。因此， NSAutoreleasePool 提供了 drain 方法，在引用 计数环境中，该方法的作用等同于调用 release ，但在垃圾回收环境 中，它会触发垃圾回收 (如果自上次垃圾回收以来分配的内存大于当 前的阈值)。因此，在通常情况下，您应该使用 drain 而不是 release 来销毁自动释放池。
36. for(int index = 0; index < 20; index ++){ NSString *tempStr = @”tempStr ”;NSLog(tempStr); NSNumber *tempNumber =

[NSNumber numberWithInt:2]; NSLog(tempNumber); } 这段代 码有什么问题 .?会不会造成内存泄露(多线程)?在内存紧张的设 备上做大循环时自动释放池是写在循环内好还是循环外好?为什
么?
37. 内存管理的几条原则时什么?按照默认法则 . 那些关键字生成的 对象需要手动释放?在和 property 结合的时候怎样有效的避免内存 泄露?
38. 在一个对象释放前 .如果他被加到了 notificationCenter 中 .不在 notificationcenter 中remove这个对象可能会出现什么问题?
39.怎样实现一个 singleton 的类 .给出思路。
40.什么是序列化或者 Acrchiving, 可以用来做什么 ,怎样与 copy结合,
原理是什么 ?.
41. 线程与进程的区别和联系 ? 答案 : 进程和线程都是由操作系统 所体会的程序运行的基本单元， 系统利用该基本单元实现系统对应用 的并发性。 程和线程的主要差别在于它们是不同的操作系统资源管 理方式。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不 会对其它进程产生影响， 而线程只是一个进程中的不同执行路径。 线 程有自己的堆栈和局部变量， 但线程之间没有单独的地址空间， 一个 线程死掉就等于整个进程死掉， 所以多进程的程序要比多线程的程序 健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些

要求同时进行并且又要共享某些变量的并发操作， 只能用线程， 不能 用进程。
42.在iphone上有两件事情要做 ,请问是在一个线程里按顺序做效率 高还是两个线程里做效率高?为什么?
43.runloop 是什么?在主线程中的某个函数里调用了异步函数，怎么 样 block 当前线程 ,且还能响应当前线程的 timer 事件， touch 事件等 .
UNIX 主要支持三种通信方式:
1. 基本通信:主要用来协调进程间的同步和互斥 (1) 锁文件通信
通信的双方通过查找特定目录下特定类型的文件
成进程间 对临界资源访问时的互斥; 例如进程 p1访问一个临界资源， 首先查看是否有一个特定类型文件， 若有，则等待一段时间再查找锁 文件。
(2) 记录锁文件
2. 管道通信:适应大批量的数据传递
(称锁文件 )来完

3. IPC :适应大批量的数据传递
50.timer 的间隔周期准吗?为什么?怎样实现一个精准的 timer?
51.UIscrollVew 用到了什么设计模式?还能再 foundation 库中找到类 似的吗?(答案众多，不知道哪个是对的~~)
模板 (Template) 模式，所有 datasource 和delegate 接口都是模板模式 的典型应用，
组合模式 composition ，所有的 containerview 都用了这个模式 观察者模式 observer ，所有的 UIResponder 都用了这个模式。
52如果要开发一个类似 eclipse 的软件，支持插件结构。且开放给第 三方开发。你会怎样去设计它?(大概思路)
53. main()
{
int a[5]={1,2,3,4,5}; int *ptr=(int *)(&a+1);

printf("%d,%d",*(a+1),*(ptr-1)); }
答: 2,5
*(a+1) 就是 a[1]，*(ptr-1) 就是 a[4],执行结果是 2.5 ，&a+1 不是首 地址+1，系统会认为加一个 a数组的偏移，是偏移了一个数组的大小 (本例是 5个int，int *ptr=(int *)(&a+1); 则ptr实际是 &(a[5]), 也就是 a+5 原因如下:
&a是数组指针， 其类型为 int (*)[5]; 而指针加 1要根据指针类型 加上一定的值，不同类型的指针 +1之后增加的大小不同。 a是长度为
5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5]，但是prt 与(&a+1)类型是不一样的 (这点很重要)，所以prt-1只会减去 sizeof(int*) ，a,&a 的地址是一样的， 但意思不一样， a是数组首地址， 也就是 a[0] 的地址， &a是对象(数组)首地址， a+1 是数组下一元素 的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].
54. 以下为 Windows NT 下的 32位 C++ 程序，请计算 sizeof 的值 voidFunc ( char str[100] ) { sizeof( str ) =? } void *p
= malloc( 100 ); sizeof ( p ) = ?
答案:这题很常见了 ,Func( char str[100] ) 函数中数组名作为函数形 参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针;

在失去其内涵的同时， 它还失去了其常量特性，可以作自增、自减等 操作，可以被修改。 Windows NT 32 位平台下，指针的长度(占用内 存的大小)为 4字节，故 sizeof( str ) 、sizeof( p ) 都为 4。
55.- (void )*getNSString(const NSString *inputString) { inputString =@"This is a main test\n";
return ;} -main(void)
{NSString *a=@"Main ";
NSString *aString =
[NSStringstringWithString:@" %@",getNSString(a )];
NSLog(@" %@\n ", aString);}
最后问输出的字符串 :NULL,output 在函数返回后，内存已经被释放。


61.cocoatouch 框架
iPhoneOS 应用程序的基础 Cocoa Touch 框架重用了许多 Mac 系 统的成熟模式，但是它更多地专注于触摸的接口和优化。 UIKit 为您 提供了在 iPhone OS 上实现图形，事件驱动程序的基本工具，其建 立在和 Mac OS X 中一样的 Foundation 框架上，包括文件处理， 网络，字符串操作等。
CocoaTouch 具有和 iPhone 用户接口一致的特殊设计。 有了 UIKit ， 您可以使用 iPhone OS 上的独特的图形接口控件，按钮，以及全屏 视图的功能，您还可以使用加速仪和多点触摸手势来控制您的应用。

各色俱全的框架除了 UIKit 外， Cocoa Touch 包含了创建世界一流 iPhone 应用程序需要的所有框架，从三维图形，到专业音效，甚至 提供设备访问 API 以控制摄像头，或通过 GPS 获知当前位置。 Cocoa Touch 既包含只需要几行代码就可以完成全部任务的强大的 Objective-C 框架，也在需要时提供基础的 C 语言 API 来直接访问 系统。这些框架包括:
CoreAnimation
通过 CoreAnimation ，您就可以通过一个基于组合独立图层的简单的
编程模型来创建丰富的用户体验。
CoreAudio
CoreAudio 是播放，处理和录制音频的专业技术，能够轻松为您的
应用程序添加强大的音频功能。
CoreData
提供了一个面向对象的数据管理解决方案， 它易于使用和理解， 甚至 可处理任何应用或大或小的数据模型。
功能列表:框架分类
下面是 CocoaTouch 中一小部分可用的框架: ? 音频和视频
? Core Audio

? OpenAL
? Media Library
? AV Foundation
? 数据管理
? Core Data
? SQLite
? 图形和动画
? Core Animation
? OpenGL ES
? Quartz 2D
? 网络 /li>
? Bonjour
? WebKit
? BSD Sockets
? 用户应用
? Address Book
? Core Location

? Map Kit
? Store Kit
62.objc 的内存管理
如果您通过分配和初始化(比如 [[MyClass alloc] init] )的方式来创建 对象，您就拥 有这个对象，需要负责该对象的释放。这个规则在使 用 NSObject 的便利方法 new 时也同样适用 .
如果您拷贝一个对象， 您也拥有拷贝得到的对象， 需要负责该对象的 释放.
如果您保持一个对象， 您就部分拥有这个对象， 需要在不再使用时释 放该对象。
如果您从其它对象那里接收到一个对象， 则您不拥有该对象， 也不应 该释放它(这个规则有少数 的例外，在参考文档中有显式的说明) 。
63.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象 的一个引用放入到最新的自动释放池。 它仍然是个正当的对象， 因此 自动释放池定义的作用域内的其它对象可以向它发送消息。 当程序执

行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象 也就被释放。
1. ojc-c 是通过一种 "referringcounting"( 引用计数 )的方式来管理内存 的 , 对象在开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到
有 copy,retain 的时候引用计数都会加一 , 每当碰到 release 和 autorelease 的时候引用计数就会减一 ,如果此对象的计数变为了 0,
就会被系统销毁 . 2. NSAutoreleasePool 就是用来做引用计数的管 理工作的 ,这个东西一般不用你管的 . 3. autorelease 和release 没什 么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的 使用真正结束的时候才做引用计数减一 .



80. autorelease 和垃圾回收机制 (gc)有什么关系? IPhone OS 有没有 垃圾回收( gc)?
81. Objective C 中的 protocal 是什么?
@protocal obj 里面的协议就如同 java 里面的 interface 。
82. Objective C 中的 selector 是什么?
你可以理解 @selector() 就是取类方法的编号 , 他的行为基本可以等 同C语言的中函数指针 ,只不过C语言中，可以把函数名直接赋给一个 函数指针，而 Objective-C 的类不能直接应用函数指针，这样只能做 一个 @selector 语法来取 .它的结果是一个 SEL 类型。这个类型本质是 类方法的编号 (函数地址 )。

83. Objective C 中的 category 是什么 ?
Objective-C 提供了一个非常灵活的类 (Class) 扩展机制-类别
(Category) 。类别用于对一个已经存在的类添加方法 (Methods) 。你 只需要知道这个类的公开接口， 不需要知道类的源代码。 需要注意的 是，类别不能为已存在的类添加实例变量 (Instance Variables) 。
子类(subclassing) 是进行类扩展的另一种常用方法。与子类相比，类 别最主要的优点是: 系统中已经存在的类可以不需修改就可使用类别 的扩展功能。
类别的第二大优点是实现了功能的局部化封装。 类别定义可以放在一 个已存在的类 (类 A)的定义文件中 (.h)。这意味着这个类别只有在类 A 被引用的前提下才会被外部看到。 如果另一个类 (类 B) 不需要用到类 A 的功能 (没有包含类 A的 .h文件 )，也就不会看到依附类 A存在的类别。 iOS SDK 中广泛运用这种类别定义法来封装功能。
84. 什么是 Notification ?什么时候用 delegate ，什么时候用 Notification ?
观察者模式， controller 向defaultNotificationCenter 添加自己的 notification ，其他类注册这个 notification 就可以收到通知， 这些类可 以在收到通知时做自己的操作 (多观察者默认随机顺序发通知给观察 者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到

他来操作，可以用 NotificationQueue 的方式安排观察者的反应顺序， 也可以在添加观察者中设定反映时间，取消观察需要在
viewDidUnload 跟dealloc中都要注销)。
delegate 针对 one-to-one 关系，并且 reciever 可以返回值给 sender ， notification 可以针对 one-to- one/many/none,reciever 无法返回值给 sender. 所以， delegate 用于 sender 希望接受到 reciever 的某个功能反 馈值，
notification 用于通知多个 object 某个事件。
85. 什么是 KVC 和KVO ?Notification 和KVO 有什么不同? KVO 在 ObjC 中是怎么实现的?
86. ViewController 的 loadView,viewDidLoad, viewDidUnload 分 别是在什么时候调用的?在自定义 ViewController 的时候这几个函数 里面应该做什么工作?
答: viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的view为nil时调用。此方法在 编程实现view时调用 ,view 控
制器默认会注册 memory warning notification, 当view controller 的任 何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将

89. UIView 和CALayer 有什么区别 ? 两者最大的区别是，图层不会直接渲染到屏幕上。
90. 以 UIView 类 animateWithDuration:animations: 为例，简述 UIView 动画原理。

11. 内存管理的几条原则时什么 ?按照默认法则 .那些关键字生成的对象需要手动释放 ?在和 property 结合的时候怎样有效的避免内存泄露 ?
答:谁申请，谁释放
遵循 Cocoa Touch 的使用原则 ;
内存管理主要要避免 ―过早释放 ‖和―内存泄漏 ‖，对于 ―过早释放 ‖需要注意 @property 设置特 性时，一定要用对特性关键字，对于 ―内存泄漏 ‖，一定要申请了要负责释放，要细心。

 关键字 alloc 或 new 生成的对象需要手动释放 ;
设置正确的 property 属性，对于 retain 需要在合适的地方释放，
13. Object C 中创建线程的方法是什么 ?如果在主线程中执行代码， 方法是什么 ?如果想延时 执行代码、方法又是什么 ?
答:线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是
performSelectorOnMainThread ，如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone:

16. 类别的作用 ?继承和类别在实现中有何区别 ?
答:category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不
能删除修改， 并且如果类别和原来类中的方法产生名称冲突， 为类别具有更高的优先级。
类别主要有 3 个作用:
1). 将类的实现分散到多个不同文件或多个不同框架中。
2). 创建对私有方法的前向引用。
3). 向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
则类别将覆盖原来的方法， 因
17. 类别和类扩展的区别。
答: category 和 extensions 的不同在于后者可以添加属性。另外后者添加的方法是必须要实
现的。
extensions 可以认为是一个私有的 Category。

 18. oc 中的协议和 java 中的接口概念有何不同 ?
答: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一
样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里
―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法， 你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。 ‖
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协
议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。
19. 什么是 KVO 和 KVC?
答:KVC: 键 – 值编码是一种间接访问对象的属性使用字符串来标识属性， 而不是通过调用 存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。 KVO: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个 button
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object chang
e:(NSDictionary *)change context:(void *)context
{ if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay]; } }
对于系统是根据 keypath 去取的到相应的值发生改变，理论上来说是和 kvc 机制的道理是一 样的。

 对于 kvc 机制如何通过 key 寻找到 value:
―当通过 KVC 调用对象时，比如: [self valueForKey:@ ‖ some时Ke，y‖程]序会自动试图通过 几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到， 会继续查找对象是否带有 someKey 这个实例变量 (iVar) ，如果还没有找到，程序会继续试图 调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话，程序会抛 出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注:Key-Value Coding 查找方法的时候， 不仅仅会查找 someKey 这个方法， 还会查找 getsomeKey 这个方法，前面加一个 get，或者 _someKey 以及 _getsomeKey 这几种
形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求 值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两
个例子说明了这样做的好处。 ― 来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们只是 关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。 20. 代理的作用 ?
答: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。 21. oc 中可修改和不可以修改类型。
add 一个相
而不需要
答:可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加修 改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可 以添加等，可以动态申请新的内存空间。
22. 我们说的 oc 是动态运行时语言是什么意思 ? 答:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。

 简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 以及调用该类别对象指 定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类 (life) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们只需 调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息 ( 响应了 eat 这个选择器 )。 因此也可以说，运行时机制是多态的基础 ?~~~
23. 通知和协议的不同之处 ? 答:协议有控制链 (has-a)的关系，通知没有。
首先我一开始也不太明白，什么叫控制链 (专业术语了 ~) 。但是简单分析下通知和代理的行 为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候 一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链 (has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
24. 什么是推送消息 ?
答:推送通知更是一种技术。
简单点就是客户端获取资源的一种手段。
普通情况下，都是客户端主动的 pull 。
推送则是服务器端主动 push。测试 push 的实现可以查看该博文。
25. 关于多态性 答:多态，子类指针可以赋值给父类。



 
38. 如果我们不创建内存池，是否有内存池提供给我们 ?

 答 : 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池 39. 什么时候需要在程序中创建内存池 ?
答:用户自己创建的数据线程，则需要创建该线程的内存池 40. 类 NSObject 的那些方法经常被使用 ?
答: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。 其中类方法 alloc 、 class、 description 对象方法 init 、 dealloc 、 –
performSelector:withObject:afterDelay: 等经常被使用 41. 什么是简便构造方法 ?
答:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber 的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法， 我们可以通过简便构造方法， 获得系统给我们创 建好的对象，并且不需要手动释放。

43. UIView 的动画效果有那些 ?
答:有很多， 如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown

 82. cocoa touch 框架
答:iPhone OS 应用程序的基础 Cocoa Touch 框架重用了许多 Mac 系统的成熟模式， 但是
它更多地专注于触摸的接口和优化。
UIKit 为您提供了在 iPhone OS 上实现图形，事件驱动程序的基本工具，其建立在和 Mac
OS X 中一样的 Foundation 框架上，包括文件处理，网络，字符串操作等。
Cocoa Touch 具有和 iPhone 用户接口一致的特殊设计。 有了 UIKit ，您可以使用 iPhone OS 上的独特的图形接口控件， 按钮， 以及全屏视图的功能， 您还可以使用加速仪和多点触摸手 势来控制您的应用。
各色俱全的框架除了 UIKit 外，Cocoa Touch 包含了创建世界一流 iPhone 应用程序需要的 所有框架，从三维图形，到专业音效，甚至提供设备访问 API 以控制摄像头，或通过 GPS 获知当前位置。
Cocoa Touch 既包含只需要几行代码就可以完成全部任务的强大的 Objective-C 框架， 也在 需要时提供基础的 C 语言 API 来直接访问系统。这些框架包括:
Core Animation :通过 Core Animation ，您就可以通过一个基于组合独立图层的简单的编程 模型来创建丰富的用户体验。
Core Audio :Core Audio 是播放， 处理和录制音频的专业技术， 能够轻松为您的应用程序添 加强大的音频功能。
Core Data:提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任 何应用或大或小的数据模型。
功能列表:框架分类
下面是 Cocoa Touch 中一小部分可用的框架:
音频和视频: Core Audio ， OpenAL ，Media Library ， AV Foundation 数据管理: Core Data ，SQLite
图形和动画: Core Animation ， OpenGL ES ， Quartz 2D
网络: Bonjour ， WebKit ， BSD Sockets
用户应用: Address Book ， Core Location ， Map Kit ， Store Kit
83. 自动释放池是什么 ,如何工作

 答:当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最 新的自动释放 .它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向 它发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象 也就被释放。
84. Objective-C 答: objc 优点:
的优缺点。
1). Cateogies
2). Posing
3). 动态识别
4). 指标计算
5). 弹性讯息传递
6). 不是一个过度复杂的 7).Objective-C 与 C++ 可混合编程 objc 缺点 :
1). 不支援命名空间
2). 不支持运算符重载
3). 不支持多重继承
4). 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。 (如内联函数等)，性能低劣。
85. sprintf,strcpy,memcpy 使用上有什么要注意的地方。 答:
1). sprintf 是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。
sprintf 格式化的函数的长度不可控， 有可能格式化后的字符串会超出缓冲区的大小， 造成溢 出。
2).strcpy 是一个字符串拷贝的函数，它的函数原型为 strcpy(char *dst, const char *src
C 衍生语言

 将 src 开始的一段字符串拷贝到 dst 开始的内存中去，结束的标志符号为 ?\0'，由于拷贝的 长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。
3). memcpy 是具备字符串拷贝功能的函数，这是一个内存拷贝函数，它的函数原型为 memcpy(char *dst, const char* src, unsigned int len); 将长度为 len 的一段内存，从 src 拷贝到 dst 中去，这个函数的长度可控。但是会有内存叠加的问题。
86. readwrite ， readonly ， assign， retain ， copy ，nonatomic 属性的作用 答: @property 是一个属性访问声明，扩号内支持以下几个属性:
1).getter=getterName ， setter=setterName，设置 setter 与 getter 的方法名
2).readwrite,readonly ，设置可供访问级别
2).assign， setter 方法直接赋值，不进行任何 retain 操作，为了解决原类型与环循引用问题
3).retain，setter 方法对参数进行 release 旧值再 retain 新值， 所有实现都是这个顺序 (CC 上有 相关资料 )
4).copy，setter 方法进行 Copy 操作，与 retain 处理流程一样，先旧值 release，再 Copy 出新 的对象， retainCount 为 1。这是为了减少对上下文的依赖而引入的机制。
5).nonatomic ，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此 属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级。
87. http 和 scoket 通信的区别。
答: http 是客户端用 http 协议进行请求，发送请求时候需要封装 http 请求头，并绑定请求
的数据，服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发 起请求， 服务器才能给响应， 一次请求完毕后则断开连接， 以节省资源。服务器不能主动给 客户端响应(除非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket 套―接字 ‖进行连接，并没有规定连接后断开，所以 客户端和服务器可以保持连接通道， 双方都可以主动发送数据。 一般在游戏开发或股票开发 这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是 CFSocketRef 。
88. TCP 和 UDP 的区别
答: TCP 全称是 Transmission Control Protocol ，中文名为传输控制协议，它可以提供可靠
的、面向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能: * 确保 IP 数据报的成功传递。
* 对程序发送的大块数据进行分段和重组。

 * 确保正确排序及按顺序传递分段的数据。
* 通过计算校验和，进行传输数据的完整性检查。
TCP 提供的是面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的 数据流传输。
简单的说， TCP 注重数据安全，而 UDP 数据传输快点，但安全性一般 89. 你了解 svn,cvs 等版本控制工具么?
答:版本控制 svn,cvs 是两种版控制的器 ,需要配套相关的 svn，cvs 服务器。
scm 是 xcode 里配置版本控制的地方。版本控制的原理就是 a 和 b 同时开发一个项目， a 写 完当天的代码之后把代码提交给服务器， b 要做的时候先从服务器得到最新版本，就可以接 着做。如果 a 和 b 都要提交给服务器，并且同时修改了同一个方法，就会产生代码冲突，如
果 a 先提交，那么 b 提交时，服务器可以提示冲突的代码， b 可以清晰的看到，并做出相应 的修改或融合后再提交到服务器。
90. 什么是 push。
答: 客户端程序留下后门端口， 客户端总是监听针对这个后门的请求， 于是服务器可以主动
像这个端口推送消息。 91. 静态链接库
答:此为 .a 文件，相当于 java 里的 jar 包，把一些类编译到一个包中，在不同的工程中如果 导入此文件就可以使用里面的类，具体使用依然是 #import ― xx.h。‖
92. fmmpeg 框架
答:音视频编解码框架，内部使用 UDP 协议针对流媒体开发，内部开辟了六个端口来接受
流媒体数据，完成快速接受之目的。 93. fmdb 框架
答:数据库框架，对 sqllite 的数据操作进行了封装，使用着可把精力都放在 sql语句上面。 94. 320 框架
答: ui 框架，导入 320 工程作为框架包如同添加一个普通框架一样。 cover(open) flower 框架 (2d 仿射技术 )，内部核心类是 CATransform3D.
94. 什么是沙盒模型?哪些操作是属于私有 api 范畴 ?

 答:某个 iphone 工程进行文件操作有此工程对应的指定的位置，不能逾越。
iphone 沙箱模型的有四个文件夹 documents， tmp， app， Library ，永久数据存储一般放
documents 文件夹，得到模拟器的路径的可使用 NSHomeDirectory() 方法。 Nsuserdefaults 保 存的文件在 tmp 文件夹里。
95. 在一个对象的方法里面: self.name= “ obje;ct和”name = ” object 有”什么不同吗 ? 答: self.name =‖object :‖会调用对象的 setName()方法;
name = ― objec:t 会‖直接把 object 赋值给当前对象的 name 属性。 96. 请简要说明 viewDidLoad 和 viewDidUnload 何时调用
答: viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时 调用。此方法在编程实现 view 时调用，view 控制器默认会注册 memory warning notification ， 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用， 在这里实现将 retain 的 view release，如果是 retain 的 IBOutlet view 属性则不要在这里 release， IBOutlet 会负责
release 。
97. 简述内存分区情况
答:
1). 代码区:存放函数二进制代码
2). 数据区:系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态 变量、常量
3). 堆区:通过 malloc 等函数或 new 等操作符动态申请得到，需程序员手动申请和释放 4). 栈区:函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数
98. 队列和栈有什么区别:
答:队列和栈是两种不同的数据容器。从 ‖数据结构 ‖的角度看，它们都是线性结构，即数据
元素之间的关系相同。
队列是一种先进先出的数据结构， 它在两端进行操作， 一端进行入队列操作， 一端进行出列 队操作。
栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈都在栈顶操作。 99. HTTP 协议中， POST 和 GET 的区别是什么?

 答:
1).GET 方法
GET 方法提交数据不安全，数据置于请求行，客户端地址栏可见 ; GET 方法提交的数据大小有限
GET 方法不可以设置书签
2).POST 方法
POST 方法提交数据安全，数据置于消息主体内，客户端不可见
POST 方法提交的数据大小没有限制
POST 方法可以设置书签
100. iOS 的系统架构
答: iOS 的系统架构分为(核心操作系统层
Services layer )、(媒体层 theMedia layer 四个层次。
)、(核心服务层
the Cocoa Touch layer )
101. 控件主要响应 3 种事件
答: 1). 基于触摸的事件 ; 2). 基于值的事件 ; 3).基于编辑的事件。
102. xib 文件的构成分为哪 3 个图标?都具有什么功能。
答: File ‘s Owne是r 所有 nib 文件中的每个图标，它表示从磁盘加载
First Responder 就是用户当前正在与之交互的对象;
View 显示用户界面;完成用户交互;是 UIView 类或其子类。
103. 简述视图控件器的生命周期。
nib 文件的对象;
theCore OS layer )和( Cocoa 界面服务层
theCore
答: loadView 尽管不直接调用该方法， 如多手动创建自己的视图， 那么应该覆盖这个方法
并将它们赋值给试图控制器的 view 属性。
viewDidLoad 只有在视图控制器将其视图载入到内存之后才调用该方法， 这是执行任何其他 初始化操作的入口。

 viewDidUnload 当试图控制器从内存释放自己的方法的时候调用， 用于清楚那些可能已经在 试图控制器中创建的对象。
viewVillAppear 当试图将要添加到窗口中并且还不可见的时候或者上层视图移出图层后本 视图变成顶级视图时调用该方法， 用于执行诸如改变视图方向等的操作。 实现该方法时确保
调用 [super viewWillAppear:
viewDidAppear 当视图添加到窗口中以后或者上层视图移出图层后本视图变成顶级视图时
调用，用于放置那些需要在视图显示后执行的代码。确保调用 [super viewDidAppear : ] 。
104. 动画有基本类型有哪几种;表视图有哪几种基本样式。
答:动画有两种基本类型:隐式动画和显式动画。
105. 实现简单的表格显示需要设置 UITableView 的什么属性、实现什么协议?
答:实现简单的表格显示需要设置 UITableView 的 dataSource 和 delegate 属性，实现 UITableViewDataSource 和 UITableViewDelegate 协议。
106. Cocoa Touch 提供了哪几种 Core Animation 过渡类型?
答: Cocoa Touch 提供了 4 种 Core Animation 过渡类型，分别为:交叉淡化、推挤、显
示和覆盖。
107. UIView 与 CLayer 有什么区别? 答:
1).UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是
由 CoreAnimation 来实现的。它真正的绘图部分，是由一个 CALayer 类来管理。 UIView
本身更像是一个 CALayer 的管理器，访问它的跟绘图和跟坐标有关的属性。 2).UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。
3).UIView 的 CALayer 类似 UIView 的子 View 树形结构， 也可以向它的 layer 上添加子 layer ，来完成某些特殊的表示。即 CALayer 层是可以嵌套的。
4).UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻辑树，这里是代码可 以操纵的;动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作;显示
树，其内容就是当前正被显示在屏幕上得内容。
5).动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改，系统将自动进行 动画生成，动画持续时间的缺省值似乎是 0.5 秒。

 6).坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint
结构表示， 值域是 0~1 ，是个比例值。 这个点是各种图形变换的坐标原点， 同时会更改 的 position 的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。
layer
7). 渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用 setNeedsDisplay 方法来重绘显示。
8). 变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform affineTransform 属性。
或
9).变形: Quartz Core 的渲染能力，使二维图像可以被自由操纵，就好像是三维的。 以在一个三维坐标系中以任意角度被旋转， 缩放和倾斜。 CATransform3D 的一套方法提供
了一些魔术般的变换效果。
108. Quatrz 2D 的绘图功能的三个核心概念是什么并简述其作用。 答:上下文:主要用于描述图形写入哪里; 路径:是在图层上绘制的内容; 状态:用于保存配置变换的值、填充和轮廓， alpha 值等。
109. iPhone OS 主要提供了几种播放音频的方法? 答: SystemSound Services
AVAudioPlayer 类
Audio Queue Services
OpenAL
110. 使用 AVAudioPlayer 类调用哪个框架、使用步骤? 答: AVFoundation.framework
步骤:配置 AVAudioPlayer 对象; 实现 AVAudioPlayer 类的委托方法; 控制 AVAudioPlayer 类的对象; 监控音量水平;
回放进度和拖拽播放。
图像可

 111. 有哪几种手势通知方法、写清楚方法名? 答:
-(void)touchesBegan:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesMoved:(NSSet*)touched withEvent:(UIEvent*)event; -(void)touchesEnded:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesCanceled:(NSSet*)touchedwithEvent:(UIEvent*)event; 112. CFSocket 使用有哪几个步骤。
答:创建 Socket 的上下文;创建 Socket ;配置要访问的服务器信息;封装服务器信息; 连接服务器;
113. Core Foundation 中提供了哪几种操作 Socket 的方法? 答: CFNetwork 、 CFSocket 和 BSD Socket 。
114. 解析 XML 文件有哪几种方式?
答:以 DOM 方式解析 XML 文件;以 SAX 方式解析 XML 文件;
115. ios 平台怎么做数据的持久化 ?coredata 和 sqlite 有无必然联系? coredata 是一个关系 型数据库吗?
答:iOS 中可以有四种持久化数据的方式: 属性列表 (plist) 、对象归档、 SQLite3 和 Core Data;
core data 可以使你以图形界面的方式快速的定义 app 的数据模型，同时在你的代码中容易 获取到它。 coredata 提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做， 允许你在 app 中继续创建新的任务。在使用 core data 的时候，你不用安装额外的数据库 系统， 因为 core data 使用内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组 定义在内存中的数据对象。 coredata 会追踪这些对象的改变，同时可以根据需要做相反的 改变，例如用户执行撤销命令。 当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些数据归档，并永久性保存。 mac os x 中 sqlite 库，它是一个轻量级功能强大 的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用， sqlite 是一个轻量级 的嵌入式 sql 数据库编程。与 core data 框架不同的是， sqlite 是使用程序式的， sql 的 主要的 API 来直接操作数据表。 Core Data 不是一个关系型数据库，也不是关系型数据库 管理系统 (RDBMS) 。虽然 Core Dta 支持 SQLite 作为一种存储类型，但它不能使用任意
的 SQLite 数据库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支持对 一、对多的关系。


 一、判断题(每题 2分，共 20分)
1、UITableView 能够绑定多个数据源。(错)
2、一个 UIViewController 可以管理多个 UITableView 。(对)
3、 Object-c 的类可以多重继承。(错)
4、 objective-c 类里面的方法只有两种 , 静态方法和实例方法。(对)
5、NSFileManager 和NSWorkspace在使用时都是基于进程进行单件对象的实例化。 (对)
6、用类别增加方法时，不能与原来类中的方法产生名称冲突。(错)
7、frame 指的是该 view 在本身坐标系统中 的位置和大小。(错)
8、method是一个方法的名字， selector 是一个组合体。(错)
9、 ARC是编译特性，不是运行时特性，在编译时，编译器会自动加上释放代码。(对)
10、从 iOS4之后， Safari 支持全屏浏览， Siri 支持普通话。(对)
二、填空题(每空 2分，共 20分)
1、iOS是使用 Objective-C 语言编写的， 使用该语言开发的 Cocoa是一款功能强大的用户 界面工具包，也是 iOS的核心。
2、数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速 访问数组中任何元素。链表恰好相反，其中的元素在内存中不是顺序存储的，而是通过 存在元素中的指针联系到一起。
3、发送同步请求，程序将停止用户交互，直至服务器返回数据完成，才可以进行下一 步操作。而发送异步请求不会阻塞主线程，会建立一个新的线程来操作，之后程序可以 继续运行。
4、autorelease 只是把 Object 放入了当前的 autorelease pool 中，当它被释放时，其中 的所有 Object 都会被调用 Release 。
5、作为 Objective-C 导入头文件的关键字， #import<> 用来包含系统的头文件， #import ”” 用来包含用户头文件。
三、简述题(每题 4分，共 20分)
1、delegate 和notification 有什么区别，什么情况下使用?
答: delegate :消息的发送者( sender )告知接收者( receiver )某个事件将要发生， delegate 同意然后发送者响应事件， delegate 机制使得接收者可以改变发送者的行为。

通常发送者和接收者的关系是直接的一对多的关系。
notification :消息的发送者告知接收者事件已经发生或者将要发生，仅此而已，接收 者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。
2、Object-C 中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果 想延时执行代码、方法又是什么?
答:线程创建有三种方法:使用 NSThread创建、使用 GCD的 dispatch 、使用子类化的 NSOperation ，然后将其加入 NSOperationQueue。
在主线程执行代码，方法是 performSelectorOnMainThread 。
如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone 。
3、iOS有哪些数据持久化方式?
答:四种:属性列表、对象归档、 SQLite3 和Core Data 。
4、Objective-C 如何对内存管理的 , 说说你的看法和解决方法?
答: Objective-C 的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内 存池。解决方法的话:谁持有，谁释放。


2、请阐述 UIViewController 的生命周期，包括代码的执行顺序。

答:当一个视图控制器被创建，并在屏幕上显示的时候。代码的执行顺序 // 视图显示在屏幕上的顺序
1、 alloc
2、 init (initWithNibName) 3 、 viewload
有使用 xib 文件创建视图。 4、viewDidLoad
他控件。
5、viewWillAppear 在屏幕上。
6、 viewDidAppear
// 视图将被从屏幕上移除的顺序
1、 viewWillDisappear
2、 viewDidDisappear
3、dealloc 创建的对象进行释放。
4、viewDidUnload 前显示的 controller 执行。
创建对象，分配空间。 初始化对象 , 初始化数据。
从 nib 载入视图 , 这一步不需要去干涉。除非没
加载完毕，可以进行自定义数据以及动态创建其
视图将出现在屏幕之前，马上这个视图即将显示
视图已在屏幕上渲染完成。
视图将被从屏幕上移除之前执行。 视图已经被从屏幕上移除。 视图被销毁，此时需要在 init 和viewDidLoad 中
出现内存警告在内存不足时执行，并对所有非当
本视图的所有子视图将被销毁，以释放内存，此时开发者需要手动对 viewDidLoad 中创建的对象释放内存。
因为当这个视图再次显示在屏幕上的时候， viewLoad 、 viewDidLoad 以便再次构造视图。
五、论述题( 20分)
viewLoad 、
再次被调用，
请针对正泰中自智慧水务 APP的需求(见现场展示的原型)，论述您的开发思路和使用 的开发技术。





谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？
      在一个进程中有多个线程，每个线程有自己单独的任务
  优点效率快   缺点不安全，耗费资源
      有三种
      第一种，使用@synchronized(self)
  第二种，使用GCD
  第三种，使用NSOperationQueue
多线程同步和异步的区别？IOS中如何实现多线程的同步？
一个进程启动的多个不相干线程，它们相互之间关系为异步。
同步的话指的是多线程同时操作一个数据 这个时候需要对数据添加保护 这个保护就是线程的同步。
     用GCD中的串行队列来解释多线程的同步，也就是队列中的任务为串行，它们各自对相邻的任务有依赖性，如果任务1不完成，那么任务2就不会开始，这就是同步
简述什么地方会用到多线程？谈谈多线程安全问题的几种解决方案？何为线程同步，如何实现的？分线程回调主线程方法是什么，有什么作用？


假设有一个字符串aabcad，请写一段程序，去掉字符串中不相邻的重复字符串，即上述字符串处理之后的输出结果为：aabcd
NSMutableArray *marry = [[NSMutableArray alloc]init];
     for (int i = 0; i < str.length - 1; i++) {
        unsigned char a = [str characterAtIndex:i];
        for (int j = i + 1; j < str.length; j++) {
            unsigned char b = [str characterAtIndex:j];
            if (a == b) {
                if (j == i + 1) {

                }else{
   
               [marry addObject:[NSString stringWithFormat:@"%d",j]];
                }
            }
        }
        }
for (int i = marry.count - 1; i > 0; i--) {
        
        NSInteger num = [[marry objectAtIndex:i]intValue];
        [str deleteCharactersInRange:NSMakeRange(num, 1)];
 
    }
    
ios类是否可以多继承？如果没有，那可以用其他方法实现吗？简述实现过程。
没有   用catogory 和 extension 可以实现
堆和栈的区别？
堆需要用户手动释放内存，而栈则是编译器自动释放内存
ios本地数据存储都有哪几种方式？
         1.  NSKeyedArchiver（加密形式）
         2.  NSUserDefaults
           3.  Write写入方式
     4.  SQLite3
写出方法获取ios内存使用情况。
void logMemoryInfo()
写一个便利构造器
UIImage初始化一张图片有几种方法？简述各自的优缺点。
回答person的retainCount值，并解释为什么
这段代码有什么问题吗:
这段代码有什么问题,如何修改
截取字符串”20 | http://www.baidu.com”中，”|”字符前面和后面的数据，分别输出它们。
用obj-c写一个冒泡排序
简述你对UIView、UIWindow和CALayer的理解
写一个完整的代理，包括声明，实现
分析json、xml的区别？json、xml解析方式的底层是如何处理的？
ViewController 的 didReceiveMemoryWarning 是在什么时候被调用的？默认的操作是什么?
面向对象的三大特征，并作简单的介绍
重写一个NSStrng类型的，retain方式声明name属性的setter和getter方法
简述NotificationCenter、KVC、KVO、Delegate？并说明它们之间的区别？
What is lazy loading?
什么是Protocol？什么是代理？写一个委托的interface？委托的property声明用什么属性？为什么？
分别描述类别（categories）和延展（extensions）是什么？以及两者的区别？继承和类别在实现中有何区别？为什么Category只能为对象添加方法，却不能添加成员变量？
谈谈你对MVC的理解？为什么要用MVC？在Cocoa中MVC是怎么实现的？你还熟悉其他的OC设计模式或别的设计模式吗？
如监测系统键盘的弹出
举出5个以上你所熟悉的ios  sdk库有哪些和第三方库有哪些？
如何将产品进行多语言发布？
如何将敏感字变成**
objc中的减号与加号代表什么？
单例目的是什么，并写出一个？
说说响应链
http和scoket通信的区别？socket连接相关库，TCP,UDP的区别？http的几种常用方式？

声明一个静态方法和一个实例方法？
什么是push？远程推送？
init和initwithobject区别（语法）？
请写出代码,用blocks来取代上例中的protocol,并比较两种方法的优势。实际应用部分？请写出代码，用blocks取代协议或回调方法
你做iphone开发时候，有哪些传值方式，view和view之间是如何传值的？
给定的一个字符串，判断字符串中是否还有png，有就删除它？
对于语句NSString* testObject = [[NSData alloc] init];testObject 在编译时和运行时分别是什么类型的对象？
OC中是所有对象间的交互是如何实现的？
什么是沙盒（sandbox）？沙盒包含哪些文件，描述每个文件的使用场景。如何获取这些文件的路径？如何获取应用程序包中文件的路径？
介绍一下XMPP？有什么优缺点吗？
谈谈对性能优化的看法，如何做？
应用程序如何省电？
写一个递归方法：计算N的阶乘，然后将计算结果进行存储。以便应用退出后下次启动课直接获取该值。
NSArray和NSMutableArray的区别，多线程操作哪个更安全？
当前有一个数组，里面有若干重复的数据，如何去除重复的数据？（会几个写几个）
isKindOfClass、isMemberOfClass作用分别是什么？
写出下面程序段的输出结果
NSDictionary *dict = [NSDictionary dictionaryWithObject:@"a string value" forKey:@"akey"];
NSLog(@"%@", [dict objectForKey:@"akey"]);
[dict release];
请写出以下代码的执行结果
NSString  * name = [ [ NSString alloc] init ];
name = @”Habb”;
[ name  release]；
请分别写出SEL、id的意思？

说说如何进行后台运行程序？
sizeof和strlen的区别和联系
sprintf,strcpy,memcpy的功能？使用上要有哪些要注意的地方
自己写函数，实现strlen功能
写一个代码片段输入一个字符串“20130322152832”,输出一个NSDate类型的对象，打印该对象输出2013-03-22 15：28：32
找错误
用变量a写出以下定义
      a、一个整型数 int a
      b、一个指向整型数的指针   int * a
      c、一个指向指针的指针，它指向的指针是指向一个整型数int **a3;
      d、一个有10个整型数的数组 int a4[10];
      e、一个有10个指针的数组，该指针是指向一个整型数的 int *a5[10];
      f、一个指向有10个整型数数组的指针int (*a6)[10];
g、一个指向函数的指针，该函数有一个整型参数，并返回一个整型数int (*a7)(int);
编写函数_memmove说明如下：实现C语言库函数memmove的功能：将一块缓冲区中的数据移动到另一块缓冲区中。可能有重复。
什么叫数据结构？
什么是抽象类？抽象类有什么作用？能实例化吗？
考察对@interface和@property的理解？
Iphone开发中控制类有什么作用？
线程中有哪些函数？写出来。
有没有写过自定义的控件？
调用一个类的静态方法需不需要release？
do-while 与 while-do的区别？
写出几个死循环？
main.m中都发生了什么？
int retVal = UIApplicationMain(argc, argv, nil, nil); 是什么意思？
编写NSArray的setter和getter？
cocoa touch框架
你了解svn,cvs等版本控制工具么？
Cocoa中有虚基类的概念么？怎么简洁的实现？
关于Objective-C++中的异常处理，可以相互捕获到吗？
OC中异常exception 怎么捕获？不同的CPU结构上开销怎样？C中又什么类似的方法？
obc中可修改和不可以修改类型
获取项目根路径，并在其下创建一个名称为userData的目录？
objective-c中的类型转换分为哪几类？
xml解析的原理是什么，你还用过其他解析方式么？
iphone阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的？另外像pdf格式的文件，你如何读取。?
你在开发大型项目的时候，如何进行内存泄露检测的? 内存泄露怎么处理？
iphone app为什么会被打回来，如何制止?
iphone应用程序的项目基本结构？
编译语言和解释语言的区别
给用户推送的通知的伪代码
什么是动态链接库和静态链接库？调用一个类的静态方法需不需要release？
OC中的数字对象都有哪些，简述它们与基本数据类型的区别是什么
ios平台怎么做数据的持久化?coredata和sqlite有无必然联系？coredata是一个关系型数据库吗？
objc优缺点
objective-c中的词典对象、可变词典对象是哪个，初始化一个含有两个键值对的可变词典对象，并动态的添加和删除一条记录，输出第一条记录
写一个NSString类的实现+ (id)initWithCString:(constchar *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
UITableView的重用机制？如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView 的delegate和dataSource?请说说实 现思路？在一个tableView中需要自定义多种样式的cell(两种或三种),通常你如何实现,说 说思路即可？UITableView的那些元素是可以自定义的？
一个tableView是否可以关联两个不同的数据源？你会怎么处理？
在一个对象释放前.如果他被加到了notificationCenter 中，在notificationcenter中remove这个对象可能会出现什么问题？
你连接服务器用的是什么方法，如果请求过程中，网络出了问题这么办？
委托是什么？委托的property声明用什么属性？为什么？
fmmpeg框架(了解一下)、fmdb框架(了解一下)、320框架（了解一下）
说说UISplitViewController的使用机制
你了解哪些加密方式？
请简述cocoa中 NSWindowController类的作用？
请用objective - c实现将一段NSString字符串放入剪贴板的代码，并加中文注释？
请用objective - c 实现获得当前运行模块的路径，并添加中文注释？
不使用继承，为NSStirng类添加新方法 myPrint？
单链表、多链表区别？
制作相册，写思路和步骤
做过哪些动画，举例说明


环信相关面试题:
1 、对环信的理解:主要回答环信是干嘛的，有哪些优 缺点，使用的什么通讯协议
环信是一个即时通信的服务提供商
环信使用的是 XMPP 协议，它是再 XMPP 的基础上进行二次开发，对服 务器 Openfire 和客户端进行功能模型的添加和客户端 SDK 的封装，环信 的本质还是使用 XMPP，基本于Socket的网络通信 环信内部实现了数据缓存， 会把聊天记录添加到 数据库 ，把附件 (如音频 文件，图片文件 )下载到本地， 使程序员更多时间是花到用户即时体验上 环信内部已经实现了视频，音频，图片，其它附件发送功能 环信使用公司可以节约时间成本，不需要公司内部搭建服务器，客户端 的开发，使用环信 SDK比使用XMPPFramework 更简洁方便
2 、环信中图片消息以及语言消息实现的逻辑是什么 图片消息:首先通过相册或相机得到图片对象，然后将图片转换成
NSData 类型或将图片保存到沙盒，通过环信的 EMImageMessageBody 的 initWithData 或者 initWithLocalPath 方法，构造出图片消息，然后发
送出去，收到图片消息时，客户端会主动将图片下载到本地，同时消息
对象包含两个路径(本地和网络)，我们可以根据路径得到图片，然后
显示
AVAudioRecorder 类进行录音，将 录音文件转化成 NSData类型或将文件保存到沙盒，构造出语音
消息，然后发送出去，收到语音消息时，客户端会主动将图片下载到本
地，同时消息对象包含两个路径(本地和网络)，我们可以根据路径得
语音消息:首先通过
AVAudioPlayer 类继续播放 3 、环信中是怎么实现好友管理的
所谓的好友管理就是好友关系的维护，包括增、删以及黑名单的设置，环信
到文件，然后通过
IEMContactManager 类有关，好友
中好友相关的操作都与
列表可以通过 FriendListViewController 方法获得，

好友的增加可以通过两种方式，一是主动添加 (addContact )，一是被动添加
( didReceiveFriendInvitationFromUsername )， 删除好友关系的方法是 deleteContact ，同时可以 通过addUserToBlackList 方法将好友拉近黑名单
4、即时通讯 app 中的气泡聊天是怎么处理图片拉伸的 气泡拉伸有三种方式:
1、 ios5 之前:
- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapW
idth topCapHeight:(NSInteger)topCapHeight; 这个方法只有 2个参数， leftCapWidth 代表左端盖宽度， topCapHeight 代表顶端盖高度。 系统会自动计算出右端盖宽度 (rightCapWidth) 和底端盖高度 (bottomCapHeight) ，使用这个方法只会拉伸图片中间的区域， 并不 会影响到边缘和角落
2、 ios5 :
- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets 这个方法只接收一个 UIEdgeInsets 类型的参数，可以通过设置 UIEdgeInsets 的left 、right 、top 、bottom 来分别指定左端盖宽 度、右端盖宽度、顶端盖高度、底端盖高度
3、ios6 :
- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets
。
resizingMode:(UIImageResizingMode)resizingMode ，
对比 iOS5.0 中的方法，只多了一个 UIImageResizingMode 参数，用
来指定拉伸的模式:
? UIImageResizingModeStretch :拉伸模式，通过拉伸 UIEdgeInsets 指定的矩形区域来填充图片
? UIImageResizingModeTile :平铺模式，通过重复显示 UIEdgeInsets 指定的矩形区域来填充图片
5 、环信与公司自己的服务器是怎么结合使用的

环信中有自己的一套用户信息，同时我们自己的服务器也有自己的用户表，该表中 保存着 app 中的用户名、密码、性别等嘻嘻，同时存着环信的用户名、密码，客户
端的登陆首先会登进自己的服务器，然后在登进环信，这样我们的 app 就可以对用 户提供很多东西
6 、环信中单聊与群聊消息的区分 环信中的聊天分三种 : EMChatTypeChat( 单
聊 )/EMChatTypeGroupChat (群聊)
/EMChatTypeChatRoom (聊天室)，我们可以通 过message 的chatType 来区分聊天类型
7 、环信中，收到消息时，怎么区分是谁发出的 通过每条消息的会话 ID ，无论是单聊还是群聊，在发送
消息时都会跟随一个 这个 ID区分消息
ConversationID ，我们可以根据
8 、如果要在环信中实现聊天记录的功能，怎么处理 首先，环信自己帮我们保存了聊天记录的，如果我们需要自己实现，则可以将消息 保存的本地数据库，或者服务端
9 、怎么通过环信实现阅后即焚需求 可以通过消息扩展配合已读回执进行实现。 流程如下:
A-->B 发送阅后即焚消息: 首先，如果是阅后即焚消息，需要在消息中标明，该消息是阅后即焚，
这个时候，
用到了 EMMessage 的 ext 属性，
NSMutableDictionary *fireDict = [NSMutableDictionary dictionary];

message.ext = [NSDictionary dictionaryWithObject:[NSNumbernumberWithBool:YES] forKey:@"isFire"]; [fireDictsetObject:messageforKey:message.messageId]; [[EaseMobsharedInstance].chatManagerasyncSendMessage:message progress:nil];
到此， A构建了一个带有 ext的message，其中带有 isFire的key，并且将 其发出给 B。
同时，我本地维护了一个 dict ，里面的 key 为 messageID ， value 为阅后 即焚的 message
当 B实现了 IChatManagerDelegate 委托，会调用回调方法，收到 A发来 的消息
B收到消息: -(void)didReceiveMessage:(EMMessage *)message{
// 此时收到了 A 发来的消息， 这个时候， 我们需要对这个消息进行分析， 看它是否是阅后即焚的消息
BOOL isFire = [[message.extobjectForKey:@"isFire"] boolValue];
如果该消息为阅后即焚，在 B看过这条消息后，调用
- (void)sendHasReadResponseForMessage:(EMMessage *)message; 方法，向 A发送 “已读”
如 A实现 IChatManagerDelegate 委托，会调用方法:
- (void)didReceiveHasReadResponse:(EMReceiptResp *)resp;

具体处理如下，
A收到消息后:从我们的 fireDict 中，通过 id ，查找该 message 是否存在 EMMessage *message = [fireDictobjectForKey:resp.chatId]; 此时如果存在，说明该消息是阅后即焚，且 B已读。
接下来就是 ui处理和db处理，
到目前为止，可以判断 B收到的消息是否为阅后即焚消息。
EMConversation *conversation = [[EaseMobsharedInstance].chatManager conversationForChatter:resp.from
isGroup:NO]; // 因为只有单聊中存在阅后即焚，所以 isGroup 始终为 NO
通过 resp.from 来查到 message 对应的 conversation ， [conversationremoveMessage:resp.chatId];
然后调用删除 message 的接口把它删掉，之后处理 ui 上的删除。 此时，阅后即焚功能就已经完成。


那些著名或非著名的 iOS 面试题(上) 1.如何追踪 app崩溃率，如何解决线上闪退
当 iOS 设备上的 App应用闪退时，操作系统会生成一个 crash 日志，保存在设 备上。crash 日志上有很多有用的信息，比如每个正在执行线程的完整堆栈 跟 踪信息和内存映像， 这样就能够通过解析这些信息进而定位 crash 发生时的代码 逻辑，从而找到 App 闪退的原因。通常来说， crash 产生来源于两种问 题:违 反 iOS 系统规则导致的 crash 和 App 代码逻辑 BUG导致的 crash ，下面分别对他 们进行分析。
违反 iOS 系统规则产生 crash 的三种类型:
(1) 内存报警闪退
当 iOS 检测到内存过低时，它的 VM系统会发出低内存警告通知，尝试回收一些 内存;如果情况没有得到足够的改善， iOS 会终止后台应用以回收更多内存;最
后，如果内存还是不足， 那么正在运行的应用可能会被终止掉。 在 Debug模式下， 可以主动将客户端执行的动作逻辑写入一个 log 文件中，这样程序童鞋可以 将
内存预警的逻辑写入该 log 文件，当发生如下截图中的内存报警时， 就是提醒当 前客户端性能内存吃紧，可以通过 Instruments 工具中的 Allocations 和
Leaks 模块库来发现内存分配问题和内存泄漏问题。 (2) 响应超时
当应用程序对一些特定的 事件(比如启动、挂起、恢复、结束)响应不及时， 苹果的 Watchdog机制会把应用程序干掉，并生成一份相应的 crash 日志。这些
事件与下列 UIApplicationDelegate 方法相对应，当遇到 Watchdog日志时，可
以检查上图中的几个方法是否有比较重的阻塞
1application:didFinishLaunchingWithOptions:
2applicationWillResignActive: 3applicationDidEnterBackground: 4applicationWillEnterForeground: 5applicationDidBecomeActive: 6applicationWillTerminate:
UI 的动作。
(3) 用户强制退出
一 看到“用户强制退出”，首先可能想到的双击
Home键，然后关闭应用程序。 不过这种场景一般是不会产生 crash 日志的， 因为双击 Home键后，所有的应 用
程序都处于后台状态， 而 iOS 随时都有可能关闭后台进程， 当应用阻塞界面并停 止响应时这种场景才会产生 crash 日志。这里指的“用户强制退出”场景， 是 稍微比较复杂点的操作: 先按住电源键， 直到出现“滑动关机”的界面时， 再按

 住 Home键，这时候当前应用程序会被终止掉，并且产生一份相应事件的 crash 日志。
应用逻辑的 Bug
大多数闪退崩溃日志的产生都是因为应用中的 Bug，这种 Bug的错误种类有很多，
比如:
SEGV:(Segmentation Violation ，段违例)，无效内存地址，比如空指 针，未初始化指针，栈溢出等;
SIGABR:T收到Abort信号，可能自身调用abort()或者收到外部发送过 来的信号;
SIGBUS:总线错误。与 SIGSEGV不同的是，SIGSEGV访问的是无效地址 (比 如虚存映射不到物理内存)，而 SIGBUS访问的是有效地址，但总线访问
异常(比如地址对齐问题);
SIGILL :尝试执行非法的指令，可能不被识别或者没有权限;
SIGFPE: Floating Point Error ，数学计算相关问题(可能不限于浮点计 算)，比如除零操作;
SIGPIPE:管道另一端没有进程接手数据;
常见的崩溃原因基本都是代码逻辑问题或资源问题， 比如数组越界， 访问野指针 或者资源不存在，或资源大小写错误等。
crash 的收集
如 果是在 windows 上你可以通过 itools 或 pp 助手等辅助工具查看系统产生的 历史 crash 日志，然后再根据 app 来查看。如果是在 Mac 系统上，只需要打开 xcode->windows->devices ，选择 device logs 进行查看，如下图，这些 crash 文件都可以导出来，然后再单独对这个 crash 文件做处理分析。
看日志

 市场上已有的商业软件提供 crash 收集服务，这些软件基本都提供了日志存储， 日志符号化解析和服务端可视化管理等服务:
Crashlytics ( www.crashlytics.com ) Crittercism ( www.crittercism.com ) Bugsense ( www.bugsense.com) HockeyApp ( www.hockeyapp.net ) Flurry( www.flurry.com )
开 源的软件也可以拿来收集 crash 日志，比如 Razor,QuincyKit (git 链接)等， 这些软件收集 crash 的原理其实大同小异，都是根据系统 产生的 crash 日志进
行了一次提取或封装， 然后将封装后的 crash 文件上传到对应的服务端进行解析 处理。很多商业软件都采用了 Plcrashreporter 这个开源工具来上传和解析 crash ，比如 HockeyApp,Flurry 和 crittercism 等。
crash 信息 由于自己的 crash 信息太长，找了一张示例:
1)crash 标识是应用进程产生 crash 时的一些标识信息， 它描述了该 crash 的唯 一标识( E838FEFB-ECF6-498C-8B35- D40F0F9FEA)E4，所发生的硬件设备类型
( iphone3,1 代表 iphone4 )，以及 App 进程相关的信息等; 2)基本信息描述的是 crash 发生的时间和系统版本;

 3)异常类型描述的是 crash 发生时抛出的异常类型和错误码; 4)线程回溯描述了 crash 发生时所有线程的回溯信息，每个线程在每一帧对应
的函数调用信息(这里由于空间限制没有全部列出);
5)二进制映像是指 crash 发生时已加载的二进制文件。以上就是一份 crash 日 志包含的所有信息， 接下来就需要根据这些信息去解析定位导致 crash 发生的代 码逻辑， 这就需要用到符号化解析的过程(洋名叫: symbolication) 。
解决线上闪退
首先保证，发布前充分测试。发布后依然有闪退现象，查看崩溃日志，及时修复 并发布。
2. 什么是事件响应链，点击屏幕时是如何互动的，事件的传递。
事件响应链
对于 IOS 设备用户来说，他们操作设备的方式主要有三种: 触摸屏幕、晃动设备、 通过遥控设施控制设备。对应的事件类型有以下三种:
1、触屏事件( Touch Event ) 2、运动事件( Motion Event )
3、远端控制事件( Remote-Control Event )

 Run Loop 的四个作用 :
使程序一直运行接受用户输入 决定程序在何时应该处理哪些 Event 调用解耦
节省 CPU时间
主线程的 run loop 默认是启动的。 iOS 的应用程序里面，程序启动后会有一个 如下的 main() 函数:
int main(int argc, char 1
*argv[])
{ 2
3
@autoreleasepool return
{ UIApplicationMain(argc,
class]));
argv, nil,
NSStri
4 ngFromClass([appDelegate
5
} }
6
重点是 UIApplicationMain()
函数，这个方法会为 NSRunLoop对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的
时候休息，需要让它干活的时候又能立马响应。
对其它线程来说， run loop 默认是没有启动的，如果你需要更多的线程交互则 可以手动配置和启动， 如果线程只是去执行一个长时间的已确定的任务则不需要。 在任何一个 Cocoa程序的线程中，都可以通过:
1NSRunLoop *runloop = [NSRunLoop currentRunLoop]; 来获取到当前线程的 run loop 。
一个 run loop 就是一个事件处理循环，用来不停的监听和处理输入事件并将其 分配到对应的目标上进行处理。
NSRunLoop是一种更加高明的消息处理模式， 他就高明在对消息处理过程进行了 更好的抽象和封装， 这样才能是的你不用处理一些很琐碎很低层次的具体消息的 处理，在 NSRunLoop中每一个消息就被打包在 input source 或者是 timer source 中了。使用 run loop 可以使你的线程在有工作的时候工作，没有工作的时候休 眠，这可以大大节省系统资源。
main thread 设置一个


6. 平常常用的多线程处理方式及优缺点
iOS有四种多线程编程的技术， 分别是:NSThread，CocoaNSOperation，GC(D全 称: Grand Central Dispatch ) ,pthread 。
四种方式的优缺点介绍 :
1)NSThread优点: NSThread 比其他两个轻量级。缺点:需要自己管理线程的
生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销。
2)Cocoa NSOperation 优点: 不需要关心线程管理， 数据同步的事情，可以把
精力放在自己需要执行的操作上。 Cocoa operation 相关的类是 NSOperation, NSOperationQueue.NSOperation 是个抽象类 , 使用它必须用它的子类， 可以实现 它或者使用它定义好的两个子类 : NSInvocationOperation 和 NSBlockOperation. 创建 NSOperation 子类的对象，把对象添加到 NSOperationQueue 队列里执行。
3)GCD(全优点 )Grand Central dispatch(GCD) 是 Apple 开发的一个多核编程的解 决方案。在 iOS4.0 开始之后才能使用。 GCD是一个替代 NSThread, NSOperationQueue,NSInvocationOperation 等技术的很高效强大的技术。
4) pthread 是一套通用的多线程 API，适用于 Linux\Windows\Unix, 跨平台，可 移植，使用 C 语言，生命周期需要程序员管理， IOS 开发中使用很少。
GCD线程死锁
GCD确实好用 ，很强大，相比 NSOpretion 无法提供 取消任务的功能。
如此强大的工具用不好可能会出现线程死锁。 如下代码:
1- (void)viewDidLoad{
2 [super viewDidLoad];
3 NSLog(@"=================4");
4 dispatch_sync(dispatch_get_main_queue(),
5 ^{ NSLog(@"=================5"); });
6 NSLog(@"=================6");
7}
GCD Queue分为三种:
1，The main queue :主队列，主线程就是在个队列中。
2，Global queues : 全局并发队列。
3，用户队列 : 是用函数 dispatch_queue_create 创建的自定义队列 dispatch_sync 和 dispatch_async 区别:

dispatch_async(queue,block) async 异步队列， dispatch_async 函数会立即 返回 , block 会在后台异步执行。
dispatch_sync(queue,block) sync 同步队列， dispatch_sync 函数不会立即返 回，及阻塞当前线程 , 等待 block 同步执行完成。
分析上面代码:
viewDidLoad 在主线程中， 及在 dispatch_get_main_queue() 中，执行到 sync
时 向 dispatch_get_main_queue() 插入 同步 threed 。sync 会等到 后面 block 执行完成才返回， sync 又再 dispatch_get_main_queue() 队列中，它是串行 队列，sync 是后加入的， 前一个是主线程， 所以 sync 想执行 block 必须等待 主线程执行完成， 主线程等待 sync 返回，去执行后续内容。 照成死锁， sync 等 待 mainThread 执行完成， mianThread 等待 sync 函数返回。下面例子:
1- (void)viewDidLoad{
2 3 4 5 6 7 8}
[super viewDidLoad]; dispatch_async(dispatch_get_global_queue(0,
NSLog(@"=================1"); dispatch_sync(dispatch_get_main_queue(),
NSLog(@"=================2"); }); NSLog(@"=================3"); });
0), ^{ ^{
程序会完成执行，为什么不会出现死锁。
首先: async 在主线程中 创建了一个异步线程 加入 全局并发队列， async 不
会等待 block 执行完成，立即返回，
1，async 立即返回， viewDidLoad 执行完毕，及主线程执行完毕。
2， 同时，全局并发队列立即执行异步 block ， 打印 1 ， 当执行到 sync 它 会等待 block 执行完成才返回， 及等待 dispatch_get_main_queue() 队列中
的 mianThread 执行完成， 然后才开始调用 block 。因为 1 和 2 几乎同时执 行，因为 2 在全局并发队列上， 2 中执行到 sync 时 1 可能已经执行完成或 等 了一会， mainThread 很快退出， 2 等已执行后继续内容。如果阻塞了主线程，
2 中的 sync 就无法执行啦， mainThread 永远不会退出， sync 就永远等待着。
7. 大量数据表的优化方案
1. 对查询进行优化， 要尽量避免全表扫描， 首先应考虑在 where 及 order by 涉
及的列上建立索引。
2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃 使用索引而进行全表扫描，如:

1select id from t where num is null
最好不要给数据库留 NULL，尽可能的使用 NOT NULL填充数据库 . 备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用 NULL。
不要以为 NULL 不需要空间，比如: char(100) 型，在字段建立时，空间就固定 了， 不管是否插入值( NULL也包含在内)，都是占用 100 个字符的空间的，如 果是 varchar 这样的变长字段， null 不占用空间。
可以在 num上设置默认值 0，确保表中 num列没有 null 值，然后这样查询: 1select id from t where num=0
3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索 引而进行全表扫描。
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一 个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如:
1select id from t where num=10 or Name='admin'
可以这样查询:
1select id from t where num=10 union all select id from t where Name='admin'
5.in 和 not in 也要慎用，否则会导致全表扫描，如: 1select id from t where num in (1,2,3) 对于连续的数值，能用 between 就不要用 in 了:
1select id from t where num between 1 and 3 很多时候用 exists 代替 in 是一个好的选择:
1select num from a where num in (select num from b)
用下面的语句替换:
1select num from a where exists (select 1 from b where num =a.num)
6. 下面的查询也将导致全表扫描:

1s elect id from t where name like ‘ %abc%’
若要提高效率，可以考虑全文检索。
7. 如果在 where 子句中使用参数， 也会导致全表扫描。 因为 SQL只有在运行时 才会解析局部变量， 但优化程序不能将访问计划的选择推迟到运行时; 它必须在 编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的， 因而无法作为索引选择的输入项。如下面语句将进行全表扫描:
1select id from t where num=@num
可以改为强制查询使用索引:
1select id from t with (index( 索引名)) where num=@num
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索 引而进行全表扫描。如:
1select id from t where num/2=100
应改为 :
1select id from t where num=100*2
9. 应尽量避免在 where 子句中对字段进行函数操作， 这将导致引擎放弃使用索引 而进行全表扫描。如:
select id from t 1abc 开头的 id
2select id from t
0 -–‘2015-11- 30’ 应改为 :
where substring(name,1,3)= ’abc’ -–name以
where datediff(day,createdate, -- 生成的 id
’2015-11- 30′)=
and createdat
select id from t where name like'abc%' 1
select id from t where createdate>='2005-11-30' 2
e<'2005-12-1'
10. 不要在 where 子句中的“ =”左边进行函数、算术运算或其他表达式运算，
否则系统将可能无法正确使用索引。
11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索 引中的第一个字段作为条件时才能保证系统使用该索引， 否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。
12. 不要写一些没有意义的查询，如需要生成一个空表结构:

1select col1,col2 into #t from t where1=0
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样:
1create table #t(,)
13.Update 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调
用会引起明显的性能消耗，同时带来大量日志。
14.对于多张大数据量(这里几百条就算大了)的表 JOIN，要先分页再 JOIN，否 则逻辑读会很高，性能很差。
15.select count(*) from table ;这样不带任何条件的 count 会引起全表扫描， 并且没有任何业务意义，是一定要杜绝的。
16. 索引并不是越多越好， 索引固然可以提高相应的 select 的效率， 但同时也 降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索 引，所以怎样建索引需要慎重考虑， 视具体情况而定。 一个表的索引数最好不要 超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
17. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列 的顺序就是表记录的物理存储顺序， 一旦该列值改变将导致整个表记录的顺序的 调整，会耗费相当大的资源。 若应用系统需要频繁更新 clustered 索引数据列， 那么需要考虑是否应将该索引建为 clustered 索引。
18. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会 降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接
时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
19. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存 储空间小，可以节省存储空间， 其次对于查询来说， 在一个相对较小的字段内搜 索效率显然要高些。
20. 任何地方都不要使用
1select * from t
用具体的字段列表代替“ * ”，不要返回用不到的任何字段。
21. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常 有限(只有主键索引)。
22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可 使用， 适当地使用它们可以使某些例程更有效， 例如， 当需要重复引用大型表或 常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。

23. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table ，避免造成大量 log ，以提高速度;如果数据量不大，为了
缓和系统表的资源，应先 create table ，然后 insert 。
24. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先
truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
25. 尽量避免使用游标， 因为游标的效率较差， 如果游标操作的数据超过 1 万行，
那么就应该考虑改写。
26. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决 问题，基于集的方法通常更有效。
27. 与临时表一样， 游标并不是不可使用。 对小型数据集使用 FAST_FORWAR游D 标通常要优于其他逐行处理方法， 尤其是在必须引用几个表才能获得所需的数据 时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。 如果开发 时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的 效果更好。
28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT O，N在结束时设置 SET NOCOUNT OF。F无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PRO消C息。
29. 尽量避免大事务操作，提高系统并发能力。
30. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合
理。
实际案例分析:拆分大的 DELETE或 INSERT语句，批量提交 SQL语句
如果你需要在一个在线的网站上去执行一个大的 DELETE或 INSERT 查询，你需 要非常小心， 要避免你的操作让你的整个网站停止相应。 因为这两个操作是会锁 表的，表一锁住了，别的操作都进不来了。
Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服 务器也不希望有太多的子进程， 线程和数据库链接， 这是极大的占服务器资源的
事情，尤其是内存。
如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站 点来说，这 30 秒所积累的访问进程 / 线程，数据库链接，打开的文件数，可能不 仅仅会让你的 WEB服务崩溃，还可能会让你的整台服务器马上挂了。
所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top) 条件是一个好的方法。 下面是一个 mysql 示例:
1while(1){// 每次只做 1000条

 mysql_query( “delete from logs where log_date < ’2015-11- 01’ limit 1000”);
usleep(50000)
}
8. 常用到的动画库
Facebook 开源动画库 Pop 的 GitHub 主页: facebook/pop · GitHub ，介绍: Playing with Pop (i)
Canvas 项目主页:Canvas – Simplify iOS Development，介绍:Animate in Xcode Without Code
拿 Canvas 来和 Pop 比其实不大合适， 虽然两者都自称 「动画库」 ，但是「库」 这个词的含义有所区别。 本质上 Canvas 是一个「动画合集」 而 Pop 是一个「动 画引擎」。
先 说 Canvas。Canvas 的目的是「 Animate in Xcode Without Code 」。开发者 可以通过在 Storyboard 中指定 User Defined Runtime Attributes 来实现一
些 Canvas 中预设的动画， 也就是他网站上能看到的那些。 但是除了更改动画的 delay 和 duration 基本上不能调整其他的参数。
Pop 就不一样了。如果说 Canvas 是对 Core Animation 的封装， Pop 则是对 Core Animation (以及 UIDynamics )的再实现。
Pop 语法上和 Core Animation 相似，效果上则不像 Canvas 那么生硬(时间四 等分，振幅硬编码)。这使得对 Core Animation 有了解的程序员可以很轻松地 把原来的「静态动画」转换成「动态动画」。
同时 Pop 又往前多走了一步。既然动画的本质是根据时间函数来做插值，那么 理论上任何一个对象的任何一个值都可以用来做插值，而不仅仅是 Core Animation 里定死的那一堆大小、 位移、旋转、缩放等 animatable properties 。
9. Restful 架构
REST是一种架构风格，其核心是面向资源， REST专门针对网络应用设计和开发 方式，以降低开发的复杂性，提高系统的可伸缩性。 REST提出设计概念和准则 为:
1. 网络上的所有事物都可以被抽象为资源 (resource)
2 3=
if(mysql_affected_rows() == 0){// 删除完成，退出!
4
5break;
6 }// 每次暂停一段时间，释放表让其他进程 / 线程访问。

2. 每一个资源都有唯一的资源标识 (resource identifier) ，对资源的操作不会 改变这些标识
3. 所有的操作都是无状态的
REST简化开发，其架构遵循 CRUD原则，该原则告诉我们对于资源 ( 包括网络资 源 ) 只需要四种行为:创建，获取，更新和删除就可以完成相关的操作和处理。 您可以 通过统一资源标识符( Universal Resource Identifier ，URI)来识别 和定位资源， 并且针对这些资源而执行的操作是通过 HTTP 规范定义的。 其核心 操作只有 GET,PUT,POST,DELE。TE
由于 REST强制所有的操作都必须是 stateless 的，这就没有上下文的约束，如 果做分布式， 集群都不需要考虑上下文和会话保持的问题。 极大的提高系统的可 伸缩性。
RESTful 架构:
(1)每一个 URI代表一种资源;
( 2)客户端和服务器之间，传递这种资源的某种表现层;
( 3)客户端通过四个 HTTP动词， 对服务器端资源进行操作， 实现”表现层状态 转化”。
10.请分析下SDWebImag的e原理
这个类库提供一个 UIImageView 类别以支持加载来自网络的远程图片。 具有缓存
管理、异步下载、同一个 URL下载次数控制和优化等特征。 SDWebImage加载图片的流程:
1. 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager根据 URL 开始处理图片。
2. 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo: ， 交给 SDImageCache从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
3. 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存， SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到
SDWebImageManag。er
4.SDWebImageManagerDelegate回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache等前端展示图片。

5. 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘 查找图片是否已经缓存。
6. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。 这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate: 。
7. 如果上一操作从硬盘读取到了图片， 将图片添加到内存缓存中 (如果空闲内存 过小，会先清空内存缓存)。 SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 。进而回调展示图片。
8. 如果从硬盘缓存目录读取不到图片， 说明所有缓存都不存在该图片， 需要下载 图片，回调 imageCache:didNotFindImageForKey:userInfo: 。
9. 共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。
10. 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、
下载完成和下载失败。
11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效 果。
12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。
13. 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI 。如果有 需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成， imageDecoder:didFinishDecodingImage:userInfo: 回调给
SDWebImageDownloade。r
15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager告知
图片下载完成。
16. 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17. 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到 硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18.SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台 的时候清理内存图片缓存，应用结束的时候清理过期图片。
19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便 使用。
20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。

SDWebImag库e的作用
通过对 UIImageView的类别扩展来实现异步加载替换图片的工作。
主要用到的对象:
1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调
2、 SDWebImageManag，er对图片进行管理的中转站，记录那些图片正在读取。
向下层读取Cache(调用SDImageCach)e，或者向网络读取对象(调用 SDWebImageDownloade)r 。
实现SDImageCache和SDWebImageDownloade的r回调。 3、SDImageCach，e根据URL的MD5摘要对图片进行存储和读取(实现存在内存
中或者存在硬盘上两种实现) 实现图片和内存清理工作。
4、SDWebImageDownloade，r根据 URL向网络读取数据(实现部分读取和全部读 取后再通知回调两种方式)
其他类: SDWebImageDecod，er异步对图像进行了一次解压?? 1、 SDImageCache是怎么做数据管理的?
SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。内存层面 的相当是个缓存器， 以 Key-Value 的形式存储图片。 当内存不够的时候会清除所 有缓存图 片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位， 剔除时间大于一周的图片文件。 当 SDWebImageManage向r SDImageCache要资源 时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从 磁盘读取出来，然后做 Decoder，将图片对 象放到内存层面做备份，再返回调 用层。
2、为啥必须做 Decoder??
由于 UIImage 的 imageWithData 函数是每次画图的时候才将 Data 解压成 ARGB 的图像，所以在每次画图的时候，会有一个解压操作，这样效率 很低，但是只 有瞬时的内存需求。为了提高效率通过 SDWebImageDecode将r包装在Data下的 资源解压，然后画在另外一张图片上， 这样这张新 图片就不再需要重复解压了。
这种做法是典型的空间换时间的做法。



 上海育创经典 iOS 面试题(二) :有关 SDWebImage 一、 clear 和 clean 的区别 ?
clear 先把之前的缓存文件夹删除掉 ,然后在新建一个文件夹
clean 先删除过期的文件 ,然后计算剩余缓存文件的大小 (currrentSize)>maxSize, 继续删除 , 按
照它缓存文件创建的时间删除 ,直到 (currrentSize)<=maxSize 二、内存缓存机制 ?
NSCache
三、使用缓存的目的 是为了使用的应用程序能更快速的响应用户输入，使程序高效的运行。
四、内存缓存时间是多久 ? 一周
五、 SDWeblmage 任务的执行 ?是怎么实现的 ? 两种 :先进先出和先进后出
实现 :依赖来实现的
六、默认的缓存路径 沙盒下的 default 下
七、怎么处理图片的名称 ? 对 URL 进行 MD5 加密
八、如何判读图片的首个字节 得到二进制的首个字节
十、 默认的超时时间是多少 ? 15 秒
十一、该框架内部对内存警告的处理方式 ? 监听系统发出的警告通知 ,然后清空内存缓存

十二、如何计算图片的成本 ? 长宽缩放比例 * 缩放比例
image.size.height * image.size.width * image.scale * image.scale
十三、保证错误的 URL 不会被尝试重新下载 因为内部设置了一个黑名单 (内部是 NSMutableset)
十四、最大的并发线程数是多少?
最大并发数是指执行任务的线程最多是两个 ,但是 ,处于回收状态的线程不算此列 .也就是说 , 执行任务的时候不只有两个线程 ,还有处于回收状态的线程 . 加起来最多也就六个。
十五、 ios允许最近本地通知数量最大为多少?
通知完一定要取消 , iOS 最多允许最近本地通知数量是 64 个 ,超过限制的本地通知将被忽略。
结语 :与 SDWebImage 相关的面试题差不多就这么多了 有遗漏的或者有错误的地方，欢迎小伙伴们在北风社区进行补充和斧正。





上海育创 iOS 经典面试题(三) 一 . CALayer 和 UIView 的区别联系
(1) UIView 是 UIKIt 的只能在 iOS 使用 , CALayer 是 QuartzCore 的 iOS 和 mac os 通用 (2) CALayer 比 UIView 更加轻量级 ,但是可以实现同样的效果
(3)UIView 的 CALayer 类似 UIView 的子 View 树形结构
(4)UIView 比 CALayer 多了一个事件处理功能 ,也就是说 UIView 能处理用户触摸
( 5) UIView 有个重要的属性 layer, 可以返回它的主 CALayer 实例 .CALayer *layer = myView.layer
(6)坐标系统 : CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性
(7) UIView 是 iOS 系统中界面的基本元素 ,所有的界面元素都是继承自它 .它本身完全是由
CoreAnimation 来实现的 .它真正的绘图部分 ,是由一个 CALayer 类来管理的 .UIView 本身更像 是一个 CALayer 的管理权 ,访问它的跟绘图和跟坐标有关的属性 ,如 frame,bounds 等 ,实际上内
部都是在访问它所包含的 CALayer 的相关属性 .
layer 可以设置圆角显示 cornerRadius 也可以设置阴影 shadowColor 但是如果 layer 中某个
layer 设置了圆角 中所有 layer 的阴影效果将都不显示 .因此要死设置有圆角还要阴影 ,可以 做两个 UIView 重叠 ,一个 layer 显示圆角一个 layer 显示阴影
( 8)渲染:当更新层 改变不能立即显示在屏幕上 .当所有的层都准备好时 , 可以调用 setNeedsDisplay 方法来重绘显示 .
( 9 )变换:要在一个层中添加一个 3D 或仿射变换 , 可以分别设置层的 transform 或者 affineTransform 属性
( 10 )变形: Quartz Core 的渲染能力 使二维图像可以被自由的操纵 ,就像是三维的 .图像可 以在一个三维坐标系中以任意的角度被旋转 缩放 和倾斜 .CATransform3D 的一套方法提供 了一些魔术般的效果。
二. 简述同步和异步
同步 :串行的执行任务 异步 : 并行的执行任务 .同步函数不具备开启线程的能力 , 而异步函数 具备
所谓同步 ,就是在发出一个调用时 ,在没有得到结果之前
就得到返回值了 . 也就是 由调用者主动等待这个调用结果
而异步则是相反 , 调用在发出之后 ,这个调用就直接返回了
当一个
三. 多线程安全怎么控制 ? 用互斥锁 ,队列组 ,栅栏函数 ,依赖
四. 简要说明什么时候使用继承 ,什么时候使用类别
在 OC 中 ,一个类继承另一个类 ,就是继承了父类所有的属性和方法 ,并且可以扩充自己的属性 而类别是在不改变原有类的基础上进行方法扩充 ;
因此 ,根据开发需求 ,如果这个类需要扩充属性 ,或者需要重写系统的类的某些方法 ,用继承 ;如 果只是对一个类扩充接口和模块 , 使用类别更加方便 .
五. 简述苹果的安全机制
(1)数字签名机制:在 iOS 中运行的 App 必须拥有自己的数字签名，而数字签名来与开发
:
, 该调用就不返回 .但是一旦调用返回
,
,所以没有返回结果
.换句话说就是

者的数字证书; 开发者需要加入 "iOS 开发者计划 "才能获取证书， 而且其开发的 App 还要经 过严格的审查才能在 AppStore 上架，保证了 App 的安全;杜绝了第三方和未签名 App 的运 行;
(2)沙盒保护机制: 这种机制使得设备内的各个 App 之间无法直接进行交流， 只能通过 iOS 来进行数据传递;虽然降低了系统的扩展性但是却保证了安全性;
不要使用越狱 ,否则苹果的安全机制就功亏一篑 ; 只从 AppStore 获取 App;
首次连接计算机 ,不要随意点 "信任 "; 不要随意给某个 App 设置隐私读取权限 ;
六 关键字 const 有什么含意 ?修饰类呢 ?static 的作用 , 用于类呢 ?还有 extern c 的作用 ?
当使用 当使用
当使用
const 修饰基数数据类型变量时 ,该变量就变为常量 ,进入静态区 const 修饰指针类型变量时 :
const 在指针类型两边 , 那么该指针变量指向的内存空间的内容就不能改变了 ,但指针
的指向可以改变 .
如果 const 在变量的左边 , 那么该指针的指向不能改变了 ,而指向内存空间的内容可以改变
当使用 const 修饰符时 ,const NSSting *str, 相当于修饰该对象 ,表示对象是不可更改的 .
static 修饰变量 ,表示这个内部全局变量 ,只能在本文件中访问 .系统会将该变量放进静态区
的生命周期被延长到了程序结束
static 修饰类 , 表示这个内部的方法 , 只能在本文件中访问 .
extern c 表示声明了一外部变量 , 多个外部变量如果同名 ,实际指向的是同一块存储空间
, 它

十六 . NSTimer 和 GCD 的定时器有什么区别
NSTimer 可以调用 invalidate 进行撤销 ,创建和撤销必须在同一线程
NSTimer 需要交定时器添加到当前的 runloop 中 它的时间单位是秒
GCD 一旦执行就不能撤销
CGD 中的定时器不受 runloop 模式的影响
时间单位是纳秒
十七 . 应用程序的沙盒下 ,都有哪些文件夹 ?它们有什么特点 ?本地缓存一般存在哪个文件
下?
1 Documents
将应用程序的数据文件保存在该目录下 .不过这些数据类型仅限于不可以再生的数据 ,可再生 的数据文件应该存在 LIbrary/Cache 下
2 Library 它有两个子文件
caches 主要是缓存文件 ,用户使用过程中缓存都可以保存在这些目录中 .保存那些可再生的
文件 ,比如网络数据请求 .因此 ,应用程序通常还需要负责删除这些文件 .
Preferences 应用程序的偏好设置文件 . 我们使用 NSUserDefaults 写的设置数据都会保存到
该目录下的一个 plist 文件中 它会被 iTunes 同步 3. tmp
各种临时文件 , 保存应用再次启动时不需要的文件 将其删除 ,因为该目录下的东西随时有可能被系统清除
统磁盘存储空间不足的时候
.而且 ,当应用不在需要这些文件时应主动 ,目前已知的一种可能清理的原因是系

二十 . plist 和 pct 文件的好处 ?
plist 文件以便用来储存数组或者字典 ,它是 iOS 中特有的存储方式 .它可以将数据与代码隔离

开 , 更便于数据的管理和展示 .
pch 里面可以保存一些全局的宏和头文件 .
pct 是预编译头文件 , 其中存放有工程中已有编译的部分代码 编译这些代码 .
pct 头文件的内容能被项目中的其他所有源文件共享访问 存放一些全局的宏 (整个项目都用得上的宏 )
用来包含一些全部的头文件 (整个项目都用得上的头文件 能自动打开或者关闭日志的输出功能
pct 弊端 : 每个文件都会导入 ,有效率问题 .
; 在以后建立工程时就不用重新
)



16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系， 并且 reciever 可以返回值 给 sender ，notification 可以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。
17 什么是 KVC 和 KVO ?答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 setValue 的时候，( 1)首先根据方法名找到运行方法的时候所需要的环境参数。( 2 )他
会从自己 isa 体的方法实现。
被观察对象的
指针结合环境参数，找到具体的方法实现的接口。( 3 )再直接查找得来的具 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，
isa 指针被修改的时候， isa 指针就会指向一个中间类，而不是真实的类。所

以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于 isa 指针。 在调用类的方法的时候，最好要明确对象实例的类名
18ViewController 的 loadView, viewDidLoad, viewDidUnload 分别是在什么时候调用的? 在自定义 ViewController 的时候这几个函数里面应该做什么工作?答: viewDidLoad 在
view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。此方法在编 程实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release, 如果是 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。
19
"NSMutableString *" 这个数据类型则是代表
的。
而 NSString 只是对象的指针而已。
面向过程就是分析出解决问题所需要的步骤，
时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象， 为了描叙某个事物在整个解决问题的步骤中的行为。;
20 类别的作用
类别主要有 3 个作用:
(1)将类的实现分散到多个不同文件或多个不同框架中。
(2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。
类别的局限性
有两方面局限性:
(1)无法向类中添加新的实例变量，类别没有位置容纳实例变量。 (2)名称冲突，即当类别中的方法与原始类方法名称冲突时，类别具有更高的优先级。类别 方法将完全取代初始方法从而无法再使用初始方法。 无法添加实例变量的局限可以使用字典对象解决
21 关键字 volatile 有什么含意 ? 并给出三个不同的例子:
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假 设这个变量的值了。精确地说就是，优化器在用到 这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。 下面是 volatile 变量的几个例子:
"NSMutableString" 对象本身，这两者是有区别
然后用函数把这些步骤一步一步实现， 使用的
建立对象的目的不是为了完成一个步骤， 而是

? 并行设备的硬件寄存器(如:状态寄存器) ?一个中断服务子程序中会访问到的非自动变量 ? 多线程应用中被几个任务共享的变量
? 一个参数既可以是 const 还可以是 volatile ? 一个指针可以是 volatile 吗?解释为什么。
(Non-automatic variables)
吗?解释为什么。
下面是答案:
? 是的。一个例子是只读的状态寄存器。它是
const 因为程序不应该试图去修改它。 ?是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个
针时。
22@synthesize 是系统自动生成 getter 和 setter 属性声明
@dynamic 是开发者自已提供相应的属性声明
@dynamic 意思是由开发人员提供相应的代码: 对于只读属性需要提供
性需要提供 setter 和 getter 。@synthesize 意思是， 除非开发人员已经做了， 否则由编译器 生成相应的代码，以满足属性声明。
查阅了一些资料确定 @dynamic 的意思是告诉编译器 ,属性的获取与赋值方法由用户自己实 现, 不自动生成。


类别的作用?继承和类别在实现中有何区别?
答案: category 可以在不获悉， 不改变原来代码的情况下往里面添加新的方法， 不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。
25 .Difference between categories and extensions?
只能添加，
因为类别具有更
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须
要实现的。
extensions 可以认为是一个私有的 Category 。
26 .Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接
口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 ―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法， 你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协 议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。

26 What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用
存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
} }
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的道理 是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
―当通过 KVC 调用对象时， 比如: [self valueForKey:@
‖ someKe时y，‖]程序会自动试图通过 someKey 这个方法，如果没找到，
iVar )，如果还没有找到，程序会继续
几种不同的方式解析这个调用。首先查找对象是否带有
会继续查找对象是否带有 someKey 这个实例变量(
试图调用 -(id) valueForUndefinedKey: 这个方法。 如果这个方法还是没有被实现的话， 程序 会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注:Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方 法，还会查找 getsomeKey 这个方法，前面加一个 get，或者 _someKey 以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请 求值时， 对象能够在错误发生前， 有最后的机会响应这个请求。 这样做有很多好处， 下面的 两个例子说明了这样做的好处。 ―

来至 cocoa ，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们只是 add 一个 相关的 keypath 就行了，
27What is purpose of delegates?
代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
28What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。
答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的， 后者可 以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动态运行时语言是什么意思? 答案:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~
30 what is difference between NSNotification and protocol?
通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的 行为模式，我们大致可以有自己的理解
以及调用该类别对象指
意思就是假设生物类 ( life )
eat ，但是调用是我们只需
eat 这个选择器)。

简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候 一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。


36 NSOperation queue?
答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发 的问题。
网上部分资料提到一点是，虽然是 queue ，但是却并不是带有队列的概念，放入的操作并 非是按照严格的先进现出。
这边又有个疑点是， 对于队列来说， 先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也 进入队列， Afunc 先执行这个是必然的，
但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概念离乱上 有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认为这还是一个队
列。
但是后来看到一票关于这操作队列话题的文章，其中有一句提到 ―因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。 ‖ 瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
37What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。
也可以理解成延时加载。
我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。

38 Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制器中嵌入两个 tableview 控制器?
答案:一个视图控制只提供了一个 View 视图，理论上一个 tableViewController 也不能放吧， 只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，如果不是我们定性思维认
为的 UIViewController ，
而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图控制者， 它可以控制多个视 图控制器，比如 TabbarController
那样的感觉。
39 Can we use one tableview with two different datasources? How you will achieve this?
一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案: 首先我们从代码来看， 数据源如何关联上的， 其实是在数据源关联的代理方法里实现 的。
因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的需要去设置 如相关的数据源。
因此， 我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢?想让列表如何显 示，不同的数据源分区块显示?
40id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object 的一个指针，这
个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject )类的对象。需 要注意的是 id 是一个指针，所以你在使用 id 的时候不需要加星号。比如 id foo=nil 定义了
一个 nil 指针，这个指针指向 NSObject 的一个任意子类。 而 id *foo=nil 则定义了一个指针， 这个指针指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C 语言的 NULL 相同，在 objc/objc.h 中定义。 nil 表示一个 Objctive-C 对象，这个对 象的指针指向空(没有东西就是空)。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类 (是 Class ，而不是对象) 。 SEL 是―selector ‖的一个类型，表示一个方法的名字
Method (我们常说的方法)表示一种类型，这种类型与 selector 和实现 (implementation) 相关

IMP 定义为 id (* IMP ) ( id, SEL , ⋯)。这样说来， IMP 是一个指向函数的指针，这个被指向 的函数包括 id( ―self ‖指针 ) ，调用的 SEL (方法名)，再加上一些其他参数 . 说白了 IMP 就是 实现方法。
41 层和 UIView 的区别是什么?
答:两者最大的区别是 , 图层不会直接渲染到屏幕上， UIView 是 iOS 系统中界面元素的基础， 所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图 部分，是由一个 CALayer 类来管理。UIView 本身更像是一个 CALayer 的管理器。一个 UIView 上可以有 n 个 CALayer ，每个 layer 显示一种东西，增强 UIView 的展现能力。
42GCD 为 Grand Central Dispatch 的缩写。 Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的较新的解决方法。在 Mac OS X 10.6 雪豹中首次推出，并在 最近引入到了 iOS4.0 。 GCD 是一个替代诸如 NSThread 等技术的很高效和强大的技术。 GCD 完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。
GCD 可以完成很多事情， 但是这里仅关注在 iOS 应用中实现多线程所需的一些基础知识。 在开始之前，需要理解是要提供给 GCD 队列的是代码块，用于在系统或者用户创建的的队 列上调度运行。 声明一个队列
如下会返回一个用户创建的队列:
dispatch_queue_t myQueue = dispatch_queue_create("com.iphonedevblog.post",
NULL); 其中，第一个参数是标识队列的， 第二个参数是用来定义队列的参数 (目前不支持，
因此传入 NULL )。 执行一个队列
 如下会异步执行传入的代码:
dispatch_async(myQueue, ^{ [self doSomething]; });
其中， 首先传入之前创建的队列， 然
后提供由队列运行的代码块。
声明并执行一个队列 如果不需要保留要运行的队列的引用，可以通过如下代码实现之前的功能:
dispatch_async(dispatch_queue_create ("com.iphonedevblog.post", NULL), ^{ [self doSomething]; }); 如果需要暂停一个队列，可以调用如下代码。暂停一个队列会阻止和
该队列相关的所有代码运行。 dispatch_suspend(myQueue); 暂停一个队列 如果暂停一个队列不要忘记恢复。 暂停和恢复的操作和内存管理中的 retain 和 release 类似。 调用 dispatch_suspend 会增加暂停计数，而 dispatch_resume 则会减少。队列只有在暂停 计数变成零的情况下才开始运行。 dispatch_resume(myQueue); 恢复一个队列 从队列

 中在主线程运行代码 有些操作无法在异步队列运行，因此必须在主线程(每个应用都 有一个)上运行。 UI 绘图以及任何对 NSNotificationCenter 的调用必须在主线程长进行。 在另一个队列中访问主线程并运行代码的示例如下: dispatch_sync(dispatch_get_main_queue(), ^{ [self dismissLoginWindow]; }); dispatch_suspend (以及 dispatch_resume )在主线程上不起作用。
使用 GCD ，可以让你的程序不会失去响应 . 多线程不容易使用，用了 单。你无需专门进行线程管理 , 很棒!
dispatch_queue_t t1= dispatch_queue_create ("1", NULL ); dispatch_queue_t t2= dispatch_queue_create ("2" , NULL );
注意，
GCD ，会让它变得简
dispatch_async [self print1 ];
}); dispatch_async
[self print2 ]; });
(t1, ^{
(t2, ^{
43Provider 是指某个 iPhone 软件的 Push 服务器，这篇文章我将使用 Provider 。
.net 作为
APNS 是 Apple Push Notification Service ( Apple Push 服务器) 的缩写， 是苹果的服务器。 上图可以分为三个阶段。
第一阶段: .net 应用程序把要发送的消息、目的 iPhone 的标识打包，发给 APNS 。 第二阶段:APNS 在自身的已注册 Push 服务的 iPhone 列表中，查找有相应标识的 iPhone ， 并把消息发到 iPhone 。
第三阶段: iPhone 把发来的消息传递给相应的应用程序，并且按照设定弹出 Push 通知。 http://blog.csdn.net/zhuqilin0/article/details/6527113 // 消息推送机制 看内存泄露时候:在搜索中搜索 run 找到 Run Static Snalyzer .
44. 可扩展标记语言 extensible markup language;XML
2. 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一
种允许用户对自己的标记语言进行定义的源语言。
3，数据库提供了更强有力的 数据存储 和分析能力，例如:数据索引、排序、查找、相关一
致性等， XML 仅仅是存储数据。

 4.XML 与 HTML 的设计区别是: XML 的核心是数据， 其重点是数据的内容。 而 HTML 被设 计用来显示数据，其重点是数据的显示。
5.XML 和 HTML 语法区别: HTML 的标记不是所有的都需要成对出现， XML 则要求所有的 标记必须成对出现; HTML 标记不区分大小写， XML 则大小敏感 ,即区分大小写。
结合
XML 的简单使其易于在任何应用 程序 中读写数据， 这使 XML 很快成为数据交换的唯一
公共语言， 虽然不同的 应用软件 也支持其它的数据交换格式， 但不久之后他们都将支持 XML ， 那就意味着程序可以更容易的与 Windows,Mac OS,Linux 以及其他平台下产生的信息结合，
然后可以很容易加载 XML 数据到程序中并分析他，并以 XML 格式输出结果。
XML 去掉了之前令许多开发人员头疼的 SGML (标准通用标记语言)的随意语法。在
XML 中，采用了如下的语法:
1 任何的起始标签都必须有一个结束 标签 。
2 可以采用另一种简化语法， 可以在一个标签中同时表示起始和结束标签。 这种语法是 在大于符号之前紧跟一个斜线 ( / )，例如 <tag/ > 。XML 解析器会将其翻译成 <tag></tag> 。
3 标签必须按合适的顺序进行 嵌套 ，所以结束标签必须按 镜像 顺序匹配起始标签， 例如 this is a sample string 。这好比是将起始和结束标签看作是数学中的左右括号: 在没有关闭
所有的内部括号之前，是不能关闭外面的括号的。 4 所有的特性都必须有值。
5 所有的特性都必须在值的周围加上双引号。 45union u
{
double a;
int b; };
union u2 {
char a[13];
int b; };

union u3 {
char a[13];
char b; };
cout<<sizeof(u)<<endl; // 8 cout<<sizeof(u2)<<endl; // 16 cout<<sizeof(u3)<<endl; // 13
都知道 union 的大小取决于它所有的成员中，
于 u 来说，大小就是最大的 double 类型成员 a 了，所以 sizeof(u)=sizeof(double)=8 。但是 对于 u2 和 u3，最大的空间都是 char[13] 类型的数组，为什么 u3 的大小是 13，而 u2 是 16 呢?关键在于 u2 中的成员 int b 。由于 int 类型成员的存在，使 u2 的对齐方式变成 4，也就
是说，u2 的大小必须在 s1
{
char a;
double b; int c; char d;
};
struct s2 {
char a; char b; int c; double d;
};
4 的对界上， 所以占用的空间变成了
16(最接近
13 的对界) 。struct
占用空间最大的一个成员的大小。 所以对

cout<<sizeof(s1)<<endl; // 24 cout<<sizeof(s2)<<endl; // 16
同样是两个 char 类型，一个 int 类型，一个 double 类型，但是因为对界问题，导致他
们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下:首先， 断结构体的对界， 根据上一节的结论， s1 和 s2 的对界都取最大的元素类型， 类型的对界 8 。然后开始摆放每个元素。
对于 s1，首先把 a 放到 8 的对界，假定是 0，此时下一个空闲的地址是
个元素 d 是 double 类型，要放到 8 的对界上，离 1 最接近的地址是 8 了，所以 d 被放在了
8，此时下一个空闲地址变成了 16，下一个元素 c 的对界是 4，16 可以满足，所以 c 放在 了 16 ，此时下一个空闲地址变成了 20 ，下一个元素 d 需要对界 1，也正好落在对界上，所
以 d 放在了 20 ，结构体在地址 21 处结束。由于 s1 的大小需要是 8 的倍数，所以 21- 23 的空间被保留， s1 的大小变成了 24 。
对于 s2，首先把 a 放到 8 的对界，假定是 0，此时下一个空闲地址是 1，下一个元素 的对界也是 1 ，所以 b 摆放在 1 ，下一个空闲地址变成了 2 ;下一个元素 c 的对界是 4，所
以取离 2 最近的地址 4 摆放 c ，下一个空闲地址变成了 8 ，下一个元素 d 的对界是 8 ，所以 d 摆放在 8，所有元素摆放完毕， 结构体在 15 处结束， 占用总空间为 16 ，正好是 8 的倍数。
46 ASIDownloadCache 设置下载缓存
它对 Get 请求的响应数据进行缓存(被缓存的数据必需是成功的
[ASIHTTPRequest setDefaultCache:[ASIDownloadCache sharedCache]];
当设置缓存策略后，所有的请求都被自动的缓存起来。 另外，如果仅仅希望某次请求使用缓存操作，也可以这样使用: ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url]; [request setDownloadCache:[ASIDownloadCache sharedCache]];
200 请求):
缓存存储方式
你可以设置缓存的数据需要保存多长时间， ASIHTTPRequest a，ASICacheForSessionDurationCacheStoragePolicy ，默认策略，基于 session 的缓存数 据存储。当下次运行或 [ASIHTTPRequest clearSession] 时，缓存将失效。
b， ASICachePermanentlyCacheStoragePolicy ，把缓存数据永久保存在本地，
提供了两种策略:
CPU 判 也就是 double
1，但是下一

如:
ASIHTTPRequest *request = [ ASIHTTPRequest requestWithURL:url ];
[ request setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy ];
47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议， 由于其简捷、快速的方式，适用于分布式超媒 体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基于
TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速:客户向服务器请求服务时， 只需传送请求方法和路径。
HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于
得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活:HTTP 允许传输任意类型的数据对象。 正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
48 URL
HTTP URL (URL 是一种特殊类型的 URI 是他的子类， 包含了用于查找某个资源的足够的信
息 ) 的格式如下:
错误 ! 超链接引用无效。 ]
http 表示要通过 HTTP 协议来定位网络资源; host 表示合法的 Internet 主机域名或者 IP 地 址; port 指定一个端口号，为空则使用缺省端口 80 ; abs_path 指定请求资源的 URI ;如果 URL 中没有给出 abs_path ，那么当它作为请求 URI 时，必须以 ―的/ ‖形式给出，通常这个工 作浏览器自动帮我们完成。
49TCP/UDP 区别联系
请求方法常用的有 GET 、 HTTP 协议简单，使
Content-Type 加以标记。

 TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能 建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包;
2. 主机 B 向主机 A 发送同意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收， 协调工作)的数据包; 3. 主机 A 再发出一个数据包确认主机 B 的要求同步: ―我现在就发， 你接着吧! ‖，这是第三次对话。三次 ―对话 ‖的目的是使数据包的发送和接收同步， 经过三次
―对话 ‖之后，主机 A 才向主机 B 正式发送数据。
UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协议。它是面向非连接
的协议，它不与对方建立连接，而是直接就把数据包发送过去! 少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接 传输可靠性可靠不可靠 应用场合传输大量数据少量数据 速度慢快
50 socket 连接和 http 连接的区别
简单说， 你浏览的网页 (网址以 http:// 开头 )都是 http 协议传输到你的浏览器的
于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层
ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
UDP 适用于一次只传送
, 而 http 是基
连接的

Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接:http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read
–> 关闭 close ‖模式来操作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一 种特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数 我们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样 的话，如果没有应用层， 便无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用 到应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自己定义应用 层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信
的能力。 )
2 )Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数
接口。
51 什么是 TCP 连接的三次握手

 第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过 ―四次握手 (‖过程就不细写了， 就是服务器和客户端交互， 最终确定断开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址
和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。
53 进程与线程
进程( process )是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为
一些功能单元。
进程中所包含的一个或多个执行单元称为线程( thread )。进程还拥有一个私有的虚拟地址 空间，该空间仅能被它所包含的线程访问。

 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。 在引入线程的操作系统中， 通常都是把进程作为分配资源的基本单位， 而把线程作为独立运 行和独立调度的基本单位。
由于线程比进程更小， 基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多， 能 更高效的提高系统内多个程序间并发执行的程度。
简而言之 ,一个程序至少有一个进程 , 一个进程至少有一个线程
个程序中的多个任务则被称为线程。
线程只能归属于一个进程并且它只能访问该进程所拥有的资源。 该进程会自动申请一个名为主线程或首要线程的线程。应用程序(
多个相互协作的进程组成的。
另外， 进程在执行过程中拥有独立的内存单元， 而多个线程共享内存， 从而极大地提高了程 序的运行效率。
线程在执行过程中与进程还是有区别的。 每个独立的线程有一个程序运行的入口、 顺序执行 序列和程序的出口。 但是线程不能够独立执行， 必须依存在应用程序中， 由应用程序提供多
个线程执行控制。
从逻辑角度来看， 多线程的意义在于一个应用程序中， 有多个执行部分可以同时执行。 但操
作系统并没有将多个线程看做多个独立的应用， 来实现进程的调度和管理以及资源分配。 就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动 , 进程是系统进行资源 分配和调度的一个独立单位 .
线程是进程的一个实体 ,是 CPU 调度和分派的基本单位 ,它是比进程更小的能独立运行的基 本单位 .线程自己基本上不拥有系统资源 ,只拥有一点在运行中必不可少的资源 (如程序计数 器 , 一组寄存器和栈 ), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 . 一个线程可以创建和撤销另一个线程 ;同一个进程中的多个线程之间可以并发执行 .
54 多线程
多线程编程是防止主线程堵塞， 增加运行效率等等的最佳方法。 而原始的多线程方法存在很
多的毛病，包括线程锁死等。在 Cocoa 中， Apple 提供了 NSOperation 这个类，提供了一 个优秀的多线程编程方法。
本次介绍 NSOperation 的子集，简易方法的 NSInvocationOperation :
这
.一个程序就是一个进程， 而一
当操作系统创建一个进程后， application )是由一个或

 一个 NSOperationQueue 操作队列，就相当于一个线程管理器，而非一个线程。因为你可 以设置这个线程管理器内可以并行运行的的线程数量等等
55oc 语法里的 @perpoerty 不用写 @synzhesize 了，自动填充了。并且的 _name; 写方法时候不用提前声明。 llvm 全局方法便利。
枚举类型。 enum hello:Integer{ } 冒号后面直接可以跟类型，以前是: enum hello{} 后面在指定为 Integer .
桥接。 ARC 自动 release retain 的时候 CFString CFArray . Core Fountion. 加上桥接 _brige 才能区分 CFString 和 NSString 而现在自动区分了，叫固定桥接。
下拉刷新封装好了。
UICollectionViewController. 可以把表格分成多列。
Social Framework( 社交集成 ) UIActivityViewController 来询问用户的社交行为
缓存:就是存放在临时文件里，比如新浪微博请求的数据， 值。
和图片，下次请求看这里有没有
56Singleton (单例模式)，也叫单子模式，是一种常用的软件设计模式。在应用这个 模式时，单例对象的类必须保证只有一个实例存在。
代码如下:
static ClassA *classA = nil
+ (ClassA *)sharedManager
{
@synchronized(self) {
if (!classA) {
classA = [[super allocWithZone:NULL]init]; }
return classA;
}
}
+ (id)allocWithZone:(NSZone *)zone {
; //静态的该类的实例

return [[self sharedManager] retain]; }
- (id)copyWithZone:(NSZone *)zone { return self;
}
- (id)retain {
return self;
}
- (NSUIntger)retainCount {
return NSUIntgerMax;
}
- (oneway void)release { }
- (id)autorelease { return self;
}
-(void)dealloc{
}
57 请写一个 C 函数，若处理器是 Big_endian 的，则返回 0;若是 Little_endian 的，
则返回 1 int checkCPU( ) {
{
union w
{
int a;
char b; } c;
c.a = 1;
return (c.b ==1); }
12 怎样防止指针的越界使用问题 ? 必须让指针指向一个有效的内存地址 ,
1 防止数组越界
 2 防止向一块内存中拷贝过多的内容
  3 防止使用空指针
4 防止改变 const 修改的指针
5 防止改变指向静态存储区的内容
6 防止两次释放一个指针 7 防止使用野指针 .
13 指针的类型转换
指针转换通常是指针类型和 void * 类型之前进行强制转换 ,从而与期望或返回 void 指针的函 数进行正确的交接 .
63static 有什么用途?(请至少说明两种) 1. 限制变量的作用域
2. 设置变量的存储域
7. 引用与指针有什么区别?
1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。 2) 不存在指向空值的引用，但是存在指向空值的指针。
8. 描述实时系统的基本特性
    在特定时间内完成特定的任务，实时性与可靠性
64 全局变量和局部变量在内存中是否有区别?如果有，是什么区别? 全局变量储存在静态数据库，局部变量在堆栈
10. 什么是平衡二叉树? 左右子树都是平衡二叉树且左右子树的深度差值的绝对值不大于 1
65 堆栈溢出一般是由什么原因导致的? 没有回收垃圾资源
13. 冒泡排序算法的时间复杂度是什么? O(n^2)
if(x>0.000001&&x<-0.000001)
16. Internet 采用哪种网络协议?该协议的主要层次结构? tcp/ip 应用层 /传输层 /网络层 /数据链路层 / 物理层
17. Internet 物理地址和 IP 地址转换采用什么协议? ARP (Address Resolution Protocol) (地址解析協議) 18.IP 地址的编码分为哪俩部分?
IP 地址由两部分组成，网络号和主机号。不过是要和
―子网掩码 ‖按位与上之后才能
分哪些是网络位哪些是主机位。
2.用户输入 M,N 值，从 1 至 N 开始顺序循环数数，每数到
M 输出该数值，直至全
部输出。写
出 C 程序。
而
循环链表，用取余操作做
3. 不能做 switch() 的参数类型是: switch 的参数不能为实型。

1 、局部变量能否和全局变量重名?
答:能，局部会屏蔽全局。要用全局变量，需要使用 "::" 局部变量可以与全局变量同名， 在函数内引用这个变量时， 会用到同名的局部变量，
不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局 部变
量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就 在那
个循环体内
2 、如何引用一个已经定义过的全局变量?
答: extern
可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用
某个
    在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如
果你
用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而接期间报错
3、全局变量可不可以定义在可被多个 .C 文件包含的头文件中?为什么? 答:可以，在不同的 C 文件中以 static 形式来声明同名全局变量。
可以在不同的 C 文件中声明同名的全局变量， 前提是其中只能有一个 C 文件中对此
变量赋
    初值，此时连接不会出错
4 、语句 for( ; 1 ; )有什么问题?它是什么意思? 答:和 while(1) 相同。
5 、 do⋯⋯ while 和 while ⋯⋯ do 有什么区别? 答:前一个循环一遍再判断，后一个判断以后再循环
661.IP Phone 的原理是什么 ? IPV6
2.TCP/IP 通信建立的过程怎样，端口有什么作用? 三次握手，确定是哪个应用程序使用该协议
3.1 号信令和 7 号信令有什么区别，我国某前广泛使用的是那一种?
4.列举 5 种以上的电话新业务? 微软亚洲技术中心的面试题!!!
1 .进程和线程的差别。
线程是指进程内的一个执行单元 ,也是进程内的可调度实体 . 与进程的区别 :
(1) 调度:线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2) 并发性: 不仅进程之间可以并发执行， 同一个进程的多个线程之间也可并发执行 (3) 拥有资源:进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问
隶属于进程的资源 .
(4) 系统开销:在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统 的开
销明显大于创建或撤消线程时的开销。 2. 测试方法
人工测试:个人复查、抽查和会审 机器测试:黑盒测试和白盒测试

 2.Heap 与 stack 的差别。
Heap 是堆， stack 是栈。
Stack 的空间由操作系统自动分配 /释放， Heap 上的空间手动分配 / 释放。 Stack 空间有限， Heap 是很大的自由存储区
C 中的 malloc 函数分配的内存空间即在堆上
    程序在编译期对变量和函数分配内存都在栈上进行参数的
传递也在栈上进行
3 . Windows 下的内存是如何管理的?
4.介绍 .Net 和.Net 的安全性。
5.客户端如何访问 .Net 组件实现 Web Service ? 6.C/C++ 编译器中虚表是如何完成的?
7 .谈谈 COM 的线程模型。然后讨论进程内 / 外组件的差别。
8 .谈谈 IA32 下的分页机制
小页 (4K) 两级分页模式，大页 (4M) 一级
9 .给两个变量，如何找出一个带环单链表中是什么地方出现环的? 一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方
10.在 IA32 中一共有多少种办法从用户态跳到内核态?
通过调用门，从 ring3 到 ring0 ，中断从 ring3 到 ring0 ，进入 vm86 等等
11 .如果只想让程序有一个实例运行，不能运行两个。像 winamp 一样，只能开一 个窗
口，怎样实现? 用内存映射或全局原子(互斥变量)、查找窗口句柄 ..
FindWindow ，互斥，写标志到文件或注册表 ,共享内存。
67 如何截取键盘的响应，让所有的 ?a‘变成 ?b‘? 键盘钩子 SetWindowsHookEx
13 . Apartment 在 COM 中有什么用?为什么要引入? 14 .存储过程是什么?有什么用?有什么优点?
我的理解就是一堆 sql 的集合，可以建立非常复杂的查询，编译运行，所以运行一 次后，
以后再运行速度比单独执行 SQL 快很多 15 . Template 有什么特点?什么时候用?
,C++ 中对应的是 new 操作符。
, 且程序运行过程中函数调用时
16 .谈谈 Windows DNA 结构的特点和优点。 网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别?
1 ，进程:子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制
2 ，线程:相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进 程的其
他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。 线程和进程在使用上各有优缺点:线程执行开销小，但不利于资源管理和保护;进程


 无限互联 iOS 开发工程师面试题【 1-30 】 1、请你自我介绍一下你自己 ?
回答提示: 一般人回答这个问题过于平常，只说姓名、年龄、爱 好、工作经验，这些在简
历上都有。其实，企业最希望知道的是求职者能否胜任工作，包 括:最强的技能、最深入研究的知识领域、个性中最积极的部分、做 过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和 学习有关，但要突出积极的个性和做事的能力，说得合情合理企业 才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每 个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。
2、你觉得你个性上最大的优点是什么 ?
回答提示: 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助 人和关心他人、适应能力和幽默感、乐观和友爱。我在 xxx 公司做 了两年项目，使我适合这份工作。
3、说说你最大的缺点 ?
回答提示: 这个问题企业问的概率很大， 通常不希望听到直接回 答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、 脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回

 答“我最大的缺点是过于追求完美”， 有的人以为这样回答会显得自 己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己
的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出 优点的部分，企业喜欢聪明的求职者。
4、你对加班的看法 ?
回答提示: 实际上好多公司问这个问题，并不证明一定要加班，
只是想测试你是否愿意为公司奉献。
回答样本: 如果是工作需要我会义不容辞加班，我现在单身， 没 有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作 效率，减少不必要的加班。
5、你对薪资的要求 ?
回答提示: 如果你对薪酬的要求太低，那显然贬低自己的能力 ; 如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。 一些雇主通常都事先对求聘的职位定下开支预算， 因而他们第一次提 出的价钱往往是他们所能给予的最高价钱， 他们问你只不过想证实一 下这笔钱是否足以引起你对该工作的兴趣。

 回答样本一: 我对工资没有硬性要求， 我相信贵公司在处理我的 问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，
我则不会计较太多。
回答样本二: 我受过系统的软件编程的训练， 不需要进行大量的 培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我 的情况和市场标准的水平，给我合理的薪水。
回答样本三: 如果你必须自己说出具体数目， 请不要说一个宽泛 的范围， 那样你将只能得到最低限度的数字。 最好给出一个具体的数 字，这样表明你已经对当今的人才市场作了调查， 知道像自己这样学 历的雇员有什么样的价值。
6、在五年的时间内，你的职业规划 ?
回答提示: 这是每一个应聘者都不希望被问到的问题， 但是几乎 每个人都会被问到，比较多的答案是“管理者”。但是近几年来，许 多公司都已经建立了专门的技术途径。 这些工作地位往往被称作“顾 问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一 些你感兴趣的职位也是可以的， 比如产品销售部经理， 生产部经理等 一些与你的专业有相关背景的工作。 要知道， 考官总是喜欢有进取心 的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。

 最普通的回答应该是“我准备在技术领域有所作为”或“我希望能 按照公司的管理思路发展”。
7、你朋友对你的评价 ?
回答提示: 想从侧面了解一下你的性格及与人相处的问题。
回答样本一: 我的朋友都说我是一个可以信赖的人。因为，我一 旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许 诺。
回答样本二: 我觉的我是一个比较随和的人， 与不同的人都可以 友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。
8、你还有什么问题要问吗 ?
回答提示: 企业的这个问题看上去可有可无，其实很关键，企业
不喜欢说“没问题”的人， 因为其很注重员工的个性和创新能力。 企 业不喜欢求职者问个人福利之类的问题， 如果有人这样问: 贵公司对 新入公司的员工有没有什么培训项目，我可以参加吗 ?或者说贵公司 的晋升机制是什么样的 ?企业将很欢迎，因为体现出你对学习的热情 和对公司的忠诚度以及你的上进心。
9、如果通过这次面试我们单位录用了你，但工作一段时间却发 现你根本不适合这个职位，你怎么办 ?

 回答提示: 一段时间发现工作不适合我，有两种情况:1如果你 确实热爱这个职业， 那你就要不断学习， 虚心向领导和同事学习业务
知识和处事经验， 了解这个职业的精神内涵和职业要求， 力争减少差 距; 2你觉得这个职业可有可无，那还是趁早换个职业，去发现适 合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人 都有好处。
10、在完成某项工作时，你认为领导要求的方式不是最好的， 自己还有更好的方法，你应该怎么做 ?
回答提示: 1. 原则上我会尊重和服从领导的工作安排，同时私 底下找机会以请教的口吻， 婉转地表达自己的想法， 看看领导是否能 改变想法。 2如果领导没有采纳我的建议， 我也同样会按领导的要求 认真地去完成这项工作。3 . 还有一种情况，假如领导要求的方式违 背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫 地再向上级领导反映。
11、如果你的工作出现失误， 给本公司造成经济损失， 你认为该 怎么办 ?
回答提示: 1我本意是为公司努力工作，如果造成经济损失， 我 认为首要的问题是想方设法去弥补或挽回经济损失。 如果我无能力负 责，希望单位帮助解决。2分清责任，各负其责，如果是我的责任，

 我甘愿受罚 ; 如果是一个我负责的团队中别人的失误，也不能幸灾 乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮
助同事查找原因总结经验。 3总结经验教训， 一个人的一生不可能不 犯错误， 重要的是能从自己的或者是别人的错误中吸取经验教训， 并 在今后的工作中避免发生同类的错误。 检讨自己的工作方法、 分析问 题的深度和力度是否不够，以致出现了本可以避免的错误。
12、如果你做的一项工作受到上级领导的表扬，但你主管领 导却说是他做的，你该怎样 ?
回答提示: 我首先不会找那位上级领导说明这件事， 我会主动找 我的主管领导来沟通， 因为沟通是解决人际关系的最好办法， 但结果
会有两种: 1我的主管领导认识到自己的错误，我想我会视具体情 况决定是否原谅他。 2他更加变本加厉的来威胁我， 那我会毫不犹豫
地找我的上级领导反映此事， 因为他这样做会造成负面影响， 对今后 的工作不利。
13、谈谈你对跳槽的看法 ? 回答提示:1正常的“跳槽”能促进人才合理流动，应该支持。
2频繁的跳槽对单位和个人双方都不利，应该反对。 14、工作中你难以和同事、上司相处，你该怎么办 ?

 回答提示: 1我会服从领导的指挥，配合同事的工作。2我会从 自身找原因， 仔细分析是不是自己工作做得不好让领导不满意， 同事
看不惯。 还要看看是不是为人处世方面做得不好， 如果是这样的话我 会努力改正。3如果我找不到原因，我会找机会跟他们沟通，请他 们指出我的不足，有问题就及时改正。4作为优秀的员工，应该时刻 以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做 好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有 一天会对我微笑的。
15、假设你在某单位工作，成绩比较突出，得到领导的肯定。 但同时你发现同事们越来越孤立你，你怎么看这个问题 ?你准备怎么 办?
回答提示: 1成绩比较突出， 得到领导的肯定是件好事情， 以后 更加努力。2检讨一下自己是不是对工作的热心度超过同事间交往的 热心了，加强同事间的交往及共同的兴趣爱好。3工作中，切勿伤害 别人的自尊心4不再领导前拨弄是非
16、你最近是否参加了培训课程 ?谈谈培训课程的内容。是公司 资助还是自费参加 ?
回答提示: 公司组织参加，就是无限互联 iOS 培训课程 ( 可以多 谈谈自己学的技术 )。

 17、你对于我们公司了解多少 ? 回答提示:在去公司面试前上网查一下该公司主营业务。 如回答:
贵公司有意改变策略，加强与国外大厂的 OEM 合作，自有品牌的部 分则透过海外经销商。
18、请说出你选择这份工作的动机 ?
回答提示: 这是想知道面试者对这份工作的热忱及理解度， 并筛
选因一时兴起而来应试的人， 如果是无经验者， 可以强调“就算职种 不同，也希望有机会发挥之前的经验”。
19、你最擅长的技术方向是什么 ?
回答提示: 说和你要应聘的职位相关的课程， 表现一下自己的热
诚没有什么坏处。
20、你能为我们公司带来什么呢 ?
回答提示: 企业很想知道未来的员工能为企业做什么， 求职者应 再次重复自己的优势，然后说:“就我的能力，我可以做一个优秀的 员工在组织中发挥能力， 给组织带来高效率和更多的收益”。 企业喜 欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位， 可以说:“我可以开发大量的新客户，同时，对老客户做更全面周到 的服务，开发老客户的新需求和消费。”等等。

 21、最能概括你自己的三个词是什么 ?
回答提示: 我经常用的三个词是:适应能力强， 有责任心和做事
有始终，结合具体例子向主考官解释，
22、你的业余爱好是什么 ?
回答提示:找一些富于团体合作精神的， 这里有一个真实的故事: 有人被否决掉，因为他的爱好是深海潜水。主考官说:因为这是一项 单人活动，我不敢肯定他能否适应团体工作。
23、作为被面试者给我打一下分 ?
回答提示: 试着列出四个优点和一个非常非常非常小的缺点
以抱怨一下设施，没有明确责任人的缺点是不会有人介意的 ) 。 24、你怎么理解你应聘的职位 ?
回答提示: 把岗位职责和任务及工作态度阐述一下。 25、喜欢这份工作的哪一点 ?
( 可
回答提示: 相信其实大家心中一定都有答案了吧 ! 每个人的价值 观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时 可不能太直接就把自己心理的话说出来， 尤其是薪资方面的问题， 不 过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内

 容颇能符合自己的兴趣等等都是不错的答案， 不过如果这时自己能仔 细思考出这份工作的与众不同之处，相信在面试上会大大加分。
26、为什么要离职 ?
回答提示: 1回答这个问题时一定要小心， 就算在前一个工作受 到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要 避免对公司本身主管的批评，避免面试官的负
面情绪及印象。 建议此时最好的回答方式是将问题归咎在自己身 上，例如觉得工作没有学习发展的空间， 自己想在面试工作的相关产
业中多加学习， 或是前一份工作与自己的生涯规划不合等等， 回答的 答案最好是积极正面的。2我希望能获得一份更好的工作，如果机 会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即沒有升迁 机会。
27、说说你对行业、技术发展趋势的看法 ?
回答提示: 企业对这个问题很感兴趣， 只有有备而来的求职者能 够过关。求职者可以直接在网上查找对你所申请的行业部门的信息， 只有深入了解才能产生独特的见解。 企业认为最聪明的求职者是对所 面试的公司预先了解很多，包括公司各个部门，发展情况，在面试 回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是 “知己”，而不是“盲人”。

 28、对工作的期望与目标何在 ? 回答提示:这是面试者用来评断求职者是否对自己有一定程度的
期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通 常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针 对工作的性质找出一个确实的答案，如业务员的工作可以这样回答: “我的目标是能成为一个超级业务员，将公司的产品广泛的推销出 去，达到最好的业绩成效 ; 为了达到这个目标，我一定会努力学习， 而我相信以我认真负责的态度，一定可以达到这个目标。 ”其他类 的工作也可以比照这个方式来回答， 只要在目标方面稍微修改一下就 可以了。
29、说你的家庭 ? 回答提示:企业面试时询问家庭问题不是非要知道求职者家庭的
情况，探究隐私， 企业不喜欢探究个人隐私，而是要了解家庭背景对 求职者的塑造和影响。 企业希望听到的重点也在于家庭对求职者的积 极影响。企业最喜欢听到的是:我很爱我的家庭，我的家庭一向很 和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲 起早贪黑，每天工作特别勤劳， 他的行动无形中培养了我认真负责的 态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所 以在单位人缘很好，她的一言一行也一直在教导我做人的道理。 企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。

 30、就你申请的这个职位，你认为你还欠缺什么 ? 回答提示:企业喜欢问求职者弱点， 但精明的求职者一般不直接
回答。他们希望看到这样的求职者:继续重复自己的优势，然后说: “对于这个职位和我的能力来说， 我相信自己是可以胜任的， 只是缺 乏经验， 这个问题我想我可以进入公司以后以最短的时间来解决， 我 的学习能力很强， 我相信可以很快融入公司的企业文化， 进入工作状 态。”企业喜欢能够巧妙地躲过难题的求职者。



无限互联 iOS 开发面试题【 31-60 】 31、你欣赏哪种性格的人 ?
回答提示: 诚实、不死板而且容易相处的人、有“实际行动”的 人。
32、你通常如何处理別人的批评 ?
回答提示: 1沈默是金，不必说什么，否则情况更糟，不过我会
接受建设性的批评。2我会等大家冷靜下来再讨论。
33、怎样对待自己的失敗 ?
回答提示: 我们大家生来都不是十全十美的， 我相信我有第二个 机会改正我的错误。
34、什么会让你有成就感 ?
回答提示: 为贵公司竭力效劳，尽我所能，完成一个项目。
35、眼下你生活中最重要的是什么 ?
回答提示: 对我来说， 能在这个领域找到工作是最重要的， 能在 贵公司任职对我说最重要。
36、你为什么愿意到我们公司来工作 ?

回答提示: 对于这个问题，你要格外小心，如果你已经对该单位 作了研究， 你可以回答一些详细的原因， 像“公司本身的高技术开发 环境很吸引我。 ”、 “我同公司出生在同样的时代，我希望能够进 入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近 几年来在市场上很有竞争力。 ”、 “我认为贵公司能够给我提供一 个与众不同的发展道路。 ”这都显示出你已经做了一些调查，也说 明你对自己的未来有了较为具体的远景规划。
37、你和别人发生过争执吗 ?你是怎样解决的 ?
回答提示: 这是面试中最险恶的问题， 其实是考官布下的一个陷 阱，千万不要说任何人的过错， 应知成功解决矛盾是一个协作团体中 成员所必备的能力。 假如你工作在一个服务行业， 这个问题简直成了 最重要的一个环节。你是否能获得这份工作，将取决于这个问题的 回答。考官希望看到你是成熟且乐于奉献的。 他们通过这个问题了解 你的成熟度和处世能力。 在没有外界干涉的情况下， 通过妥协的方式 来解决才是正确答案。
38、问题:你做过的哪件事最令自己感到骄傲 ?
回答提示: 这是考官给你的一个机会， 让你展示自己把握命运的 能力。这会体现你潜在的领导能力以及你被提升的可能性。 假如你应 聘于一个服务性质的单位，你很可能会被邀请去午餐。记住:你的前 途取决于你的知识、你的社交能力和综合表现。

39、新到一个部门， 一天一个客户来找你解决问题， 你努力想让 他满意，可是始终达不到群众得满意，他投诉你们部门工作效率低， 你这个时候怎么作 ?
回答提示: (1) 首先，我会保持冷静。作为一名工作人员，在工 作中遇到各种各样的问题是正常的，关键是如何认识它，积极应对， 妥善处理。 (2) 其次，我会反思一下客户不满意的原因。一是看是否 是自己在解决问题上的确有考虑的不周到的地方， 二是看是否是客户 不太了解相关的服务规定而提出超出规定的要求， 三是看是否是客户 了解相关的规定，但是提出的要求不合理。 (3) 再次，根据原因采取 相对的对策。 如果是自己确有不周到的地方， 按照服务规定作出合理 的安排，并向客户作出解释 ; 如果是客户不太了解政策规定而造成的 误解，我会向他作出进一步的解释，消除他的误会 ; 如果是客户提出 的要求不符合政策规定，我会明确地向他指出。 (4) 再次，我会把整 个事情的处理情况向领导作出说明， 希望得到他的理解和支持。 (5) 我不会因为客户投诉了我而丧失工作的热情和积极性， 而会一如既往 地牢记为客户服务的宗旨，争取早日做一名领导信任、公司放心、客 户满意的职员。
40、对这项工作，你有哪些可预见的困难 ?
回答提示: 1不宜直接说出具体的困难， 否则可能令对方怀疑应 聘者不行。2可以尝试迂回战术，说出应聘者对困难所持有的态度 ——工作中出现一些困难是正常的， 也是难免的， 但是只要有坚忍不

拔的毅力、 良好的合作精神以及事前周密而充分的准备， 任何困难都 是可以克服。
分析:一般问这个问题， 面试者的希望就比较大了，因为已经在 谈工作细节，但常规思路中的回答，又被面试官“骗”了。当面试官 询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行， 说出的困难是不是在这个职位中一般都不可避免的问题。 第二，是想 看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。 而不是想了解应聘者对困难的态度。
41、如果我录用你，你将怎样开展工作 ?
回答提示: 1如果应聘者对于应聘的职位缺乏足够的了解， 最好 不要直接说出自己开展工作的具体办法。 2可以尝试采用迂回战术来 回答，如“首先听取领导的指示和要求， 然后就有关情况进行了解和 熟悉，接下来制定一份近期的工作计划并报领导批准， 最后根据计划 开展工作。”。
分析:这个问题的主要目的也是了解应聘者的工作能力和计划性、
条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面 试官会认为回避问题， 如果引导了几次仍然是回避的话， 此人绝对不 会录用了。
42、你希望与什么样的上级共事 ?

回答提示:1通过应聘者对上级的“希望”可以判断出应聘者对 自我要求的意识，这既上一个陷阱，又是一次机会。2最好回避对上 级具体的希望，多谈对自己的要求。3如“做为刚步入社会的新人， 我应该多要求自己尽快熟悉环境、 适应环境， 而不应该对环境提出什 么要求，只要能发挥我的专长就可以了。
分析:这个问题比较好的回答是， 希望我的上级能够在工作中对 我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个 方面谈，不会有大的纰漏。
43、在完成某项工作时，你认为领导要求的方式不是最好的， 自己还有更好的方法，你应该怎么做 ?
回答提示:1. 原则上我会尊重和服从领导的工作安排 ; 同时私底 下找机会以请教的口吻， 婉转地表达自己的想法， 看看领导是否能改 变想法。 2如果领导没有采纳我的建议， 我也同样会按领导的要求认 真地去完成这项工作。3 . 还有一种情况，假如领导要求的方式违背 原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地 再向上级领导反映。
44、与上级意见不一是，你将怎么办 ?
回答提示:1一般可以这样回答“我会给上级以必要的解释和提 醒，在这种情况下，我会服从上级的意见。”2如果面试你的是总经 理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以

这样回答:“对于非原则性问题，我会服从上级的意见，对于涉及公 司利益的重大问题，我希望能向更高层领导反映。”
分析: 这个问题的标准答案是思路1，如果用2的回答，必死无 疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有 人敢要。
45、你工作经验欠缺，如何能胜任这项工作 ?
常规思路:1如果招聘单位对应届毕业生的应聘者提出这个问题， 说明招聘公司并不真正在乎“经验”， 关键看应聘者怎样回答。 2对 这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。3 如“作为应届毕业生， 在工作经验方面的确会有所欠缺， 因此在读书 期间我一直利用各种机会在这个行业里做兼职。 我也发现， 实际工作 远比书本知识丰富、复杂。 但我有较强的责任心、适应能力和学习能 力，而且比较勤奋，所以在兼职中均能圆 满完成各项工作，从中 获取的经验也令我受益非浅。 请贵公司放心， 学校所学及兼职的工作 经验使我一定能胜任这个职位。 ”点评:这个问题思路中的答案尚可， 突出自己的吃苦能力和适应性以及学习能力 ( 不是学习成绩 ) 为好。
46、您在前一家公司的离职原因是什么 ?
回答提示: 1最重要的是:应聘者要使找招聘单位相信，应聘 者在过往的单位的“离职原因”在此家招聘单位里不存在。 2避免把 “离职原因”说得太详细、太具体。3不能掺杂主观的负面感受，如

“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人 才”、“公司排斥我们某某的员工”等。4但也不能躲闪、回避，如 “想换换环境”、 “个人原因”等。 5不能涉及自己负面的人格特征， 如不诚实、懒惰、缺乏责任感、不随和等。6尽量使解释的理由为应 聘者个人形象添彩。7相关例子:如“我离职是因为这家公司倒闭 ; 我在公司工作了三年多，有较深的感情 ; 从去年始，由于市场形势突 变，公司的局面急转直下 ; 到眼下这一步我觉得很遗憾，但还要面对 显示，重新寻找能发挥我能力的舞台。 ”同一个面试问题并非只有一 个答案， 而同一个答案并不是在任何面试场合都有效， 关键在应聘者 掌握了规律后， 对面试的具体情况进行把握， 有意识地揣摩面试官提 出问题的心理背景，然后投其所好。
分析:除非是薪资太低， 或者是最初的工作，否则不要用薪资作 为理由。 “求发展”也被考官听得太多， 离职理由要根据每个人的真 实离职理由来设计， 但是在回答时一定要表现得真诚。 实在想不出来 的时候，家在外地可以说是因为家中有事，须请假几个月，公司又不 可能准假，所以辞职，这个答案一般面试官还能接受。
47、你工作经验欠缺，如何能胜任这项工作 ?
回答提示:1如果招聘单位对应届毕业生的应聘者提出这个问题， 说明招聘公司并不真正在乎“经验”， 关键看应聘者怎样回答。 2对 这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。3 如“作为应届毕业生， 在工作经验方面的确会有所欠缺， 因此在读书

期间我一直利用各种机会在这个行业里做兼职。 我也发现， 实际工作 远比书本知识丰富、复杂。 但我有较强的责任心、适应能力和学习能 力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取 的经验也令我受益非浅。 请贵公司放心， 学校所学及兼职的工作经验 使我一定能胜任这个职位。”
分析:这个问题思路中的答案尚可。 突出自己的吃苦能力和适应 性以及学习能力 ( 不是学习成绩 ) 为好。
48、为了做好你工作份外之事，你该怎样获得他人的支持和 帮助?
回答提示: 每个公司都在不断变化发展的过程中， 你当然希望你 的员工也是这样。 你希望得到那些希望并欢迎变化的人， 因为这些人 明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样 的员工往往很容易适应公司的变化，并会对变化做出积极的响应。
49、果你在这次面试中没有被录用，你怎么打算 ?
回答提示: 现在的社会是一个竞争的社会， 从这次面试中也可看 出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功 的背后有许多的困难和挫折， 如果这次失败了也仅仅是一次而已， 只 有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下 几个方面来正确看待这次失败: 1要敢于面对，面对这次失败不气馁， 接受已经失去了这次机会就不会回头这个现实， 从心理意志和精神上

体现出对这次失败的抵抗力。 要有自信， 相信自己经历了这次之后经 过努力一定能行，能够超越自我。2善于反思，对于这次面试经验要 认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实 事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。3 走出阴影， 要克服这一次失败带给自己的心理压力， 时刻牢记自己弱 点，防患于未然，加强学习，提高自身素质。4认真工作，回到原单 位岗位上后， 要实实在在、 踏踏实实地工作， 三十六行、行行出状元， 争取在本岗位上做出一定的成绩。 5再接再厉， 成为国家公务员一直 是我的梦想，以后如果有机会我仍然后再次参加竞争。
50、假如你晚上要去送一个出国的同学去机场， 可单位临时有事 非你办不可，你怎么办 ?
回答提示:我觉得工作是第一位的， 但朋友间的情谊也是不能偏 废的，这个问题我觉得要按照当时具体的情况来决定。
1如果我的朋友晚上 9 点中的飞机，而我的加班八点就能够完 成的话，那就最理想了，干完工作去机场，皆大欢喜。2如果说工作
不是很紧急，加班仅仅是为了明天上班的时候能把报告交到办公室， 那完全可以跟领导打声招呼， 先去机场然后回来加班， 晚点睡就是了。
3如果工作很紧急， 两者不可能兼顾的情况下， 我觉得可以由两 种选择。 (1) 如果不是全单位都加班的话，是不是可以要其他同事来 代替以下工作，自己去机场，哪怕就是代替你离开的那一会儿。 (2)

如果连这一点都做不到的话，那只好忠义不能两全了，打电话给朋 友解释一下，相信他会理解，毕竟工作做完了就完了，朋友还是可以 再见面的。
51、谈谈你过去做过的成功案例 ?
回答提示: 举一个你最有把握的例子，把来龙去脉说清楚， 而不
要说了很多却没有重点。 切忌夸大其词，把别人的功劳到说成自己的， 很多主管为了确保要用的人是最适合的， 会打电话向你的前一个主管 征询对你的看法及意见，所以如果说谎，是很容易穿梆的。
52、谈谈你过去的工作经验中，最令你挫折的事情 ?
回答提示:曾经接触过一个客户， 原本就有耳闻他们以挑剔出名， 所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力， 最后客户虽然并没有照单全收， 但是接受的程度已经出乎我们意料之 外了。原以为从此可以合作愉快， 却得知客户最后因为预算关系选择 了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这 次的经验学到很多， 如对该产业的了解， 整个 team 的默契也更好了。
分析: 借此了解你对挫折的容忍度及调解方式。 53、如何安排自己的时间 ?会不会排斥加班 ?

回答提示: 基本上，如果上班工作有效率，工作量合理的话，应 该不太需要加班。 可是我也知道有时候很难避免加班， 加上现在工作 都采用责任制，所以我会调配自己的时间，全力配合。
分析:虽然不会有人心甘情愿的加班， 但依旧要表现出高配合度 的诚意。
54、为什么我们要在众多的面试者中选择你 ?
回答提示:根据我对贵公司的了解， 以及我在这份工作上所累积 的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态 度、 EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。
分析: 别过度吹嘘自己的能力， 或信口开河地乱开支票，例如一 定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、 不切实际的感觉。
55、这个职务的期许 ?
回答提示: 希望能借此发挥我的所学及专长， 同时也吸收贵公司
在这方面的经验，就公司、我个人而言，缔造“双赢”的局面。
分析: 回答前不妨先询问该公司对这项职务的责任认定及归属， 因为每一家公司的状况不尽相同， 以免说了一堆理想抱负却发现牛头
不对马嘴。

56、为什么选择这个职务 ?
回答提示: 这一直是我的兴趣和专长，经过这几年的磨练， 也累
积了一定的经验及人脉，相信我一定能胜任这个职务的。
分析:适时举出过去的“丰功伟业”， 表现出你对这份职务的熟 稔度，但避免过于夸张的形容或流于炫耀。
57、什么选择我们这家公司 ?
回答提示: 曾经在报章杂志看过关于贵公司的报道， 与自己所追 求的理念有志一同。 而贵公司在业界的成绩也是有目共睹的， 而且对 员工的教育训练、升迁等也都很有制度分析:去面试前先做功课，了 解一下该公司的背景， 让对方觉得你真的很有心想得到这份工作， 而 不只是探探路。
58、认为你在学校属于好学生吗 ?
回答提示:企业的招聘者很精明， 问这个问题可以试探出很多问 题:如果求职者学习成绩好，就会说:“是的，我的成绩很好，所有 的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在 学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、 团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应 该说我是一个全面发展的学生。 ”如果求职者成绩不尽理想， 便会说: “我认为是不是一个好学生的标准是多元化的， 我的学习成绩还可以，

在其他方面我的表现也很突出， 比如我去很多地方实习过， 我很喜欢 在快节奏和压力下工作，我在学生会组织过 ××活动，锻炼了我的 团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业 喜欢诚实的求职者。
59、谈谈如何适应办公室工作的新环境 ?
回答提示: 1办公室里每个人有各自的岗位与职责， 不得擅离岗 位。2根据领导指示和工作安排，制定工作计划，提前预备，并按计 划完成。3多请示并及时汇报，遇到不明白的要虚心请教。4抓间隙 时间，多学习，努力提高自己的政治素质和业务水平。
60、工作中学习到了些什么 ?
回答提示: 这是针对转职者提出的问题， 建议此时可以配合面试 工作的特点作为主要依据来回答， 如业务工作需要与人沟通， 便可举 出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把 握这些要点做陈述，就可以轻易过关了。


1. 谈谈你对多线程开发的理解? iOS中有几种实现多线程的方法? 好处: 1 、 使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的
下载 2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用 户体验更好缺点: 1、大量的线程降低代码的可读性， 2 、更多的线程需要更 多的内存空间 3、当多个线程对同一个资源出现争夺的时候要注意线程安全 的问题。iOS有三种多线程编程的技术:1、NSThread( 两种创建方 式 )[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];NSThread *myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];
[myThread start];2 、NSOperationQueue
NSOperationQueue *oprationQueue = [[NSOperationQueue alloc] init];
oprationQueue addOperationWithBlock:^{
// 这个 block 语句块在子线程中执行
}
http://alloc.sinaapp.com/wp/?p=237
3、Grand Central Dispatch (GCD)
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRI ORITY_DEFAULT, 0), ^{
// 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{
// 更新界面 });
}); http://blog.csdn.net/totogo2010/article/details/8016129
PS: 不 显 示 的 创 建 线 程 的 方 法 : 用 NSObject 的 类 方 法 performSelectorInBackground:withObject: 创 建 一 个 线 程 : [Obj performSelectorInBackground:@selector(doSomething) withObject:nil];
1. 线程同步和异步的区别? IOS中如何实现多线程的同步? 同步: 一个线程要 等待上一个线程执行完之后才能执行当前的线程， 生活中的例子 (上厕所)。 异步:同时去做两件或者多件事。比如边听歌边看报。原子操作 (atomic) 、

加锁(NSLock、NSRecursive 、NSConditionLock )、@synchronized GCD 串行队列 ,GCD 当中的屏障 ,NSOperationQueue 设置最大并发数为 1
参考( http://blog.csdn.net/lifengzhong/article/details/7487505 )
1. iOS类是否可以多继承?如果没有， 那可以用其他方法实现吗?简述实现过程。 不可以，可以通过消息转发、 delegate 和 protocol 和类别来实现类似多继承。
1. iOS本地数据存储都有哪几种方式? iOS如何实现复杂对象的存储? NSKeyedArchiver (归档)采用归档的形式来保存数据，该数据对象需要遵守
NSCoding协议，并且该对象对应的类必须提供 encodeWithCoder: 和initWithCoder: 方法。
1. NSUserDefaults :用来保存应用程序设置和属性、用户保存的数据。用户再 次打开程序或开机后这些数据仍然存在。 NSUserDefaults 可以存储的 数据类型包括: NSData 、NSString 、NSNumber 、NSDate 、NSArray 、 NSDictionary 。
2. Write 写入方式:永久保存在磁盘中。
3. SQLite ( FMDB 、 CoreData )
NSCoding + NSKeyedArchiver 实现复杂对象的存储。

1. 怎样实现一个 singleton 的类。 static LOSingleton * shareInstance;
+( LOSingleton *)sharedInstance{
@synchronized(self){// 这个东西其实就是一个加锁。如果 self 其他线程访问，
则会阻塞。这样做一般是用来对单例进行一个死锁的保护
if (shareInstance == nil) {
shareInstance = [[super allocWithZone:NULL] init];
} }
return shareInstance; }

// 第二种方式
+ (LOSingleton *) sharedInstance
{
static LOSingleton *sharedInstance = nil ;
static dispatch_once_t onceToken;
dispatch_once (& onceToken, ^ { sharedInstance = [[self alloc] init];
});
return sharedInstance; }
1. 什么是安全释放?
在对象 release 之后把指针置为 nil
// 锁
// 最多调用一次
1. RunLoop是什么? 一个RunLoop 就是一个时间处理的循环，用来不停的调 度工作以及处理输入时间。 使用 runloop 的目的是让你的线程在有工作的时候 忙于工作 ,而没工作的时候处于休眠状态。 runloop 的设计是为了减少 cpu 无谓 的空转。
1. 什么是序列化和反序列化， 可以用来做什么?如何在 OC中实现复杂对象的存 储? 如果你需要存储一个复杂的对象的话，经常要以二进制的方法序列化 这个对象，这个过程叫 Archiving 。如果一个对象需要进行序列化，那么需要 遵循 NScoding 协议，主要有两个方法:-(id)initWithCoder:(NSCoder*)coder;// 从 coder 中 读 取 数 据 ， 保 存 到 相 应 变 量 中 ， 即 反 序 列 化 数 据 。 -(void)encodeWithCoder:(NSCoder*)coder;// 读取实例变量，并把这些数据 写到 coder 中去，即序列化数据。
1. 简述应用程序按 Home键进入后台时的生命周期，以及从后台回到前台时的 生命周期? 应用程序的状态: Not running 未运行，程序没启动 Inactive 未激活，程序在前台运行，不过没接受到事件，没有事件处理的状态下通常 处于这个状态。 Active 激活程序在前台并且接收到了事件 Backgound 后台程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状
态 上 停 留 一 会 。 Suspended 挂 起 程 序 在 后 台 不 能 执 行 代 码 。 - (BOOL)application:(UIApplication *)application

willFinishLaunchingWithOptions:(NSDictionary *)launchOptions // 告诉代理 进 程 启 动 但 还 没 进 入 状 态 保 存 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions// 告诉代理启动基本完成程序准备开始运行- (void)applicationWillResignActive:(UIApplication *)application // 当应用程序 将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电
话 了 - (void)applicationDidBecomeActive:(UIApplication *)application // 当应用程序入活动状态执行，这个刚好跟上面那个方法相 反- (void)applicationDidEnterBackground:(UIApplication *)application // 当 程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里
面 设 置 即 可 - (void)applicationWillEnterForeground:(UIApplication *)application //当程序从后台将要重新回到前台时候调用，这个刚好跟上面的
那 个 方 法 相 反 。 - (void)applicationWillTerminate:(UIApplication *)application //当程序将要退出是被调用，通常是用来保存数据和一些退出前
的 清理 工作 。 这 个需要 要设 置 UIApplicationExitsOnSuspend 的键 值 。 - (void)applicationDidFinishLaunching:(UIApplication*)applicatio // 当 程 序 载入后执行
1. 描述应用程序的启动顺序。
1、程序入口main 函数创建UIApplication 实例和UIApplication 代理实例
2、在UIApplication 代理实例中重写启动方法，设置第一 ViewController 3、 在第一ViewController 中添加控件，实现对应的程序界面。
1. UIImage 初始化一张图片有几种方法?简述各自的优缺点。 1 、从资源读取 UIImage *image = [UIImage imageNamed:@ ”1.png ”];2 、 从 网 络 读 取 NSURL*url=[NSURL URLWithString:@"http://www.sinaimg.cn/qc/photo_auto/chezhan/2012/50/ 00/15/80046_950.jpg"];3. 从手机本地读取//读取本地图片非 resourceNSString *aPath3=[NSString stringWithFormat:@"%@/Document s/%@.jpg",NSHomeDirectory(),@"test"];UIImage *imgFromUrl3=[[UIImage
alloc]initWithContentsOfFile:aPath3]; 4.从现有的 context 中获得图像
//add ImageIO.framework and #import <ImageIO/ImageIO.h> CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL);
CGImageRef img= CGImageSourceCreateImageAtIndex(source,0,NULL);

1.
1.
CGContextRef ctx=UIGraphicsGetCurrentContext(); CGContextSaveGState(ctx);
//transformCTM 的2种方式
//CGContextConcatCTM(ctx, CGAffineTransformMakeScale(.2, -0.2)); //CGContextScaleCTM(ctx,1,-1);
//注意坐标要反下 ,用ctx来作为图片源
CGImageRef capture=CGBitmapContextCreateImage(ctx); CGContextDrawImage(ctx, CGRectMake(160, 0, 160, 230), [image CGImage]);
CGContextDrawImage(ctx, CGRectMake(160, 230, 160, 230), img); CGImageRef capture2=CGBitmapContextCreateImage(ctx);
5、用 Quartz 的CGImageSourceRef 来读取图片
CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL);
CGImageRef img= CGImageSourceCreateImageAtIndex(source,0,NULL); 参考( http://blog.csdn.net/jerryvon/article/details/7526147# )
这段代码有什么问题吗 : @implementation Person
- (void)setAge:(int)newAge { self.age = newAge;
}
@end死循环
这段代码有什么问题 ,如何修改
for (int i = 0; i < someLargeNumber; i++) {
NSString *string = @”Abc”;
string = [string lowercaseString];
string = [string stringByAppendingString:@"xyz"];
NSLog(@“%@”, string);
}
如果数字很大的话会造成内存一直增加(因为一直通过便利构造器方法创建 autorelease 对象)，直到循环结束才减少，在循环内加一个自动释放池，更改 后代码如下:
for (int i = 0; i < someLargeNumber; i++) {
NSString *string = @”Abc”;@autoreleasepool {

string = [string lowercaseString];
string = [string stringByAppendingString:@"xyz"]; NSLog(@“%@”, string);
} }
1. 截取字符串” 20 | http://www.baidu.com ”中，”| ”字符前面和后面的数据， 分别输出它们。 NSString *string = @”20 | http://www.baidu.com ”;[string
componentsSeparatedByString:@ ”| ”];
2. 简述你对 UIView 、UIWindow和 CALayer的理解
UIView 继承于 UIResponder, UIResponder 继承于 NSObject,UIView 可以响应
用户事件。 CALayer 继承于 NSObject ，所以 CALayer 不能响应事件。 UIView 构建界 面 ,UIView 侧重于对内容的管理， CALayer 侧重于对内容的绘制。 UIView 是用来显 示内容的，可以处理用户事件; CALayer 是用来绘制内容的， 对内容进行动画处理， 依赖与 UIView 来进行显示，不能处理用户事件。

1. 什么是 Protocol?什么是代理?写一个委托的 interface?委托的 property声明 用什么属性?为什么? 协议提供了一组方法，但是并不负责实现，如果一个 类遵循了某个协议，并且实现了协议里面的方法，那么我们称这个类就是遵 循了某个协议的代理。属性的声明使用 assign ，防止出现循环引用的问题。
1. 分别描述类别(categorie)s和延展(extensions)是什么?以及两者的区别? 继承和类别在实现中有何区别?为什么 Category只能为对象添加方法， 却不能 添加成员变量?
category 类目:在不知道源码的情况下为一个类扩展方法， extension : 为一个类声明私有方法和变量。继承是创建了一个新的类，而类别
只是对类的一个扩展，还是之前的类。类目的作用就是为已知的类添加方法。
1. Objective-C有私有方法么?私有变量呢?如多没有的话，有没有什么代替的 方法?

objective-c–类里面的方法只有两种 , 静态方法和实例方法 . @private来修饰私有变量 OC中所有的实例变量默认都是私有的，所有
的实例方法默认都是公有的。 ,吗
1. 如 何 监 测 系 统 键 盘 的 弹 出 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector( name:UIKeyboardWillShowNotification object:nil];
2. 举出 5个以上你所熟悉的 iOS SDK 库有哪些和第三方库有哪些? CoreFraphics
)
Foundation ， ，
UIKit,MapKit,CoreLocation,CFNetWork,MessageUI,ImageIO,CoreData ， AFNetWorking,MKNetWorkKit,ASIHttpRequest,FMDB,ZXing,ZBar,SDWeb Image
1. 如何将产品进行多语言发布? 程序的国际化
1. 如何将敏感字变成 ** 字符串替换 stringByReplacingOccurrencesOfString:
withString:
+ 静态方法，也叫类方法， -实例方法
1. 给定的一个字符串，判断字符串中是否还有 png ，有就删除它? [string
stringByReplacingOccurrencesOfString:@"png" withString: @ “"]
1. 对于语句 NSString* testObject = [[NSData alloc] init];testObject在编译时和运行 时分别是什么类型的对象? 编译的时候是 NSString 类型，运行的时候是 NSData 类型
1. OC中是所有对象间的交互是如何实现的? 函数指针实现

 1. NSArray和NSMutableArray的区别，多线程操作哪个更安全? NSArray 不可变 数组，NSMutableArray 可变数组，NSArray更安全，多线程操作的时候记得 加锁。
1. 当前有一个数组，里面有若干重复的数据，如何去除重复的数据?(会几个 写几个) 最简单的方式，把数组里面的元素放到集合里面。 也可以对数组进
   行排序，排序之后把数组里相同的元素删除掉
1. isKindOfClass、 isMemberOfClass作用分别是什么? -(BOOL) isKindOfClass: classObj 判断是否是这个类或者是这个类子类的实例-(BOOL) isMemberOfClass: classObj 判断是否是这个类的实例
1. iPhone上，不能被应用程序直接调用的系统程序是什么? 时钟、视频、指南针、天气、计算器、备忘录、提醒事件、股市 http://blog.sina.com.cn/s/blog_7dc11a2e01016qve.html
http://blog.csdn.net/yhawaii/article/details/7587355

1. sizeof和 strlen的区别和联系
sizeof 是运算符， strlen 是函数 char str[20]="0123456789";
a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00
束。 int b=sizeof(str); // 而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。
c++ 函数内
int
为字符串结

1. sprintf,strcpy,memcpy的功能?使用上要有哪些要注意的地方 char*strcpy(char *dest, const char *src);
其对字符串进行操作，完成从源字符串到目的字符串的拷贝 ,当源字符串 的大小大于目的字符串的最大存储空间后，执行该操作会出现段错误。
int sprintf(char*str, const char *format, ...)
函数操作的源对象不限于字符串:源对象可以是字符串、也可以是任意 基本类型的数据。主要是实现将其他数据类型转换为字符串
void *memcpy(void*dest, const void *src, size_t n)
实现内存的拷贝，实现将一块内存拷贝到另一块内存。该函数对源对象 与目的对象没有类型现在，只是对内存的拷贝
1. 写一个代码片段输入一个字符串“ 2013032215283”2 ,输出一个 NSDate类型的 对 象 ， 打 印 该 对 象 输 出 2013-03-22 15: 28: 32NSDateFormatter @
“yyyy-MM-dd HH:mm:ss ”
1. 用变量 a写出以下定义 a、一个整型数 int a;
b、一个指向整型数的指针 int *a; c、一个指向指针的指针，它指向的指针是指向一个整型数 d、一个有 10个整型数的数组 int a[10];
e、一个有 10个指针的数组，该指针是指向一个整型数的 f、一个指向有 10个整型数数组的指针 int (*a)[10] ;
int **a; int *a[10];
g、一个指向函数的指针，该函数有一个整型参数，并返回一个整型数 int(*a)(int);




 1.When to use NSMutableArray and when to use NSArray?
什么时候使用 NSMutableArray ，什么时候使用 NSArray ?
答案: 当数组在程序运行时， 需要不断变化的， 使用 NSMutableArray ，当数组在初始化后， 便不再改变的， 使用 NSArray 。需要指出的是，使用 NSArray 只表明的是该数组在运行时不发生改变，即不能往 NSAarry 的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。 NSArray 是线程安全的， NSMutableArray 不是线程安全的，多线程使用到 NSMutableArray 需要注意。
2.Give us example of what are delegate methods and what are data source methods of uitableview.
给出委托方法的实例，并且说出 UITableVIew 的 Data Source 方法
答案: CocoaTouch 框架中用到了大量委托，其中 UITableViewDelegate 就是委托机制的典型应用，是一 个典型的使用委托来实现适配器模式，其中 UITableViewDelegate 协议是目标， tableview 是适配器，实现
UITableViewDelegate 协议，并将自身设置为 talbeview 的 delegate 的对象，是被适配器，一般情况下该 对象是 UITableViewController 。
UITableVIew 的 Data Source 方法有 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
3.How many autorelease you can create in your application? Is there any limit?
在应用中可以创建多少 autorelease 对象，是否有限制?
答案:无
4.If we don ’t create any autorelease pool in our application then is there any autorelease pool already provided to us?
如果我们不创建内存池，是否有内存池提供给我们?
答案 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
5.When you will create an autorelease pool in your application?

 什么时候需要在程序中创建内存池?
答案:用户自己创建的数据线程，则需要创建该线程的内存池
6.When retain count increase?
什么时候内存计数会增加?
答案: 见 iOS 面试题(一)
7.What are commonly used NSObject class methods?
类 NSObject 的那些方法经常被使用?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。
其中类方法 alloc 、class 、 description 对象方法 init 、dealloc 、– performSelector:withObject:afterDelay: 等经常被使用
8.What is convenience constructor?
什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber 的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象， 并且不需要手动释放。
9.How to design universal application in Xcode?


 在 Objetive-C 什么时原子关键字
答案: atomic ，nonatomic 见 iOS 面试题(一)
11.What are UIView animations?
UIView 的动画效果有那些?
答案:有很多，如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn
UIViewAnimationOptionCurveEaseOu t UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown
如何使用可见该博文
12.How can you store data in iPhone applications?
在 iPhone 应用中如何保存数据?
答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中
3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.What is coredata?
什么是 coredata ?
答案: coredata 是苹果提供一套数据保存框架，其基于 SQlite
14.What is NSManagedObject model?
什么是 NSManagedObject 模型?
答案: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成部分， 它是一个通用的类 , 实现 了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。

 15.What is NSManagedobjectContext?
什么是 NSManagedobjectContext ?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
16.What is predicate?
什么是谓词?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n];
a = [customers filteredArrayUsingPredicate:predicate]; 17.What kind of persistence store we can use with coredata?
使用 coredata 有哪几种持久化存储机制?
答案:无



类别的作用?继承和类别在实现中有何区别?
答案:category 可以在不获悉， 不改变原来代码的情况下往里面添加新的方法， 不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。
继承可以增加，扩展父类方法，并且可以增加属性。
3.Difference between categories and extensions?
因为类别具有更
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是
必须要实现的。
extensions 可以认为是一个私有的 Category 。
4.Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC中的协议有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java
, 那么发现 A 引用的对象同样被修改， , 内存中存在了
只能添加，

 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现， 就会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 “非正式协议概念其实就是类别的另一种表达方式 “这里有一些你可能希望实现的方法， 你 可以使用他们更好的完成工作”。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说“非正式 协议使用 interface 修饰“，
现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
OC中的协议 (formal protocol) 与 java 中的接口概念基本一致， OC中非正式协议 (informal protocol) 就是类别。在 java 中如果继承了接口，但不实现其方法，会得到一个
error (无法编译) ;在 OC中的正式协议， 如果不实现， 会得到一个 warning(可编译执行) ， 如果想去除 waring ，还可以加关键字( @optional )，让它可选实现方法。
5.What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调 用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{

 if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
} }
对于系统是根据 keypath 去取的到相应的值发生改变，理论上来说是和 理是一样的。
kvc 机制的道
对于 kvc 机制如何通过 key 寻找到 value :
“当通过 KVC调用对象时，比如: [self valueForKey:@ 通过几种不同的方式解析这个调用。首先查找对象是否带有
到，会继续查找对象是否带有 someKey 这个实例变量(
续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话， 程序会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注:Key-Value Coding 查找方法的时候， 不仅仅会查找 someKey这个方法， 还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey以及 _getsomeKey 这几种 形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变量，也会查找 _someKey 这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中 请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面
的两个例子说明了这样做的好处。“
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 . 因此为何上面我们只是 相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
6.What is purpose of delegates?
代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.What are mutable and immutable types in Objective C? oc 中可修改和不可以修改类型。
add 一个
而不需
” someKey” ] 时，程序会自动试图 someKey 这个方法，如果没找
iVar )，如果还没有找到，程序会继

 答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可 以添加等，可以动态申请新的内存空间。
8.When we call objective c is runtime language what does it mean? 我们说的 oc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别，
定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类 ( life ) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只 需调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~


 11.看下面的程序 ,第一个 NSLog 会输出什么?这时 str 的 retainCount 是多少?第二个和第 三个呢?为什么?
[cpp] view plaincopyprint?
1. =================================================== ====
2. NSMutableArray* ary = [[NSMutableArray array] retai
n];
3. NSString *str = [NSString stringWithFormat:@
"test" ]
;
4. [strretain];
5. [aryaddObject:str];
6. NSLog(@"%@%d,"str,[str retainCount]);
7. [strretain];
8. [strrelease];
9. [strrelease];
10. NSLog(@"%@%d,"str,[str retainCount]);
11. [aryremoveAllObjects];
12. NSLog(@"%@%d,"str,[str retainCount]);
13. ==================================================
=====
str 的 retainCount 创建 +1 ， retain+1 ，加入数组自动 +1 3

 retain+1 ， release-1 ， release-1 2
数组删除所有对象，所有数组内的对象自动 -1 1
12. Object C 中创建线程的方法是什么?如果在主线程中执行代码， 方法是什么?如果想延 时执行代码、方法又是什么?
线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch 、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是 performSelectorOnMainThread ，如果想延时执行代码可以用 performSelector:onThread:withObject: afterDelay: 或者使用 GCD 的函数: dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 *
NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 2 秒后异步执行这里的代码 ...
});


如果我们不创建内存池，是否有内存池提供给我们?
答案 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
5.When you will create an autorelease pool in your application?
什么时候需要在程序中创建内存池?
答案:用户自己创建的数据线程，则需要创建该线程的内存池

 类 NSObject 的那些方法经常被使用?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。
其中类方法 alloc 、 class 、 description 对象方法 init 、 dealloc 、 –performSelector:withObject:afterDelay: 等经常被使用
什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber
的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithI
nt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象， 并且不需要手动释放。
9.How to design universal application in Xcode?
如何使用 Xcode 设计通用应用?
答案:使用 MVC 模式设计应用， 其中 Model 层完成脱离界面， 即在 Model 层，其是可运行在任何设备上， 在 controller 层，根据 iPhone 与 iPad(独有 UISplitViewController )的不同特点选择不同的 viewController
对象。在 View 层，可根据现实要求，来设计，其中以
11.What are UIView animations?
UIView 的动画效果有那些?
答案:有很多，
如 UIViewAnimationOptionCurveEaseInOut
xib 文件设计时，其设置其为
universal 。
UIViewAnimationOptionCurveEaseIn ationOptionCurveEaseOu t UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOption
UIViewAnim

 TransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransition CurlDown
如何使用可见该博文
12.How can you store data in iPhone applications?
在 iPhone 应用中如何保存数据?
答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中
3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.What is coredata?
什么是 coredata ?
答案: coredata 框架是 apple 提供的一套通用自动的解决方案，包括了对象生存周期、对象关系图、持久 化机制。
补充答案:上面是翻译的，按我个人理解 coredata 提供一种一机制，让我们可以方便的把内存中对象，及 对象间的关系，映射到 coredata ，然后由它为我们持久化数据。相比普通的文件数据库 SQlite ，它的功能 更强大，不需要我们先将对象数据 format 成 SQL 语句，存入数据库，再用 select 语句读出，而现在是从 内存到 coredata 的数据管理，我们只需管理 coredata 的 managed 对象。
是苹果提供一套数据保存
14.What is NSManagedObject model?
什么是 NSManagedObject 模型?
答案: NSManagedObject 是 NSObject 的子类，也是 coredata 的重要组成部分，它是一个通用的类 ,实现 了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。
15.What is NSManagedobjectContext?

 什么是 NSManagedobjectContext ?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
16.What is predicate?
什么是谓词?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n]; a = [customers filteredArrayUsingPredicate:predicate];
17.What kind of persistence store we can use with coredata?
coredata 有哪几种持久化存储机制?
答案: coredatat 提供以下几种存储机制: XML (iOS 系统不支持) ,自动存储 ,SQLite, 内存存储。
补充说明:这个问题问的是， coredate 框架的存储机制，平时使用 coredata 时，更多关注的是 managed 的对象，这里是 coerdata 框架的存储实现细节。 BTW: 其他常用的持久化存储方法: 存入到文件、 存
入到 NSUserDefaults (系统 plist 文件中)。


8.Objective-C 如何对内存管理的 ,说说你的看法和解决方法 ?
Objective-C 的内存管理主要有三种方式 ARC (自动内存计数) 、手动内存计数、内存池。
9. 内存管理的几条原则时什么?按照默认法则 .那些关键字生成的对象 需要手动释放?在和 property 结合的时候怎样有效的避免内存泄露?
谁申请，谁释放
遵循 Cocoa Touch 的使用原则;
内存管理主要要避免“过早释放”和“内存泄漏”， 对于“过早释放”需要注意 设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放， 要细 心。
关键字 alloc 或 new 生成的对象需要手动释放;
设置正确的 property 属性，对于 retain 需要在合适的地方释放，
@property


NSMutableArray* ary = [[NSMutableArray array]
retain];
NSString *str = [NSString stringWithFormat:@ "test" ]; [strretain];
[aryaddObject:str];
NSLog(@"%@%d,"str,[str retainCount]);
[strretain];
[strrelease];
[strrelease];
NSLog(@"%@%d,"str,[str retainCount]);
[aryremoveAllObjects];
NSLog(@"%@%d,"str,[str retainCount]); ===================================================
====
str 的 retainCount 创建 +1， retain+1 ，加入数组自动 +1

 3
retain+1 ， release-1 ， release-1
2
数组删除所有对象，所有数组内的对象自动 -1
1
12. Object C 中创建线程的方法是什么?如果在主线程中执行代码， 方法是什么?如果想延
时执行代码、方法又是什么?
线程创建有三种方法:使用 NSThread 创建、使用 GCD 的 dispatch 、使用子类化的
NSOperation, 然后将其加入 NSOperationQueue; 在主线程执行代码，方法是 performSelectorOnMainThread ，如果想延时执行代码可以用
performSelector:onThread:withObject:waitUntilDone:



链表逆序( C语言)(10分)。

57. ID 声明的对象有什么特性? 14 58.自动释放池跟GC(垃圾回收)有什么区别?IPHONE上有GC么?[POOLRELEAS]E和[POOLDRAI]N有什
I PHONEOS主要提供了几种播放音频的方法( 10 分)? 使用 AVAUDIOPLAYER类调用哪个框架、使用步骤( 10 分)?
有哪几种手势通知方法、写清楚方法名( 10 分)? 实例化一个 UITABLEVIEW对象，要求写出关键语句( CFSOCKET使用有哪几个步骤( 10 分)。
12 类别的作用?继承和类别在实现中有何区别? 13 通知和协议的不同之处? 13 关于多态性 13 对于单例的理解 13 是否在一个视图控制器中嵌入两个 TABLEVIEW控制器? 13 一个 TABLEVIEW是否可以关联两个不同的数据源?你会怎么处理? 13
14
OBJECT - C 的类可以多重继承么?可以实现多个接口么?重写一个类的方式用继承好还是分
么区别?
59. 线程与进程的区别和联系 ? 14 60.IOS平台怎么做数据的持久化?COREDATA和SQLITE有无必然联系?COREDAT是A一个关系型数据库吗?
61. 62.
63. 64. 分)。 65. 66. 67. 68. 69. 70. 71. 73. 74. 75. 76. 77.
14
14 14 15
* 号外， 15 15
获取项目根路径，并在其下创建一个名称为
这段代码有什么问题吗
用变量 A 给出下面的定义
给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置? 17 OBJECTIVE- C 中的数字对象都有哪些，简述它们与基本数据类型的区别是什么? 18 用 NSLOG 函数输出一个浮点类型，结果四舍五入，并保留一位小数 18 获取项目根路径，并在其下创建一个名称为 USERDATA 的目录。 19 DO- WHILE 与 WHILE- DO 的区别? 19
2 到 100 内的所有素数和。 19 10 分)。 20 , 如何工作。 20
假定输入的字符串中只包含字母和 * 号。编写函数
截取字符串” 20 |HTTP:// WW.W621 LIFE. COM“ 中 ‘|’字符前面及后面的数据，分别输出它们( 10
用 C 语言，求 单件实例是什么( 自动释放池是什么
USERDATA
的目录。(10 分)。 15 16 16 16
FUN，功能是，除了中间和尾部的

首先需要分配空间设置表格类型 然后需要设置两个必须的委托对象。
7.使用 sql 语句查询出省名以湖开头，邮编为 436001 所在的市区?(
select* fromcitys where postcode= 436001 and province=’湖%’;
8.打印结果
main() {
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1);
printf( “%d,%d ”,*(a+1),*(ptr-1));
}
5 分)(表名及字段名自定义)
答: 2,5
*(a+1 )就是 a[1] ， *(ptr-1) 就是 a[4], 执行结果是 2 ，5
&a+1 不是首地址 +1，系统会认为加一个 a 数组的偏 移，是偏移了一个数组的大小(本例是 5 个 int) int *ptr=(int *)(&a+1);
则 ptr 实际 是&(a[5]), 也就是 a+5
原因如下:
&a 是数组指针，其类型为 int (*)[5];
而 指针加 1 要根据指针类型加上一定的值，不同类型的指针
a 是长度为 5 的 int 数组指针，所以要加 5*sizeof(int)
所以 ptr 实际是 a[5]
但是 prt 与 (&a+1) 类型是不一样的 (这点很重要 )
所以 prt-1 只会减去 sizeof(int*)
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0] 的地址， &a 是对象(数组)首地址，
a+1是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即
void Func ( char str[100] ) {
sizeof(str ) = ?
}
void*p = malloc( 100 ); sizeof( p ) = ?
这题 很常见了 ,Func ( char str[100] )函数中数组名作为函数形参时， 在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。 Windows NT 32 位平台下，指针的长度 (占用内存的大小)为 4字节，故 sizeof( str ) 、sizeof( p ) 都为 4。
+1 之后增加的大小不同。
a[5].
在函数体内， 数组名失去了本身的内涵，
仅仅只是一个指针;

9.用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题)
答: #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情:
#define 语法的基本知识(例如:不能以分号结束，括号的使用，等等) 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而 没有代价的。
意识到这个表达式将使一个 16 位机的整型数溢出 -因此要用到长整型符号 L,告诉编译器这个常数是的长整型数。 如果你在你的表达式中用到 UL(表示无符号长整型) ，那么你有了一个好的起点。记住，第一印象很重要。
10.写一” 标准”宏 MIN ，这个宏输入两个参数并返回较小的一个
答: #define MIN(A,B) (( A ) <= (B) ? (A) : (B))
这个测试是为下面的目的而设的:
标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码 的唯一方
法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是
很重要的。 懂得在宏中小心地把参数用括号括起来 我也用这个问题开始讨论宏的副作用， 么事? least = MIN(*p++, b);
结果是:
((*p++) <= (b) ? (*p++) :(*p++)) 这个表达式会产生副作用，指针 p 会作三次 ++自增操作。
11.数组和指针的区别
( 1)数组可以申请在栈区和数据区;指针可以指向任意类型的内存块
( 2) sizeof 作用于数组时，得到的是数组所占的内存大小;作用于指针时，得到的都是
例如:当你写下面的代码时会发生什
4 个字节的大小
( 3 )数组名表示数组首地址，值不可以改变，如不可以将++作用于数组名上;普通指针的值可以改变，如可将++作用于指
针上
( 4)用字符串初始化字符数组是将字符串的内容拷贝到字符数组中;用字符串初始化字符指针是将字符串的首地址赋给指针， 也就是指针指向了该数组
12.static 的作用
( 1)函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次， 因此其值在下次调用时仍维持上次的值;
( 2)在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问;
( 3)在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内;
( 4)在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;

( 5)在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的
static
成员变量。
13.简述内存分区情况
( 1)代码区:存放函数二进制代码
( 2)数据区:系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量 (3)堆区:通过 malloc 等函数或 new 等操作符动态申请得到，需程序员手动申请和释放
( 4)栈区:函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数
14.# include<filename>和# include” filename”有什么区别
答:# include<filename>直接在库文件目录中搜索所包含的文件;# include”filename”在当前目录下搜索所包含的文件，如果 没有的话再到库文件目录搜索。
15.const char *p; charconst*p; char*const p; const char* const p四; 个修饰指针有什么区别
答: (1)定义了一个指向不可变的字符串的字符指针
(2)和( 1)一样
( 3)定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向 ( 4)定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向

17.在 Obj-c 中有没有私有方法?私有变量?一般采用什么方法实现?
objective-c – 类里面的方法只有两种 , 静态方法和实例方法 . 这似乎就不是完整的面向对象了 ,按照 OO 的原则就是一个对象只
暴露有用的东西 . 如果没有了私有方法的话 , 对于一些小范围的代码重用就不那么顺手了 @interfaceController : NSObject { NSString *something; }
+(void)thisIsAStaticMethod;
-(void)thisIsAnInstanceMethod;
@end
@interfaceController (private) -(void)thisIsAPrivateMethod;
@end
@private 可以用来修饰私有变量
在 Objective‐ C 中，所有实例变量默认都是私有的，所有实例方法默认都是公有的
. 在类里面声名一个私有方法

18.OC 中加号方法与减号的区别?
加号方法是类方法，属于静态方法
减号方法是实例方法必须由类的实例来调用
19.free 与 release的区别
20.在终端环境下，分别说明 4,2,1,0 对应的权限是什么
21.ARC 机制
ARC 就是 automatic reference counting ，简单说就是就是代码中自动加入了 理的引用计数的代码可以自动地由编译器完成了。
使用 ARC 的好处
使用 ARC 有什么好处呢?
retain/release，原先需要手动添加的用来处理内存管
看到上面的例子，大家就知道了，以后写 Objective-C 的代码变得简单多了，因为我们不需要担心烦人的内存管理，担心内存泄 露了
代码的总量变少了，看上去清爽了不少，也节省了劳动力 代码高速化，由于使用编译器管理引用计数，减少了低效代码的可能性
不好的地方
记住一堆新的 ARC 规则—关键字及特性等需要一定的学习周期 一些旧的代码，第三方代码使用的时候比较麻烦;修改代码需要工数，要么修改编译开关
22.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对 象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释 放，池中的所有对象也就被释放。
1. ojc-c 是 通过一种” referring counting ”(引用计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc)的时候引用计数为一 ,以后 每当碰到有 copy,retain的时候引用计数都会加一 , 每当碰到 release和 autorelease的时候引用计数就会减一 ,如果此对象的计数变 为了 0, 就会被系统销毁 .
2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease和 release没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease会在对象的使用真正结束的时候才做引用计数 减一.

23.ViewController 的 loadView, viewDidLoad,viewDidUnload 分别是在什么时候调用的?在自定义 ViewController 的时候这几 个函数里面应该做什么工作?
viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。此方法在编程实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里
实现将 retain 的 view release,如果是 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。


28. 写出几个死循环?
29. 队列和栈有什么区别:
答:队列和栈是两种不同的数据容器。从”数据结构”的角度看，它们都是线性结构，即数据元素之间的关系相同。 队列是一种先进先出的数据结构，它在两端进行操作，一端进行入队列操作，一端进行出列队操作。 栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈都在栈顶操作。


31. iOS 的系统架构分为( 核心操作系统层 theCore OS layer )、( 核心服务层 theCore Services layer )、( 媒体层 theMedia layer )和( Cocoa界面服务层 the Cocoa Touch layer)四个层次。
32. 控件主要响应 3 种事件:( 基于触摸的事件 )、( 基于值的事件 )和( 基于编辑的事件 )。
33. xib 文件的构成分为哪 3 个图标?都具有什么功能。 (10 分)
答: File’ s Owner 是所有 nib 文件中的每个图标，它表示从磁盘加载 First Responder 就是用户当前正在与之交互的对象;
View 显示用户界面;完成用户交互;是 UIView 类或其子类。
34. 简述视图控件器的生命周期( 10 分)。
答: loadView 尽管不直接调用该方法， 如多手动创建自己的视图， 性。
nib 文件的对象;
那么应该覆盖这个方法并将它们赋值给试图控制器的
view 属
用于
viewDidLoad 只有在视图控制器将其视图载入到内存之后才调用该方法，这是执行任何其他初始化操作的入口。 viewDidUnload 当试图控制器从内存释放自己的方法的时候调用，用于清楚那些可能已经在试图控制器中创建的对象。
viewVillAppear 当试图将要添加到窗口中并且还不可见的时候或者上层视图移出图层后本视图变成顶级视图时调用该方法， 执行诸如改变视图方向等的操作。实现该方法时确保调用 [super viewWillAppear:].
viewDidAppear 当视图添加到窗口中以后或者上层视图移出图层后本视图变成顶级视图时调用， 执行的代码。确保调用 [super viewDidAppear : ] 。
35. 动画有基本类型有哪几种;表视图有哪几种基本样式( 10 分)?
答:动画有两种基本类型:隐式动画和显式动画。
36. 实现简单的表格显示需要设置 UITableView 的什么属性、实现什么协议( 10 分)?
用于放置那些需要在视图显示后
答 : 实 现 简 单 的 表 格 显 示 需 要 设 置 UITableView 的 dataSource 和 delegate 属 性 ， 实 现 UITableViewDataSource 和 UITableViewDelegate 协议。
37. Cocoa Touch提供了哪几种 Core Animation 过渡类型( 10 分)?
答: Cocoa Touch 提供了 4 种 Core Animation 过渡类型，分别为:交叉淡化、推挤、显示和覆盖。
38. UIView 与 CLayer 有什么区别( 10 分)?
答: 1. UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真 正的绘图部分，是由一个 CALayer 类来管理。 UIView 本身更像是一个 CALayer 的管理器，访问它的跟绘图和跟坐标有关的属 性。

2. UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。
3. UIView 的 CALayer 类似 UIView 的子 View 树形结构，也可以向它的 layer 上添加子 layer ，来完成某些特殊的表示。 即 CALayer 层是可以嵌套的。
4. UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻辑树，这里是代码可以操纵的;动画树，是一个中间层，系 统就在这一层上更改属性，进行各种渲染操作;显示树，其内容就是当前正被显示在屏幕上得内容。
5. 动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改，系统将自动进行动画生成，动画持续时间的缺省值似乎 是 0.5 秒。
6. 坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint 结构表示，值域是 0~1 ，是个比例值。 这个点是各种图形变换的坐标原点，同时会更改 layer 的 position 的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。
7. 渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用 setNeedsDisplay 方法来重绘显示。 8. 变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform 或 affineTransform 属性。
9. 变形: Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的。图像可以在一个三维坐标系中以任意角度被 旋转，缩放和倾斜。 CATransform3D 的一套方法提供了一些魔术般的变换效果。
39.链表翻转。
40. 链表逆序(C语言)(10分)。
链表逆序就是把一个链表按照原来的链接顺序逆序实现(也就是将头变成尾，尾变成头) 。 编程思路:其实最关键的是先通过原来的链接顺序找到下个节点，然后再把前个节点反序。
41. Quatrz 2D 的绘图功能的三个核心概念是什么并简述其作用(
答:上下文:主要用于描述图形写入哪里; 路径:是在图层上绘制的内容; 状态:用于保存配置变换的值、填充和轮廓， alpha 值等。
42. iPhone OS 主要提供了几种播放音频的方法( 10 分)?
答: SystemSound Services AVAudioPlayer 类
Audio Queue Services OpenAL
43. 使用 AVAudioPlayer 类调用哪个框架、使用步骤( 10 分)?
答: AVFoundation.framework 步骤:配置 AVAudioPlayer 对象;
实现 AVAudioPlayer 类的委托方法;
10 分)。

控制 AVAudioPlayer 类的对象; 监控音量水平; 回放进度和拖拽播放。
44. 有哪几种手势通知方法、写清楚方法名( 10 分)?
答:
-(void)touchesBegan:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesMoved:(NSSet*)touched withEvent:(UIEvent*)event; -(void)touchesEnded:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesCanceled:(NSSet*)touchedwithEvent:(UIEvent*)event;
45. 实例化一个 UITableView 对象，要求写出关键语句( 10 分)。
答: UITableView *my = [[UITableView alloc]initWithFrame:<(CGRect)frame> style:<(UITableViewStyle)style>]; my.delegate = self;
my.dataSource = self;
首先需要分配空间设置表格类型
然后需要设置两个必须的委托对象。
46. CFSocket 使用有哪几个步骤( 10 分)。
答:创建 Socket 的上下文;创建 Socket ;配置要访问的服务器信息;封装服务器信息;连接服务器;
47. Core Foundation 中提供了哪几种操作 Socket的方法( 10 分)?
答: CFNetwork 、 CFSocket 和 BSD Socket 。
48. 解析 XML 文件有哪几种方式( 10 分)?
答:以 DOM 方式解析 XML 文件;以 SAX 方式解析 XML 文件;
49. 自定义一个委托( 15 分)。
答: @protocol SimpleProtocol -(void)doSomething:(NSString*)str;
@end
@interfaceSimpleClass:NSObject< SimpleProtocol >{ }
@end @implementationSimpleClass -(void)doSomething:(NSString *)str

{ NSLog(str); }
@end
50. 类别的作用?继承和类别在实现中有何区别?
答案: category可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。 类别主要有 分散到多个不同文件或多个不同框架中。 (2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。 法，并且可以增加属性。
51.通知和协议的不同之处?
并且如果类别和原 3 个作用: (1) 将类的实现
继承可以增加，修改方
答案:协议有控制链 (has-a)的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 通知和代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受 者。代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的
事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发 出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因 此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
52.关于多态性
答案:多态，子类指针可以赋值给父类。 这个题目其实可以出到一切面向对象语言中， 因此关于多态，继承和封装基本最好都 有个自我意识的理解，也并非一定要把书上资料上写的能背出来。 最重要的是转化成自我理解。
53.对于单例的理解
答案: 基本能用熟悉的语言写出一个单例， 以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。 考虑下如何在多线程访问单例时的安全性。
54. 是否在一个视图控制器中嵌入两个 tableview 控制器?
答案:一个视图控制只提供了一个 View 视图，理论上一个 图。当然，题目本身也有歧义，如果不是我们定性思维认为的 以把其看成一个视图控制者，它可以控制多个视图控制器，比如
进一步点，
tableViewController 也不能放吧， 只能说可以嵌入一个 UIViewController ， 而是宏观的表示视图控制者，那我们倒是可
TabbarController 那样的感觉。
55. 一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案:首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 因此我们并不关心如何去关联 他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。 因此，我觉得可以设置多个数据源啊，但是有 个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示?
~ )。但是简单分析下
tableview 视

56. Object - c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式用继承好还是分类 好?为什么?
答案: Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现， cocoa 中所有的类都 是 NSObject 的子类，多继承在这里是用 protocol 委托代理来实现的。
57. id 声明的对象有什么特性?
答案: id 是个很重要的类型，是个可以指向任何类型的指针或者可以理解为指向任何未知类型的指针。
58. 自动释放池跟 GC (垃圾回收)有什么区别? iPhone 上有 GC 么?[ poolrelease] 和[ pooldrain]有什么区别?
iPhone 上没有 GC 。iPhone 开发的时候没有垃圾回收机制。 在垃圾回收环境中， release 是一个空操作。 因此，NSAutoreleasePool 提 供了 drain 方法，在引用计数环境中，该方法的作用等同于调用 release，但在垃圾回收环境中，它会触发垃圾回收(如果自上次 垃圾回收以来分配的内存大于当前的阈值) 。因此，在通常情况下，您应该使用 drain 而不是 release来销毁自动释放池。
59. 线程与进程的区别和联系 ?
答案 : 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。 主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程 产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线 程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
程和线程的
iOS 中可以有四种持久化数据的方式:属性列表、对象归档、
式快速的定义 app 的数据模型， 同时在你的代码中容易获取到它。
撤销和重做，允许你在 app 中继续创建新的任务。在使用 core data 的时候，你不用安装额外的数据库系统，因为 core data 使用 内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组定义在内存中的数据对象。 coredata 会追踪这些对象的改变，同时 可以根据需要做相反的改变，例如用户执行撤销命令。当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些 数据归档，并永久性保存。 mac os x 中 sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在 多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。与 core data 框架不同的是， sqlite 是使用程序式的， sql 的主要 的 API 来直接操作数据表。 Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 Core Dta 支持
SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支 持对一、对多的关系。
61. obj-c 有多重继承么 ? 如果没有什么替代方法 ?
cocoa中所有的类都是 NSObject 的子类， 多继承在这里是用 protocol 委托代理来实现的。 你不用去考虑繁琐的多继承， 虚基类 的概念。
60. ios平台怎么做数据的持久化 ?coredata和 sqlite有无必然联系?
coredata 是一个关系型数据库吗?
SQLite3 和 Core Data; core data 可以使你以图形界面的方 coredata提供了基础结构去处理常用的功能， 例如保存， 恢复，

62. obj-c 有私有方法么 ? 私有变量呢?
objective-c – 类里面的方法只有两种 , 静态方法和实例方法 . 这似乎就不是完整的面向对象了 ,按照 OO 的原则就是一个对象只
暴露有用的东西 . 如果没有了私有方法的话 , 对于一些小范围的代码重用就不那么顺手了
@interface Controller : NSObject { NSString *something; } + (void)thisIsAStaticMethod;
- (void)thisIsAnInstanceMethod;
@end
@interface Controller (private) - (void)thisIsAPrivateMethod; @end
@private 可以用来修饰私有变量
在 Objective‐C 中，所有实例变量默认都是私有的，所有实例方法默认都是公有的
63. 假定输入的字符串中只包含字母和 * 号。编写函数 fun，功能是，除了中间和尾部的
将字符串中其他 * 号全部删除。编写时，不用 c 的其他函数。
. 在类里面声名一个私有方法
例: *****A*BC*DEF*G**** void fun (char *a)
{
int j=0;
char *p=a;
while (*p== ’ * ’ )p++; while (*p){
a[j++]=*p;
p++;
结果为: A*BC*DEF*G****
} a[j]=0;
}
64. 截取字符串”
20 | http://www.621life.com“ 中
65. 获取项目根路径，并在其下创建一个名称为 userData 的目录。(10 分)。
“20|http://www.621life.com”;
NSString *str =
NSRange range = [strrangeOfString:@” |” ];
int location = range.location;
NSString *str1 = [strsubstringToIndex:location]; NSString *str2 = [str substringFromIndex:location+1];
‘|’字符前面及后面的数据，分别输出它们(
10 分)。
// 获取根路径
NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES);
* 号外，

NSString *documentsDirectory = [paths objectAtIndex:];
// 创建文件系统管理器
NSFileManager *fileManager = [[NSFileManageralloc] init];
// 判断 userData 目录是否存在
if(![fileManagerfileExistsAtPath:[NSStringstringWithFormat:@
// 不存在 , 创建一个 userData 目录
[fileManagercreateDirectoryAtPath:[NSStringstringWithFormat:@ ”%@/userData ”,documentsDirectory]withIntermediateDir ectories:falseattributes:nilerror:nil];
}
66. tableView 的重用机制( 10 分)?
UITableView 通过重用单元格来达到节省内存的目的 : 通过为每个单元格指定一个重用标识符
(reuseIdentifier),即指定了单元格
的种类 ,以及当单元格滚出屏幕时 就够了 .
67. 这段代码有什么问题吗
@implementation Person
i. (void)setAge:(int)newAge {
self.age = newAge;
}
死循环
68.用变量 a 给出下面的定义
,允许恢复单元格以便重用
.对于不同种类的单元格使用不同的
ID,对于简单的表格
,一个标识符
a)
b) c)
d) e) f) g) h)
a) b)
c) d)
e) f) g)
一个整型
一个指向整型数的指针 一个指向指针的的指针，它指向的指针是指向一个整型数
一个有 10个整型数的数组
一个有 10 个指针的数组，该指针是指向一个整型数的
一个指向有 10 个整型数数组的指针 一个指向函数的指针，该函数有一个整型参数并返回一个整型数
一个有 10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数
int a; int *a;
int **a; int a[10]
int *a[10]; int (*a)[10];
int (*a)(int);
”%@/userData ”,documentsDirectory]]) {

i) int (*a[10])(int);
69. 给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置?
比如” abaccddeee”f 则是 b，输出 2
int find(char *_str) {
char *p = _str;
inti = 1;
while (*p)
{
char *temp = _str;
while (*temp)
{
if ((*p ==*temp)&&(p != temp))
{
break;
}
temp++;
if (*temp == 0) {
returni;
}
}
i++;
p++;
}
return-1;
}
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
intfind_char(constchar* str)
{
staticintpos[256];
const unsigned char* p =(const unsigned char*)str; inti = 0;
if( (!str) || (!(*str)) )return -1; memset(pos,-1,sizeof(pos));
while(*p){
if(pos[*p] == -1){
pos[*p] = p-(const unsigned char*)str;
}else{
pos[*p] = -2;

}
p++;
}
for(i=0;i<sizeof(pos)/sizeof(pos[0]);i++){ if(pos[i]>=0)returnpos[i];
}
return -1;
}
int main()
{
constchar* p =” abaccddeeef” ;
intpos = find_char(p);
printf( “ %d, it is ’ %c ’ \n” ,pos,pos!=-1?p[pos]’: ‘ ); p =”abcdefghijklmnopqrstuvwxyz “ “abcdefghijklmnopqrstuwxyz”;
pos = find_char(p);
printf( “ %d, it is ’ %c ’ \n” ,pos,pos!=-1?p[pos]’: ‘ ); return0;
}
70. objective-c中的数字对象都有哪些，简述它们与基本数据类型的区别是什么?
在 OC 中 NSNumber 是数字对象，可以进行拆装箱操作! // 将 int 转为 NSNumber
NSNumber *num = [NSNumber numberWithInt:123];
// 得到一个 int
inttestNum = [numintValue];
71.用 NSLog函数输出一个浮点类型，结果四舍五入，并保留一位小数
NSLog(@ ” %0.1f ” ,4.4324);
72. objective-c中的词典对象、可变词典对象是哪个，初始化一个含有两个键值对的可变词典对象，并动态的添加和删除一条记
录，输出第一条记录 .
词典 NSDictionary ，可变词典 NSMutableDictionary ，
// 初始化一个可变词典，带有 2 个键值对
NSMutableDictionary *dic =[NSMutableDictionarydictionaryWithObjectsAndKeys:@ key2′′ ,nil];
// 添加
[dicsetObject:@” value3′′ forKey:@ ” key3′′ ];
// 删除
[dicremoveObjectForKey:@ ” key3′′ ];
// 获取(按 key 获取)
[dicobjectForKey:@” key1′′];
” value1′′ ,@ ” key1′′ ,@” value2′′ ,@”

73. 获取项目根路径，并在其下创建一个名称为 userData 的目录。
// 获取根路径
NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString*documentsDirectory = [paths objectAtIndex:];
// 创建文件系统管理器
NSFileManager *fileManager= [[NSFileManageralloc] init];
// 判断 userData 目录是否存在
if(![fileManagerfileExistsAtPath:[NSStringstringWithFormat:@
// 不存在 , 创建一个 userData 目录
[fileManagercreateDirectoryAtPath:[NSStringstringWithFormat:@ ”%@/userData ”,documentsDirectory]withIntermediateDir ectories:falseattributes:nilerror:nil];
}
74. do-while 与 while-do 的区别?
do-while 先执行循环体，然后判断条件，如果条件判断为 ture ，则继续执行循环体，如果判断为 false，则不执行循环体 while-do 是先判断条件是否正确，若正确则执行循环体，若不正确则不执行循环体。
所以 do-while 至少循环一次，而 while-do 有可能一次也不循环。
75. 用 C 语言，求
#include<stdio.h> intisPrime(int n)
{
inti; for(i=2;i*i<=n;i++) if(n%i==0)
return 0; return 1;
}
int main()
{
inti,sum=0; for(i=2;i<100;i++)
if( isPrime(i))
sum+=i;
printf( “%5d ”,sum); return 0 ;
}
intisPrime(int n)
{
inti;
2 到 100 内的所有素数和。
// 求素数，这是最经典的算法代码。建议记住
”%@/userData ”,documentsDirectory]]) {

for(i=2;i<=n/2;i++) {
if(n%i==0) break;
} if(i>n/2)
return1; else
return0; }
76.单件实例是什么(
10 分)。
Foundation 和 Application Kit 框架中的一些 类 只允 许创 建 单 件 对 象，即 这 些 类 在当前 进 程中的唯一 实 例。 举 例来 说 ， NSFileManager 和 NSWorkspace类 在使用时 都是基于 进 程 进 行 单 件 对 象的 实 例化。当向 这 些 类请 求 实 例的 时 候，它 们 会向您 传递单 一 实例的一个引用，如果 该实 例还不存在， 则 首先 进行 实例的分配 和初始化。 单件 对象充当控制中心 的角色， 负责 指引或 协调类 的各种服 务 。如果 类 在概念上只有一个 实 例(比如
NSWorkspace)，就 应该产 生 一个 单 件 实 例，而不是多个 实 例;如果将来某一天可能有多个 实 例，您可以使用 单 件 实 例 机制，而不是工厂方法或函数。
77.自动释放池是什么 ,如何工作。
当您向一个对象发送一个 autorelease消息时， Cocoa就会将该对象的一个




 IOS 面试题
1.在一个对象的方法里面: self.name= “ object;和” name =” object 有”什么 不同吗 ?
答:
self.name=” object:会”调用对象的 setName()方法; name=“objec:t会”直接把object赋值给当前对象的name属性。
2.请简述self.name=nil的机制，以及与[namerelease的]区别? self.name=nil; //使用 nil 参数调用 setName:方法
[ name release]生成的访问器将自动释放以前的 name 对象 3.请简要说明 viewDidLoad 和 viewDidUnload 何时调用
答 viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。 此方法在编程实现 view 时调用， view 控制器默认会 注册 memory warning notification ，当 view controller 的任何 view 没有用的 时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release，如果 是 retain 的 IBOutlet view 属性则不要在这里 release，IBOutlet 会负责 release 。
4.打印结果 main()
{
int a[5]={1,2,3,4,5};
int *ptr=(int*)(&a+1);
printf( “ %d,%d” ,*(a+1),*(ptr-1));
}
答:
*(a+1)就是 a[1]，*(ptr-1) 就是 a[4],执行结果是 2，5

 &a+1 不是首地址 +1，系统会认为加一个 a 数组的偏移，是偏移了一个数 组的大小(本例是 5 个 int)
int *ptr=(int *)(&a+1);
则 ptr 实际 是 &(a[5]), 也就是 a+5
原因如下:
&a 是数组指针，其类型为 int (*)[5]; 而指针加 1 要根据指针类型加上一定的
值，不同类型的指针 +1 之后增加的大小不同。
a 是长度为 5 的 int 数组指针，所以要加 5*sizeof(int) 所以 ptr 实际是 a[5]
但是 prt 与(&a+1)类型是不一样的 (这点很重要 )
所以 prt-1 只会减去 sizeof(int*)
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0]的地址， &a 是对象(数组)首地址，
a+1 是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].
5.简述内存分区情况 提示:分为代码区、数据区、堆区、栈区
(1)代码区:存放函数二进制代码 (2)数据区:系统运行时申请内存并初始化，系统退出时由系统释放。存 放全局变量、静态变量、常量
(3)堆区:通过 malloc 等函数或 new 等操作符动态申请得到， 需程序员手 动申请和释放
(4)栈区:函数模块内申请， 函数结束时由系统自动释放。 存放局部变量、 函数参数
6.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease消息时， Cocoa就会将该对象的

 一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释 放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域 结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。
1)objc-c 是 通过一种 ”referringcounting 引”用(计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc)的时候引用计数为一 ,以后每当碰到有 copy,retain
的时候引用计数都会加一 , 每当碰到 release和 autorelease的时候引用计数 就会减一 ,如果此对象的计数变为了 0, 就会被系统销毁 .
2)NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不 用你管的 .
3) autorelease和 release没什么区别 ,只是引用计数减一的时机不同而 已 ,autorelease会在对象的使用真正结束的时候才做引用计数减一 .

8. 队列和栈有什么区别:
答:队列和栈是两种不同的数据容器。 从”数据结构 ”的角度看， 它们都是线 性结构，即数据元素之间的关系相同。
队列是一种先进先出的数据结构，它在两端进行操作，一端进行入队 列操作，一端进行出列队操作。
栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈 都在栈顶操作。


24.TCP/UDP 区别联系
TCP---传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户
和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才 能传输数据。 TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等 功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议， 是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不
能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器 之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
TCP(TransmissionControl Protocol，传输控制协议)是基于连接的协 议，也就是说， 在正式收发数据前， 必须和对方建立可靠的连接。 一个 TCP 连接必须要经过三次 “对话 ”才能建立起来，我们来看看这三次对话的简单过 程: 1.主机 A 向主机 B 发出连接请求数据包; 2.主机 B 向主机 A 发送同意 连接和要求同步(同步就是两台主机一个在发送，一个在接收，协调工作) 的数据包; 3.主机 A 再发出一个数据包确认主机 B 的要求同步: “我现在就

 发，你接着吧! ”，这是第三次对话。三次 “对话 ”的目的是使数据包的发送 和接收同步，经过三次 “对话 ”之后，主机 A 才向主机 B 正式发送数据。
UDP( User Data Protocol，用户数据报协议)是与 TCP 相对应的协议。 它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送 过去! UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接 传输可靠性可靠不可靠 应用场合传输大量数据少量数据 速度慢快
25.socket 连接和 http 连接的区别 简单说，你浏览的网页(网址以
http://开头)都是 http 协议传输到你的 浏览器的,而http是基于 socket之上的。socket是一套完成 tcp，udp协议的
接口。
HTTP 协议:简单对象访问协议， 对应于应用层，HTTP 协议是基于 TCP 连接的。
tcp 协议:对应于传输层 ip 协议:对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是 应用层协议，主要解决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调 用接口( API )，通过 Socket，我们才能使用 TCP/IP 协议。
http 连接:http 连接就是所谓的短连接，即客户端向服务器端发送一次 请求，服务器端响应后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端 一旦建立起连接将不会主动断掉;但是由于各种环境因素可能会是连接断
开，比如说:服务器端或客户端主机 down 了，网络故障，或者两者之间长 时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以

 当一个 socket连接中没有数据的传输，那么为了维持连接需要发送心跳消 息 ~~具体心跳消息格式是开发者自己定义的。
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 “一切皆文件 ”， 都可以用 “打开 open –>读写 write/read –>关闭 close ”模式来操作。我的理解 就是 Socket就是该模式的一个实现， socket即是一种特殊的文件， 一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数我们在后面 进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是 那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数 据有意义，则必须使用到应用层协议， 应用层协议有很多， 比如 HTTP、FTP、 TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层 协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网 络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层。 而 http 是个应用层的协议， 它 实际上也建立在 TCP 协议之上。 (HTTP 是轿车，提供了封装或者显示数据 的具体形式; Socket是发动机，提供了网络通信的能力。 )
2)Socket是对 TCP/IP 协议的封装， Socket本身并不是协议，而是一 个调用接口( API )，通过 Socket，我们才能使用 TCP/IP 协议。 Socket 的
出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议 的抽象，从而形成了我们知道的一些最基本的函数接口。
26 什么是 TCP 连接的三次握手
第一次握手:客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND
状态，等待服务器确认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1)，
同时自己也发送一个 SYN 包( syn=k)，即 SYN+ACK 包，此时服务器进 入 SYN_RECV 状态;

 第三 不次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送 确认包 ACK(ack=k+1) ，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务 器才正式开始传送数据。理想状态下， TCP 连接一旦建立，在通信双方中 的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。断开连接 时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经 过“四次握手 ”(过程就不细写了， 就是服务器和客户端交互， 最终确定断开) 27利用 Socket建立网络连接的步骤
建立 Socket连接至少需要一对套接字，其中一个运行于客户端，称为
ClientSocket，另一个运行于服务器端，称为 ServerSocke。t 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连
接确认。
1)服务器监听:服务器端套接字并不定位具体的客户端套接字，而是 处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
2)客户端请求:指客户端的套接字提出连接请求，要连接的目标是服 务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器 的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接 字提出连接请求。
3)连接确认:当服务器端套接字监听到或者说接收到客户端套接字的 连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器
端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立 连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字 的连接请求。
28 多线程 多线程编程是防止主线程堵塞，增加运行效率等等的最佳方法。而原
始的多线程方法存在很多的毛病， 包括线程锁死等。 在 Cocoa中，Apple 提 供了 NSOperation这个类，提供了一个优秀的多线程编程方法。

 本次介绍 NSOperation 的子集，简易方法的 NSInvocationOperation:一 个 NSOperationQueue操作队列，就相当于一个线程管理器， 而非一个线程。 因为你可以设置这个线程管理器内可以并行运行的的线程数量等等
29指针与地址的区别 ? 区别:
1)指针意味着已经有一个指针变量存在 ,他的值是一个地址 ,指针变量 本身也存放在一个长度为四个字节的地址当中 ,而地址概念本身并不代表有 任何变量存在。
2)指针的值 ,如果没有限制 ,通常是可以变化的 ,也可以指向另外一个地 址。
地址表示内存空间的一个位置点 ,他是用来赋给指针的 ,地址本身是没 有大小概念 ,指针指向变量的大小 ,取决于地址后面存放的变量类型。
30.id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object
的一个指针，这个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject)类的对象。需要注意的是 id 是一个指针，所以你在使用
id 的时候不需要加星号。比如 id foo=nil 定义了一个 nil 指针，这个指针指 向 NSObject 的一个任意子类。而 id *foo=nil 则定义了一个指针，这个指针
指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C语言 的 NULL 相同 ，在 objc/objc.h 中定 义。 nil 表示 一个
Objctive-C 对象，这个对象的指针指向空(没有东西就是空)。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类 (是 Class， 而不是对象)。
SEL是“selecto的r一”个类型，表示一个方法的名字Method(我们常说 的方法)表示一种类型，这种类型与 selector和实现(implementation)相关IMP
定义为 id(*IMP) (id,SEL, ⋯)。这样说来， IMP 是一个指向函数的指针，这 个被指向的函数包括 id( “sel指f ”针 )，调用的 SEL(方法名)，再加上一些 其他参数 .说白了 IMP 就是实现方法。




 ios 笔试题 最近找工作，有面试有笔试部分，故把笔试题自己整理了下。
面试能力要求:精通 iphone 的 UI 开发，能熟练操作复杂表视图， 熟练使用图层技术， 可以自 定义 UI 控件，使用类别扩展系统控件功能 ;
擅长通讯技术，熟悉各种通信协议，精通 xml, json, 服务器实现客户端与服务器的通讯以提交开发效率
熟练掌握各种数据存储技术，如 core data, sqlite, 的设计。
  二进制或其他形式的自定义解析，能架设
;
精通 object-c ，java ， c 等编程语言 , 熟悉 c++ ，对于 面向对象编程思想有深入理解，熟 悉常见设计模式的应用，
对于大型项目有一定的架构能力。
1. ViewController 的 didReceiveMemoryWarning 怎么被调用: [supper didReceiveMemoryWarning];
2. 什么时候用 delegate, 什么时候用 Notification?
delegate 针对 one-to-one 关系，用于 sender 接受到 reciever 的某个功能反馈值。 notification 针对 one-to-one/many/none,reciver, 用于通知多个 object 某个事件。
3. 用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题)
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情:
#define 语法的基本知识(例如:不能以分号结束，括号的使用，等等)
懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不 是计算出实际的值，是更清晰而没有代价的。
意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常 数是的长整型数。
如果你在你的表达式中用到 UL (表示无符号长整型)，那么你有了一个好的起点。记住，第一 印象很重要。
写一个 " 标准 " 宏 MIN ，这个宏输入两个参数并返回较小的一个。
对象序列化，文件读写操作，熟悉数据库

#define MIN(A,B) (( A ) <= (B) ? (A) : (B)) 这个测试是为下面的目的而设的:
标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方
法，
对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。
懂得在宏中小心地把参数用括号括起来
我也用这个问题开始讨论宏的副作用，例如:当你写下面的代码时会发生什么事?
least = MIN(*p++, b);
结果是:
((*p++) <= (b) ? (*p++) : (*p++))
这个表达式会产生副作用，指针
4. 写一个委托的 interface @protocol MyDelegate;
@interface MyClass: NSObject
{
id <MyDelegate> delegate;
}
// 委托方法
@protocol MyDelegate
- (void)didJobs:(NSArray *)args; @end
p 会作三次 ++ 自增操作。

5. 写一个 NSString 类的实现
+ (id)initWithCString:(const char *)nullTerminatedCString
encoding:(NSStringEncoding)encoding;
+ (id) stringWithCString: (const char*)nullTerminatedCString encoding: (NSStringEncoding)encoding
{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return AUTORELEASE(obj);
}
6.obj-c 有多重继承么 ? 不是的话有什么替代方法 ?
cocoa 中所有的类都是 NSObject 的子类
多继承在这里是用 protocol 委托代理 来实现的 你不用去考虑繁琐的多继承 , 虚基类的概念 .
ood 的多态特性 在 obj-c 中通过委托来实现 .
7.obj-c 有私有方法么 ? 私有变量呢
objective-c - 类里面的方法只有两种 , 静态方法和实例方法
了, 按照 OO 的原则就是一个对象只暴露有用的东西 . 如果没有了私有方法的话 围的代码重用就不那么顺手了 . 在类里面声名一个私有方法
@interface Controller : NSObject { NSString *something;
}
+ (void)thisIsAStaticMethod;
- (void)thisIsAnInstanceMethod; @end
@interface Controller (private)
. 这似乎就不是完整的面向对象
, 对于一些小范

-(void)thisIsAPrivateMethod; @end
@private 可以用来修饰私有变量
在 Objective ‐C 中，所有实例变量默认都是私有的，所有实例方法默认都是公有的。
8. 关键字 const 有什么含意?修饰类呢 ?static 的作用 , 用于类呢 ?还有 extern c 的作用
const 意味着 " 只读 " ，下面的声明都是什么意思? const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，
第三个意味着 a 是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。
第四个意思 a 是一个指向整型数的常指针(也就是说，指针指向的整型数是可以修改的，但指 针是不可修改的)。
最后一个意味着 a 是一个指向常整型数的常指针 (也就是说， 指针指向的整型数是不可修改的， 同时指针也是不可修改的)。
结论:
关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量 是为了告诉了用户这个参数的应用目的。
如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。(当然， 懂得用 const 的程序员很少会留下的垃圾让
别人 来清理的。) 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的 代码。
合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意 的代码修改。简而言之，这样可以减少 bug
的出 现。
a 是一个常整型数。

(1 )欲阻止一个变量被改变，可以使用 它进行初
始化，因为以后就没有机会再去改变它了; (2 )对指针来说，可以指定指针本身为 同时指
定为 const ;
const
const
关键字。 在定义该 const 变量时， 通常需要对
，也可以指定指针所指的数据为 const ，或二者
(3 )在一个函数声明中， const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变 其值;
(4 )对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成 员变量;
(5 )对于类的成员函数， 有时候必须指定其返回值为 const 类型，以使得其返回值不为 “左值 ”。
关键字 volatile 有什么含意 ?并给出三个不同的例子。
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设
这个变量的值了。
精确地说就是， 优化器在用到这个变量时必须每次都小心地重新读取这个变量的值， 保存在寄存器里的备份。
下面是 volatile 变量的几个例子: 并行设备的硬件寄存器(如:状态寄存器)
一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables) 多线程应用中被几个任务共享的变量
一个参数既可以是 const 还可以是 volatile 吗?解释为什么。 一个指针可以是 volatile 吗?解释为什么。
下面是答案:
是的。一个例子是只读的状态寄存器。 它是 volatile 因为它可能被意想不到地改变。 因为程序不应该试图去修改它。
而不是使用
它是 const 是的。尽管这并不很常见。 一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。
9. static 关键字的作用:
(1 )函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分 配一次，
因此其值在下次调用时仍维持上次的值;
(2 )在模块内的 (3 )在模块内的 在声明 它的模块内; (4 )在类中的
static static
static
全局变量可以被模块内所用函数访问， 但不能被模块外其它函数访问; 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制
成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;


23.http 和 scoket 通信的区别。
http 是客户端用 http 协议进行请求， 发送请求时候需要封装 http 请求头，并绑定请求的数据， 服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发起请求，服 务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应(除
非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket “套接字 ”进行连接， 并没有规定连接后断开， 所以客
户端和服务器可以保持连接通道， 双方都可以主动发送数据。 求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是


 30.320 框架(了解一下)
( ui 框架，导入 320 工程作为框架包如同添加一个普通框架一样)。
cover(open) flower 框架 (2d 仿射技术 ) ，内部核心类是 CATransform3D.
31. 什么是沙箱模型?哪些操作是属于私有 api 范畴 ?
某个 iphone 工程进行文件操作有此工程对应的指定的位置，不能逾越。
iphone 沙箱模型的有四个文件夹，分别是什么，永久数据存储一般放在什么位置，得到模拟器
的路径的简单方式是什么 . documents ， tmp ， app
， Library 。 ( NSHomeDirectory() )，
手动保存的文件在 documents 文件里 Nsuserdefaults 保存的文件在 tmp 文件夹里
Documents 目录:您应该将所有 de 应用程序数据文件写入到这个目录下。 这个目录 用于存储用户数据或其它应该定期备份 的 信息。
AppName.app 目录:这是应用程序 的 程序包目录，包含应用程序 的 本身。由于应用 程序必须经过签名，
所以您在运行时不能对这个目录中 的 内容进行修改，否则可能会使应用程序无法启 动。
Library 目录:这个目录下有两个子目录: Caches 和 Preferences
Preferences 目录包含应用程序 的偏好设置文件。 您不应该直接创建偏好设置文件， 而是应该使用 NSUserDefaults 类来取得和设置应用程序 的 偏好 .
Caches 目录用于存放应用程序专用 的支持文件，保存应用程序再次启动过程中需要 的 信息。
tmp 目录:这个目录用于存放临时文件，保存应用程序再次启动过程中不需要 的信 息。
获取这些目录路径 的 方法:
1，获取家目录路径 的 函数:
NSString *homeDir = NSHomeDirectory();
2，获取 Documents目录路径 的方法:
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
3，获取 Caches目录路径的方法:
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,

 NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];
4，获取 tmp 目录路径 的方法:
NSString *tmpDir = NSTemporaryDirectory(); 5，获取应用程序程序包中资源文件路径 的 方法: 例如获取程序包中一个图片资源( apple.png )路径 的方法:
NSString *imagePath = [[NSBundle mainBundle] pathForResource:@ ofType:@”png”];
UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath]; 代码中的 mainBundle 类方法用于返回一个代表应用程序包 的对象。
文件 IO 写入
1，将数据写到 Documents 目录:
- (BOOL)writeApplicationData:(NSData *)data toFile:(NSString *)fileName {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0]; if (!docDir) {
NSLog(@”Documents directory not found! ”); return NO; }
” apple ”
NSString *filePath = [docDir stringByAppendingPathComponent:fileName]; return [data writeToFile:filePath atomically:YES];
}
2，从 Documents目录读取数据:
- (NSData *)applicationDataFromFile:(NSString *)fileName {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
NSString *filePath = [docDir stringByAppendingPathComponent:fileName];
NSData *data = [[[NSData alloc] initWithContentsOfFile:filePath] autorelease];
return data;

 }
NSSearchPathForDirectoriesInDomains 这个主要就是返回一个绝对路径用来存放 我们需要储存 的文件。
- (NSString *)dataFilePath {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
return [documentsDirectory stringByAppendingPathComponent:@"shoppingCar.plist"]; }
NSFileManager* fm=[NSFileManager defaultManager]; if(![fm fileExistsAtPath:[self dataFilePath]]){
// 下面是对该文件进行制定路径 的 保存
[fm createDirectoryAtPath:[self dataFilePath] withIntermediateDirectories:YES attributes:nil error:nil];
// 取得一个目录下得所有文件名
NSArray *files = [fm subpathsAtPath: [self dataFilePath] ];
// 读取某个文件
NSData *data = [fm contentsAtPath:[self dataFilePath]];
// 或者
NSData *data = [NSData dataWithContentOfPath:[self dataFilePath]]; }
iphone 常见私有 api 的应用(比如直接发送短信，访问沙箱之外的磁盘文件) .
32. 你在开发项目中时，用到了哪些数据存储方式， iphone 中常见的方式有哪些，各有什么区
别?
数据存储五种形式的应用范围和性能区别
( core data, sqllite, 对象序列化，文件直接读写， NSUserDefault( 保存数据到 temp 文件 夹中 ) )
文件直接读写 >core data> 对象序列化 > sqllite>NSUserDefault.

33. 线程的常见方法有哪些，你是如何处理多线程的，多线程同步问题你了解么? 线程创建的几种方式，线程的加锁，休眠，唤醒，解锁，退出，
多线程要考虑同步问题 , 解决同步问题的方式就是对某一资源加锁，当一个线程操作本资源时， 其他线程不能操作 。
系统自带线程池( NSOpertionQueue )的作用:
凡是需要启动多个线程的地方都可以使用 NSOpertionQueue ，加入到 NSOpertionQueue 中 的对象都需要继承 NSOpertion 。 NSOpertionQueue 会在系统内部启动一个独立线程去执行 这个被加入对象的 main 方法。
常用的地方是用 nsoprationqueue 下载图片，文件。如果是自己创建一个线程池，无非就是 启动多个线程的时候，
把这些线程对象放到一个大数组中，如果需要启动线程的时候，先从数组中找空闲线程来使用。
自己管理线程池最大的难题是不好处理当启动多个线程后， 用户在多个界面的跳转的时候， 对线 程方法的回调管理。
而 NSOpertionQueue 可以很好的处理他。
34.init 和 initwithobject 区别(语法)? init 创建的对象不带自动释放
36. 你使用过 json 解析方式么，他们的底层是如何处理的你了解么?
json 解析的用法，用框架的用法简单介绍: 底层原理遍历字符串中的字符，最终根据格式规定的特殊字符，比如
{} 号， [] 号 , :
号 等进行
区分，
{} 号是一个字典的开始， [] 号是一个数组的开始 , : 号是字典的键和值的分水岭，最终乃是将
json 数据转化为字典， 字典中值可能是字典，数组，或字符串而已。

37.xml 解析的原理是什么，你还用过其他解析方式么?
NSXMLParser, 其他解析方式有自定义二进制解析，就是按字节去解析，电话会谈就是如此，
还可以是字符串之间用特殊符号连接的数据，将此数据用特殊符号可以分割成所用数据。
38. 协议是什么，有什么作用 . ?
协议很像 java 中的接口，某个类实现协议后，就必须实现协议中规定的 @require 的方法，比 如一个类 A, 一个类 B 都实现某 “协议 ”后，
这个类 A 的对象和 B 的对象都可以赋值给这个协议的类型变量，比如 id< 协议 > 变量名 = A 类或 B 类的对象，
于是这个变量就完成了能够指向多个不同的类的对象并调用对象中的实现协议的方法。
39. 类别有什么作用?
类别的使用 。 类别有三大作用，
1. 可以使本来需要在 .h 中声明的方法放到 .m 文件中声明，达到了可以使方法不对外公开。 2. 可以方便的扩展类，甚至系统类都可以轻易扩展，维护了代码原本的结构不受影响。
3. 类别可以写到不同的 .h 或 .m 文件中，可以分散代码到跟类别的扩展功能想关联的地方，方 便查看。
40. 分线程回调主线程方法是什么，有什么作用?
[self performSelectorOnMainThread:@selector(buttonGo2) withObject:nil
waitUntilDone:YES];
[self performSelector:@selector(buttonGo2) onThread:[NSThread mainThread]
withObject:nil waitUntilDone:YES]; 需要即时刷新 ui 控件的时候，经常使用。
41.iphone 阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的?另外像 式的文件，你如何读取。 ?
pdf 格
iphone 手机阅读器中对于 上下到很多直接读取 pdf 格式的代码
控件显示，也可以从网
直接从 pdf 中得到数据。 复杂表格动画
- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths
withRowAnimation:(UITableViewRowAnimation)animation; -(void)deleteRowsAtIndexPaths:(NSArray *)indexPaths
PDF 格式的阅读，可以直接用
UIWebView

 withRowAnimation:(UITableViewRowAnimation)animation; - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths
withRowAnimation:(UITableViewRowAnimation)animation;
42. 你在开发大型项目的时候，如何进行内存泄露检测的 ?
可以通过 xcode 的自带工具 run---start with performance tool 里有 instruments 下有
个 leaks 工具， 启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助
进行内存泄露的处理。
43. 你做 iphone 开发时候，有哪些传值方式， view 和 view 之间是如何传值的? 压栈。
44. 让一个物体从界面中的一点运动到另外一点，有哪些方法? 四种方式: 1. beginAnimation
2. 线程
3. NSTimer
4. 图层动画(路径)
45. 你了解哪些加密方式?
Base64, MD5, 循环右移位等 .
46. 地图定位
CLLocationManager 位置管理器 使用 Core Location 框架来确定 iphone 的位置( GPS，
蜂窝基站三角网， wps 三种方式) MKMapView提供了一套可植入的地图接口，可以让我们在应用中展示地图，并对其
进行相关的操作。一般来说，我们可以指定一个展示区域，放一些标记在上面，还 可以加盖一些层在上面。
MKMapView依赖 Google map 里面相关服务(如 Google Earth API 等)，所以地图 的左下角会有 Google 字样。
47. 打开 url
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://8004 664411"]]; mailto:// sms://

48. http 网络通信
ASIHTTPRequest 是一个直接在 CFNetwork 上做的开源项目:提供直接提交 (HTTP POST)
文件的 API ，异步请求与队列，自动管理上传与下载队列管理机 适合上传文件，图片数据。
49. 图片浏览
UIImagePickerController 可以从相册，相机，胶卷里获得图片。
50. 对像序列化
NSCoding encodeWithCoder initWithCoder
NSKeyedUnarchiver NSKeyedArchiver
51. 各种 picker UIDatePicker UIPickerView
52. 电影播放 MPMoviePlayerController
音乐播放
MPMusicPlayerController
53. 线程 ?
,ASIFormDataRequest 用于
a.
ent;
线程的创建和使用规则 ? 答: NSThread
三种方法
- (id)init; // designated initializer
- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argum
+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarge t withObject:(id)anArgument
- (void)start; b. 主分线程

答:启动分线程，上面已提到!加到主线程方法 performSelector !
// 加到主线程 addData() 是主线程的方法! 只有加到主线程后， 才能调用主线程的方法
[target performSelector:@selector(addData:) onThread:[NSThread mainTh read] withObject:item waitUntilDone:YES];
//[target addData:item];//
没有加到主线程后，调用主线程的方法!一定会崩!
c. 线程锁
答: NSCondition
方法:
[thread lock];//
sleep(n);// [thread singnal];//
[thread unlock];// [thread exit];//
加锁 线程休眠
    相当于通知，线程启动
    解锁
54. 各种 排序算法? 希尔排序、快速排序、冒泡排序、
55. 通信底层原理
答: OSI 七层模型
7 应用层: 发送到网络中!)
6 表现层: 5 会话层: 4 传输层:
ftp,smtp,http,telnet,tftp
(通过各种协议，最终还是包装成
TCP 数据包，
3 网络层:
2 数据链路层: STP,VT 1 物理层:
线程退出
tcp udp ip,ICMP,IGRP,EIGRP,OSPF,ARP
56. 为什么很多内置类如 UITableViewController 的?
的 delegate 属性都是 assign 而不是 retain

答:
会引起循环引用
所有的引用计数系统，都存在循环应用的问题。例如下面的引用关系:
* 对象 a 创建并引用到了对象 b.
* 对象 b 创建并引用到了对象 c.
* 对象 c创建并引用到了对象 b.
这时候 b和c的引用计数分别是 2和1。
当 a 不再使用 b，调用 release 释放对 b 的所有权，因为 c 还引用了 b，所以 b 的引用计
数为 1，b不会被释放。
b 不释放， c 的引用计数就是 1，c 也不会被释放。从此， b 和 c 永远留在内存中。
这种情况，必须打断循环引用，通过其他规则来维护引用关系。我们常见的 delegate 往往是 assign 方式的属性而不是 retain 方式 的属性，
赋值不会增加引用计数，就是为了防止 delegation 两端产生不必要的循环引用。
如果一个 UITableViewController 对象 a 通过 retain 获取了 UITableView 对象 b 的所有权，
这个 UITableView 对象 b 的 delegate 又是 a，
如果这个 delegate 是 retain 方式的，那基本上就没有机会释放这两个对象了。自己在设计使
用 delegate 模式时，也要注意这点。
57. 以下每行代码执行后， person 对象的 retain count Person *person = [[Person alloc] init]; count 1
[person retain]; retain count 2 [person release];retain count 1
[person release];retain count = 0
分别是多少?
58. 在一个对象的方法里面 : self.name = “ object
和
name =” object ”
有什么不同吗 ? 答: self.name = "object"
name = "object" 会直接把
”;
会调用对象的
object 赋值给当前对象的
方法 ,会使
name 属性，引用计数不增加。
1 ，
setName()
object
引用计数加


60.1.main() {
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1));
}
答: 2,5
锁被加到所属对象实例级
( 我是这么理解的 ⋯)。
*(a+1 )就是 a[1] ， *(ptr-1) 就是 a[4],
&a+1 不是首地址 +1 ，系统会认为加一个 a 数组的偏移，是偏移了一个数组的大小(本例
是 5 个 int )
int *ptr=(int *)(&a+1);
则 ptr 实际是 &(a[5]), 也就是 a+5 原因如下:
&a 是数组指针，其类型为 int (*)[5];
而指针加 1 要根据指针类型加上一定的值，不同类型的指针 a 是长度为 5 的 int 数组指针，所以要加 5*sizeof(int) 所以 ptr 实际是 a[5]
+1 之后增加的大小不同。
执行结果是
2 ， 5

但是 prt 与 (&a+1) 类型是不一样的 ( 这点很重要 ) 所以 prt-1 只会减去 sizeof(int*)
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0] 的地址， &a 是对象(数组)首地址，
a+1 是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].

13. Object C 中创建线程的方法是什么 ?如果在主线程中执行代码，方 法是什么 ?如果想延时执行代码、方法又是什么 ?
答:线程创建有三种方法:使用 NSThread创建、使用 GCD的dispatch、 使用子类化的NSOperation,然后将其加入NSOperationQueue在;主线程执
行代码，方法是 performSelectorOnMainThread，如果想延时执行代码可 以用 performSelector:onThread:withObject:waitUntilDone:

16. 类别的作用 ?继承和类别在实现中有何区别 ?
答:category 可以在不获悉，不改变原来代码的情况下往里面添加新 的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法 产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先 级。
类别主要有 3个作用: 1).将类的实现分散到多个不同文件或多个不同框架中。
2).创建对私有方法的前向引用。 3).向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
17. 类别和类扩展的区别。
答: category和extensions的不同在于后者可以添加属性。另外后者添加
的方法是必须要实现的。 extensions可以认为是一个私有的 Category。
18. oc中的协议和 java中的接口概念有何不同 ?
答: OC中的代理有 2层含义，官方定义为 formal 和informal protocol 。
前者和 Java接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，
但是如果有实现，就会改变类的属性。
其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，
―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能 希望实现的方法，你可以使用他们更好的完成工作 ‖。
这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会 申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的 方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。 ‖ 现在来看，其实 protocal已经开始对两者都统一和规范起来操作，因为
资料中说 ―非正式协议使用 interface修饰―， 现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和―可选实现
(@optional) 。‖
19. 什么是 KVO 和KVC?
答:KVC:键 –值编码是一种间接访问对象的属性使用字符串来标识 属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple文档其实给了一个很好的例子。 KVO: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化
了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监 控。
比如我自定义的一个 button
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{

if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
}
}
对于系统是根据 keypath去取的到相应的值发生改变，理论上来说是和 kvc 机制的道理是一样的。
对于kvc机制如何通过 key寻找到 value:
―当通过 KVC 调用对象时，比如: [self valueForKey:@ ‖ someKe时y‖，]
程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是 否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有 someKey这个实例变量 (iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的 话，程序会抛出一个 NSUndefinedKeyException异常错误。
(cocoachina.com注: Key-Value Coding查找方法的时候，不仅仅会查找 someKey这个方法，还会查找 getsomeKey这个方法，前面加一个 get， 或者 _someKey以及 _getsomeKey这几种形式。同时，查找实例变量的时 候也会不仅仅查找 someKey这个变量，也会查找 _someKey这个变量是 否存在。 )
设计 valueForUndefinedKey:方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应 这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。
―
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button却是存在一个 highlighted实例变量 .因此为何上面我
们只是 add一个相关的 keypath就行了， 可以按照 kvc查找的逻辑理解，就说的过去了。 20. 代理的作用 ?

答:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通 知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java中的回调监听机制的一种类似。 21. oc中可修改和不可以修改类型。
答:可修改不可修改的集合类。这个我个人简单理解就是可动态添加 修改和不可动态添加修改一样。
比如 NSArray和NSMutableArray 。前者在初始化后的内存空间就是固定 不可变的，后者可以添加等，可以动态申请新的内存空间。
22. 我们说的 oc是动态运行时语言是什么意思 ?
答:多态。主要是将数据类型的确定由编译时，推迟到了运行时。
这个问题其实浅涉及到两个概念，运行时和多态。
简单来说，运行时机制使我们直到运行时才去决定一个对象的类别， 以及调用该类别对象指定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思 就是假设生物类 (life) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life后，实现各自的 eat，但 是调用是我们只需调用各自的 eat方法。
也就是不同的对象以自己的方式响应了相同的消息 (响应了 eat这个选择 器)。
因此也可以说，运行时机制是多态的基础 ?~~~ 23. 通知和协议的不同之处 ?

答:协议有控制链 (has-a)的关系，通知没有。 首先我一开始也不太明白，什么叫控制链 (专业术语了 ~)。但是简单分
析下通知和代理的行为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息 接受者。
代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星 经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不 可能说明天要处理 A明星要一个发布会，代理人发出处理发布会的消息 后，别称 B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接 收到感兴趣要处理。
因此控制链 (has-a从英语单词大致可以看出，单一拥有和可控制的对应 关系。
24. 什么是推送消息 ?
答:推送通知更是一种技术。 简单点就是客户端获取资源的一种手段。 普通情况下，都是客户端主动的 pull 。
推送则是服务器端主动 push。测试 push的实现可以查看该博文。 25. 关于多态性
答:多态，子类指针可以赋值给父类。

30. OC的垃圾回收机制 ?
答: OC2.0有Garbage collection，但是 iOS平台不提供。
一般我们了解的 objective-c对于内存管理都是手动操作的，但是也有自 动释放池。
但是差了大部分资料，貌似不要和 arc机制搞混就好了。 31. NSOperation queue?
答:存放 NSOperation的集合类。
操作和操作队列，基本可以看成 java中的线程和线程池的概念。用于处
理 ios多线程开发的问题。
网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概
念，放入的操作并非是按照严格的先进现出。
这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队 列， Bfunc紧跟着也进入队列， Afunc 先执行这个是必然的，



38. 如果我们不创建内存池，是否有内存池提供给我们 ?
答 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要
创建该线程的内存池
39. 什么时候需要在程序中创建内存池 ? 答:用户自己创建的数据线程，则需要创建该线程的内存池
40. 类 NSObject 的那些方法经常被使用 ? 答:NSObject是Objetive-C的基类，其由 NSObject类及一系列协议构
成。
其中类方法 alloc、class、 description 对象方法 init、dealloc、–
performSelector:withObject:afterDelay:等经常被使用 41. 什么是简便构造方法 ?
答:简便构造方法一般由 CocoaTouch框架提供，如 NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: +
numberWithFloat: + numberWithInt:

Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法， 获得系统给我们创建好的对象，并且不需要手动释放。
42. 如何使用 Xcode设计通用应用 ?
答:使用 MVC 模式设计应用，其中 Model层完成脱离界面，即在 Model 层，其是可运行在任何设备上，在 controller层，根据 iPhone与iPad(独有 UISplitViewController) 的不同特点选择不同的 viewController 对象。在 View 层，可根据现实要求，来设计，其中以 xib 文件设计时，其设置其 为 universal。
43. UIView 的动画效果有那些 ?
答:有很多，如 UIViewAnimationOptionCurveEaseInOut
UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransiti onCurlDown
44. 在iPhone应用中如何保存数据 ? 答:有以下几种保存机制:
1).通过 web服务，保存在服务器上
2).通过 NSCoder固化机制，将对象保存在文件中 3).通过 SQlite或CoreData保存在文件数据库中 45. 什么是 coredata?
答: coredata是苹果提供一套数据保存框架，其基于
SQlite

46. 什么是 NSManagedObject 模型 ?
答:NSManagedObject是NSObject的子类，也是 coredata的重要组成部 分，它是一个通用的类 ,实现了 core data 模型层所需的基本功能，用户 可通过子类化 NSManagedObject，建立自己的数据模型。
47. 什么是 NSManagedobjectContext?
答: NSManagedobjectContext对象负责应用和数据库之间的交互。
48. 什么是谓词 ?
答:谓词是通过 NSPredicate，是通过给定的逻辑条件作为约束条件，
完成对数据的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n]; a = [customers filteredArrayUsingPredicate:predicate];
49. 和coredata 一起有哪几种持久化存储机制 ? 答:存入到文件、存入到 NSUserDefaults(系统 plist文件中 )、存入到
Sqlite文件数据库


55. 多线程是什么
答: 多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了 资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多 线程被赋予不同的内涵，对于硬件，现在市面上多数的 CPU都是多核 的，多核的 CPU运算多线程更为出色 ;从操作系统角度，是多任务，现 在用的主流操作系统都是多任务的，可以一边听歌、一边写博客 ;对于 应用来说，多线程可以让应用有更快的回应，可以在网络下载时，同 时响应用户的触摸操作。在 iOS应用中，对多线程最初的理解，就是并

发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水 的同时去摘菜，最后去炒菜。
56. iOS 中的多线程
答: iOS中的多线程，是 Cocoa框架下的多线程，通过 Cocoa的封装，可 以让我们更为方便的使用线程，做过 C++的同学可能会对线程有更多的 理解，比如线程的创立，信号量、共享变量有认识， Cocoa框架下会方 便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本 身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提 供程序的健壮性。
GCD是(Grand Central Dispatch)的缩写，从系统级别提供的一个易用地 多线程类库，具有运行时的特点，能充分利用多核心硬件。 GCD的 API 接口为 C语言的函数，函数参数中多数有 Block，关于 Block的使用参看 这里，为我们提供强大的 ―接口 ‖，对于 GCD的使用参见本文
NSOperation与 Queue
NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过 子类化该对象，加上 NSQueue来同面向对象的思维，管理多线程程序。 具体可参看这里:一个基于 NSOperation的多线程网络访问的项目。
NSThread
NSThread是一个控制线程执行的对象，它不如 NSOperation抽象，通过 它我们可以方便的得到一个线程，并控制它。但 NSThread的线程之间 的并发控制，是需要我们自己来控制的，可以通过 NSCondition实现。
参看 iOS多线程编程之 NSThread的使用 其他多线程

在Cocoa的框架下，通知、 Timer和异步函数等都有使用多线程， (待补 充).
57. 在项目什么时候选择使用 GCD ，什么时候选择 NSOperation?
答: 项目中使用 NSOperation的优点是 NSOperation是对线程的高度抽象， 在项目中使用它，会使项目的程序结构更好，子类化 NSOperation的设 计思路，是具有面向对象的优点 (复用、封装 )，使得实现是多线程支持， 而接口简单，建议在复杂项目中使用。
项目中使用 GCD的优点是 GCD本身非常简单、易用，对于不复杂的多 线程操作，会节省代码量，而 Block 参数的使用，会是代码更为易读， 建议在简单项目中使用。
58. 什么是 block
答: 对于闭包 (block),有很多定义，其中闭包就是能够读取其它函数内
部变量的函数，这个定义即接近本质又较好理解。对于刚接触 Block 的
同学，会觉得有些绕，因为我们习惯写这样的程序 main(){ funA();}
funA(){funB();} funB(){ ⋯就.是.};函数 main调用函数 A ，函数 A 调用函
数 B⋯ 函数们依次顺序执行，但现实中不全是这样的，例如项目经理
M，手下有 3个程序员 A、B、C，当他给程序员 A安排实现功能 F1时， 他并不等着 A 完成之后，再去安排 B去实现 F2，而是安排给 A 功能 F1，
B 功能 F2， C功能 F3，然后可能去写技术文档，而当 A 遇到问题时，他 会来找项目经理 M，当B做完时，会通知 M，这就是一个异步执行的例 子。在这种情形下， Block 便可大显身手，因为在项目经理 M ，给 A 安 排工作时，同时会告诉 A 若果遇到困难，如何能找到他报告问题 (例如 打他手机号 )，这就是项目经理 M 给 A 的一个回调接口，要回掉的操作， 比如接到电话，百度查询后，返回网页内容给 A，这就是一个 Block， 在M交待工作时，已经定义好，并且取得了 F1的任务号 (局部变量 )，却 是在当 A遇到问题时，才调用执行，跨函数在项目经理 M查询百度，获 得结果后回调该 block。
59. block 实现原理

答: Objective-C是对C语言的扩展， block的实现是基于指针和函数指 针。
从计算语言的发展，最早的 goto，高级语言的指针，到面向对象语言的 block，从机器的思维，一步步接近人的思维，以方便开发人员更为高
效、直接的描述出现实的逻辑 (需求 )。 使用实例
cocoaTouch框架下动画效果的 Block 的调用 使用 typed声明 block
typedef void(^didFinishBlock) (NSObject *ob); 这就声明了一个 didFinishBlock类型的block，
然后便可用
@property (nonatomic,copy) didFinishBlock finishBlock;
声明一个 blokc对象，注意对象属性设置为 copy，接到 block 参数时，
便会自动复制一份。 __block是一种特殊类型，
使用该关键字声明的局部变量，可以被 block所改变，并且其在原函数 中的值会被改变。
60.关于 block
答: 面试时，面试官会先问一些，是否了解 block，是否使用过 block， 这些问题相当于开场白，往往是下面一系列问题的开始，所以一定要 如实根据自己的情况回答。
1). 使用 block和使用 delegate完成委托模式有什么优点 ?

首先要了解什么是委托模式，委托模式在 iOS中大量应用，其在设计模 式中是适配器模式中的对象适配器， Objective-C中使用 id类型指向一切 对象，使委托模式更为简洁。了解委托模式的细节:
iOS设计模式 —-委托模式
使用block实现委托模式，其优点是回调的 block代码块定义在委托对象
函数内部，使代码更为紧凑 ;
适配对象不再需要实现具体某个 protocol，代码更为简洁。
2). 多线程与 block
GCD与Block
使用 dispatch_async 系列方法，可以以指定的方式执行
GCD 编程实例
dispatch_async的完整定义
void dispatch_async( dispatch_queue_t queue, dispatch_block_t block);
对象
dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();}); 62.谈谈 Object-C 的内存管理方式及过程?
答: 1).当你使用 new,alloc和copy方法创建一个对象时 ,该对象的保留计数 器值为 1.当你不再使用该对象时 ,你要负责向该对象发送一条 release或 autorelease消息 .这样 ,该对象将在使用寿命结束时被销毁 .
block ，不阻塞当前线程 通过 queue来控制 block执行的线程。主线程执行前文定义的 finishBlock
功能:在指定的队列里提交一个异步执行的
block
TCP提供的是面向连接的、可靠的数据流传输，而 UDP提供的是非面向 连接的、不可靠的数据流传输。
简单的说， TCP注重数据安全，而 UDP数据传输快点，但安全性一般 89. 你了解 svn,cvs等版本控制工具么?
答:版本控制 svn,cvs是两种版控制的器 ,需要配套相关的 svn，cvs服务 器。
scm是xcode里配置版本控制的地方。版本控制的原理就是 a和 b同时开 发一个项目， a写完当天的代码之后把代码提交给服务器， b要做的时 候先从服务器得到最新版本，就可以接着做。如果 a和b都要提交给服 务器，并且同时修改了同一个方法，就会产生代码冲突，如果 a先提交， 那么 b提交时，服务器可以提示冲突的代码， b可以清晰的看到，并做 出相应的修改或融合后再提交到服务器。
90. 什么是 push。 答:客户端程序留下后门端口，客户端总是监听针对这个后门的请求，
于是服务器可以主动像这个端口推送消息。 91. 静态链接库
答:此为.a文件，相当于 java里的jar包，把一些类编译到一个包中，在 不同的工程中如果导入此文件就可以使用里面的类，具体使用依然是
#import ―xx。.h‖ 92. fmmpeg框架
答:音视频编解码框架，内部使用 UDP协议针对流媒体开发，内部开 辟了六个端口来接受流媒体数据，完成快速接受之目的。
93. fmdb 框架

答:数据库框架，对 sqllite 的数据操作进行了封装，使用着可把精力都 放在 sql语句上面。
94. 320框架
答: ui框架，导入 320工程作为框架包如同添加一个普通框架一样。
cover(open) flower 框架 (2d 仿射技术 )，内部核心类是 CATransform3D.
94. 什么是沙盒模型?哪些操作是属于私有 api范畴?
答:某个 iphone工程进行文件操作有此工程对应的指定的位置，不能逾
越。
iphone沙箱模型的有四个文件夹 documents，tmp，app，Library ，永久
数据存储一般放 documents文件夹，得到模拟器的路径的可使用 NSHomeDirectory()方法。Nsuserdefaults保存的文件在 tmp文件夹里。
95. 在一个对象的方法里面: self.name= “ obje;ct和”name = ” object ” 有什么不同吗 ?
答: self.name = ‖obje:ct会‖调用对象的 setName()方法; name = ―obje:ct会‖直接把 object赋值给当前对象的 name属性。
96. 请简要说明 viewDidLoad 和viewDidUnload 何时调用
答: viewDidLoad 在view 从 nib文件初始化时调用， loadView在 controller 的view为nil时调用。此方法在编程实现 view时调用， view控制器默认 会注册 memory warning notification ，当 view controller 的任何 view 没有用 的时候， viewDidUnload 会被调用，在这里实现将 retain的view release， 如果是 retain的 IBOutlet view 属性则不要在这里 release，IBOutlet 会负责 release 。

97. 简述内存分区情况 答:
1).代码区:存放函数二进制代码 2).数据区:系统运行时申请内存并初始化，系统退出时由系统释放。
存放全局变量、静态变量、常量
3).堆区:通过 malloc等函数或 new等操作符动态申请得到，需程序员手 动申请和释放
4).栈区:函数模块内申请，函数结束时由系统自动释放。存放局部变 量、函数参数
98. 队列和栈有什么区别:
答:队列和栈是两种不同的数据容器。从 ‖数据结构 ‖的角度看，它们
都是线性结构，即数据元素之间的关系相同。
队列是一种先进先出的数据结构，它在两端进行操作，一端进行入队 列操作，一端进行出列队操作。
栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈 都在栈顶操作。
99. HTTP 协议中， POST和GET 的区别是什么? 答:
1).GET方法
GET 方法提交数据不安全，数据置于请求行，客户端地址栏可见 ;

GET 方法提交的数据大小有限
GET 方法不可以设置书签
2).POST方法
POST 方法提交数据安全，数据置于消息主体内，客户端不可见 POST 方法提交的数据大小没有限制
POST 方法可以设置书签 100. iOS 的系统架构
答: iOS的系统架构分为(核心操作系统层 theCore OS layer )、(核 心服务层 theCore Services layer )、(媒体层 theMedia layer )和( Cocoa 界面服务层 the Cocoa Touch layer )四个层次。
101. 控件主要响应 3种事件
答:1). 基于触摸的事件 ; 2). 基于值的事件 ; 3).基于编辑的事件。
102. xib 文件的构成分为哪 3个图标?都具有什么功能。
答: File ‘s Owne是r 所有 nib 文件中的每个图标，它表示从磁盘加载
nib 文件的对象;
First Responder 就是用户当前正在与之交互的对象;
View 显示用户界面;完成用户交互;是 UIView 类或其子类。 103. 简述视图控件器的生命周期。

答: loadView 尽管不直接调用该方法，如多手动创建自己的视图， 那么应该覆盖这个方法并将它们赋值给试图控制器的 view 属性。
viewDidLoad 只有在视图控制器将其视图载入到内存之后才调用该方 法，这是执行任何其他初始化操作的入口。
viewDidUnload 当试图控制器从内存释放自己的方法的时候调用，用 于清楚那些可能已经在试图控制器中创建的对象。
viewVillAppear 当试图将要添加到窗口中并且还不可见的时候或者上 层视图移出图层后本视图变成顶级视图时调用该方法，用于执行诸如 改变视图方向等的操作。实现该方法时确保调用 [super viewWillAppear:
viewDidAppear 当视图添加到窗口中以后或者上层视图移出图层后本 视图变成顶级视图时调用，用于放置那些需要在视图显示后执行的代
码。确保调用 [super viewDidAppear:] 。
104. 动画有基本类型有哪几种;表视图有哪几种基本样式。
答:动画有两种基本类型:隐式动画和显式动画。
105. 实现简单的表格显示需要设置 UITableView 的什么属性、实现什 么协议?
答:实现简单的表格显示需要设置 UITableView 的 dataSource 和 delegate 属性，实现 UITableViewDataSource 和 UITableViewDelegate
协议。

107. UIView 与CLayer 有什么区别? 答:
1).UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承 自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图部分，
是由一个 CALayer 类来管理。 UIView 本身更像是一个 CALayer 的 管理器，访问它的跟绘图和跟坐标有关的属性。
2).UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。 3).UIView 的 CALayer 类似 UIView 的子 View 树形结构，也可以向
它的 layer 上添加子 layer ，来完成某些特殊的表示。即 CALayer 层 是可以嵌套的。
4).UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻 辑树，这里是代码可以操纵的;动画树，是一个中间层，系统就在这 一层上更改属性，进行各种渲染操作;显示树，其内容就是当前正被 显示在屏幕上得内容。
5).动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改， 系统将自动进行动画生成，动画持续时间的缺省值似乎是 0.5 秒。
6).坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint 结构表示，值域是 0~1 ，是个比例值。这个点是 各种图形变换的坐标原点，同时会更改 layer 的 position 的位置，它 的缺省值是 {0.5,0.5} ，即在 layer 的中央。
7).渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备 好时，可以调用 setNeedsDisplay方法来重绘显示。
8).变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform 或affineTransform 属性。

9).变形: Quartz Core 的渲染能力，使二维图像可以被自由操纵，就 好像是三维的。图像可以在一个三维坐标系中以任意角度被旋转，缩 放和倾斜。 CATransform3D 的一套方法提供了一些魔术般的变换效 果。
108. Quatrz 2D 的绘图功能的三个核心概念是什么并简述其作用。 答:上下文:主要用于描述图形写入哪里; 路径:是在图层上绘制的内容; 状态:用于保存配置变换的值、填充和轮廓， alpha 值等。 109. iPhone OS主要提供了几种播放音频的方法?
答: SystemSound Services AVAudioPlayer 类
Audio Queue Services
OpenAL
110. 使用 AVAudioPlayer 类调用哪个框架、使用步骤? 答: AVFoundation.framework
步骤:配置 AVAudioPlayer 对象;
实现 AVAudioPlayer 类的委托方法;
控制 AVAudioPlayer 类的对象;
监控音量水平;

回放进度和拖拽播放。
111. 有哪几种手势通知方法、写清楚方法名? 答:
-(void)touchesBegan:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesMoved:(NSSet*)touched withEvent:(UIEvent*)event; -(void)touchesEnded:(NSSet*)touchedwithEvent:(UIEvent*)event; -(void)touchesCanceled:(NSSet*)touchedwithEvent:(UIEvent*)event; 112. CFSocket使用有哪几个步骤。
答:创建 Socket 的上下文;创建 Socket ;配置要访问的服务器信息; 封装服务器信息;连接服务器;
113. Core Foundation 中提供了哪几种操作 Socket的方法? 答: CFNetwork 、 CFSocket 和 BSD Socket 。
114. 解析 XML 文件有哪几种方式?
答:以 DOM 方式解析 XML 文件;以 SAX 方式解析 XML 文件;
115. ios 平台怎么做数据的持久化 ?coredata和sqlite有无必然联系? coredata 是一个关系型数据库吗?
答:iOS 中可以有四种持久化数据的方式:属性列表 (plist)、对象归档、
SQLite3 和 Core Data; core data 可以使你以图形界面的方式快速的 定义 app 的数据模型，同时在你的代码中容易获取到它。 coredata 提 供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允

许你在 app 中继续创建新的任务。在使用 core data 的时候，你不用 安装额外的数据库系统，因为 core data 使用内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组定义在内存中的数据对象。 coredata 会追踪这些对象的改变，同时可以根据需要做相反的改变， 例如用户执行撤销命令。当 core data 在对你 app 数据的改变进行保 存的时候， core data 会把这些数据归档，并永久性保存。 mac os x 中sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入 到应用程序。可以在多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。与 core data 框架不同的是， sqlite 是使用程序式的，
sql 的主要的 API 来直接操作数据表。 Core Data 不是一个关系型数 据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 Core Dta 支持
SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据库。
Core Data 在使用的过程种自己创建这个数据库。 Core Data 支持对一、
对多的关系。

116. tableView 的重用机制?
答: UITableView 通过重用单元格来达到节省内存的目的 : 通过为每个 单元格指定一个重用标识符 (reuseIdentifier),即指定了单元格的种类 , 以 及当单元格滚出屏幕时 ,允许恢复单元格以便重用 .对于不同种类的单元 格使用不同的 ID,对于简单的表格 ,一个标识符就够了 .

__block 和 __weak 修饰符的区别其实是挺明显的:
1.__block 不管是 ARC 还是 MRC 模式下都可以使用， 可以修饰对象， 还可以修饰基本数据 类型。
2.__weak 只能在 ARC 模式下使用，也只能修饰对象( NSString )，不能修饰基本数据类 型( int )。
3.__block 对象可以在 block 中被重新赋值， __weak 不可以。
，否则不能循环执行。

 tableView 滑动卡的问题主要是因为:从缓存中或者是从本地读取图片给 UIImage 的时候
耗费的时间。需要把下面的两句话放到子线程里面:
1. NSData *imgData = [NSData dataWithContentsOfURL :[NSURL URLWithString :app.ico
n]]; // 得到图像数据
2. UIImage *image = [UIImage imageWithData :imgData];
把 UIImage 赋值给图片的时候在主线程。
子线程不能更新 UI 所有的 UI 跟新都是主线程执行了。手指滑动屏幕了。或者屏幕的某个 方法执行了。
子线程里面加入 NSTimer 的时候需要手动添加 NSRunloop 否则不能循环。 单利里面添加 NSMutableArray 的时候，防止多个地方对它同时便利和修改的话，需要加
原子属性。 并且用 strong ，，，并且写一个遍历和修改的方法。 加上锁。 Lock UnLock
__weak ViewController* weakSelf = self;
GCD 里面用 __weak 防止内存释放不了，循环引用。

二、 SDWebImage 内部实现过程
1. 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，
然后 SDWebImageManager 根据 URL 开始处理图片。
2. 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:
SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
3. 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存， SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: SDWebImageManager 。
4. SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: UIImageView+WebCache 等前端展示图片。
，交给
5. 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片 是否已经缓存。
 6. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。 这一步是在 NSOperation 进行 的操作，所以回主线程进行结果回调 notifyDelegate: 。
7. 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中(如果空闲内存过小， 会先清空内存缓存)。 SDImageCacheDelegate 回调
imageCache:didFindImage:forKey:userInfo: 。进而回调展示图片。
8. 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，
回调 imageCache:didNotFindImageForKey:userInfo: 。
9. 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。

13. 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对
下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14. 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，
imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader 。
15. imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下 载完成。
16. 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17. 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也
在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18. SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台的时候
清理内存图片缓存，应用结束的时候清理过期图片。
19. SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache ，方便使 用。
20. SDWebImagePrefetcher 可以预先下载图片，方便后续使用。
从上面流程可以看出，当你调用 setImageWithURL: 方法的时候，他会自动去给你干这么多 事， 当你需要在某一具体时刻做事情的时候， 你可以覆盖这些方法。 比如在下载某个图片的 过程中要响应一个事件，就覆盖这个方法:
1 // 覆盖方法，指哪打哪，这个方法是下载 imagePath2 的时候响应
2 SDWebImageManager*manager = [SDWebImageManager sharedManager];

10 NSLog(@下"载完成"); 11 }];
[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed NSLog(@显"示当前进度");
} completed:^(UIImage *image, NSError
*error, SDImageCacheType cac
对于初级来说，用 sd_setImageWithURL: 的若干个方法就可以实现很好的图片缓存。
UIButton 的父类是
UIControl UIControl 的父类是
UIView UIView 的父类是 UIResponder
http 状态吗:302 是请求重定向。500 以上是服务器错误。 400 以上是请求
链接错误或者找不到服务器。 200 以 上是正确。100 以上是请求接受成功。
HTTP Keep-Alive 详解 [ 转 ]
HTTP 是一个 请求 <-> 响应 模式的典型范例，即客户端向服务器发送一个请求信息，服务器来 响应这个信息。在老的 HTTP 版本中，每个请求都将被创建一个新的 客户端 -> 服务器 的连接， 在这个连接上发送请求，然后接收请求。这样的模式有一个很大的优点就是， 它很简单，很容易

 理解和编程实现;它也有一个很大的缺点就是，它效率很低，因此 Keep-Alive 被提出用来解决 效率低的问题。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，
Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet 、
IIS 和 Apache ，都支持 HTTP Keep-Alive 。对于提供静态内容的网站来说，这个功能通常很 有用。但是，对于负担较重的网站来说，这里存在另外一个问题: 虽然为客户保留打开的连接有 一定的好处，但它同样影响了性能，因为在处理暂停期间， 本来可以释放的资源仍旧被占用。 当 Web 服务器和应用服务器在同一台机器上运行时， Keep- Alive 功能对资源利用的影响尤其突 出。此功能为 HTTP 1.1 预设的功能， HTTP 1.0 加上 Keep-Aliveheader 也可以提供 HTTP 的持续作用功能。
Keep-Alive: timeout=5, max=100
timeout :过期时间 5 秒(对应 httpd.conf 里的参数是: KeepAliveTimeout )， max 是最 多一百次请求，强制断掉连接
就是在 timeout 时间内又有新的连接过来，同时 面的四个图，注意看 Date 的值(前后时间差都是在
HTTP/1.0
在 HTTP/1.0 版本中，并没有官方的标准来规定
max 会自动减 1 ，直到为 0 ，强制断掉。见下 5 秒之内)!
Keep-Alive 如何工作，因此实际上它是被附 加到 HTTP/1.0 协议上， 如果客户端浏览器支持 Keep-Alive ，那么就在 HTTP 请求头中添加一
个字段 Connection: Keep-Alive ，当服务器收到附带有 Connection: Keep-Alive 的请求 时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之
间的 HTTP 连接就会被保持， 不会断开(超过 Keep-Alive 规定的时间， 意外断电等情况除外) ， 当客户端发送另外一个请求时，就使用这条已经建立的连接
HTTP/1.1
在 HTTP/1.1 版本中，官方规定的 Keep-Alive 使用标准和在 HTTP/1.0 版本中有些不同，默
认情况下所在 HTTP1.1 中所有连接都被保持，除非在请求头或响应头中指明要关闭:
Connection: Close ，这也就是为什么 Connection: Keep-Alive 字段再没有意义的原因。
另外，还添加了一个新的字段 Keep-Alive: ，因为这个字段并没有详细描述用来做什么，可忽 略它
Not reliable (不可靠)
HTTP 是一个无状态协议，这意味着每个请求都是独立的， Keep-Alive 没能改变这个结果。另
外， Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也 如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于
Keep-Alive 的保持连接特性，否则会有意想不到的后果 Keep-Alive 和 POST
在 HTTP1.1 细则中规定了在一个 POST 消息体后面不能有任何字符， 还指出了对于某一个特定 的浏览器可能并不遵循这个标准(比如在 POST 消息体的后面放置一个 CRLF 符)。而据我所 知，大部分浏览器在 POST 消息体后都会自动跟一个 CRLF 符再发送，如何解决这个问题呢? 根据上面的说明在 POST 请求头中禁止使用 Keep-Alive ，或者由服务器自动忽略这个 CRLF ， 大部分服务器都会自动忽略，但是在未经测试之前是不可能知道一个服务器是否会这样做。
1 、常用的方法 dispatch_async

 为了避免界面在处理耗时的操作时卡死，比如读取网络数据， IO, 数据库读写等，我们会在另外 一个线程中处理这些操作，然后通知主线程更新界面。
用 GCD 实现这个流程的操作比前面介绍的 NSThread NSOperation 的方法都要简单。代码 框架结构如下:
1.
2. 3. 4. 5. 6.
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAUL T, 0), ^{
// 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{
// 更新界面
}); });
运行显示:
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAUL T, 0), ^{
NSURL * url = [NSURL URLWithString:@ "http://avatar.csdn.net/2/C/D/1_toto go2010.jpg" ];
NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data];
if (data != nil) { dispatch_async(dispatch_get_main_queue(), ^{
self.imageView.image = image; });
}

 是不是代码比 NSThread NSOperation 简洁很多，而且 GCD 会自动根据任务在多核处理器 上分配资源，优化程序。
系统给每一个应用程序提供了三个 concurrent dispatch queues 。这三个并发调度队列是全 局的，它们只有优先级的不同。因为是全局的，我们不需要去创建。我们只需要通过使用函数
dispath_get_global_queue 去得到队列，如下:
1. dispatch_queue_t globalQ = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY _DEFAULT, 0);
这里也用到了系统默认就有一个串行队列 main_queue

 1. dispatch_queue_t mainQ = dispatch_get_main_queue();
虽然 dispatch queue 是引用计数的对象，但是以上两个都是全局的队列，不用 retain 或 release 。
2 、dispatch_group_async 的使用
dispatch_group_async 可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。 这个方法很有用， 比如你执行三个下载任务， 当三个任务都下载完成后你才通知界面说完成的了。 下面是一段例子代码:
1.
2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18.
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_D EFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{
[NSThread sleepForTimeInterval:1];
NSLog(@ "group1" ); });
dispatch_group_async(group, queue, ^{ [NSThread sleepForTimeInterval:2]; NSLog(@ "group2" );
});
dispatch_group_async(group, queue, ^{
[NSThread sleepForTimeInterval:3];
NSLog(@ "group3" ); });
dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@ "updateUi" );
}); dispatch_release(group);
dispatch_group_async 是异步的方法，运行后可以看到打印结果:
2012-09-25 16:04:16.737 gcdTest[43328:11303] group1 2012-09-25 16:04:17.738 gcdTest[43328:12a1b] group2 2012-09-25 16:04:18.738 gcdTest[43328:13003] group3 2012-09-25 16:04:18.739 gcdTest[43328:f803] updateUi

 每个一秒打印一个，当第三个任务执行后， upadteUi 被打印。
 4 、dispatch_apply

1. 1. 写一个 NSString 类的实现
 + (id)initWithCString:(c*****t char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id) stringWithCString: (c*****t char*)nullTerminatedCString
encoding: (NSStringEncoding)encoding
{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return AUTORELEASE(obj);
}
2static 关键字的作用:
(1)函数体内 static 变量的作用范围为该函数体， 不同于 auto
配一次，
因此其值在下次调用时仍维持上次的值;
( 2 )在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访
问;
( 3 )在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限 制在声明
它的模块内;
( 4 )在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;
( 5 )在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访 问类的 static 成员变量。
3 线程与进程的区别和联系 ?
进程和线程都是由操作系统所体会的程序运行的基本单元，
应用的并发性。
程和线程的主要差别在于它们是不同的操作系统资源管理方式。
个进程崩溃后， 在保护模式下不会对其它进程产生影响，
路径。 线程有自己的堆栈和局部变量， 但线程之间没有单独的地址空间， 一个线程死掉就等 于整个进程死掉， 所以多进程的程序要比多线程的程序健壮， 但在进程切换时， 耗费资源较 大， 效率要差一些。 但对于一些要求同时进行并且又要共享某些变量的并发操作， 只能用线 程，不能用进程。
4 堆和栈的区别 管理方式:对于栈来讲，是由编译器自动管理，无需我们手工控制;对于堆来说，释放工作 由程序员控制，容易产生 memory leak 。
申请大小:
变量， 该变量的内存只被分
系统利用该基本单元实现系统对
进程有独立的地址空间， 一 而线程只是一个进程中的不同执行

 栈:在 Windows 下 ,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意 思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M (也有的说是 1M ，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间 时，将提示 overflow 。因此，能从栈获得的空间较小。
堆: 堆是向高地址扩展的数据结构， 是不连续的内存区域。 这是由于系统是用链表来存储的 空闲内存地址的， 自然是不连续的， 而链表的遍历方向是由低地址向高地址。 堆的大小受限 于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题:对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量 的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列， 他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式:堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式:静态分配和动态 分配。 静态分配是编译器完成的， 比如局部变量的分配。 动态分配由 alloca 函数进行分配， 但是栈的动态分配和堆是不同的， 他的动态分配是由编译器进行释放， 无需我们手工实现。 分配效率: 栈是机器系统提供的数据结构， 计算机会在底层对栈提供支持: 分配专门的寄存 器存放栈的地址， 压栈出栈都有专门的指令执行， 这就决定了栈的效率比较高。 堆则是 C/C++ 函数库提供的，它的机制是很复杂的。

16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系， 并且 reciever 可以返回值 给 sender ，notification 可以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。
17 什么是 KVC 和 KVO ?答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 setValue 的时候，( 1)首先根据方法名找到运行方法的时候所需要的环境参数。( 2 )他
会从自己 isa
体的方法实现。
被观察对象的
以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于 isa 指针。 在调用类的方法的时候，最好要明确对象实例的类名
指针结合环境参数，找到具体的方法实现的接口。( 3 )再直接查找得来的具 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，
isa 指针被修改的时候， isa 指针就会指向一个中间类，而不是真实的类。所
18ViewController 的 loadView, viewDidLoad, viewDidUnload 分别是在什么时候调用的? 在自定义 ViewController 的时候这几个函数里面应该做什么工作?答: viewDidLoad 在
view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。 此方法在编程 实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release, 如果是 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。
19
"NSMutableString *" 这个数据类型则是代表 的。
"NSMutableString" 对象本身，这两者是有区别
而 NSString 只是对象的指针而已。 面向过程就是分析出解决问题所需要的步骤， 时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象， 为了描叙某个事物在整个解决问题的步骤中的行为。; 20 类别的作用
类别主要有 3 个作用: (1)将类的实现分散到多个不同文件或多个不同框架中。 (2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。
类别的局限性
有两方面局限性: (1)无法向类中添加新的实例变量，类别没有位置容纳实例变量。
然后用函数把这些步骤一步一步实现， 使用的 建立对象的目的不是为了完成一个步骤， 而是

 (2)名称冲突，即当类别中的方法与原始类方法名称冲突时，类别具有更高的优先级。类别 方法将完全取代初始方法从而无法再使用初始方法。 无法添加实例变量的局限可以使用字典对象解决
21 关键字 volatile 有什么含意 ? 并给出三个不同的例子:
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假 设这个变量的值了。精确地说就是，优化器在用到 这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。 下面是 volatile 变量的几个例子:
? 并行设备的硬件寄存器(如:状态寄存器) ?一个中断服务子程序中会访问到的非自动变量 ? 多线程应用中被几个任务共享的变量
? 一个参数既可以是 const 还可以是 volatile ? 一个指针可以是 volatile 吗?解释为什么。
下面是答案:
? 是的。一个例子是只读的状态寄存器。它是
(Non-automatic variables)
吗?解释为什么。
volatile 因为它可能被意想不到地改变。它是
const 因为程序不应该试图去修改它。 ?是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 针时。
22@synthesize 是系统自动生成 getter 和 setter 属性声明
@dynamic 是开发者自已提供相应的属性声明
@dynamic 意思是由开发人员提供相应的代码: 对于只读属性需要提供
性需要提供 setter 和 getter 。@synthesize 意思是， 除非开发人员已经做了， 否则由编译器 生成相应的代码，以满足属性声明。
查阅了一些资料确定 @dynamic 的意思是告诉编译器 ,属性的获取与赋值方法由用户自己实 现, 不自动生成。

类别的作用?继承和类别在实现中有何区别?
答案: category 可以在不获悉， 不改变原来代码的情况下往里面添加新的方法， 不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。
25 .Difference between categories and extensions?
类别和类扩展的区别。
  只能添加，
因为类别具有更
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须 要实现的。
extensions 可以认为是一个私有的 Category 。
26 .Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接
口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 ―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法，你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协 议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。

 26 What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用
存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
} }
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的道理 是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
―当通过 KVC 调用对象时， 比如: [self valueForKey:@ 几种不同的方式解析这个调用。首先查找对象是否带有
会继续查找对象是否带有 someKey 这个实例变量(
试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话，程序 会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方 法，还会查找 getsomeKey 这个方法，前面加一个 get，或者 _someKey 以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请 求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的 两个例子说明了这样做的好处。 ―
来至 cocoa ，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们只是 add 一个 相关的 keypath 就行了，
‖ someKe时y，‖]程序会自动试图通过 someKey 这个方法，如果没找到，
iVar )，如果还没有找到，程序会继续

 27What is purpose of delegates?
代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
28What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。
答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的， 后者可 以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动态运行时语言是什么意思? 答案:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~
30 what is difference between NSNotification and protocol?
通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 ~ )。但是简单分析下通知和代理的 行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候 一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
以及调用该类别对象指 意思就是假设生物类 ( life )
eat ，但是调用是我们只需 eat 这个选择器)。

 36 NSOperation queue? 答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 的问题。
网上部分资料提到一点是， 虽然是 queue ，但是却并不是带有队列的概念， 是按照严格的先进现出。
ios 多线程开发 放入的操作并非
这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也 进入队列， Afunc 先执行这个是必然的，
但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行， 因此队列的概念离乱上有 点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认为这还是一个队 列。
但是后来看到一票关于这操作队列话题的文章，其中有一句提到 ―因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。 ‖ 瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
37What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。
也可以理解成延时加载。
我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。
38 Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制器中嵌入两个 tableview 控制器?
答案:一个视图控制只提供了一个 View 视图，理论上一个 tableViewController 也不能放吧， 只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，如果不是我们定性思维认
为的 UIViewController ，
而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图控制者， 它可以控制多个视 图控制器，比如 TabbarController
那样的感觉。
39 Can we use one tableview with two different datasources? How you will achieve this?
一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案: 首先我们从代码来看， 数据源如何关联上的， 其实是在数据源关联的代理方法里实现 的。

 因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的需要去设置 如相关的数据源。
因此， 我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢?想让列表如何显 示，不同的数据源分区块显示?
40id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object 的一个指针，这 个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject )类的对象。需 要注意的是 id 是一个指针，所以你在使用 id 的时候不需要加星号。比如 id foo=nil 定义了 一个 nil 指针，这个指针指向 NSObject 的一个任意子类。 而 id *foo=nil 则定义了一个指针， 这个指针指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C 语言的 NULL 相同，在 objc/objc.h 中定义。 nil 表示一个 Objctive-C 对象，这个对 象的指针指向空(没有东西就是空)。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类 (是 Class ，而不是对象) 。 SEL 是―selector ‖的一个类型，表示一个方法的名字
Method (我们常说的方法)表示一种类型，这种类型与 selector 和实现 (implementation) 相关
IMP 定义为 id (* IMP ) ( id, SEL , ⋯)。这样说来， IMP 是一个指向函数的指针，这个被指向 的函数包括 id( ―self ‖指针 )，调用的 SEL (方法名)，再加上一些其他参数 .说白了 IMP 就是 实现方法。
41 层和 UIView 的区别是什么?
答:两者最大的区别是 , 图层不会直接渲染到屏幕上， UIView 是 iOS 系统中界面元素的基础， 所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图 部分，是由一个 CALayer 类来管理。UIView 本身更像是一个 CALayer 的管理器。一个 UIView 上可以有 n 个 CALayer ，每个 layer 显示一种东西，增强 UIView 的展现能力。
42GCD 为 Grand Central Dispatch 的缩写。 Grand Central Dispatch (GCD) 是 Apple 开发的一个多核编程的较新的解决方法。在 Mac OS X 10.6 雪豹中首次推出，并在
最近引入到了 iOS4.0 。 GCD 是一个替代诸如 NSThread 等技术的很高效和强大的技术。 GCD 完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。
GCD 可以完成很多事情， 但是这里仅关注在 iOS 应用中实现多线程所需的一些基础知识。 在开始之前，需要理解是要提供给 GCD 队列的是代码块，用于在系统或者用户创建的的队 列上调度运行。 声明一个队列
如下会返回一个用户创建的队列:

 dispatch_queue_t myQueue = dispatch_queue_create("com.iphonedevblog.post",
NULL); 其中，第一个参数是标识队列的， 第二个参数是用来定义队列的参数 (目前不支持， 因此传入 NULL )。
执行一个队列
如下会异步执行传入的代码:
dispatch_async(myQueue, ^{ [self doSomething]; });
其中， 首先传入之前创建的队列， 然
后提供由队列运行的代码块。
声明并执行一个队列 如果不需要保留要运行的队列的引用，可以通过如下代码实现之前的功能:
dispatch_async(dispatch_queue_create ("com.iphonedevblog.post", NULL), ^{ [self
doSomething]; }); 如果需要暂停一个队列，可以调用如下代码。暂停一个队列会阻止和 该队列相关的所有代码运行。 dispatch_suspend(myQueue); 暂停一个队列 如果暂停一个队列不要忘记恢复。 暂停和恢复的操作和内存管理中的 retain 和 release 类似。 调用 dispatch_suspend 会增加暂停计数，而 dispatch_resume 则会减少。队列只有在暂停 计数变成零的情况下才开始运行。 dispatch_resume(myQueue); 恢复一个队列 从队列 中在主线程运行代码 有些操作无法在异步队列运行， 因此必须在主线程 (每个应用都有 一个)上运行。 UI 绘图以及任何对 NSNotificationCenter 的调用必须在主线程长进行。在 另一个队列中访问主线程并运行代码的示例如下:
dispatch_sync(dispatch_get_main_queue(), ^{ [self dismissLoginWindow]; });
dispatch_suspend (以及 dispatch_resume )在主线程上不起作用。
使用 GCD ，可以让你的程序不会失去响应 . 多线程不容易使用，用了 单。你无需专门进行线程管理 , 很棒!
dispatch_queue_t t1= dispatch_queue_create ("1", NULL ); dispatch_queue_t t2= dispatch_queue_create ("2" , NULL );
dispatch_async
[self print1 ]; });
dispatch_async [self print2 ];
(t1, ^{
(t2, ^{
});
43Provider 是指某个 iPhone 软件的 Push 服务器，这篇文章我将使用
.net 作为 APNS 是 Apple Push Notification Service ( Apple Push 服务器) 的缩写， 是苹果的服务器。
上图可以分为三个阶段。
第一阶段: .net 应用程序把要发送的消息、目的 iPhone 的标识打包，发给 APNS 。 第二阶段:APNS 在自身的已注册 Push 服务的 iPhone 列表中，查找有相应标识的 iPhone ，
Provider 。
注意， GCD ，会让它变得简

 并把消息发到 iPhone 。
第三阶段: iPhone 把发来的消息传递给相应的应用程序，并且按照设定弹出 Push 通知。 http://blog.csdn.net/zhuqilin0/article/details/6527113 // 消息推送机制 看内存泄露时候:在搜索中搜索 run 找到 Run Static Snalyzer .
44. 可扩展标记语言 extensible markup language;XML
2. 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一 种允许用户对自己的标记语言进行定义的源语言。
3，数据库提供了更强有力的 数据存储 和分析能力，例如:数据索引、排序、查找、相关一 致性等， XML 仅仅是存储数据。
4.XML 与 HTML 的设计区别是: XML 的核心是数据， 其重点是数据的内容。 而 HTML 被设 计用来显示数据，其重点是数据的显示。
5.XML 和 HTML 语法区别: HTML 的标记不是所有的都需要成对出现， XML 则要求所有的 标记必须成对出现; HTML 标记不区分大小写， XML 则大小敏感 ,即区分大小写。
结合
XML 的简单使其易于在任何应用 程序 中读写数据， 这使 XML 很快成为数据交换的唯一 公共语言， 虽然不同的 应用软件 也支持其它的数据交换格式， 但不久之后他们都将支持 XML ， 那就意味着程序可以更容易的与 Windows,Mac OS,Linux 以及其他平台下产生的信息结合， 然后可以很容易加载 XML 数据到程序中并分析他，并以 XML 格式输出结果。
XML 去掉了之前令许多开发人员头疼的 SGML (标准通用标记语言)的随意语法。在 XML 中，采用了如下的语法:
1 任何的起始标签都必须有一个结束 标签 。
2 可以采用另一种简化语法， 可以在一个标签中同时表示起始和结束标签。 这种语法是 在大于符号之前紧跟一个斜线 ( / )，例如 <tag/ > 。XML 解析器会将其翻译成 <tag></tag> 。
3 标签必须按合适的顺序进行 嵌套 ，所以结束标签必须按 镜像 顺序匹配起始标签， 例如 this is a sample string 。这好比是将起始和结束标签看作是数学中的左右括号: 在没有关闭
所有的内部括号之前，是不能关闭外面的括号的。 4 所有的特性都必须有值。
5 所有的特性都必须在值的周围加上双引号。
45union u
{
double a;
int b; };
union u2

 {
char a[13]; int b;
};
union u3 {
char a[13]; char b;
};
cout<<sizeof(u)<<endl; // 8 cout<<sizeof(u2)<<endl; // 16 cout<<sizeof(u3)<<endl; // 13
都知道 union 的大小取决于它所有的成员中，
于 u 来说，大小就是最大的 double 类型成员 a 了，所以 sizeof(u)=sizeof(double)=8 。但是 对于 u2 和 u3 ，最大的空间都是 char[13] 类型的数组，为什么 u3 的大小是 13 ，而 u2 是 16 呢?关键在于 u2 中的成员 int b 。由于 int 类型成员的存在，使 u2 的对齐方式变成 4，也就 是说，u2 的大小必须在 4 的对界上， 所以占用的空间变成了 16(最接近 13 的对界)。struct s1
{
char a; double b; int c; char d;
};
struct s2
{
char a;
char b;
int c;
double d; };
占用空间最大的一个成员的大小。 所以对

 cout<<sizeof(s1)<<endl; // 24 cout<<sizeof(s2)<<endl; // 16
同样是两个 char 类型，一个 int 类型，一个 double 类型，但是因为对界问题，导致他
们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下:首先， 断结构体的对界， 根据上一节的结论， s1 和 s2 的对界都取最大的元素类型， 类型的对界 8 。然后开始摆放每个元素。
CPU 判 也就是 double
对于 s1 ，首先把 a 放到 8 的对界，假定是 0，此时下一个空闲的地址是
元素 d 是 double 类型，要放到 8 的对界上， 离 1 最接近的地址是 8 了，所以 d 被放在了 8， 此时下一个空闲地址变成了 16 ，下一个元素 c 的对界是 4 ，16 可以满足， 所以 c 放在了 16 ， 此时下一个空闲地址变成了 20 ，下一个元素 d 需要对界 1，也正好落在对界上，所以 d 放 在了 20 ，结构体在地址 21 处结束。 由于 s1 的大小需要是 8 的倍数， 所以 21- 23 的空间被 保留， s1 的大小变成了 24。
对于 s2，首先把 a 放到 8 的对界，假定是 0，此时下一个空闲地址是 1，下一个元素的 对界也是 1，所以 b 摆放在 1，下一个空闲地址变成了 2;下一个元素 c 的对界是 4，所以
取离 2 最近的地址 4 摆放 c ，下一个空闲地址变成了 8，下一个元素 d 的对界是
摆放在 8 ，所有元素摆放完毕，结构体在 15 处结束，占用总空间为 16 ，正好是 8 的倍数。
46 ASIDownloadCache 设置下载缓存
它对 Get 请求的响应数据进行缓存(被缓存的数据必需是成功的 200 请求):
[ASIHTTPRequest setDefaultCache:[ASIDownloadCache sharedCache]];
当设置缓存策略后，所有的请求都被自动的缓存起来。 另外，如果仅仅希望某次请求使用缓存操作，也可以这样使用:
ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url]; [request setDownloadCache:[ASIDownloadCache sharedCache]];
缓存存储方式
你可以设置缓存的数据需要保存多长时间， ASIHTTPRequest 提供了两种策略:
a， ASICacheForSessionDurationCacheStoragePolicy ，默认策略，基于 session 据存储。当下次运行或 [ASIHTTPRequest clearSession] 时，缓存将失效。
b， ASICachePermanentlyCacheStoragePolicy ，把缓存数据永久保存在本地， 如:
ASIHTTPRequest *request = [ ASIHTTPRequest requestWithURL:url ];
[ request setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy ];
的缓存数
1 ，但是下一个
8 ，所以 d

 47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒
体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基于
TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速:客户向服务器请求服务时， 只需传送请求方法和路径。
HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于
得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活:HTTP 允许传输任意类型的数据对象。 正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
48 URL
HTTP URL (URL 是一种特殊类型的 URI 是他的子类， 包含了用于查找某个资源的足够的信
息 ) 的格式如下:
http://host[":"port][abs_path ]
http 表示要通过 HTTP 协议来定位网络资源; host 表示合法的 Internet 主机域名或者 IP 地 址; port 指定一个端口号，为空则使用缺省端口 80 ;abs_path 指定请求资源的 URI ;如果 URL 中没有给出 abs_path ，那么当它作为请求 URI 时，必须以 ―的/ ‖形式给出，通常这个工 作浏览器自动帮我们完成。
49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP
在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
请求方法常用的有 GET 、 HTTP 协议简单，使
Content-Type 加以标记。

 TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能 建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包;
2. 主机 B 向主机 A 发送同意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收，
协调工作)的数据包; 3. 主机 你接着吧! ‖，这是第三次对话。
―对话 ‖之后，主机 A 才向主机
UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协议。它是面向非连接
A 再发出一个数据包确认主机 B 的要求同步: ―我现在就发， 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次
B 正式发送数据。
的协议，它不与对方建立连接，而是直接就把数据包发送过去! 少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接
传输可靠性可靠不可靠
应用场合传输大量数据少量数据
速度慢快
50 socket 连接和 http 连接的区别
简单说， 你浏览的网页 (网址以 http:// 开头 ) 都是 http 协议传输到你的浏览器的 于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层 ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
UDP 适用于一次只传送
, 而 http 是基
连接的

 我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read –> 关闭 close ‖模式来操作。 我的理解就是 Socket 就是该模式的一个实现， socket 即是一种 特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数我 们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样的 话，如果没有应用层，便无法识别数据内容， 如果想要使传输的数据有意义，则必须使用到 应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自己定义应用层 协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信
的能力。 )
2 )Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数 接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN (ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过 ―四次握手 (‖过程就不细写了， 就是服务器和客户端交互， 最终确定断开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。

 1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址 和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。
53 进程与线程
进程( process )是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为
一些功能单元。
进程中所包含的一个或多个执行单元称为线程( thread )。进程还拥有一个私有的虚拟地址 空间，该空间仅能被它所包含的线程访问。
通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。 在引入线程的操作系统中， 通常都是把进程作为分配资源的基本单位， 而把线程作为独立运 行和独立调度的基本单位。
由于线程比进程更小， 基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多， 能 更高效的提高系统内多个程序间并发执行的程度。
简而言之 ,一个程序至少有一个进程 , 一个进程至少有一个线程
个程序中的多个任务则被称为线程。
线程只能归属于一个进程并且它只能访问该进程所拥有的资源。 该进程会自动申请一个名为主线程或首要线程的线程。应用程序(
多个相互协作的进程组成的。
另外， 进程在执行过程中拥有独立的内存单元， 而多个线程共享内存， 从而极大地提高了程 序的运行效率。
线程在执行过程中与进程还是有区别的。 每个独立的线程有一个程序运行的入口、 顺序执行 序列和程序的出口。 但是线程不能够独立执行， 必须依存在应用程序中， 由应用程序提供多 个线程执行控制。
从逻辑角度来看， 多线程的意义在于一个应用程序中， 有多个执行部分可以同时执行。 但操 作系统并没有将多个线程看做多个独立的应用， 来实现进程的调度和管理以及资源分配。 这 就是进程和线程的重要区别。
.一个程序就是一个进程， 而一
当操作系统创建一个进程后， application )是由一个或

 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动 , 进程是系统进行资源 分配和调度的一个独立单位 .
线程是进程的一个实体 ,是 CPU 调度和分派的基本单位 ,它是比进程更小的能独立运行的基 本单位 .线程自己基本上不拥有系统资源 ,只拥有一点在运行中必不可少的资源 (如程序计数 器 , 一组寄存器和栈 ), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源 . 一个线程可以创建和撤销另一个线程 ;同一个进程中的多个线程之间可以并发执行 .
54 多线程
多线程编程是防止主线程堵塞， 增加运行效率等等的最佳方法。 而原始的多线程方法存在很 多的毛病，包括线程锁死等。在 Cocoa 中， Apple 提供了 NSOperation 这个类，提供了一 个优秀的多线程编程方法。
本次介绍 NSOperation 的子集，简易方法的 NSInvocationOperation :
一个 NSOperationQueue 操作队列，就相当于一个线程管理器，而非一个线程。因为你可 以设置这个线程管理器内可以并行运行的的线程数量等等
55oc 语法里的 @perpoerty 不用写 @synzhesize 了，自动填充了。并且的 _name; 写方法时候不用提前声明。 llvm 全局方法便利。
枚举类型。 enum hello:Integer{ } 冒号后面直接可以跟类型，以前是: enum hello{} 后面在指定为 Integer .
桥接。 ARC 自动 release retain 的时候 CFString CFArray . Core Fountion. 加上桥接 _brige 才能区分 CFString 和 NSString 而现在自动区分了，叫固定桥接。
下拉刷新封装好了。
UICollectionViewController. 可以把表格分成多列。
Social Framework( 社交集成 ) UIActivityViewController 来询问用户的社交行为
缓存: 就是存放在临时文件里， 比如新浪微博请求的数据，和图片，下次请求看这里有没有 值。

12. Object C 中创建线程的方法是什么?如果在主线程中执行代码，方法 是什么?如果想延时执行代码、方法又是什么?
线程创建有三种方法:使用 NSThread 创建、使用 GCD的 dispatch 、使用 子类化的 NSOperation, 然后将其加入 NSOperationQueue;在主线程执行代 码，方法是 performSelectorOnMainThread ，如果想延时执行代码可以用 performSelector:onThread:withObject:waitUntilDone:

13. 类别的作用?继承和类别在实现中有何区别? 答案:category 可以在不获悉， 不改变原来代码的情况下往里面添加新的 方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 因为类别具有更高的优先级。 类别主要有3个作用: (1) 将 类 的 实 现 分 散 到 多 个 不 同 文 件 或 多 个 不 同 框 架 中 。 (2) 创 建 对 私 有 方 法 的 前 向 引 用 。 (3) 向 对 象 添 加 非 正 式 协 议 。
继承可以增加，修改或者删除方法，并且可以增加属性。
3.Difference between categories and extensions?
类别和类扩展的区别。 答案: category 和 extensions 的不同在于 后者可以添加属性。另外后
者添加的方法是必须要实现的。 extensions 可以认为是一个私有的 Category 。
4.Difference between protocol in objective c and interfaces in java? oc 中的协议和 java 中的接口概念有何不同? 答案:OC中的协议有 2 层含义，官方定义为 formal 和 informal protocol 。 前 者 和 Java 接 口 一 样 。 informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的， 但是如果有实现，就会改变类的属性。 其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也 写在了学习教程里 “非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希 望实现的方法，你可以使用他们更好的完成工作”。 这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明 一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。" 现在来看，其实 protocal 已经开始对两者都统一和规范起来操作， 因为资 料中说“非正式协议使用 interface 修饰“， 现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
OC中的协议 (formal protocol) 与 java 中的接口概念基本一致， OC中非正 式协议 (informal protocol) 就是类别。在 java 中如果继承了接口，但不
实现其方法，会得到一个 error (无法编译);在 OC中的正式协议，如果 不实现，会得到一个 warning (可编译执行)，如果想去除 waring ，还可 以加关键字( @optional )，让它可选实现方法。
5.What are KVO and
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属
KVC?

 性，而不是通过调用存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代 码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比 如 我 自 定 义 的 一 个 button [cpp]
[self addObserver:self forKeyPath:@"highlighted" context:nil];
#pragma mark
- (void)observeValueForKeyPath:(NSString ofObject:(id)object change:(NSDictionary *)change *)context
{
options:0
KVO
*)keyPath context:(void
if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
}
}
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的道理是一样的。 对于 kvc 机制如何通过 key 寻找到 value : “当通过 KVC调用对象时，比如: [self valueForKey:@ ”someKey”] 时， 程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带
有 someKey 这个方法，如果没找到，会继续查找对象是否带有 someKey 这个实例变量( iVar )，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。 如果这个方法还是没有被实现的话， 程 序 会 抛 出 一 个 NSUndefinedKeyException 异 常 错 误 。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或 者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也 会不仅仅查找 someKey这个变量，也会查找 _someKey这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前，有最 后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样 做的好处。“ 来 至 cocoa ， 这 个 说 法 应 该 挺 有 道 理 。 因为我们知道 button 却是存在一个 highlighted 实例变量 . 因此为何上面 我们只是 add 一个相关的 keypath 就行了， 可以按照 kvc 查找的逻辑理解，就说的过去了。

 6.What is purpose of delegates?
代理的作用? 答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知 到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.What are mutable and immutable types in Objective C? oc 中 可 修 改 和 不 可 以 修 改 类 型 。 答案:可修改不可修改的集合类。这个我个人简单理解就是可动态添加修 改和不可动态添加修改一样。 比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不 可变的，后者可以添加等，可以动态申请新的内存空间。
8.When we call objective c is runtime language what does it mean?
我 们 说 的 oc 是 动 态 运 行 时 语 言 是 什 么 意 思 ? 答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及 调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是
假 设 生 物 类 ( life ) 都 用 有 一 个 相 同 的 方 法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但 是 调 用 是 我 们 只 需 调 用 各 自 的 eat 方 法 。 也就是不同的对象以自己的方式响应了相同的消息(响应了 eat 这个选择 器)。 因此也可以说，运行时机制是多态的基础? ~~~
9.what is difference between NSNotification and protocol? 通知和协议的不同之处? 答案:协议有控制链(has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析 下通知和代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受 者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济 代理人，很多时候一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能 说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别 称B的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到 感兴趣要处理。 因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应 关系。

17.NSOperation queue? 答案:存放 NSOperation 的集合类。 操作和操作队列， 基本可以看成 java 中的线程和线程池的概念。 用于处理 ios 多 线 程 开 发 的 问 题 。 网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概念， 放入的操作并非是按照严格的先进现出。 这边又有个疑点是， 对于队列来说， 先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也进入队列，Afunc 先执行这个是必然的， 但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队 列的概念理论上有点违背了多线程处理这个概念。 但是转念一想其实可以参考银行的取票和叫号系统。 因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认 为这还是一个队列。 但是后来看到一票关于这操作队列话题的文章，其中有一句提到 “因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定 的。” 瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮助多线程编程就好了。 楼上区分了线程执行时的次序( Afunc 和 Bfunc 谁先启动)和线程执行完 成(Afunc 和 Bfunc 谁先执行完)时的次序不同，而多线程的重要概念是 并发(同时执行多个任务)， NSOperationQueue 是管理并发线程的对象， 可以在其中放入 NSOpertation 对象(对象化的线程实体)，通过设置 maxConcurrentOperationCount 的大小，控制并发数目，如楼上所说希望 “Afunc 添加进队列，执行完后， Bfunc 紧跟进入队列，继续执行”，那只 需将 maxConcurrentOperationCount 设为 1，变会依次执行，这时候实际 是在单线程依次执行。 所以这里的 NSOperationQueue就是对象化抽象的去 管理多线程，这样的好处，使用者通过继承 NSOperation 对象，可以方便 的用对象来管理线程，而不再用关心线程同步、信号量等细节，更多地关 注于业务逻辑。
18.What is lazy loading? 答案:懒汉模式，只在用到的时候才去初始化。 也可以理解成延时加载。 我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。
19.Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制器中嵌入两个 tableview 控制器? 答案:一个视图控制只提供了一个 View 视图，理论上一个 tableViewController 也 不 能 放 吧 ， 只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，如果不 是我们定性思维认为的 UIViewController ， 而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，

 它可以控制多个视图控制器，比如 TabbarController 那样的感觉。
20.Can we use one tableview with two different datasources? Howyou will achieve this? 一个 tableView 是否可以关联两个不同的数据源?你会怎么处理? 答案:首先我们从代码来看，数据源如何关联上的，其实是在数据源关联 的代理方法里实现的。 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据 自己的需要去设置如相关的数据源。 因此，我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢? 想让列表如何显示，不同的数据源分区块显示?
三.。。。。
1.When to use NSMutableArray and when to use NSArray? 什么时候使用 NSMutableArray ，什么时候使用 NSArray ?
答案:当数组在程序运行时，需要不断变化的，使用 NSMutableArray ，当数组在初 始化后，便不再改变的，使用 NSArray。需要指出的是，使用 NSArray 只表明的是该 数组在运行时不发生改变， 即不能往 NSAarry 的数组里新增和删除元素， 但不表明其 数组內的元素的内容不能发生改变。 NSArray 是线程安全的， NSMutableArray 不是线 程安全的，多线程使用到 NSMutableArray 需要注意。
2.Give us example of what are delegate methods and what are data source methods of uitableview.
给出委托方法的实例，并且说出 UITableVIew 的 Data Source 方法
答案: CocoaTouch 框架中用到了大量委托，其中 UITableViewDelegate 就是委托机 制的典型应用， 是一个典型的使用委托来实现适配器模式， 其中 UITableViewDelegate 协议是目标， tableview 是适配器，实现 UITableViewDelegate 协议，并将自身设置 为 talbeview 的 delegate 的对象，是被适配器，一般情况下该对象是 UITableViewController 。
UITableVIew 的 Data Source 方 法 有 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
3.How many autorelease you can create in your application? Is there any limit? 在应用中可以创建多少 autorelease 对象，是否有限制?
答案:无
4.If we don ’ t create any autorelease pool in our application then is there
any autorelease pool already provided to us?
如果我们不创建内存池，是否有内存池提供给我们?
答案 : 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程 的内存池
5.When you will create an autorelease pool in your application? 什么时候需要在程序中创建内存池? 答案:用户自己创建的数据线程，则需要创建该线程的内存池
6.When retain count increase?

 什么时候内存计数会增加?
答案:见 iOS 面试题(一)
7.What are commonly used NSObject class methods?
类 NSObject 的那些方法经常被使用?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。 其中类方法 alloc 、class 、 description 对象方法 init 、dealloc 、– performSelector:withObject:afterDelay: 等经常被使用
8.What is convenience constructor?
什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统 给我们创建好的对象，并且不需要手动释放。

UIView 的动画效果有那些? 答案:有很多， 如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEa seIn UIViewAnimationOptionCurveEaseOu t UIViewAnimationOptionTran sitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UI ViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDow
n
如何使用可见该博文
12.How can you store data in iPhone applications?
在 iPhone 应用中如何保存数据?
答案:有以下几种保存机制:
1.通过 web服务，保存在服务器上
2. 通过 NSCoder固化机制，将对象保存在文件中
3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.What is coredata?
什么是 coredata ?
答案: coredata 框架是 apple 提供的一套通用自动的解决方案，包括了对象生存周 期、对象关系图、持久化机制。
补充答案:上面是翻译的，按我个人理解 coredata 提供一种一机制，让我们可以方 便的把内存中对象，及对象间的关系，映射到 coredata ，然后由它为我们持久化数

 据。相比普通的文件数据库 SQlite ，它的功能更强大，不需要我们先将对象数据 format 成 SQL语句，存入数据库， 再用 select 语句读出， 而现在是从内存到 coredata 的数据管理，我们只需管理 coredata 的 managed对象。
是苹果提供一套数据保存
14.What is NSManagedObject model?
什么是 NSManagedObject 模型?
答案: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成部分，它 是一个通用的类 , 实现了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject，建立自己的数据模型。
15.What is NSManagedobjectContext?
什么是 NSManagedobjectContext ?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
16.What is predicate?
什么是谓词?
答案:谓词是通过 NSPredicate ，是通过给定的逻辑条件作为约束条件，完成对数据 的筛选。
predicate = [NSPredicate predicateWithFormat:@"customerID == %d",n]; a = [customers filteredArrayUsingPredicate:predicate];

1. 什么情况使用 weak 关键字，相比 assign有什么不同? 什么情况使用 weak 关键字?
1)在 ARC中,在有可能出现循环引用的时候 ,往往要通过让其中一端使用 weak 来解 决,比如 :delegate 代理属性
2)自身已经对它进行一次强引用 , 没有必要再强引用一次 义 IBOutlet 控件属性一般也使用 weak ;当然，也可以使用
《IBOutlet 连出来的视图属性为什么可以被设置成 weak?》 不同点:
,此时也会使用 weak,自定 strong 。在下文也有论述:
1) weak 此特质表明该属性定义了一种“非拥有关系”
为这种属性设置新值时， 设置方法既不保留新值， 也不释放旧值。 此特质同 assign 类似，
(nonowning relationship) 。 然而在属性所指的对象遭到摧毁时， 属性值也会清空 (nil out) 。而 assign 的“设置方法”
只会执行针对 “纯量类型” (scalar type，例如 CGFloat或 NSlnteger 等)的简单赋值操作。 2) assigin 可以用非 OC对象 ,而 weak 必须用于 OC 对象

 7. runtime 如何通过 selector 找到对应的 IMP 地址?(分别考虑类方法和实例 方法)
每一个类对象中都一个方法列表 , 方法列表中记录着方法的名称 ,方法实现 , 以及参数类型 , 其实 selector 本质就是方法名称 ,通过这个方法名称就可以在方法列表中找到对应的方法
实现 .
8. objc 使用什么机制管理对象内存?
通过 retainCount 的机制来决定对象是否需要释放。每次 runloop 的时候，都会检查对象
的 retainCount ，如果 retainCount 为 0，说明该对象没有地方需要继续使用了，可以释 放掉了。
9. ARC通过什么方式帮助开发者管理内存? 编译时根据代码上下文，插入 retain/release
10.BAD_ACCES在S什么情况下出现? 访问了野指针， 比如对一个已经释放的对象执行了
量或者发消息。死循环
11.苹果是如何实现 autoreleasepool的?
autoreleasepool 以一个队列数组的形式实现 objc_autoreleasepoolPush objc_autoreleasepoolPop objc_aurorelease
release、访问已经释放对象的成员变
看函数名就可以知道， 对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行 操作。
release

 1 、请你自我介绍一下你自己?
我叫 XX，今年 X 岁， XXXX年毕业于 XX大学。有 2 年的开发工作经验，我对技术有深厚的兴趣， 专业知识面宽，责任心强，思路清晰，沟通力能好，精通 iOS 开发的相关技术体系，熟悉常用 的设计模式。平常有时间看看博客，并且自己也喜欢在 CSDN上写技术类的文章，与博友一起讨 论。谢谢! 您还有什么想了解的么?我们可以细聊
(不要说简历里已经写过的内容，要说出和 iOS 开发相关的素质和能力爱好) 、、、、、、、 2、为什么要离职?
2.1 “我离职是因为这家公司倒闭;我在公司工作了三年多，有较深的感情;从去年始，由于市 场形势突变，公司的局面急转直下;到眼下这一步我觉得很遗憾，但还要面对显示，
发挥我能力的舞台。”
2.2 因为家中有事，须请假几个月，公司又不可能准假，所以辞职或者说 在转型做其他的业务 。
(不要表达出任何消极的情感: 比如上家单位领导不好， 同事不好等， 你上家离职的原因在这家也会发生)
、、、、、、、 3 、说说你最大的缺点?
重新寻找能 小公司换了领导层， 正
目的是让面试官不要觉得
我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深 夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息 的工作范围内有创新意识， 并没有扩展给其他同事。 这些问题我想我可以进入公司后以最短的时 间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化， 进入工作状态。 我想就这 些吧。
、、、、、、、 4、在五年的时间内，你的职业规划 ?
我希望从现在开始， 1-2 年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力 后，最好能有晋升，希望 3-5 年内可以从开发做到架构师。同时我也希望自己能够在企业的平台 上得到进一步的职业能力提升 。
、、、、、、、 5 、你对薪资的要求?
5.1 我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找 对工作机会，所以只要条件公平，我则不会计较太多。
5.2 如果你必须自己说出具体数目， 那就不要说一个宽泛的范围， 不要说 8000-10000 之间， 那样你将只会得到最低限底的数字，也就是 8000 。最好给出一个具体的数字。
5.3 我可以直接入职工作，不需要进行大量的 培训 ，而且我本人也对编程特别感兴趣。因 此， 我希望公司能根据我的情况和市场标准的水平，给我合理的薪水 。
、、、、、、、 6 、你还有什么问题问我吗?
项目进展和 部门人员分工情况、开发技术 / 工具、贵公司的晋升机制是什么样的、是否提供 培训或为参加培训的员工提供一些补助、如何解决团队成员之间的矛盾、有没有什么集体活动、 加班什么情况等等 。
1

 (问的越多，越能表达你是在认真的对待这个工作，当然，不要问很 low 的问题，比如加 班费，调休什么的)
、、、、、、 7 、你对加班的看法?你的家人或朋友抱怨你加班怎么办? 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入
工作。但同时，我也会提高工作效率，减少不必要的加班 。
、、、、、、 8 、你觉得你个性上最大的优点是什么? 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、
乐观和友爱 。我经过一到两年的 学习 及项目实战，加上实习工作，使我适合这份工作。 、、、、、 9、你对于我们公司了解多少?
回答提示:在去公司 面试 前上网查一下该公司主营业务。 与国外大厂的 OEM合作，自有品牌的部分则透过海外经销商。 (表现的专业一些。或者注意观察临时编词)
、、、、、、、、、、 10、你最擅长的技术方向是什么? 要 说和你要应聘的职位相关的技术 。
、、、、、、、 11 、你为什么愿意到我们公司来工作?
如回答:贵公司有意改变策略， 加强
11.1 “ 公司本身的高技术开发环境很吸引我 ，希望能够进入一家与我共同成长的公司。”、
11.2 “ 你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、
11.3 “我认为贵公司能够给我提供一个与众不同的发展道路 。”
、、、、、、、、 12、谈谈你过去做过的成功案例?
回答提示: 举一个你最有把握的例子 ，把来龙去脉说清楚， 而不要说了很多却没有重点。 切忌夸
大其词，把别人的功劳到说成自己的
、、、、、、、、、、 13、谈谈你过去的工作经验中，最令你挫折的事情?
曾经接触过一个客户， 原本就有耳闻他们以挑剔出名， 所以事前的准备功夫做得十分充分， 入了相当多的时间与精力， 最后客户虽然并没有照单全收， 但是接受的程度已经出乎我们意料之 外了。 原以为从此可以合作愉快， 却得知客户最后因为预算关系选择了另一家代理商， 之前的努 力因而付诸流水。尽管如此，我还是从这次的经验学到很多， 如对该产业的了解，整个 team 的默 契也更好了 。
(表现出遇到问题时相应地解决方法和学习到的东西)

9、内存管理的几条原则是什么?按照默认法则，哪些关键字生成的对象需要手 动释放?哪些情况下不需要手动释放，会直接进入自动释放池?
? 当使用 new、alloc 或copy方法创建一个对象时，该对象引用计数器为 1。 如果不需要使用该对象， 可以向其发送 release 或 autorelease 消息，在其使用完 毕时被销毁。
? 如果通过其他方法获取一个对象， 则可以假设这个对象引用计数为 1，并 且被设置为 autorelease ，不需要对该对象进行清理，如果确实需要 retain 这个 对象，则需要使用完毕后 release 。
? 如果 retain 了某个对象，需要 release 或autorelease 该对象，保持 retain 方法和release 方法使用次数相等。
使用 new、alloc 、copy关键字生成的对象和 retain 了的对象需要手动释放。 设置 为 autorelease 的对象不需要手动释放，会直接进入自动释放池。
10、怎样实现一个单例模式的类，给出思路，不写代码。
? 首先必须创建一个全局实例， 通常存放在一个全局变量中
置为 nil
? 提供工厂方法对该全局实例进行访问，检查该变量是否为
就创建一个新的实例，最后返回全局实例
, 此全局变量设 nil ，如果nil
? 全局变量的初始化在第一次调用工厂方法时会在 +allocWithZone: 中进 行，所以需要重写该方法，防止通过标准的 alloc 方式创建新的实例

 ? 为了防止通过 copy方法得到新的实例，需要实现 -copyWithZone 方法
? 只需在此方法中返回本身对象即可，引用计数也不需要进行改变，因为
单例模式下的对象是不允许销毁的，所以也就不用保留
? 因为全局实例不允许释放，所以 retain,release,autorelease 方法均需 重写

11. Object C 中创建线程的方法是什么?如果在主线程中执行代码，方法是什 么?如果想延时执行代码、方法又是什么?
线程创建有三种方法: 使用NSThread创建、使用 GCD的dispatch 、使用子类化的 NSOperation, 然后将其加入 NSOperationQueue;在主线程执行代码，方法是 performSelectorOnMainThread ， 如 果 想 延 时 执 行 代 码 可 以 用 performSelector:onThread:withObject:waitUntilDone
1、iPhone5 的屏幕分辨率大小为 1136 * 640 ?
屏幕分辨率:用于量度位图图像内数据量多少的一个参数。 通常表示成 ppi (每英寸像素 Pixel per inch )。屏幕物理尺寸不变，分辨率越高，每单位面积 内包含的细节(像素点)越多。
2、struct strA{ int a; floatb; char c; } expA;

 printf("%ld",sizeof(expA)); 输出结果为 12 ? 该问题涉及编译器的“内存对齐”问题:
现代计算机中内存空间都是按照 byte(字节) 划分的， 从理论上讲似乎对任何类 型的变量的访问可以从任何地址开始， 但实际情况是在访问特定变量的时候经常 在特定的内存地址访问， 这就需要各类型数据按照一定的规则在空间上排列， 而 不是顺序的一个接一个的排放，这就是对齐。
对齐的作用和原因: 各个硬件平台对存储空间的处理上有很大的不同。 一些平台 对某些特定类型的数据只能从某些特定地址开始存取。 其他平台可能没有这种情
况，但是最常见的是如果不按照适合其平台的要求对数据存放进行对齐， 会在存 取效率上带来损失。 比如有些平台每次读都是从偶地址开始， 如果一个 int 型(假 设为 32 位)如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如 果存放在奇地址开始的地方，就可能会需要 2个读周期，并对两次读出的结果的 高低字节进行拼凑才能得到该 int 数据。显然在读取效率上下降很多。这也是空 间和时间的博弈。
通常，我们写程序的时候， 不需要考虑对齐问题。 编译器会替我们选择适合目标 平台的对齐策略。 当然，我们也可以通知给编译器传递预编译指令而改变对指定 数据的对齐方法。
但是，正因为我们一般不需要关心这个问题， 所以因为编辑器对数据存放做了对 齐，而我们不了解的话， 常常会对一些问题感到迷惑。 最常见的就是 struct 数据
结构的sizeof 结果，出乎意料。
对于结构体来说，按成员中所占字节最大的是 float 类型，占用 4个字节，
一共有 3个成员，所以总的占用字节为: 4 * 3 = 12. 可通过编译器命令来设定:

@property (retain) test* aTest; @property (copy) test* aTest; 等效代码:
-(void)aTest
{
[aTest retain];
return [aTest autorelease];
}
setter 分析:
@property (nonatomic, retain) test* aTest; @property (retain) test* aTest;
等效于:
-(void)setaTest:(test *)newaTest {
if (aTest != newaTest) { [aTest release];
aTest = [newaTest retain];
} }
==========貌似我是分割线===========
@property (nonatomic, copy) test* aTest;

 @property (copy) test* aTest;
等效于:
-(void)setaTest:(test *)newaTest { if (aTest != newaTest) {
[aTest release];
aTest = [newaTest copy]; }
}
8、 iOS中有哪些回调机制，并作简单的比较。 各种回调机制的比较:
1、目标动作对:当两个对象之间有比较紧密的关系时，如视图控制器与其下的 某个视图。
2、代理:也叫委托，当某个对象收到多个事件，并要求同一个对象来处理所有 事件时。委托机制依赖于某个协议定义的方法来发送消息。
3、通告机制:当需要多个对象或两个无关对象处理同一个事件时。

10、JSON中 { } 代表 _____，[ ] 代表 _____，试将下面的 JSON串用 OC对象表示出来: { "people": [
{ "firstName":"Brett", "lastName":"McLaughlin","email": "aaaa" },
{ "firstName":"Jason", "lastName":"Hunter", "email":"bbbb"},
{ "firstName":"Elliotte", "lastName":"Harold","email": "cccc" } ]，
“location ”: ”中华人民共和国” }
JSON中{ } 代表对象，数据结构为{ key1:value1, key2:value2, key3: ,, } [ ] 代表数组，与其他语言中的数组类似。
@interfacePeople : NSObject
@property(nonatomic, copy) NSString* strFirstName; @property(nonatomic, copy) NSString* strLastName; @property(nonatomic, copy) NSString* strEmail;
@end

@interfaceJSonData : NSObject
@property(nonatomic, retain) NSMutableArray* arrPeople; //
对象
@property(nonatomic, copy) NSString* strLocation;
@end
存放 People
1. Object-C 有多继承吗?没有的话用什么代替?
没有， cocoa 中所有的类都是 NSObject 的子类 protocol 委托代理来实现的 ood 的多态特性在 实现.
多继承在这里是用 obj-c 中通过委托来
2. Object-C 有私有方法吗?私有变量呢?
objective-c –类里面的方法只有两种 , 静态方法和实例方法 . 在类里面声名一个私有方法 @interface Controller: NSObject
{ NSString*something;
} +(void)thisIsAStaticMethod; – (void)thisIsAnInstanceMethod; @end

 @interface Controller
(private)
-(void)thisIsAPrivateMethod; @end
@private 可以用来修饰私有变量在 Objective ‐ C中，所有实例变量默认都是私有 的，所有实例方法默认都是公有的

 26.sprintf,strcpy,memcpy 使用上有什么要注意的地方 strcpy 是一个字符串拷 贝的函数，它的函数原型为 strcpy(char *dst, const char *src); 将src 开始的
一段字符串拷贝到 dst 开始的内存中去，结束的标志符号为 '\0' ，由于拷贝的长 度不是由我们自己控制的， 所以这个字符串拷贝很容易出错。 具备字符串拷贝功 能的函数有 memcpy，这是一个内存拷贝函数，它的函数原型为 memcpy(char *dst,const char* src, unsigned int len); 将长度为 len 的一段内存，从 src 拷贝到 dst 中去，这个函数的长度可控。 但是会有内存叠加的问题。 sprintf 是格 式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。
sprintf 格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的 大小，造成溢出。
27. 用变量 a 给出下面的定义 a) 一个整型数( An integer ) b) 一个指向整 型数的指针( Apointer to an integer ) c) 一个指向指针的的指针，它指向
的指针是指向一个整型数( A pointer to a pointer to an intege ) r d) 一个有 10 个整型数的数组( An array of 10 integers ) e) 一个有 10 个 指针的数组，该指针是指向一个整型数的。 ( An array of 10 pointers to integers ) f) 一个指向有 10 个整型数数组的指针( A pointer to an array of 10 integers ) g) 一个指向函数的指针，该函数有一个整型参数并返回 一个整型数(A pointer to a function that takes an integer as an argument and returns an integer ) h)一个有 10 个指针的数组，该指针 指向一个函数，该函数有一个整型参数并返回一个整型数( An array of ten pointers to functions t hat take an integer argument and returnan integer ) 答案是: a) int a; // An integer b) int *a; // A pointer to aninteger c) int **a; // A pointer to a pointer toan integer d) int a[10]; // An array of 10integers e) int *a[10]; // An array of 10pointers to integers f) int (*a)[10]; // A pointer to anarray of 10
integers g) int (*a)(int); // A pointer to afunction a that takes an integerargument and returns an integer h) int (*a[10])(int); // An
array of 10pointers to functions that take aninteger argument and return an integer

面试能力要求:精通 iphone 的 UI 开发，能熟练操作复杂表视图，熟练使用图层技术， 可以自定义 UI 控件，使用类别扩展系统控件功能 ;
擅长通讯技术， 熟悉各种通信协议， 精通 xml, json, 二进制或其他形式的自定义解析， 能架设服务器实现 客户端与服务器的通讯以提交开发效率 ;
熟练掌握各种数据存储技术，如 core data, sqlite, 对象序列化，文件读写操作，熟悉数据库的设计。 精通 object-c ，java ， c 等编程语言 , 熟悉 c++ ，对于 面向对象编程思想有深入理解，熟悉常见设计 模式的应用，
对于大型项目有一定的架构能力。
1. ViewController 的 didReceiveMemoryWarning 怎么被调用:
[supper didReceiveMemoryWarning];
2. 什么时候用 delegate, 什么时候用 Notification?
delegate 针对 one-to-one 关系，用于 sender 接受到 reciever 的某个功能反馈值。 notification 针对 one-to-one/many/none,reciver, 用于通知多个 object 某个事件。
3. 用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题)
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情:
#define 语法的基本知识(例如:不能以分号结束，括号的使用，等等) 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实 际的值，是更清晰而没有代价的。
意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整 型数。
如果你在你的表达式中用到 UL(表示无符号长整型) ，那么你有了一个好的起点。 记住， 第一印象很重要。
写一个 " 标准 " 宏 MIN ，这个宏输入两个参数并返回较小的一个。 #define MIN(A,B) (( A) <= (B) ? (A) : (B))
这个测试是为下面的目的而设的:
标识 #define 在宏中应用的基本知识。 这是很重要的， 因为直到嵌入 (inline) 操作符变为标准 C 的一部分，
宏是方便产生嵌入代码的唯一方
法，
对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化 的代码，了解这个用法是很重要的。
懂得在宏中小心地把参数用括号括起来 我也用这个问题开始讨论宏的副作用，例如:当你写下面的代码时会发生什么事?
least = MIN(*p++, b);
结果是:
((*p++) <= (b) ? (*p++) : (*p++))
这个表达式会产生副作用，指针 p 会作三次 ++自增操作。

25. 你了解 svn,cvs 等版本控制工具么?
版本控制 svn,cvs 是两种版控制的器 , 需要配套相关的
scm 是 xcode 里配置版本控制的地方。 版本控制的原理就是 a 和 b 同时开发一个项目， 后把代码提交给服务器，
b 要做的时候先从服务器得到最新版本，就可以接着做。 如果 a 和 b 都要提交给服务器，并且同时修改了 同一个方法，就会产生代码冲突，
如果 a 先提交，那么 b 提交时，服务器可以提示冲突的代码， b 可以清晰的看到，并做出相应的修改或融 合后再提交到服务器。
26. 什么是 push( 了解一下)。
客户端程序留下后门端口， 客户端总是监听针对这个后门的请求， 于是 服务器可以主动像这个端口推送消
息。
27. 静态链接库 ( 了解一下)
(此为 .a 文件，相当于 java 里的 jar 包，把一些类编译到一个包中，在不同的工程中如果导入此文件就 可以使用里面的类，
具体使用依然是 #import “ xx.h ”)。 28.fmmpeg 框架 ( 了解一下)
(音视频编解码框架，内部使用 UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成 快速接受之目的) .
29.fmdb 框架 ( 了解一下 )
(数据库框架，对 sqllite 的数据操作进行了封装，使用着可把精力都放在 30.320 框架(了解一下)
(ui 框架，导入 320 工程作为框架包如同添加一个普通框架一样)。 cover(open) flower 框架 (2d 仿射技术 ) ，内部核心类是 CATransform3D.
sql 语句上面)。
svn ，cvs 服务器。
a 写完当天的代码之

 31.什么是沙箱模型?哪些操作是属于私有 api 范畴?
某个 iphone 工程进行文件操作有此工程对应的指定的位置，不能逾越。
iphone 沙箱模型的有四个文件夹，分别是什么，永久数据存储一般放在什么位置，得到模拟器的路径的简 单方式是什么 .
documents ，tmp， app，Library 。
( NSHomeDirectory() )，
手动保存的文件在 documents 文件里
Nsuserdefaults 保存的文件在 tmp 文件夹里
Documents 目录: 您应该将所有 de 应用程序数据文件写入到这个目录下。 这个目录用于存储用户数据或其 它应该定期备份 的 信息。
AppName.app 目录:这是应用程序 的程序包目录，包含应用程序 的本身。由于应用程序必须经过签名， 所以您在运行时不能对这个目录中 的 内容进行修改，否则可能会使应用程序无法启动。
Library 目录:这个目录下有两个子目录: Caches 和 Preferences
Preferences 目录包含应用程序 的 偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用 NSUserDefaults 类来取得和设置应用程序 的 偏好 .
Caches 目录用于存放应用程序专用 的支持文件，保存应用程序再次启动过程中需要 的信息。
tmp 目录:这个目录用于存放临时文件，保存应用程序再次启动过程中不需要 的信息。 获取这些目录路径 的 方法:
1，获取家目录路径 的 函数:
NSString *homeDir = NSHomeDirectory();
2，获取 Documents 目录路径 的 方法:
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,
YES);
NSString *docDir = [paths objectAtIndex:0];
3，获取 Caches目录路径 的方法:
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cachesDir = [paths objectAtIndex:0];
4，获取 tmp 目录路径 的 方法:
NSString *tmpDir = NSTemporaryDirectory();
5，获取应用程序程序包中资源文件路径 的 方法:
例如获取程序包中一个图片资源( apple.png )路径的方法:
NSString *imagePath = [[NSBundle mainBundle] pathForResource:@
UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath];
代码中 的 mainBundle 类方法用于返回一个代表应用程序包 的对象。
文件 IO 写入
1，将数据写到 Documents 目录:
- (BOOL)writeApplicationData:(NSData *)data toFile:(NSString *)fileName {
” apple ” ofType:@ ”png”];

 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
if (!docDir) {
NSLog(@”Documents directory not found! ”); return NO; }
NSString *filePath = [docDir stringByAppendingPathComponent:fileName]; return [data writeToFile:filePath atomically:YES];
}
2，从 Documents 目录读取数据:
- (NSData *)applicationDataFromFile:(NSString *)fileName {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
NSString *filePath = [docDir stringByAppendingPathComponent:fileName]; NSData *data = [[[NSData alloc] initWithContentsOfFile:filePath] autorelease]; return data;
}
NSSearchPathForDirectoriesInDomains 这个主要就是返回一个绝对路径用来存放我们需要储存 的 文件。 - (NSString *)dataFilePath {
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,
YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
return [documentsDirectory stringByAppendingPathComponent:@"shoppingCar.plist"];
}
NSFileManager* fm=[NSFileManager defaultManager];
if(![fm fileExistsAtPath:[self dataFilePath]]){
// 下面是对该文件进行制定路径 的保存
[fm createDirectoryAtPath:[self dataFilePath] withIntermediateDirectories:YES attributes:nil
error:nil];
// 取得一个目录下得所有文件名
NSArray *files = [fm subpathsAtPath: [self dataFilePath] ];
// 读取某个文件
NSData *data = [fm contentsAtPath:[self dataFilePath]];
// 或者
NSData *data = [NSData dataWithContentOfPath:[self dataFilePath]];
}

iphone 常见私有 api 的应用(比如直接发送短信，访问沙箱之外的磁盘文件) .
32. 你在开发项目中时，用到了哪些数据存储方式， iphone 中常见的方式有哪些，各有什么区别?
数据存储五种形式的应用范围和性能区别
(core data, sqllite, 对象序列化，文件直接读写， NSUserDefault( 保存数据到 temp 文件夹中 ) )
文件直接读写 >core data> 对象序列化 > sqllite>NSUserDefault.
33. 线程的常见方法有哪些，你是如何处理多线程的，多线程同步问题你了解么?
线程创建的几种方式，线程的加锁，休眠，唤醒，解锁，退出，
多线程要考虑同步问题 , 解决同步问题的方式就是对某一资源加锁， 当一个线程操作本资源时， 其他线程不 能操作 。
系统自带线程池( NSOpertionQueue )的作用:
凡是需要启动多个线程的地方都可以使用 NSOpertionQueue ，加入到 NSOpertionQueue 中的对象都需要继 承 NSOpertion 。 NSOpertionQueue 会在系统内部启动一个独立线程去执行这个被加入对象的 main 方法。
常用的地方是用 nsoprationqueue 下载图片，文件。如果是自己创建一个线程池，无非就是启动多个线程 的时候，
把这些线程对象放到一个大数组中，如果需要启动线程的时候，先从数组中找空闲线程来使用。
自己管理线程池最大的难题是不好处理当启动多个线程后，用户在多个界面的跳转的时候，对线程方法的 回调管理。
而 NSOpertionQueue 可以很好的处理他。 34.init 和 initwithobject 区别(语法)?
init 创建的对象不带自动释放

38. 协议是什么，有什么作用 . ?
协议很像 java 中的接口，某个类实现协议后， 就必须实现协议中规定的 @require 的方法，比如一个类 A, 一 个类 B都实现某“协议”后，
这个类 A 的对象和 B 的对象都可以赋值给这个协议的类型变量，比如 id< 协议 > 变量名 = A 类或 B 类的对 象，
于是这个变量就完成了能够指向多个不同的类的对象并调用对象中的实现协议的方法。 39. 类别有什么作用?
类别的使用 。 类别有三大作用，
1. 可以使本来需要在 .h 中声明的方法放到 .m 文件中声明，达到了可以使方法不对外公开。
2. 可以方便的扩展类，甚至系统类都可以轻易扩展，维护了代码原本的结构不受影响。
3. 类别可以写到不同的 .h 或 .m 文件中，可以分散代码到跟类别的扩展功能想关联的地方，方便查看。
40. 分线程回调主线程方法是什么，有什么作用?
[self performSelectorOnMainThread:@selector(buttonGo2) withObject:nil waitUntilDone:YES]; [self performSelector:@selector(buttonGo2) onThread:[NSThread mainThread] withObject:nil waitUntilDone:YES];
需要即时刷新 ui 控件的时候，经常使用。
41.iphone 阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的?另外像
pdf 格式的文件， iphone 手机阅读器中对于 PDF格式的阅读，可以直接用 UIWebView 控件显示，也可以从网上下到很多直接
你如何读取。 ? 读取 pdf 格式的代码
直接从 pdf 中得到数据。
复杂表格动画
- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; -(void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
42. 你在开发大型项目的时候，如何进行内存泄露检测的 ?
可以通过 xcode 的自带工具 run---start with performance tool 里有 instruments 下有个 leaks 工具，
启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助进行内存泄 露的处理。
43. 你做 iphone 开发时候，有哪些传值方式， view 和 view 之间是如何传值的? 压栈。
44. 让一个物体从界面中的一点运动到另外一点，有哪些方法? 四种方式: 1. beginAnimation
2. 线程
3. NSTimer

 4. 图层动画(路径)
45. 你了解哪些加密方式?
Base64, MD5, 循环右移位等 . 46. 地图定位
CLLocationManager 位置管理器 使用 Core Location 框架来确定 iphone 的位置( GPS，蜂窝基站三角网， wps 三种方式)
MKMapView提供了一套可植入的地图接口，可以让我们在应用中展示地图，并对其进行相关的操作。一般 来说，我们可以指定一个展示区域，放一些标记在上面，还可以加盖一些层在上面。
MKMapView依赖 Google map 里面相关服务(如 Google Earth API 等)，所以地图的左下角会有 Google 字 样。
47. 打开 url
[[UIApplication sharedApplication] openURL:[NSURL
URLWithString:@"tel://8004664411"]]; mailto:// sms:// 48. http 网络通信
ASIHTTPRequest 是一个直接在 CFNetwork 上做的开源项目:提供直接提交 请求与队列，自动管理上传与下载队列管理机 ,ASIFormDataRequest 用于适合上传文件，图片数据。
49. 图片浏览
UIImagePickerController 可以从相册，相机，胶卷里获得图片。 50. 对像序列化
NSCoding encodeWithCoder initWithCoder
NSKeyedUnarchiver NSKeyedArchiver
53.线程 ?
a. 线程的创建和使用规则 ?
答: NSThread
三种方法
- (id)init; // designated initializer
(HTTP POST)文件的 API，异步

- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;
+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument
- (void)start;
b. 主分线程
答:启动分线程，上面已提到!加到主线程方法 performSelector !
// 加到主线程 addData() 是主线程的方法!只有加到主线程后，才能调用主线程的方法
[target performSelector:@selector(addData:) onThread:[NSThread mainThread] withObject:item waitUntilDone:YES];
//[target addData:item];// c. 线程锁
答: NSCondition
方法:
[thread lock];// 加锁 sleep(n);// 线程休眠
[thread singnal];//
[thread unlock];// 解锁 [thread exit];// 线程退出 54. 各种 排序算法? 希尔排序、快速排序、冒泡排序、 55. 通信底层原理
答: OSI 七层模型
没有加到主线程后，调用主线程的方法!一定会崩!
相当于通知，线程启动
7 应用层:
6 表现层:
5 会话层:
4 传输层:
3 网络层:
2 数据链路层: STP,VT 1 物理层:

{
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1));
}
答: 2,5
*(a+1 )就是 a[1] ， *(ptr-1) 就是 a[4],
(我是这么理解的 ,) 。
2， 5
原因如下:
&a 是数组指针，其类型为 int (*)[5];
而指针加 1 要根据指针类型加上一定的值，不同类型的指针 a 是长度为 5 的 int 数组指针，所以要加 5*sizeof(int) 所以 ptr 实际是 a[5]
但是 prt 与(&a+1) 类型是不一样的 ( 这点很重要 )
所以 prt-1 只会减去 sizeof(int*)
执行结果是
&a+1不是首地址 +1，系统会认为加一个 a 数组的偏移，是偏移了一个数组的大小(本例是 5 个 int )
int *ptr=(int *)(&a+1);
则 ptr 实际是 &(a[5]), 也就是 a+5
a,&a 的地址是一样的，但意思不一样
a 是数组首地址，也就是 a[0] 的地址， &a 是对象(数组)首地址，
a+1 是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].
+1 之后增加的大小不同。

类别的作用?继承和类别在实现中有何区别?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法， 只能添加，不能删除修改。?并 且如果类别和原来类中的方法产生名称冲突，则 类别将覆盖原来的方法，因为类别具有更高的优先级。? 类别主要有 3 个作 用:?(1) 将类的实现分散到多个不同文件或多个不同框架中。? (2) 创建对私有方法 的前向引用。?(3) 向对象添加非正式协议。? 继承可以增加，修改或者删除方法， 并且可以增加属性。

3.Difference between categories and extensions?类别和类 扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。另外后者添加 的方法是必须要实现的。?extensions 可以认为是一个私有的 Category 。
4.Difference between protocol in objective c and interfaces in java? obc 中的协议和 java 中的接口概念有何不同?
答案: OBC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前 者和 Java 接口一样。?informal protocol 中的方法属于设计模式考虑范畴，不是 必须实现的，但是如果有实现，就会改变类的属性。? 其 实关于正式协议，类别 和非正式协议我很早前学习的时候大致看过，也写在了学习教程里? “非正式协议 概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可 以使用他们更好的完成工作”。?这 个意思是，这些是可选的。比如我门要一个更 好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用 这些更好的方法。?这 么看，总觉得类别这玩意儿有点像协议的可选协议。 现"在? 来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说“非 正式协议使用 interface 修饰“，现?在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
5.What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而 不是通过调用存取方法，直接或通过实例变量访问的机制。? 很 多情况下可以简 化程序代码。 apple 文档其实给了一个很好的例子。?kvo:键值观察机制，他提供 了观察某一属性变化的方法，极大的简化了代码。? 具体用看到嗯哼用到过的一 个地方是对于按钮点击变化状态的的监控。? 比如我自定义的一个
button?[cpp] [self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO - (void)observeValueForKeyPath:(NSString

*)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void
*)context { if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay]; } }
对于系统是根据 keypath 去取的到相应的值发生改变，理论上来说是和 kvc 机 制的道理是一样的。?对于 kvc 机制如何通过 key 寻找到 value :?“当通过 KVC 调用对象时，比如: [self valueForKey:@ ”someKey”] 时，程序会自动试图通过 几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法， 如果没找到，会继续查找对象是否带有 someKey 这个实例变量( iVar)，如果 还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如 果这个方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。?(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅 会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ， 或者 _someKey 以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也 会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存
在。)?设 计 valueForUndefinedKey: 方法的主要目的是当你使用 -
(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前，有最后的机 会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“? 来至 cocoa ，这个说法应该挺有道理。?因 为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们只是 add 一个相关的 keypath 就行了，? 可以按照 kvc 查找的逻辑理解，就说的过去了。
6.What is purpose of delegates? 代理的作用?
答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其 他类，而不需要获取到那些类的指针。可以减少框架复杂度。? 另 外一点，代理 可以理解为 java 中的回调监听机制的一种类似。

7.What are mutable and immutable types in Objective C? obc
中可修改和不可以修改类型。
答案:可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和 不可动态添加修改一样。?比如 NSArray 和 NSMutableArray 。前者在初始化后 的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。
8.When we call objective c is runtime language what does it mean? 我们说的 obc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。? 这 个问题 其实浅涉及到两个概念，运行时和多态。? 简单来说，运行时机制使我们直到运 行时才去决定一个对象的类别，以及调用该类别对象指定方法。? 多 态:不同对 象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类( life ) 都用有一个相同的方法 -eat;?那 人类属于生物，猪也属于生物，都继承了 life 后， 实现各自的 eat，但是调用是我们只需调用各自的 eat 方法。?也就是不同的对象 以自己的方式响应了相同的消息(响应了 eat 这个选择器)。?因此也可以说， 运行时机制是多态的基础? ~~~
9.what is difference between NSNotification and protocol? 通 知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。?首先我一开始也不太明白，什 么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的行为模式，我们 大致可以有自己的理解?简 单来说，通知的话，它可以一对多，一条消息可以发 送给多个消息接受者。?代 理按我们的理解，到不是直接说不能一对多，比如我 们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。? 只 是 对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要
处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的?发布会

15.Difference between method and selector? 方法和选择器 有何不同?
答案: selector 是一个方法的名字， method 是一个组合体，包含了名字和实 现.详? 情可以看 apple 文档。
16.Is there any garbage collection mechanism in Objective C.? OBC的垃圾回收机制?
答案: OBC2.0 有 Garbage collection ，但是 iOS 平台不提供。?一般我们了解 的 objective-c 对于内存管理都是手动操作的，但是也有自动释放池。? 但 是差了
大部分资料，貌似不要和 arc 机制搞混就好了。?求更多 ~~ 17.NSOperation queue?
答案:存放 NSOperation 的集合类。?操 作和操作队列，基本可以看成 java 中 的线程和线程池的概念。用于处理 ios 多线程开发的问题。?网上部分资料提到 一点是，虽然是 queue ，但是却并不是带有队列的概念，放入的操作并非是按 照严格的先进现出。?这 边又有个疑点是，对于队列来说，先进先出的概念是
Afunc 添加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，?但 是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概 念离乱上有点违背了多线程处理这个概念。? 但是转念一想其实可以参考银行的

取票和叫号系统。?因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦 然可以感性认为这还是一个队列。? 但 是后来看到一票关于这操作队列话题的文 章，其中有一句提到?“因为两个操作提交的时间间隔很近，线程池中的线程，谁 先启动是不定的。”瞬?间觉得这个 queue 名字有点忽悠人了，还不如 pool~?综合 一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
18.What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。? 也可以理解成延时加载。?我觉 得最好也最简单的一个列子就是 tableView 中图片的加载显示了。?一 个延时载， 避免内存过高，一个异步加载，避免线程堵塞。
19.Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制器中嵌入两个
tableview 控制器?
答案:一个视图控制只提供了一个 View 视图，理论上一个
tableViewController 也不能放吧，?只 能说可以嵌入一个 tableview 视图。当然， 题目本身也有歧义，如果不是我们定性思维认为的 UIViewController ，?而是宏
观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制 多个视图控制器，比如 TabbarController?那样的感觉。
20.Can we use one tableview with two different datasources? How you will achieve this? 一个 tableView 是否可以关联两 个不同的数据源?你会怎么处理?
答案:首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代 理方法里实现的。?因 此我们并不关心如何去关联他，他怎么关联上，方法只是
让我返回根据自己的需要去设置如相关的数据源。? 因此，我觉得可以设置多个

34.Cocoa 中有虚基类的概念么?怎么简洁的实现?
35. 自动释放池跟 GC(垃圾回收)有什么区别? iPhone 上有 GC么?[ pool release] 和[ pool drain]有什么区别?
iPhone 上没有 GC。iPhone 开发的时候没有垃圾回收机制。
在垃圾回收环境中， release 是一个空操作。因此， NSAutoreleasePool 提供了 drain 方法，在引用计数环境中，该方法的作用等同于调用 release ，但在垃圾 回收环境中，它会触发垃圾回收(如果自上次垃圾回收以来分配的内存大于当

前的阈值)。因此，在通常情况下，您应该使用 动释放池。
36.
for(int index = 0; index < 20; index ++){ NSString *tempStr = @ ”tempStr ”;
drain 而不是 release 来销毁自
NSLog(tempStr);
NSNumber *tempNumber = [NSNumber numberWithInt:2]; NSLog(tempNumber);
}
这段代码有什么问题 . ?会不会造成内存泄露(多线程)?在内存紧张的设备上
做大循环时自动释放池是写在循环内好还是循环外好?为什么?

37. 内存管理的几条原则时什么?按照默认法则 .那些关键字 生成的对象需要手动释放?在和 property 结合的时候怎样
有效的避免内存泄露?
38. 在一个对象释放前 .如果他被加到了 notificationCenter 中 .
不在 notificationcenter 中 remove 这个对象可能会出现什么 问题?
39.怎样实现一个 singleton的类 .给出思路。 40.什么是序列化或者Acrchiving可,以用来做什么,怎样与
copy结合,原理是什么 ?.
41. 线程与进程的区别和联系 ?
答案: 进程和线程都是由操作系统所体会的程序运行的基本 单元，系统利用该 基本单元实现系统对应用的并发性。 程和线程的主要差别在于它们是不同的操作系统资源 管理方式。进程有独立的 地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程 只是一个进程中的不同执行路径。线程有自己的堆栈和局部变 量，但线程之间 没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序 要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一 些。但 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能 用进程。

42.在 iphone上有两件事情要做 ,请问是在一个线程里按顺 序做效率高还是两个线程里做效率高?为什么?
44.ios 平台怎么做数据的持久化 ?coredata和 sqlite 有无必
然联系? coredata是一个关系型数据库吗?
iOS 中可以有四种持久化数据的方式: 属性列表、对象归档、 SQLite3 和 Core Data ;core data 可以使你以图形界面的方式快速的定义 app 的数据模型，同 时在你的代码中容易获取到它。 core data 提供了基础结构去处理常用的功能， 例如保存，恢复，撤销和重做，允许你在 app 中继续创建新的任务。在使用
core data 的时候，你不用安装额外的数据库系统，因为 core data 使用内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组定义在内存中的数据对 象。 core data 会追踪这些对象的改变，同时可以根据需要做相反的改变，例如 用户执行撤销命令。当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些数据归档，并永久性保存。
mac os x 中 sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌 入到应用程序。可以在多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库 编程。与 core data 框架不同的是， sqlite 是使用程序式的， sql 的主要的 API 来直接操作数据表。
Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。 虽然 Core Dta 支持 SQLite 作为一种存储类型，但它不能使用任意的 SQLite
数据库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支持对 一、对多的关系。

52 如果要开发一个类似 eclipse的软件，支持插件结构。且 开放给第三方开发。你会怎样去设计它?(大概思路)
53.
main() {
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1));
}
答: 2,5
*(a+1) 就是 a[1] ，*(ptr-1) 就是 a[4], 执行结果是 2.5，? &a+1 不是首地址 +1， 系统会认为加一个 a 数组的偏 移，是偏移了一个数组的大小(本例是 5 个
int，int *ptr=(int *)(&a+1);?则 ptr 实际 是&(a[5]), 也就是 a+5?原因如下:
&a 是数组指针，其类型为 int (*)[5];?而指针加 1 要根据指针类型加上一定
的值，不同类型的指针 +1 之后增加的大小不同。 a 是长度为 5 的 int 数组指 针，所以要加 5*sizeof(int) 所以 ptr 实际是 a[5] ，但是 prt 与 (&a+1) 类型是不一
样的 (这点很重要 )，所以 prt-1 只会减去 sizeof(int*) ， a,&a 的地址是一样的，但 意思不一样， a 是数组首地址，也就是 a[0]的地址， &a 是对象(数组)首地 址， a+1 是数组下一元素的地址，即 a[1],&a+1 是下一个对象的地址，即 a[5].

 54. 以下为 Windows NT 下的 32 位 C++程序，请计算 sizeof 的值 void Func ( char str[100] ) { sizeof( str )
= ? } void *p = malloc( 100 ); sizeof ( p ) = ?
答案:这题 很常见了 ,Func ( char str[100] ) 函数中数组名作为函数形参时，在 函数体内，数组名失去了本身的内涵，仅仅只是一个指针;在失去其内涵的同 时，它还失去了其常量特性，可以作自增、自减等 操作，可以被修改。 Windows NT 32 位平台下，指针的长度(占用内存的大小)为 4 字节，故 sizeof( str ) 、sizeof ( p ) 都为 4。
55.
- (void)*getNSString(const NSString * inputString) { inputString = @"This is a main test\n";
return ;}
-main(void)
{NSString *a=@"Main ";
NSString *aString = [NSString stringWithString:@"%@",getNSString(a)]; NSLog(@"%@\n", aString);}
最后问输出的字符串 :NULL,output 在 函数返回后，内存已经被释放。





62. objc的内存管理 如果您通过分配和初始化(比如
)的方式来创建对象，您
[[MyClass alloc] init] 就拥?有这个对象，需要负责该对象的释放。这个规则在使用 NSObject 的便利
方法 new 时也同样适用 . 如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放 .
如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对 象。 如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它 (这个规则有少数?的 例外，在参考文档中有显式的说明)。
63. 自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对 象的一个引 用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的 作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置 时， 自动释放池就会被释放，池中的所有对象也就被释放。
1. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在 开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到有 copy,retain 的时候引 用计数都会加一 , 每当碰到 release 和 autorelease 的时候引用计数就会减一 ,如 果此对象的计数变为了 0, 就会被系统销毁 2.?. NSAutoreleasePool 就是用来做 引用计数的管理工作的 ,这个东西一般不用你管的 3..?autorelease 和 release 没 什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的使用真正 结束的时候才做引用计数 减一 .

 sqlite coredata 的区别
SQLite 比较原始，需要通过 sql 语句来创建表格，对数据 进行操作，用起来比较麻烦，但是可控性强。
Core Data 是 ios3 以后引入的数据库持久化解决方案， 是苹 果官方推荐的，在使用的过程中不需要写 sql 语句，可以很
方便的将数据存储到数据库中。 正因为不需要要写 具体的功能已经被封装好了，因此可控性要弱一些。
ORM (对象关系映射)的封装
侧边栏的实现和控制机制
封装一个类作为根控制器，里面包含中间的 和两侧的侧边栏，可以通过添加手势，实现侧边栏的
滑动。
侧边栏这个功能很常见， 有很多不错的第三方的类库
retain 在 mrc 的使用
表示持有特性， setter 方法将传入参数先保留，再赋值，传 入参数的 retaincount 会 +1;
sql 语句， 类似
view ，

 kvo 的实现
kvo 键 -值观察机制 Key-Value Observing : 当制定的对象的属性被修改后，对象就会接到通知。每次指
定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。


网络请求传表单
用 NSURLRequest ，自已拼接 post 体，然后发请求，比较
麻烦。
可以利用第三方的如 afnetworking 完成
[urlRequest setHTTPMethod: @"POST"];
[urlRequest setValue: IPADDRESS forHTTPHeaderField:@"Host"]; [urlRequest setValue: postLength forHTTPHeaderField:@"Content-Length"]; [urlRequest setValue: @"application/x-www-form-urlencoded"
forHTTPHeaderField:@"Content-Type"]; [urlRequest setHTTPBody: postData];

如何和服务器进行交互， 交互怎么向服务器 传一个表单。
还有除了 afnetworking 和 sdwebimage 还 有哪些请求方式。
比较原始的 NSURLRequest ， nsurlconection 其他著名第三方， ASihttprequest, MKNetworkKit

观察者模式
观察者模式完美的将观察者和被观察者分离开。 观察者模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态
发生变化时，所有依赖它的对象都得到通知并自动刷新。 在IOS 开发中经典观察者模式的实现方式有:
NSNotificationCenter 、KVO 等 优势: 解耦合
解耦合: 把原来引用很紧密的对象通过中间一层的分离， 敏捷原则: 开放 —封闭原则
不直接引用
通知 NSNotificationCenter :
一般为 model 层对 controller 和 view 进行的通知方式，不关心
谁去接收，只负责发布信息。
通知可以是一对一，也可以是一对多。 实例: Notification 通 知中心，注册通知中心，任何位置可以发送消息，注册观察 者的对象可以接收。
kvo 键 -值观察机制 Key-Value Observing :

 当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。


代理模式 代理的目的是改变或传递控制链。
允许一个类在某些特定时刻通知到其他类，而不需要获取到 那些类的指针。可以减少框架复杂度。
应用场景: 当一个类的某些功能需要由别的类实现，但是又 不确定由哪个类实现，可以使用代理实现。
实例: tableview 、 Scrollview 等中的 delegete ⋯ ********************************************
java 和 oc 的优缺点
Java 优点:简单、面向对象、分布式、解释执行、鲁棒、安
全、体系结构中立、可移植、高性能、多线程以及动态性。

 主要缺点:运行速度慢， 机，所以相对于其他语言 它不是直接，执行机器码。
objc 优点:
1) Cateogies
2) 动态识别
3) 指标计算
4 弹性讯息传递
5) 不是一个过度复杂的 6) Objective-C 与
Java 程序的运行依赖于 Java 虚拟 (汇编 ,C,C++) 编写的程序慢，因为
C++
可混合编程
缺点:
1)不支援命名空间，因此类前面加了 NS 前缀 2) 不支持运算符重载
3 不支持多重继承
4)使用动态运行时类型，所有的方法都是函数调用，所 以很多编译时优化方法都用不到。(如内联函数等)，性能
低劣。


 解释一下多态
多态:用父类指针指向子类的对象。 通过不同的对象调用相
同的名称的方法，却产生不同的结果。
通过父类指针得到的几个对象， 都调用了父类中某个方法， 但实际上 在运行的时候，是执行的自己真实类中的方法。
多态增强了软件的 灵活性 和重用性 。
方法的重载也是多态的一种体现，但是在 OC 中，方法的参 数个数不同，方法名也不同，因此不符合方法重载的定义。
********************************************
后台语言
iOS 网络开发分客户端和服务器，
在客户端可以用 socket ，但不常用，
服务器自然可以用 c、c++ 写 CGI 或者 Asp 、Asp.Net 、Php 、 Java 、 JSP
********************************************
数据存储
在 IOS 中，少量的数据持久化可以使用属性列表、
NSUserDefaults 、归档等;
大量的数据持久化可以使用 SQLite 数据库、 Core Data 等，
也可以使用 FMDB 第三方类库完成。

 ********************************************
子线程调用
(1)Object 隐式方法: 轻量级的方式
[self performSelectorInBackground:@selector(run:) withObject:@"nsobject thread"];
(2)NSThread :轻量级的方式 (具有很少的规则和惯例， 依赖的东西少)，比较底层和原始。 需要自己手动管理线程的生命周期，同步的时候需要加锁来 控制线程执行顺序，会增加系统开销。不推荐使用。
( 3 )NSOperationQueue :一个 NSoperation 对象可以通过 调用 start 方法执行任务，默认是同步执行;也可以将
NSOperation 添加到一个 NSOperationQueue 中执行，这时 是异步的。
通过这个方式开启线程后，可以中途停止、继续、取消等操 作。
如果想控制线程执行顺序，可以通过添加依赖完成。 优点:不需要关心线程管理，数据同步的事情，可以把精力 放在自己需要执行的操作上。 对于上传、下载这种复杂的操作，推荐使用。

 (4)GCD :苹果提供的，异步执行。提高了代码执行效率 和多核的利用率，性能更好。对于复杂的不推荐使用，但是 简单的提交数据推荐使用。
******************************************** nsstring 拼接字符串，内部实现机制
Objective C 中有很多不定参函数， 例如 NSLog(format, arg1, arg2) ， 还 有 字 符 串 或 数 组 在 构 造 时 所 用 的 [NSString
stringWithFormat: format, arg1, arg2, arg3] ，它们的方法原 型分别是:
FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);
http://jingyan.baidu.com/article/f0062228c4679efbd3f0c82 7.html
******************************************** 网络请求 afnetworking
1. 首 先 需 要 实 例 化 一 个 请 求 管 理 器 对 象 AFHTTPRequestOperationManager
2. 设置请求和返回数据格式(是二进制? json ? plist ?)

 3. 如果登陆传参，设置传递的参数，字典(键名为参数名， 键值为参数值)
4. 发get 或 post 请求，去网络取数据。返回的数据成功和失败 分别是在两个块中进行处理。
********************************************
不用块怎么做 用协议代理实现
******************************************** 工厂模式怎么做 ,画图
工厂模式是我们最常用的实例化对象模式了 ， 是用工厂方 法代替 new 操作的一种模式 。

 ******************************************** 宏定义 URL
#define BASERUL @”” ********************************************
用过哪些第三方
在开发的过程中，用过很多第三方类库， AFNetWorking 、 SDWebImage 、MBProgressHUD 、FMDB 、MKNetworkKit 、 EGOTableViewPullRefresh 、ShareSDK 等。注意:提到的 可能面试官都会问到。
大多是从 Github 、 CocoaChina 地方等下载。
第三方类库主要是用它的功能，对于比较优秀的代码自己也 读了一下，写的非常棒，比如。。。(这个时候可以详细介 绍一个你最熟悉的第三方类库)
******************************************** 用没用过 ASIhttprequest
ASIHTTPRequest 是一款极其强劲的 HTTP 访问开源 项目。
********************************************

分享是用什么做的
<一> 分享功能可以选择使用第三方的 ShareSDK。
ShareSDK 是一种社会化的分享组件，支持 ios、
android 、wp8 等，提供了常用的类库和接口， 可以缩
短开发时间，并且还有统计分析的管理后台。
ShareSDK 提供了主流的社交平台分享，比如微博、
QQ、人人、微信、豆瓣等，可以直接进行信息的分享， 也可以使用这些第三方的平台进行登录。
ShareSDK有自己的官方网站， 里面有详细的文档可以 使用，非常的好
优缺点: ShareSDK比较重， 里面的东西比较多， 在使 用的时候需要精简或者优化。
<二>友盟
与 ShareSDK 类似，可以做登陆、分享、短信注册、
统计数据等其他功能，使用的时候从它的官网下载 SDK 即可
优缺点: 比 ShareSDK 轻一些，但仍需在使用的时候 进行优化。好处就是实现功能比较简单。
<三 >注册各个平台账号 优缺点:单个注册就是比较麻烦， 但是套路是一样的，
现在的社交平台网站都做得比较好，有专门的说明文
档，所以也比较好

********************************************
视频和音频的上传和下载怎么实现 可以用第三方的 afnetworking 实现
上传:
找到要上传资料的 url –> 获取服务器上的 php 文件
url 创建请求 –> 创建管理者 –> 设置数据类型 发送请求
下载:
获取要下载的资源的 url 创建下载请求
******************************************** kvo 和 kvc 是什么，什么时候用到过
kvo 键 -值观察机制 Key-Value Observing :
当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。

 ********************************************
频道和下边显示的新闻切换是如何实现的 每个频道是一个按钮， 然后把频道放到小的 scrollview
上面;
每个频道的新闻的详情都可以用 tableview 展示，把
多个 tableview 放到大的 scrollview 上; 点击上面的频道按钮是，可以调整下面 scroolview 的
contentoffset ，展示对应的新闻列表;同样，当切换 下面展示的新闻列表是，上面选中的频道按钮改变;
完成方式最好采用自定义 ContainerController
********************************************
做没做过注册，怎么做注册 注册有很多方式，常用的方式有电话注册、 邮箱注册。
发短信注册可以使用第三方的， 比如友盟、 shareSDK， 去下载对应的 SDK 实现
注册的界面: 注册需要有输入框，并且输入的电话或 者邮箱要进行客户端的验证，符合格式才发送到服务 器。进行 格式验证 有多种方式，比较简单灵活的方式 是选择正则表达式验证。
注册通常还需要一个 验证码 ，验证码可以通过手机发 送，如果是图形的验证码，可以通过第三方生成。

******************************************** 用没用过 sqlite ，怎么用
创建数据库 引入类库 获得沙盒路径 创 建或打开数据库 判断是否打开成功，如果成功， 可以进行增、删、改、查操作 关闭数据库
********************************************
什么是索引
索引是对数据库表中一列或者多列的值进行排序的 一种结构。通过索引，可以快速的访问数据表中的特
定信息。
********************************************
数据库里的主键是什么 数据库中存储的是多张表，每张表中有多行数据，能
够唯一标示表中每一行的数据项就是主键。 另外主键可以是一个或者多个联合主键

快速排序的时间复杂度是多少 平均 时间复杂度
插入排序 O(n^2 ) 冒泡排序 O(n^2 ) 选择排序 O(n^2 ) 快速排序 O(n log n) 堆排序 O(n log n) 归并排序 O(n log n) 基数排序 O(n) 希尔排序 O(n^1.25 )
********************************************
做没做过缓存，怎么做缓存
第一种: 将服务器第一次返回的数据保存在沙盒里
面。这样在手机断网的情况下可以从本地读取数据了。 取数据时先去沙盒取，要是没有再联网获取。
第二种:使用 ASIHTTPRequest 和 ASIDownloadCache 实现本地缓存

 1、可以将数据缓存到本地磁盘。 2、可以判断一个资源是否已经被缓存。如果已经被缓存，在请求相同的资源，先到本地磁
盘搜索。
3、可以判断文件缓存什么时候过期。 这里为了简单起见这里， 我们在请求 url 资源的时候， 给每次请求的文件设定一个过期的时间。
4、可以实现:如果文件已经被缓存，而且没有过期，这将本地的数据返回，否则重新请求 url 。
5、可以实现:如果文件下载不成功或者下载没有完成，下次打开程序的时候，移除这些没 有成功或者没有下载完成的文件。
6、可以实现:同时请求或者下载多个资源。

多线程都有哪些实现， GCD 要注意些什么
(1)NSThread :轻量级的方式 (具有很少的规则和惯例， 依赖的东西少)，比较底层和原始。
需要自己手动管理线程的生命周期，同步的时候需要加锁来 控制线程执行顺序，会增加系统开销。不推荐使用。 (2)NSOperationQueue :一个 NSoperation 对象可以通过 调用 start 方法执行任务，默认是同步执行;也可以将 NSOperation 添加到一个 NSOperationQueue 中执行，这时 是异步的。 通过这个方式开启线程后，可以中途停止、继续、取消等操
作。 如果想控制线程执行顺序，可以通过添加依赖完成。

优点:不需要关心线程管理，数据同步的事情，可以把精力 放在自己需要执行的操作上。 对于上传、下载这种复杂的操作，推荐使用。
(3)GCD :苹果提供的，异步执行。提高了代码执行效率 和多核的利用率，性能更好。对于复杂的不推荐使用，但是 简单的提交数据推荐使用。

如何在子线程中更新界面， 如何让线程延迟 执行?
多线程编程有一个原则，就是一切和 UI 有关的操作都必须放 到主线程做，子线程只负责事务，数据方面的处理。
主界面先加载默认的界面，然后开启子线程去加载数据，加
载得到数据之后，通知主线程，在主线程进行界面的更新。 子线程是不能直接调用主线程类的更新界面的方法，可以在
子线程中通过 performSelectorOnMainThread :方法做。 [self performSelectorOnMainThread:@selector(updateUI)withObject:updateData
waitUntilDone:YES];


多个 iphone 版本适配?
最简单有效的方式是通过 autolayout+sizeclass 来进行适配 的，但是这种方式的缺点需要添加的约束比较多，对于手写
的代码非常麻烦。一般手写代码进行布局的时候，会选择第 三方类库来做，比如 FLKAutoLayout ，可以用简单的一句代 码完成对一个控件添加的全部约束，非常实用。
********************************************
三种线程优缺点?
(1)NSThread :轻量级的方式(具有很少的规则和惯例， 依赖的东西少)，比较底层和原始。 需要自己手动管理线程的生命周期，同步的时候需要加锁来 控制线程执行顺序，会增加系统开销。不推荐使用。

(2)NSOperationQueue :一个 NSoperation 对象可以通过 调用 start 方法执行任务，默认是同步执行;也可以将
NSOperation 添加到一个 NSOperationQueue 中执行，这时 是异步的。
通过这个方式开启线程后，可以中途停止、继续、取消等操 作。
如果想控制线程执行顺序，可以通过添加依赖完成。 优点:不需要关心线程管理，数据同步的事情，可以把精力 放在自己需要执行的操作上。 对于上传、下载这种复杂的操作，推荐使用。
(3)GCD :苹果提供的，异步执行。提高了代码执行效率 和多核的利用率，性能更好。对于复杂的不推荐使用，但是 简单的提交数据推荐使用。
AFN 传值方式?
AFNetworking 用于网络数据传输以及网络中多线程的处 理。
AFN 中我们常用的功能有发 GET/POST 请求， json 、plist 数据的解析，上传和下载等 ⋯
如何使用 AFN ?

1. 首 先 需 要 实 例 化 一 个 请 求 管 理 器 对 象 AFHTTPRequestOperationManager
2. 设置请求和返回数据格式(是二进制? json ? plist ?) 3. 如果登陆传参，设置传递的参数，字典(键名为参数名，
键值为参数值)
4. 发get 或 post 请求，去网络取数据。返回的数据成功和失败 分别是在两个块中进行处理。
AFN 特性
1. 登陆传参时，传递字典即可(键名为参数名，键值为参数
值)
2. 自动到子线程中执行，执行完返回到主线程 返回的结果自动序列化为 NSDictionary
让你做一个类似 QQ 音乐的东西，怎么做?
< 一 > QQ 音乐最核心的功能就是 歌曲的播放 。
播放音频， 首先想到可以用 AVFoundation 框架， 来完成播放 音乐的主要功能。但是 AVFoundation 只能播放本地的音乐， 不能在线播放。虽然可以先从网络下载资源到本地在播放， 但是必须要整首歌都下载完成后才能播放，这样效果并不好。

如果想在线播放， 可以选择 AudioToolbox 框架中的音频队列 服务 Audio Queue Services 。音频队列服务可以完成音频的 录制和播放。
一个音频服务队列 Audio Queue 有三部分组成: 三个缓冲器 Buffers: 每个缓冲器都是一个存储音频数据的临时仓库。
一个缓冲队列 Buffer Queue: 一个包含音频缓冲器的有序队列。 一个回调 Callback: 一个自定义的队列回调函数。
音频播放的流程:
将音频读取到缓冲器中， 一旦一个缓冲器填充满之后就放到缓冲队列 中，然后继续填充其他缓冲器;当开始播放时，则从第一个缓冲器中 读取音频进行播放; 一旦播放完之后就会触发回调函数， 开始播放下 一个缓冲器中的音频， 同时填充第一个缓冲器放; 填充满之后再次放 回到缓冲队列。
流媒体
好的音乐播放器要保证播放的流畅性，一定是边加载边播放， 如果做得再好一些，可以用流媒体来做。
详细内容后续给大家补充 ⋯

< 二 > 获取歌单，显示在界面
这部分主要通过 AFN 来从网络获取歌曲信息，然后展示在界 面上。对于界面展示这部分比较熟悉，做起来难度不大。 自 己补充分析一下 ⋯
< 三 > 歌曲下载到本地存储
歌曲离线下载管理这部分，也很重要。歌曲名称、作者等相 关信息可以存储到数据库中，歌曲的源文件以及歌词文件， 下载之后存到沙盒中指定的文件夹中。
<四>其他 其他的设置等功能和其他软件大同小异。
可以比照 QQ 播放器，挑自己熟悉的地方详细的解释说明一 下，是如何实现的。

自动释放池
自动释放池( Autorelease pool )是 OC 的一种内存自动回 收机制，可以将一些临时变量通过自动释放池来回收统一释 放。自动释放池本事销毁的时候，池子里面所有的对象都会 做一次 release 操作
******************************************** json 序列化反序列化
序列化就是将数据转成 NSData，然后进行传输。 反序列化就是把得到的数据， 转为字典或数组，使用。 可以使用 NSJSONSerialzation完成
********************************************
链表数组
oc 中只有数组的概念，没有链表。但是在 C 语言中， 有链表。

 链表是一种物理 存储单元 上非连续 、非顺序的 存储结构 ，数据元素 的逻辑顺序是通过链表中 的指针 链接次序实现的 。链表由一系列结点 ( 链表中每一个元素称为结点 )组成 ，结点可以 在运行时动态生成 。每个结点包括两个部分 : 一个是存储 数据元素 的数据域 ， 另一个是存储 下一个结点地址的 指针 域 。
链表和数组都是线性结构， 但是二者却有很大的区别:
数组静态分配内存，链表动态分配内存;
数组在内存中连续，链表不连续;
数组元素在栈区，链表元素在堆区;
数组利用下标定位，时间复杂度为 O(1) ，链表定位元素时间复杂度 O(n) ; 数组插入或删除元素的时间复杂度 O(n) ，链表的时间复杂度 O(1) 。 数组可以随机读取，链表允许插入和移除表上任意位置的节点，但是不允许随机存取。 链表由于增加了节点的指针域，因此空间开销比较大。

单例
单例设计模式是 IOS 开发中一种很重要很常用的一种设计模 式。
确保程序运行期某个类，只有一份实例，用于进行资源共享 控制。也就是，无论请求多少次，始终返回一个实例，也就 是一个类只有一个实例。 优势: 使用简单，延时求值，易于 跨模块 敏捷原则: 单一职责原则(单一功能原则) 实例: NSUserDefaults
[UIApplication sharedApplication] 等注意事项: 确保使用 者只能通过 getInstance 方法才能获得， 单例类的唯一实例。
单例代码:
单例的创建分 Non-ARC( 非 ARC) 和 ARC+GCD ，后者现在用 的比较广泛，它保证了线程的安全，满足了静态分析器的要 求，还兼容了 ARC ，代码如下:
+( AccountManager *)sharedManager {
static AccountManager *sharedAccountManagerInstance = nil;
static dispatch_once_t predicate; dispatch_once (&predicate, ^{
sharedAccountManagerInstance = [[ self alloc] init]; });
return sharedAccountManagerInstance;

 }
代码分析: 通过这个类方法，可以得到当前类的单例对象。
在方法中先声明了一个实例，并初始化为 nil，前面的 static 关键字可以保证只执行一次为 nil的操作。 dispatch_once_t 是多线程中的， 保证只执行一次。 dispatch_once 这个函数用 于检查该代码块是否已经被调用过，通过它不仅可以保证块 里面初始化的代码仅被运行一次，还能保证线程的安全。
另外，单例最好用宏定义实现，通过条件编译兼容
ARC

1. 几个重点技术: 即时通讯，支付(支付宝，微信)，runtime ，runloop ，
二维码(使用系统接口实现)， socket ，音频视频

什么时候会报 unrecognized selector 的异常?
一个 objc 对象如何进行内存布局?(考虑有父类的情况)

runtime通过selector找到对应的IMP地址?(分别考 虑类方法和实例方法)
使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么?中o的bjc类方法和实例方法有什么本质区别和联系?
objc_msgForward 函数是做什么的， 直接调用它将会发 生什么?
runtime如何实现 weak 变量的自动置 nil ?
能否向编译后得到的类中增加实例变量?能否向运行时 创建的类中添加实例变量?为什么?
通AR过C什么方式帮助开发者管理内存?
手动指定 autoreleasepool 的前提下，一个 autorealese 对象在什么时刻释放?(比如在一个 vc的viewDidLoad 中创建)
BACDC_EASS在什么情况下出现?
果是如何实现 autoreleasepool 的?

第三方登录分享
1. 注册并登陆第三方开放平台，向第三方平台注册 APP ，添加 APP 名称、图标、基本描述 等信息，等待审核通过;
2.APP 在第三方审核通过后，会获得一个 app id 和一个 app key (不同的平台可能名字不 一样，但都类似于 APP 账号和密码的意思)，这个 id 和 key 在 APP 代码里会用到，主要 用于提供给第三方获取认证信息用;
3. 将第三方 SDK 集成进我们的代码里，根据文档说明， Xcode 中设置相应的配置信息(如 跳转第三方的 URL 、一些第三方需要的特定编译选项等)，开发调试;
Socket :通常也称作 "套接字 "，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来 实现不同虚拟机或不同计算机之间的通信。任何用户在通话之前，首先要占有一部电话机，
相当于申请一个 Socket ;同时要知道对方的号码，相当于对方有一个固定的 Socket 。然后 向对方拨号呼叫，相当于发出连接请求(假如对方不在同一区内，还要拨对方区号，相当于 给出网络地址) 。假如对方在场并空闲(相当于通信的另一主机开机且可以接受连接请求) ， 拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机 发出信号和对方从电话机接收信号的过程， 相当于向 Socket 发送数据和从 socket 接收数据。 通话结束后， 一方挂起电话机相当于关闭 Socket ，撤消连接。 Socket 的通信过程是透明的， 用户不需要了解具体的细节。
TCP/UDP :传输层协议; TCP 是面向连接的可靠传输; UDP 的传输不是面向连接的，不可 靠;TCP 应用于大量数据传输时， 慢;UDP 应用于少量数据时， 快。TCP ，浏览网页， UDP ，
聊天消息的发送。TCP 是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一
个 TCP 连接必须要经过三次“对话”才能建立起来，简单过程:主机 A 向主机 B 发出连接 请求数据包:“我想给你发数据，可以吗?”，这是第一次对话;主机 B 向主机 A 发送同 意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收， 协调工作) 的数据包: “可 以，你什么时候发?”，这是第二次对话;主机 A 再发出一个数据包确认主机 B 的要求同 步:“我现在就发，你接着吧!”，这是第三次对话。三次“对话”的目的是使数据包的发 送和接收同步，经过三次“对话”之后，主机 A 才向主机 B 正式发送数据。
UDP ，是面向非连接的。“面向非连接”就是在正式通信前不必与对方先建立连接，不管 对方状态就直接发送。 与手机短信非常相似: 你在发短信的时候， 只需要输入对方手机号就 OK 了。
APP 审核被拒 :
提交 app 与描述不符
提交的描述中含有与 IOS 平台不相关的关键字，如 android windows phone 等 在版本信息中加入 Bate 字样，因为 apple 不希望你提交的软件还是不稳定 页面布局混乱
需要登录才能使用相关功能，未提交测试账号
存在明显的 bug
性能测试
Product->Profile
视频
音频
音乐播放:
AVAudioPlayer ，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。 AVAudioPlayer 的使用比较简单:
初始化 AVAudioPlayer 对象，此时通常指定本地文件路径。 设置播放器属性，例如重复次数、音量大小等。
调用 play 方法播放。

1.NSNotification是同步还是异步？作用是什么？
2.sizeof()的作用？

探秘百度移动面试 iOS试题分享
百度移动云可穿戴部门的面试经历，面试官都非常热情友好，一上来到弄的我挺不好意思的。下面记录一下自己的面试过程，因为我真的没啥面试经验，需要总结下。
AD：
百度移动云可穿戴部门的面试经历，面试官都非常热情友好，一上来到弄的我挺不好意思的。下面记录一下自己的面试过程，因为我真的没啥面试经验，需要总结下。

1面
 Objective C runtime library：Objective C的对象模型，block的底层实现结构，消息发送，消息转发，这些都需要背后C一层的描述，内存管理。
 Core Data：中多线程中处理大量数据同步时的操作。
 Multithreading：什么时候处理多线程，几种方式，优缺点。
 Delegate， Notification，KVO， other 优缺点
runtime有一点追问，category，method 的实现机制，class的载入过程。 1面整体感觉不错，40分钟不到，感觉回答的还可以。被通知一会儿二面。
2面
二面的时间非常长，差不多将近3个小时，直接面到快下班了。1面问的主要是知识点。2面问主要考察的是设计解决方案的能力，另外辅助追问的方式，考 察深度和广度，回答过程中需要列出适合的具体例子，方案还需要细致到具体的关键的函数名称，方法。另外考察设计模式的理解，最后还考了算法。因为时间太长，这里记录一些重要的问题。
 设计一个progress bar解决方案，追问到 Core Graphic、CGPath、maskLayer。
 设计一个popup view被追问到 keyWindow、UIWindow的layer、UIView hierarchy。
 从设计模式的角度分析Delegate、Notification、KVO的区别。被追问到自己写的library和开源的项目中用到哪些设计模式，高山茶 eupai.net为什么使用，有哪些好处和坏处，现在能否改进。
 算是问题3的追问，设计一个方案来检测KVO的同步异步问题。willChange和 didChange的不同点，然后被追问到有没有其他地方也有类似情况，被追问到Core Data 中falut object。
 这个是问题4的追问，设计一个KVO系统。
 Multithreading，什么时候采用Multithreading方案，以及理由。追问到系统还有哪些在后台运行的thread，被追问到view life cycle、iOS6之后的不同以及内存管理。
 Multithreading中常常遇到的问题，追问到死锁，优先级翻转，线程池等。
 百度有一个亿级别的APP需要统计用水草玛瑙 mnwg.net户行为的日志系统。不使用数据库，只是使用普通文件，设计一个系统。被追问到内存映射文件。这个问题本来是服务器的问题，我表示从来没做过，回答很瞎。
算法考了2个。一个是如何求2个集合的交集。另一个是百亿数据中查找相同的数字以及出现的次数。
最后还补充了几个小问题
 自己对可穿戴设备的感受
 自己如果进入这个team，自己准备做那方面的事情
 为什么创业，自己未来规划
一会被告知3面，但是因为太晚，约到次日下午3面。
3面
3面的时间和1面差不多40分钟，问了几个问题，主要是考察精神层面的东西。
 为什么做Windows Mobile
 为什么改iOS
 为什么来百度
 为什么iPhone 可以成功，那些吸引你
 如何看待AppStore 现在的生态圈
后面就是他说的多一些，介绍团队遇到的困难以及14年团队的打算。最后他给了我2句话的评价，我觉得还是蛮对的。
 选择的时候都是经过深思熟虑的
 有野心，wanna make a difference
有意思的是，他说他也wanna make a difference。
总结
整体还是挺尴尬的，几乎所有的知识点都是1，2年前积累的，13年积累的东西基本上没有，都是一些虚的东西。 2面挺好的，暴露了自己不少问题，设计模式那部分几乎没有概念了。
最后
面试通过，我个人觉得2面我的问题在思考设计模式上面少，另外在window hierarchy 上面有不足。设计 KVO 上面在 didChange上面考虑不足。这些都是被当场戳穿的。 有一点疑虑的是整个面试中并没有问到Core Animation。这个还是我蛮喜欢的部分。Anyway 个人很喜欢追问的方式，很容易考察出来理解的深度和广度。
整个面试收获很大，发现了很多不足。另外1，2面的面试题目个人觉得也不错。这里分享给大家。





/******************************iOS基本认识和基础知识******************************/
#iOS简介：
概念：iOS由苹果公司开发的操作系统；
操作系统：直接运行在硬件上的系统软件，其他软件都是运行在操作系统上；
iOS开发：手机软件开发
主流手机操作系统：iOS、Android、Black Berry OS、WP、Symbian
//iOS和Android区别？
iOS：基于UNIX、不开源、AppStore
Android：基于Linux的虚拟机、开源、GooglePlay

#mac系统的介绍：
finder文件管理器：windows里的计算机
Dock工具栏：应用程序图标
Safari浏览器：windows里的IE
系统偏好设置：windows的控制面板
App store：苹果商店

#常用快捷键：
command（windows键）+空格：切换输入法
command+s：存储
command+c/v/x：复制、粘贴、剪切
command+a：全选
command+z：撤销
command+shift+z：恢复撤销
command+f：查找、替换
command+n：新建
command+tab：切换应用程序
command+shift+3/4：截图
command+option+左/右：折叠/展开代码
command+\：添加断点
command+press：查看方法名
option+press：查看文档

#常用终端命令：
ls     //查询当前目录下的子目录活文件
pwd    //查看当前路径：./Users/changmeng/...
mkdir+文件夹名  //在当前目录下新建文件夹
open+文件名 //打开一个文件
touch+xxx.txt  //在当前文件夹下新建文件
cat+文件名 //查看文件
cd+目录名 //切换到当前目录
cd ..   //返回上一级目录
cd /    //切换到根目录
clear  //清除终端
ctrl+l //清屏

#vi编译器：用来编写c程序
vi test.c //新建一个.c文件
i  //切换命令模式到编辑模式
//编写一段c语言代码
#include <stdio.h>
int main() {
    prinf("hello world!\n");//\n可以用在iOS中，写在"""内部、表示换行
}
esc   //退出编辑模式
:wq   //保存代码
gcc test.c -o t  //将c源文件通过gcc编译器编译成可以运行的程序
./t   //生成可执行文件

#进制转换：
1).十进制：用0—9来表示所有的自然数-D
2).二进制：用0—1来表示所有的自然数-B
//为什么要引入二进制？？？
因为计算机是以二进制形式进行数据存储的;
二进制->十进制：
1101(2)=1*2^0+0*2^1+1*2^2+1*2^3=13;
十进制->二进制：除2取余法（倒除法）：底下是高位，上面是低位
45=101101(2);
八进制：用0—7来表示所有的自然数-O
十六进制：用0—9，A—F来表示所有的自然数-H
123(10)=173(8)=7B(16);
//引入八进制和十六进制的原因：
可以更好的表示二进制；
八进制->二进制：3位1取(将每一位八进制数用3位二进数表示，高位0可以省略）;
173(8)=001 111 011(2)
十六进制->二进制：4位1取：将每一位十六进制数用四位二进制数表示（高位的0可以省略）;
二进制->八进制：3位1取(从低位开始,将每三位二进制数用一位八进制数来表示,如果高位不足三位,在高位补0)
001 101 011(2)=153(8)
二进制->十六机制：四位一取(从低位开始,将每四位二进制数用一位十六进制数表示,如果高位不足,在高位补0)
0110 1011(2)=6b(16)

#原码反码补码：
真值：一个数的十进制表示形式；
机器数：一个数的二进制的表示形式；
计算机内存是由大量开关组成，分别用0和1表示每一位开关，每一位成为1bit，每8位成为1字节（byte）；
内存中以字节为单位：1byte=8bit 1kb=1024byte 1Mb=1024kb 1Gb=1024Mb 1Tb=1024Gb
注意：计算机分配内存的最小单位是字节
1).原码：将一个数的真值的绝对值转为二进制，存储的八位内存空间，最高位存储符号位，1表示负数，0表示正数，其余7位用来存储真值的绝对值的二进制表示形式；
结论：计算机不以原码的方式进行数据存储，原码会出现计算错误
2).反码：正数的反码是原码，负数的反码是原码符号位不变，其余位数按位取反（0变1，1变0）反码的反码是原码；
结论：计算机不以反码的方式进行数据存储，反码解决不了0的问题
3).补码：正数的补码是原码，负数的补码是反码加1，补码的补码是原码；
结论：计算机是以补码的形式进行存储的
        原码         反码        补码
 1   0000 0001   0000 0001   0000 0001
-1   1000 0001   1111 1110   1111 1111

#注释：不会参与编译
//单行注释：可以嵌套在多行注释
/*
多行注释：不可嵌套
*/
/**
 * 文档注释
 * @brief
 * @return
 */
/******************************C语言基础******************************/
#变量：先定义、再使用
定义：可以改变的量；
格式：int a; //定义一个变量：申请一块存储空间
变量的赋值：int a = 3;//变量的初始化：在定义时直接赋值
注意：未初始化的变量的值是随机的，实质是垃圾数据；
命名：标识符-不能以关键字命名；
//输出：
printf("你好");//在""中写入要在终端输出的内容
printf("%d,%d",a,b);//在""里写入要输出的格式,后面跟着变量名
分类：作用域：变量在程序中的使用范围；
生命周期：变量在时间上的有效范围；
1).局部变量：定义在函数内部、代码块和形参列表中的变量；必须init
作用域：存储在栈中，在函数内部有效；
生命周期：从变量定义开始，到函数结束；
存储位置：局部变量存储在栈中，当作用域结束系统会自动释放栈中的局部变量；
2).全局变量：定义在所有函数外部的变量，只能通过对象来访问；不能定义的同时init、默认为0
作用域：存储在静态区，在整个文件内有效；
生命周期：从变量定义开始，到程序结束；
存储位置：全局变量存储在静态区中，随着程序的启动而创建，随着程序的结束而结束；
//extern和static的区别？
extern用来修饰全局变量，表示声明一个全局变量，仅仅是告诉系统我们有这个全局变量，不开辟内存空间；
extern用来修饰函数，表示声明/定义一个外部函数(可以被其他文件访问的函数)；
static用来修饰全局变量，表示定义一个内部全局变量，只能被当前文件访问，开辟内存空间；
static用来修饰局部变量，当执行到定义局部变量的代码就会分配存储空间，但只有程序结束才会释放该存储空间；
static用来修饰函数，表示定义一个内部函数(只能被当前文件访问的函数)；

#数据类型：任何变量都有数据类型
1).整型：默认int
类型     16位系统      32位系统       64位系统
short      2            2             2
int         2            4             4
long       4            4             8
unsigned //只能用来存正数
signed //有符号整数：二进制最高位是符号位
2).浮点型：用来存储小数，默认double
float   单精度   小数点后保留3—6位     4字节
double  双精度  小数点后保留13—16位    8字节
3).字符型：
char c;//定义一个字符型变量
字符型常量的表示形式：单引号只可以有一个字符 例如：'a'正确、'12'错误、'汉'错误
转义字符：'\n'
4).字符串常量："ABC"
ASCII码：字符型常量的整数表示形式，每个字符都对应一个ASCII码值
常用字符的ASCII码:'A'65 'a'97 '0'48
4).格式化输入输出的格式符：
%d      //十进制整型
%o      //八进制整型
%x      //十六进制整型
%f      //浮点型
%lf     //double型
%.mf    //保留小数点后m位
%c      //字符型格式符

#转义字符：
定义：一类特殊的字符，通常以\开头，有实际的意义，但是在终端看不到输出结果
转义字符只出现在printf里面。(斜线是向右)
'\t' tab键的位置
'\r' 回车
'\n' 换行

#运算符的使用：
1).算术运算符：+ - * / %
注意：相同数据类型变量做算术运算，结果类型不变：两个整型变量做除法运算，结果仍然为整数；
自动类型提升：int num = 10.9;//num = 10、int sum = 10 + 9.9; //num = 19
强制转换运算符(不建议使用)：变量 = (数据类型)表达式; //有可能丢失精度
结果：原表达式的值不变，强转之后的结果发生变化；
2).自增运算符：使变量的值+1；
变量++：先使用，后加1；
++变量：先加1，后使用；
3).自减运算符：使变量的值-1；
变量--：先使用，后减1；
--变量：先减1，后使用；
4).复合运算符：
a+=3;<==>a=a+3;
-= *= /= %=
5).关系运算符：
>  大于
<  小于
== 等于
>= 大于等于
<= 小于等于
!= 不等于
值：如果关系表达式为真，那么值为1；否则值为0；
真：非0为真
假：0为假
1.赋值运算符(=)和关系运算符(==)是不一样的；
2.关系运算符主要用于条件语句；
6).逻辑运算符：
逻辑与：&&
格式：表达式1&&表达式2&&...&&表达式n;
值：只要有一个表达式为假，那么&&结果为假；
逻辑或：||
格式：表达式1||表达式2||...||表达式n;
值：只要有一个表达式为真，逻辑或结果为真；
逻辑非：！
格式：!表达式;
7).条件运算符：唯一的一个三目运算符
格式：表达式1?表达式2:表达式3;
值：如果表达式1的值为真，那么返回表达式2的值；如果表达式1的值为假，那么返回表达式3的值；
8).逗号运算符：没有什么意义
格式：表达式1,表达式2,...,表达式n;
值：返回最后一个表达式的值
9).特殊运算符：sizeof(常量/变量/数据类型)：计算常量/变量/数据类型在内存中所占字节
10).位运算& | ^ ~ >> <<：都是针对二进制

#条件语句：C语言中任何数值都有真假性，非真即假
//if语句：可以嵌套
if(表达式) {
    //执行语句
}
if(表达式) {
    //执行语句
} else {
    //执行语句
}
if(表达式1) {
    //执行语句
} else if(表达式3) {
    //执行语句
} else if(表达式3) {
    //执行语句
} else {
    //执行语句
}
if(表达式) //执行语句:只能执行第一句
//switch语句：
switch(表达式) {
    case 常量1:
        break;
    case 常量2:
        break;
    default:
        break;
}

#输入函数&输出函数：指定位宽？
int a;
scanf(“%d”,&a);//从键盘输入整型变量a的值：阻塞式函数
printf(“%d”,a);//从控制台输出变量a的值
注意：\n不能用在scanf里面，只能用在printf里面；
scanf里面不能做文字性的说明；

#循环语句：三种形式
1).while循环：
格式：while（表达式）{
    //循环体
}
执行：当程序执行到while循环时，先判断表达式的值，如果表达式的值为真，
那么执行循环体语句；继续判断表达式的值，如果仍然为真，那么再次执行循环体语句；
直到表达式的值为假，循环结束；
2).do...while循环：
格式：do {
    //循环体
} while(表达式);
执行：当程序执行到do...while循环时，先执行语句，再判断表达式的值，如果表达式
的值为真，那么继续执行语句；判断表达式，直到表达式的值为假，循环终止；
3).for循环：
格式：for(语句1;表达式;语句2) {
    //循环体
}
执行：当程序执行到for循环时，先执行语句1，再判断表达式的值；如果表达式的值为真，那么
执行循环体，执行语句2；再判断表达式的值，如果仍然为真，继续执行循环体，执行语句2；
直到表达式的值为假，循环终止；
注意：break可以用来终止循环、continue结束本次循环，继续下一次循环；
4).goto：已经被淘汰

#死循环：
while (YES) {
    //循环体
}
for(;;) {
    //循环体
}
注意：死循环下面不允许写无法访问的语句；

#数组：
定义：一组有序数据的集合；
特点：每个元素具有相同的数据类型；
1).一维数组：下标从0开始，到n－1结束
格式：int array[5];
int //定义一个长度为5的数组
array //数组名
5  //数组长度
array[0]...array[4] //数组元素
//初始化
int array[5]={1,2,3,4,5};//完全初始化
int array[5]={1,2,3};//部分初始化，剩下元素默认为0
//数组的访问越界
array[5]=4;
2).二维数组：
定义：元素是一维数组的数组称为二维数组；
格式：int array [3][4];//3代表横行X轴,4代表竖行Y轴
//初始化：3行4列
int array[3][4]={
    {1,2,3,4},
    {2,3,4,5},
    {3,4,5,6},
};

#冒泡排序：
原理：将相邻元素两两排序，让较大的数沉底，一共需要(n-1)轮排序；
#include <stdio.h>
int main() {
    int arr[5] = {3,5,8,6,2};
    int temp;
    //外层循环控制轮数
    for(int i=0;i<5;i++) {
        for(int j=0;j<5-i;j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
        for(int k=0;k<5;k++) {
            printf("%d ",arr[k]);
        }
        printf("\n");
    }
    return 0;
}

#选择排序：
原理：从下标0开始，依次作为待比较的元素，然后遍历数组找到最小的元素与待比较的元素
交换，一共需要(n-1)轮排序；
#include <stdio.h>
int main() {
    int arr[5]={2,6,4,7,3};
    int max;
    int pos;
    //外层循环控制排序轮数
    for(int i=0;i<4;i++) {
        max = arr[i];
        pos = i;
        //里层循环控制选择一个值最大的元素
        for(int j=i;j<5;j++) {
            if(max < arr[j]) {
                max = arr[j];
                pos = j;
            }
        }
        //用值最大的元素与待比较元素进行交换
        arr[pos] = arr[i];
        arr[i] = max;
    }
    printf("%d\n",arr[1]*arr[2]);
    return 0;
}

#快速排序：NO

#二分查找：NO

#函数：
定义：执行某种功能的代码块；
格式：
返回值类型 函数名(形式参数) {
    //函数体
    return 返回值;
}
分类：
标准函数：由官方或第三方库提供的函数，可以直接调用，无需实现；
自定义函数：由程序猿自己编写的函数；
步骤：
声明函数：.h
实现函数：.m
调用函数：整个程序
范例：
//无参无返回值
void log(void);//1.声明
void log(void) {
    //函数体：实现函数的功能
    printf("hello world!\n");
}//2.实现
log();//3.调用：相当于把函数体的代码执行一遍
//有参有返回值
int sum(int a,int b);//1.声明：形式参数(简称形参)，用,隔开
int sum(int a,int b) {
    //定义局部变量：不同的函数内部可以定义相同的变量名
    int sum = 0;
    return;//任何函数最多只有一个返回值，函数遇到return执行结束
}//2.实现
int ret = sum(10,15);//3.调用：相当于把函数体的代码执行一遍
//实参和形参的关系和区别
1.形参是在定义变量，实参是在传值；
2.实参的值直接赋给形参；
3.实参是在函数调用的地方传递值，形参是在函数实现的地方接收实参的值；

#递归：函数自己调用自己、容易栈内存溢出
作用：当不知道循环次数的时候，使用递归；
注意：递归一定要有明确的结束条件，否则会造成死循环；
代码：参见NBSDK

#指针：
定义：变量的地址(唯一标识一块内存的索引)；
int a;//a变量名、&a变量地址
int *p;//定义一个指针变量p：p指针变量名、*指向
指针变量p的作用：用来存储地址；
*p：指p指向的内容；
p = &a;//将整型变量a的地址赋给指针变量p
*p = a;//*p是p指向的变量
int *p;//变量p是int*类型、int是p指向变量的基类型
int *p = NULL;//指针变量p初始化为空、不能使用空指针
int *p;//未初始化的指针称为野指针、不能使用野指针
printf("&a=%p",&a);//输出变量a的地址：％p地址格式符
注意：1.定义指针时，一定要初始化为空；
2.指针做为参数或者已经赋值，则无需初始化为空；
3.使用指针前，一定要给指针赋值；
4.使用指针时，一定要判空；
if(p == NULL) {
    return;
}
//指针大小：固定4个字节-因为地址在内存中都是以整型的方式分配的

#数组和指针：
概述：数组名作为函数参数，代表数组的首地址；
int *p = NULL;
int a = 5;
p = &a;
p++;//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
//指针数组
int *p[10];//数组：每个元素都是个指向整型的指针
//指向数组的指针
int (*p)[10];//指针：指向10个int元素的数组
//指向指针的指针
int **p;//指针：指向指针
//指向函数的指针
int (*p)(int a);//指向函数的指针
//指针作为函数返回值
格式：数据类型* 函数名(形参列表) {//...}
//交换两个变量？
1.传值：无法实现交换；
2.传地址：交换指针指向，无法实现交换；
3.传地址：交换指针指向变量的值，可以实现交换；

#字符串：c语言部分
1.定义：字符串就是一串字符，由一对双引号括起来；
char *a = "hello world";//每个字符占1个字节，\0称为尾零
2.指向字符串的指针：char *p = "123456";
3.了解：
#include <ctype.h>
int isalpha(int c);//判断单个字符是否是字母
int isnumber(int c);//判断单个字符是否是表示数字
int isupper(int c);//判断单个字符是否是大写字母
int islower(int c);//判断单个字符是否是小写字母
int toupper(int c);//将单个字符转换为大写字母
int tolower(int c);//将单个字符转换为小写字母
4.掌握：
#include<string.h>
size_t strlen(const char *s);//返回字符串的有效字符个数：与sizeof()区别？
char *strcat(char *s1,const char *s2);//将s2的内容拼接到s1后面形成新的字符串s1
//返回子串在s1中首次出现位置的第一个字符的地址
char *strstr(const char *s1, const char *s2);//在字符串s1中，寻找子串s2首次出现的位置
//s1必须有足够大的空间，如果数组越界，可能导致未知的错误
char *strcpy(char *s1,const char *s2);//将字符串s2拷贝到字符数组s1，返回s1
char *strchr(const char *s,char c);//查找字符串s中首次出现字符c的位置，不存在c,返回NULL
//s1>s2->返回正数，s1<s2->返回负数，s1==s2->返回0
int strcmp(const char* s1,const char* s2);//比较两个字符串的大小关系
char *strrchr(char *str, char c);//在串中查找指定字符的最后一个出现，失败返回NULL

#结构体：
定义：相同或者不同数据类型变量的集合，自定义的数据类型；
格式：放在头文件下面、所有函数上面
//结构体定义用struct关键字，名字为data
struct data {
    //成员变量
    int a;
    char b;
    short c;
};
//结构体别名：wm_data
typedef struct data {
    int a;
    char b;
    short c;
}wm_data;
//难点：结构体指针？

#枚举：
定义：如果变量只有几种可能的值，可以使用枚举；
//枚举可以有无数个：不推荐使用
typedef enum direction {
    枚举1,
    枚举2,
    枚举3
} direction_t;
//定义通用枚举：只能同时存在一个枚举值
typedef NS_ENUM(NSInteger,WMDirection) {
    枚举1,
    枚举2,
    枚举3
};
//定义位移枚举：可以同时存在多个枚举值
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    枚举1,
    枚举2,
    枚举3
};

#共用体：使几个不同变量共同占用一段内存的结构
union date {
    int a;
    char b;
    short c;
};
大小：1.共用体变量所占内存长度等于最长成员的长度；
2.共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种；
3.共用体变量中起作用的成员是最后一次存放的成员；
/******************************Objective-C语言基础******************************/
#Objective-C语言：面向对象(oop)的C语言
特点：Objective-C语言区分大小写，并且完全兼容C语言，C语言可以直接编译在Objective-C语言的工程中；
//C语言和Objective-C语言的区别？
1).后缀：
C语言：头文件.h/源文件.c
Objective-C语言：头文件.h/源文件.m
.m//Objective-C文件
.mm//c++/c文件
2).引用头文件：
C语言：#include //将include右边的文件copy到当前文件：可能会出现重复包含头文件
Objective-C语言：#import //可以避免重复包含头文件
3).格式化输出函数：
C语言：printf(""); //需要\n来换行
Objective-C语言：NSLog(@""); //打印有时间信息、工程名、线程号；打印会自动换行
4).关键字&字符串
C语言：不需要加@
Objective-C语言：需要加@
注意：C语言可以直接操作硬件；

#主头文件：
1.定义：拷贝了该工具箱中所有工具的头文件，只需要导入主头文件就可以使用该工具箱中所有的
工具，避免了每次使用都要导入一个对应头文件；
2.规律：所有的主头文件名称和工具箱名称一致；所有的主头文件都是导入了该工具箱中的所有的头文件
3.Frameworks地址：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks

#面向对象的三大特征：
1).封装性：
定义：利用类将数据和基于数据的操作封装起来，数据被保护在类的内部，系统的其他部分只有
通过被授权的操作，才可以与这个类进行交互；
好处：将数据隔离、便于使用、提高重用性、提高安全性；
原则：将不需要对外提供的内容隐藏起来、把属性隐藏起来，提供公共方式对外访问；
2).继承性：
定义：新类可以从其它已有的类中派生：保持了父类中的行为和属性，但增加了新的功能；
3).多态：
定义：指一个程序中可以有同名的不同方法共存的情况，可以利用子类对父类方法的覆盖
和重载在同一个类中定义多个同名的方法来实现；

#类：class
定义1：既可以存数数据，又可以管理数据-结构体(用来存储数据)+函数(用来管理数据)；
定义2：具有相同或相似性质对象的抽象就是类，对象的抽象就是类，类的具体化就是对象；
实质：类的实质也是一个对象、该对象会在这个类第一次被使用的时候创建；
//类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#类方法和对象方法的区别：
对象方法以"-"开头，必须用对象调用/类方法以"+"开头，必须用类调用；
对象方法中可以直接访问属性(成员变量)/类方法中不可以直接访问属性(成员变量);
类方法的执行效率比对象方法高；

#构造方法：所有init开头的方法
作用：用于初始化对象、初始化对象的成员变量；
特征：构造方法理论上只能被调用一次；
//重写构造方法
1.先初始化父类->初始化子类
2.判断父类是否初始化成功才能继续初始化子类；
3.返回当前对象的地址；
- (instancetype)init {
    self = [super init]; //1.初始化父类
    if (self != nil) { //2.判断父类是否初始化成功
        _age = 6; //3.初始化子类
    }
    return self; //4.返回地址
}
//自定义构造方法：自定义一个init方法
-(instancetype)initWithAge:(int)age withName:(NSString*)name {
    //自定义
}
特征：一个类中可以自定义0到多个构造方法；

#单例模式：程序运行过程中，实例对象只有一个
作用：在C语言中，全局变量存储的数据为整个程序函数共享；在Objective-C语言中
不允许对象静态内存分配，因此不能声明全局变量，但是可以声明为单例对象，单例对象
存储的数据为程序共享；
代码：见WMBook.h/m | WMGame/单例模式；

#Foundtion框架：众多Api的集合
iOS框架：UIKit框架+Foundtion框架
Mac开发：AppKit框架+Foundtion框架
包含：结构体、枚举、类
注意：想要操作Foundtion框架(NSString、NSArray、NSDictionary)最常用的方法就是Category；

#字符串：
//不可变字符串：NSString
Objective-C语言：NSString *msg = @"aaa";%@//在Cocoa中集成了一系列方法，可以很方便的操作字符串
C语言：char *msg = "aaa";/char msg[20] = "hello";%s//c语言将字符串作为字符数组
//可变字符串：NSMutableString
char c = ' ' //代表空格
见WMPayInfo.h/m；

#数组：
//不可变数组：NSArray
Objective-C语言：NSArray是一个类，任意类型对象地址的集合，不能存放简单的基本数据类型(int、float)；
C语言：数组是相同类型变量的有序集合，可以保存任意类型的数据；
注意：在iOS中，数组下标越界不会有警告，但是运行会直接报错；
//可变数组：NSMutableArray
定义：数组长度不确定的数组，是一个类；
特点：数组元素不能是基本数据类型，比如int；只能是对象的引用(指针)；
代码：见WMPayInfo.h/m；
遍历数组：通过下标遍历数组&快速枚举法(for in)&枚举器法

#NSEnumerator枚举器：直接作用于数组NSArray
NSEnumerator *enumerator = [array objectEnumerator];//返回一个枚举器
[array objectEnumerator];//正序输出所有元素：返回NSEnumerator
[array reverseObjectEnumerator];//逆序输出所有元素：返回NSEnumerator
NSArray *arr = [enumerator allObjects];//获取枚举器所有的元素
NSString *s = [enumerator nextObject];//nextObject指向第一个元素

#字典：
定义：由任意类型的对象地址构成键值对为元素的集合结构；
存储方式：无序保存的集合；
//不可变字典：NSDictionary
//可变字典：NSMutableDictionary
代码：见WMPayInfo.h/m；
遍历字典：枚举器法&快速枚举法；

#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？

#Category类别/分类：
新建：New File->Objective-C File->Category
@interface 类名 (类别名)
//定义方法：不允许添加成员变量
@end
特点：一旦使用Category给已有的类增补方法，那么这个类的对象就可以使用这个方法；
功能：1.可以给已有/系统原生的类增加方法；
2.分模块：可以对类的方法进行分类管理：将类的实现分散到多个不同文件或多个不同框架中；
注意：1.category中不能添加成员变量；
2.使用类别增加的方法必须导入类别头文件；
3.父类类别中的方法，子类也可以用；

#类扩展/匿名类别：声明和实现均在.m文件中
定义：可以定义不想对外公开的类的属性/方法；
格式：
@interface WMPayInfo()
-(void)show;
@end
功能：1.可以实现私有方法；
2.可以声明私有成员变量；

#点语法：为了让程序设计简单化
//点语法在等号左边就是set方法，点语法在等号右边就是get方法
[xiaoming setName:@""];==xiaoming.name = @"";
NSString *name = [xiaoming getName];==NSString *name = xiaoming.name;
注意：1.点语法只是访问set/get方法，不是使用成员变量；
2.点语法是一个编译器的特性：会在程序翻译成二进制的时候，自动转换成set/get方法；
3.真正OC语法：self->_age = 15;
代码：WMBook.h/m

#继承：派生
定义：父类的属性(不包括私有)和方法，子类可以直接获取，叫做继承；子类在父类的基础上，创建自己的属性和方法，叫做派生；
提示：每个类中都有一个[super class]指针指向自己的父类；
Objective-C语言只支持单继承；
好处：1.创建大量的相似类的时候，可以节省工作量；
2.建立了类与类之间的联系；
缺点：耦合性太强；
格式：
//子类可以使用父类的所有方法，访问父类非私有的成员变量
@interface 子类名 : 父类
@end
继承在内存中的体现：
子类继承父类以后，子类对象的构成：
1.父类的字段和方法；
2.子类自己独有的字段和方法；
super：子类在重写父类方法时，想要保留父类的一些行为

#多态：同一个接口不同的实现，父类的指针创建子类的对象
//重写：重新实现一遍父类的方法，子类最终执行子类重写以后的方法
//重载：在一个类中定义多个同名的方法，要求每个方法具有不同的参数类型和个数；
注意：Objective-C语言没有严格的方法重载；
//实现条件
1.有继承关系；
2.有重写；
3.父类的指针指向子类的对象；

#虚方法：
定义：调用方法的时候，不看指针看对象，对象的地址指向什么对象就调用什么方法；
好处：可以描述不同事物被相同的事件触发，产生不同的响应；
特征：Objective-C语言每个方法都是虚方法；

#类工厂方法：用于快速创建对象的类方法
作用：用于创建一个对象；
+ (instancetype)person {  //类方法：方法名称==类名称(首字母小写)、返回值id/instancetype
    [[self alloc]init]; //谁调用+ (instancetype)person()、self就代表谁
}

#工厂类：NO
特点：NSString/NSArray/NSDictionary/NSNumber都是工厂类/抽象类，不能被继承；
不能被继承的原因：
NSString采用了“抽象工厂”模式，内部是个类簇(class cluster)，它在外层提供了很
多方法接口，但是这些方法的实现是由具体的内部类来实现的，当使用NSString生成一个对象时，
初始化方法会判断哪个“自己内部的类”最适合生成这个对象，然后这个“工厂”就会生成这个具体的
类对象返回给你，这种由外层类提供统一抽象的接口，然后隐藏具体的内部类来实现；

#内存管理：
//C语言：sizeof()是一个运算符，用来计算变量或数据类型的大小
1.静态内存分配：在编译阶段分配的内存
分配在数据段、只读数据段、栈区的内存，由编译器自动申请和释放的内存，称为静态内存分配；
2.动态内存分配：在运行阶段分配的内存
分配堆区的内存，手动申请100个字节的内存，并将这个空间的首地址返回给指针变量p；
char *p = (char *)malloc(100*sizeof (char)); //动态申请内存
free(p); //动态释放内存
3.注意：防止提前释放、防止内存泄露、防止重复释放；
4.区别：动态内存分配和静态内存分配的区别
静态内存分配：操作系统分配空间、空间在编译时确定，而非运行时、空间在栈段，数据段，只读数据段、自动释放空间
动态内存分配：程序员分配空间、运行时确定，每次运行都不同、空间在堆段、手动释放空间
5.总结：C语言的内存管理需要我们手动申请，手动释放
1>.手动申请内存，使用以后需要手动释放，如果不释放会造成内存泄露；
2>.不能多次释放，如果多次释放，则会崩溃；
3>.不能提前释放，如果提前释放再使用，也会崩溃；
6.问题：如果项目比较复杂，需要上百号人一起分工完成，就很容易出现问题：比如我们开辟了一块内存空间，
存放了一块很有用的数据。但是，这个数据不只有我在这一块代码里用，甚至有多个人，在程序的多个地方使用。
这样造成的结果：就算我使用完成这块内存，我也不能去释放他，因为我不能确定，别人在别的地方是否还需要
使用这块内存。内存泄露在所难免了；
//Objective-C语言：管理对象、基本数据类型不需要管理
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；

#ARC和MRC的混合编程：
//MRC转ARC：选中工程->target->Build Settings->Automatic Reference Counting改成NO

#协议protocol：直接新建、可以实现多继承
定义：Objective-C语言中用来规范方法的声明，可以实现多继承和对象间通信；
格式：见WMBook.h
注意：1.协议中只声明方法，不实现方法，也不能声明属性；
2.遵从协议的类必须导入协议头文件；
3.协议中@required权限的方法必须实现；//不实现不会报错、只会报警告
4.父类遵循某个协议，那么子类也遵循该协议；
5.协议的应用场景：类型限定？？？
遵从协议：见BaseViewController.h/m

#代理delegate：
1.定义：代理是实现两个类的对象间通信的一种机制；
2.委托方：持有协议的id指针，可以使用协议；
@property (weak,nonatomic) id <CLGODelegate> delegate;//代理对象使用weak，防止内存泄露
3.代理方：遵从协议，实现协议中的方法；
4.怎么实现代理回调？--见NBSDK；

#block：block是一种数据类型
作用：block用来封装一段代码，效率高，block标志^
//无参无返回值：(void)可以省略不写
void (^myBlock)(void);
myBlock = ^(void) {
    NSLog(@"");
};
myBlock();
//无参有返回值
NSString* (^myBlock)(void);
myBlock = ^(void) {
    return @"";
};
myBlock();
//有参无返回值
void(^myBlock)(NSString *);
myBlock = ^(NSString *msg) {
    NSLog(msg);
}
myBlock();
//有参有返回值
int (^myBlock)(int,int);
myBlock = ^(int a,int b) {
    return a+b;
};
NSLog(@"%d",myBlock(3,4));
//作为参数
(int (^)(int,int))myBlock;
注意：block内部可以访问外部的变量，给局部变量加上__block关键字，就可以在block内部修改该局部变量
//需要在变量定义的前面加上__block关键字，才可以修改该变量
__block int i = 1;
__block int sum = 0;
int (^sumBlock)(void);
sumBlock = ^(void) {
    while (i<=100) {
    sum += i;
    i++;
}
    return sum;
};
NSLog(@"%d",sumBlock());
注意：1.声明block可以使用typedef取别名：将myblock变成本质跟int、float没有区别，可以多次使用
typedef int (^myblock) (int a,int b);
myblock block = ^(int a,int b) {
    return a+b;
};
NSLog(@"%d",block(3,5));
2.block内部可以访问外部变量、block内部可以定义与外部相同名称的变量：就近原则使用；
3.默认情况下：不允许在block内部修改外部变量、如果需要修改：必须在变量前面加上__block；
4.block内部修改了外部变量、会影响外部变量的值；
#作用：实现回调-见CLGO代码；
https://blog.csdn.net/liu537192/article/details/45579791
/******************************网络基础******************************/
#异步网络请求：
//分类：
网络请求：get
网络上传：post
下载：NO
//原生网络请求：
CFNetwork：纯C语言
NSURLConnection：iOS7.0被废弃
NSURLSession：NO
https://www.jianshu.com/p/b0ddadd34037
//ASIHttpRequest：不在更新
//MKNetworkKit：简单易用，使用者较少
//AFNetworking：
1.概述：2.0使用的是NSURLConnection、3.0使用NSURLSession；
2.代码：NetworkViewController.h/m
注意：不要在子线程中更新UI；
//利用KVO、KVC进行网络请求：参考2015-10-13
1.新建数据模型PostInfo.h/m
2.新建数据源：必须初始化
3.设置单例：全局使用
3.监测数据源变化：KVO
4.新建下拉控件：进入VC->开始下拉加载->网络请求：改变数据源->加载UITableView
5.在View中更新UI
代码：NetworkViewController.h/m
//设置应用支持https
Xcode7.0以后：NSAppTransportSecurity->NSAllowsArbitraryLoads->YES

#网络编程需要掌握的内容：NO
0.实时监测网络变化
1.数据请求、数据上传、下载
2.原生网络请求的原理
3.网络请求第三方库的使用
4.KVC在网络请求中的应用
5.进入VC以后怎么加载操作
/******************************iOS进阶******************************/
#App的主目录：沙盒机制NSHomeDirectory()
概念：沙盒机制是一种安全体系，规定了应用程序只能在该应用创建的文件夹内读取文件，不可以
访问其他地方的内容。所有的非代码文件都保存在这个地方：比如图片、声音、属性列表和文本文件等；
沙盒中的文件：Documents(持久化数据)、Library(缓存)、tmp(临时文件)
NSString *home = NSHomeDirectory(); //沙盒根目录
NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; //获取Documents(持久化数据)
NSString *libarayPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]; //获取Library(缓存)
NSString *tempPath = NSTemporaryDirectory(); //获取tmp(临时文件)
注意：1).每个应用程序都在自己的沙盒；
2).不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容；
3).应用程序向外请求或接收数据都需要经过权限认证；

#数据持久化的方法：存放在沙盒
原因：通常程序在运行中或者程序结束以后，需要保存一些信息，比如登录信息，视频播放记录，收藏等；
常见方法：
1.文件操作：见FileViewController.h/m
2.plist：属性列表文件-只能存储NSString/NSNumber/NSDate/NSArray/NSDictionary
作用：对一些登录、注册和配置信息进行持久化存储；
格式：xml语法；
创建：Xcode创建/代码创建
读取：需要时自行百度
3.NSUserDefaults：见FileViewController.h/m
4.归档/解归档：一种序列化与反序列化
//归档
//解归档
https://www.jianshu.com/p/3e08fa21316d
5.数据库：
//sql语句：结构化查询语言
1.创建表
create table if not exists sso (
id integer primary key autoincrement,//将id设为主键
author text,//文本
price real,//浮点型
pages integer);//整型
2.插入
insert into sso (author,price,pages) values(?,?,?);
3.更新
update sso set price = ?,pages = ? where author = ?;
4.删除
delete from sso where pages > ?;
5.查询
select * from sso;
//FMDB
代码：SqliteViewController.h/m
//MagicalRecord：
一.Core Data：
1.新建Core Data；
2.新建表：写上需要存储的文件；
3.关联生成属性类；
二.导入数据：
4.导入MagicalRecord；
三.app启动：
5.设置数据库存放的文件名；
6.让Magical Record支持数据库版本管理；
7.查询所有的数据库内容，如果有内容则送到数据源；
if([MusicInfo MR_findAll].count) {
    for(MusicInfo *music in [MusicInfo MR_findAll]) {
        MusicInformation *musicInfo = [[MusicInformation alloc] init];
        musicInfo.songUrl = music.songUrl;
        musicInfo.songName = music.songName;
        musicInfo.songId = music.songId;
        musicInfo.userName = music.userName;
        musicInfo.albumName = music.albumName;
        musicInfo.albumPic = music.albumPic;
        [[MusicManager sharedIntance].selectMusics addObject:musicInfo];//把对象加到数据源
    }
}
四.app杀掉：
8.删除数据库里的表，将数据源保存；
for(MusicInfo *music in [MusicInfo MR_findAll]) {
    [music MR_deleteEntity];//删除数据表
}
[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
9.新建数据库的表，将数据源所有内容放到数据库，保存；
for(MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
    MusicInfo *zNewMusic = [MusicInfo MR_createEntity];//新建数据表
    zNewMusic.songName = newMusic.songName;
    zNewMusic.songUrl = newMusic.songName;
    zNewMusic.songId = newMusic.songId;
    zNewMusic.userName = newMusic.userName;
    zNewMusic.albumName = newMusic.albumName;
    zNewMusic.albumPic = newMusic.albumPic;
}
/*
1.数据的增删改查
2.多表的链接查询
3.数据回滚
*/
http://hao.jobbole.com/magicalrecord/

#通知中心：WMGameProxy直接看代码
定义：每个App都有一个通知中心，专门负责协助不同对象之间的消息通信
//创建消息对象
NSNotification *notice=[[NSNotification alloc]initWithName:@"123" object:nil userInfo:@{@"1":@"123"}];
[[NSNotificationCenter defaultCenter] postNotification:notice];
代码：ObserverViewController.h/m

#KVC/KVO：
//KVC：键值编码(key-value-coding)
#作用：间接访问属性的方法
1.给对象赋值：[VC setValue:@"XWJ" forKey:@"name"];
2.通过键值路径获取属性的值：NSString *name = [VC valueForKey:@"name"];
NSString *name = [VC valueForKeyPath:@"name"];
3.字典转型Model：setValuesForKeysWithDictionary
NSDictionary *dic = @{
                        @"name":@"XWJ",
                        @{@"age",@"18"},
                    };//定义字典
PersonModel *p = [[PersonModel alloc]init];//创建模型
[p setValuesForKeysWithDictionary:dic];//字典转模型
注意：1.字典的key和Model的属性必须一一对应，否则会报错；
//KVO：键值观察者
#作用：用于监听对象属性的改变
1.下拉刷新/上拉加载监听UIScrollView的contentoffsize；
2.webview混排监听contentsize；
3.监听模型属性实时更新UI；
#步骤：
/**
给对象的属性添加观察者：
self.post-被观察者
self-观察者
array-属性
*/
[self.post addObserver:self forKeyPath:@"array" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL];
//给可变数组添加属性：
[[self mutableArrayValueForKeyPath:@"array"] addObject:@2];
//NSMutableSet==>[self mutableSetValueForKeyPath:@"可变集合属性名"];
//如果属性改变，自动调用方法：
-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {
    NSLog(@"new:%@",change[@"new"]);
    NSLog(@"old:%@",change[@"old"]);
}
//取消监听：
-(void)dealloc {
    [self.post removeObserver:self forKeyPath:@"name"];
}
代码：
https://www.jianshu.com/p/742b4b248da9

#选择器SEL：一个数据类型，内部是消息，类似于函数指针
原理：Objective-C在编译的时候，会根据方法的名字(包括参数序列)，生成用来区分这个方法的唯一ID，这个ID就是SEL类型；
作用：提高执行的效率、增强程序的灵活性；
//创建
@selector 方法选择器
@selector (方法名)
//获取
SEL s1 = @selector(onClick:);
//将一个字符串转换为一个SEL类型
SEL s2 = NSSelectorFromString(@"onRun:");
//执行SEL
Dog *dog = [[Dog alloc]init];
[dog performSelector:s1];
[dog performSelector:@selector(setName:) withObject:@"Tom"];//最多支持两个参数
//使用@selector对数组排序：
代码：SelViewController.h/m
//在ARC(自动内存管理)的条件下，使用选择器很可能会报警：参照该方式去除报警
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
//执行代码
Dog *dog = [[Dog alloc]init];
SEL s1 = @selector(onClick:);
[dog performSelector:@selector(setName:) withObject:@"Tom"];
#pragma clang diagnostic pop
/******************************UI基础******************************/
#UI介绍：UI全称User Interface(用户接口)
作用：用户通过UI与应用程序进行交互；
//UIKit坐标系：坐标系(0,0)在左上角，x轴向右x正向延伸、y轴向下正向延伸

#NSTimer：
应用：定时上传数据、获取验证码、重复执行；
代码：见TimeViewController.h/m
https://blog.csdn.net/zhuzhihai1988/article/details/7742881

#UIView：UIView是所有视图的父类，UIView的属性和方法就是所有视图的属性和方法
//属性：
@property(class, nonatomic, readonly) Class layerClass; //可以通过+ (Class)layerClass{//修改图层}
@property(nonatomic,readonly,strong) CALayer *layer; //图层：可以操作layer修改UIView
@property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; //是否可以点击
@property(nonatomic) NSInteger tag; //tag
@property(nonatomic) CGRect frame; //该view在父view坐标系统中的位置和大小
@property(nonatomic) CGRect bounds; //该view在本身坐标系统中的位置和大小
@property(nonatomic) CGPoint center; //中心点坐标
@property(nonatomic) CGAffineTransform transform; //二维形变：平移、旋转、缩放
@property(nullable, nonatomic,readonly) UIView *superview; //父视图
@property(nonatomic,readonly,copy) NSArray<__kindof UIView *> *subviews; //子视图
- (void)sizeToFit; //根据内容/图片的大小，会计算出最优的size而且会改变自己的size
- (void)sizeThatFits; //根据内容/图片的大小，会计算出最优的size但是不会改变自己的size
//UIView动画
[UIView animateWithDuration:0.5 animations:^{
    //执行代码：只能修改关于坐标系的属性以及色彩和透明度
}];

#自定义控件：
1.在initWithFrame:方法中添加子控件，提供便利构造方法；
2.在layoutSubviews方法中设置子控件的frame：一定要调用[super layoutSubviews]；
3.增加模型属性，在模型属性set方法中设置数据到子控件；
代码：见WMGame

#UILabel的包裹模式：自适应
特点：UILabel的高度是随着文字内容的增加而拉伸的；
应用：评论/朋友圈等；
步骤：1.设置UILabel的位置(x,y);
2.设置UILabel的最大宽度；

#重写UIButton：推荐使用-(void)layoutSubviews {}
默认布局：title在右边、image在左边
重写布局1：title在左边、image在右边
重写布局2：title在下边、image在上面
注意：1.设置UIButton的内边距；//记住密码btn
https://blog.csdn.net/wanglei0918/article/details/53286597
https://blog.csdn.net/wwc455634698/article/details/55252719
https://www.jianshu.com/p/a4755c789545

#跳转：
1).模态方式：见WidgetViewController.h/m->TimeViewController.h/m
基本方式传值：OK
block传值：实现回调
代理传值：OK
2).通过导航控制器迁移：见WidgetViewController.h/m

#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#事件响应：
//UITouch：NO
//hitTest：NO
//UIEvent：每产生一个事件就会产生一个UIEvent对象

#手势：UIGestureRecognizer
响应者对象：能够接受并处理事件的对象称为响应者对象、继承UIResponder;
常见响应者对象：UIApplication、UIViewController、UIView;
单击/双击：UITapGestureRecognizer
长按：UILongPressGestureRecognizer
拖动：UIPanGestureRecognizer
捏合：UIPinchGestureRecognizer
旋转：UIRotationGestureRecognizer
清扫：UISwipeGestureRecognizer
代码：GestureViewController.h/m
注意：1.一个视图可以附着多个手势，一个手势只能附着在一个视图；
2.应用场景：抽屉效果！！！
https://www.jianshu.com/p/b1eaeff5ec81
https://www.jb51.net/article/108236.htm

#UIScrollView：滚动视图
定义：能够滚动的视图控件，用来展示大量的内容；
代码：ScrollViewController.h/m；
注意：1.不要通过索引subviews数组访问scrollView子控件；
2.contentOffset&contentSize的区别？

#UITableView：表格视图
模式：UITableView有两种模式：普通模式/编辑模式；
代码：TableViewController.h/m
#纯代码模式：根据业务需求确定数据模型->确定cell中视图控件的组成
仿QQ折叠：http://blog.sina.com.cn/s/blog_12ff4f7900102vjro.html
//多选：OK
//搜索栏(新版)
1.给"全部数据"MyTableView和"搜索结果"SearchResultTableView都创建一个UITableView
2.先写MyTableView：
1).创建搜索栏：定义搜索控制器UISearchController、SearchBar
2).设置代理：UISearchResultsUpdating、UISearchBarDelegate
3).定义"全部数据"的数据源
4).定义"搜索数据"数据源
3.再写SearchResultTableViewController
1).定义数组接受传过来的数据
2).实现代理方法
//搜索栏(旧版)
1.创建UITableView：用于显示搜索结果
2.定义搜索栏和搜索显示控制器
3.定义数据源、定义搜索结果
4.创建搜索栏：将搜索栏做为UITableView的tableHeaderView
5.设置搜索显示控制器(显示搜索结果)的数据源代理
6.两个UITableView相等就是给"全部数据"赋值、不等就是给"搜索结果"赋值
#用xib定制：见XibDemo
注意：1.对于cell的循环引用：设置数据源和自定义cell的时候必须是有if的地方
就有else，不然容易引起数据和控价混乱；

#数据源：
实质：数据源实质就是一个数组(NSArray、NSMutableArray)；
Model类必须是单例：全局都可能使用这个Model；
VC需要网络请求，可以委托(PostStore类)来进行网络请求；
PostStore类网络请求完成，需要告诉VC网络请求操作完成；

#懒加载：用到的时候再加载、全局只加载一次
定义：在开发中，程序启动的时候不加载资源，只有在运行中需要资源的时候，再去加载这些资源；
好处：1.不必将创建对象的代码全部写在viewDidLoad()中，代码的可读性强；
2.每个属性的getter方法中分别负责各自的实例化处理，只有真正需要资源的时候，才会加载资源，节省了内存资源；
//实现：重写getter方法
-(NSArray *)dataArr {
    if (_dataArr == nil) {  //这里不能使用self.dataArr：循环引用
        self.dataArr = @[@"",@"",@""];
    }
    return dataArr;
}
self.dataArr; //每次使用均会调用-(NSArray *)dataArr;

#瀑布流：
//实现原理：
我们利用多个UITableView联动就可以实现瀑布流效果：调用UIScrollView的代理方法
让多个UITableView的偏移量都等于UIScrollView的偏移量实现联动，当一个cell超过屏
幕，我们不要release，而是回收到复用队列，然后在创建cell的时候首先去复用队列中
取，如果没有我们在创建。
//代码：见WaterFall

#父子控制器：多控制器管理
概述：利用普通UIViewController也可以管理子控制器；
//正好相反的操作
[self.view addSubview:_topLineVc.view];
[_societyVc.view removeFromSuperview];

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#实现画折线图：利用第三方库
1.加入tk库文件；
2.添加QuartzCore.framework；
/******************************iOS高级******************************/
#可视化布局：
//xib：可视化文件，可以通过拖拽进行界面布局，实质是一个xml文件
特点：只可以显示一个视图,在创建视图的时候可以同时创建(无需关联)；
- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
if (self) {
//xib初始化
}
return self;
}
xib加载UIViewController：
1.UIViewController *vc = [[SqliteViewController alloc]initWithNibName:@"One" bundle:nil];
//加载xib
NSArray *views = [[NSBundle mainBundle] loadNibNamed:@"xib名称" owner:nil options:nil];
UIView *view = [views firstObject];
2.关联class、拖线；
//xib的加载原理：NO
//storyboard：管理多个xib文件并处理场景与场景之间的跳转
UIStoryboard *main=[UIStoryboard storyboardWithName:@"Main" bundle:[NSBundle mainBundle]]; //Main指storyboard名字
UIViewController *vc=[main instantiateViewControllerWithIdentifier:@“VC”]; //VC指storyboard ID
UIViewController *vc = [main instantiateInitialViewController]; //启始ViewController实例化
总结：1.在storyboard/xib进行UI界面的布局；
2.通过Segue实现页面的跳转：自动型/手动型；
3.通过AutoLayout做适配；
4.UIStackView(iOS9.0以上)；
5.xib文件编译以后就成了nib文件；

#AutoLayout：
1.约束：通过给控件添加约束决定控件的位置和尺寸；
2.参照：在添加约束的时候是依照谁来添加的；
3.自动布局的核心计算公式：obj1.property1 = (obj2.property2 * multiplier)+constant value
https://www.jianshu.com/p/4ef0277e9c5e

#代码实现AutoLayout：NO

#VFL实现AutoLayout：NO

#用户通知：
//概述：
推送功能一般分为两种：本地推送和远程推送；
1.对于本地推送(UILocalNotification)，我们可以先注册通知；
然后新建本地推送，设置属性；最后执行推送(会调用某个方法)；
2.对于远程推送，我们使用第三方极光推送，按照极光推送文档操作；
//本地通知(本地推送)：
定义：由App发送到当前设备，不需要网络支持；
问题：什么时候使用本地通知？App在前台需要与客户交互的时候使用本地通知；
本地通知怎么在AppDelegate.m中使用？
代码：AppDelegate.m
//远程通知(远程推送)：由App服务端->APNs服务器->设备
https://www.jianshu.com/p/ad43bc1a970a

#基于位置的服务LBS：
//系统定位
1.导入MapKit.framework，创建MKMapView
2.显示用户位置，把MKMapkit加到self.view，设置代理
3.导入CoreLocation.framework，创建CLLocationManager(定位对象)设置属性
4.问用户是否允许更新用户信息：开始更新
5.设置代理
6.需要在Info里边添加两项:
1)当APP在前台的时候才使用,会跟用户弹出一个确认框：
NSLocationWhenInUseUsageDescription
2)当APP总是请求用户定位的时候,会跟用户弹出一个确认框：
NSLocationAlwaysUsageDescription
代码：MapViewController.h/m
//大头针：知道经纬度就可以标注位置
1.导入两个框架 MapKit.framework、CoreLocation.framework；
2.创建MKMapView把地图显示出来；
3.定义显示标注的类(MyAnnotation类)，实现MKAnnotation协议；
4.从协议复制属性，初始化协议属性；
5.给地图添加标注：MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
6.给地图添加标注：[self.mapview addAnnotation:a];
代码：MKAnnotation.h/m
//高德地图
1.登录LBS开放平台，申请Key；
2.下载相关SDK和实例代码；
https://blog.csdn.net/a910577347/article/details/73499515
//百度地图
1.登录LBS开放平台，获取密钥；
2.下载相关SDK和实例代码；
https://www.jianshu.com/p/b0169d332918
//腾讯地图
1.登录LBS开放平台，获取参数；
2.下载相关SDK和实例代码；
https://blog.csdn.net/liyun123gx/article/details/44222255

#多语言：en/tw/cn
定义：根据用户设置的Language and Region Format(语言和区域格式)修改应用
本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html //特别详细
https://www.jianshu.com/p/c7a6408410aa

#程序之间通信：
概念：URL组成-协议类型+服务器地址+资源路径+请求参数
原理：从一个App跳转到另一个App的必要条件：另一个App必须配置scheme(skim)协议，这样App才可以根据协议找到需要打开的应用；
1.第三方登录、分享、支付：由于是封装的SDK，可以根据文档直接集成；
2.打电话、发短信、发邮件：https://blog.csdn.net/cc1991_/article/details/74990013
3.实现两个单独App之间的跳转：TestApp->Demo
1).在Demo中配置协议url scheme：test；
2).在TestApp执行跳转方法：
NSURL *url = [NSURL URLWithString:@"test://"];
if ([[UIApplication sharedApplication] canOpenURL:url]) {
    [[UIApplication sharedApplication] openURL:url];
} else {
    NSLog(@"尚未安装应用");
}
3).在TestDemo中配置协议白名单：iOS9.0以后
在info.plist中添加字段：LSApplicationQueriesSchemes(数组)；
配置需要跳转的协议白名单test；
4.实现两个App之间跳转到指定界面：
1).在"test://"协议后面跟上域名来标记需要跳转的界面；
NSURL *url = [NSURL URLWithString:@"test://map"];
if ([[UIApplication sharedApplication] canOpenURL:url]) {
[[UIApplication sharedApplication] openURL:url];
} else {
NSLog(@"尚未安装应用");
}
2).在AppDelegate.h中，监听代理方法：
- (BOOL)application:(UIApplication *)app openURL:(nonnull NSURL *)url options:(nonnull NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {
    if ([url.host isEqualToString:@"map"]) {
        //在此做界面的跳转处理
    }
}
https://blog.csdn.net/cc1991_/article/details/79050275

#分享：
//原生分享
https://blog.csdn.net/qq_28009573/article/details/77744001
//shareSDK集成
注意：1.在Xcode7.0以上，需要在info.plist中设置访问权限；
https://www.cnblogs.com/xubojoy/p/3885932.html
https://www.jianshu.com/p/71499300a133

#第三方登录：基于OAuth2.0协议构建的OAuth2.0授权登录系统
1.微信登录：只提供原生登录方式(必须安装客户端)，所有使用之前必须判断；
https://www.cnblogs.com/sunfuyou/p/7843612.html
2.QQ登录：xxx
https://blog.csdn.net/alexander_wei/article/details/72626396
https://www.jianshu.com/p/133d84042483
3.微博登录：xxx
https://blog.csdn.net/zhonggaorong/article/details/51724810
https://blog.csdn.net/u010545480/article/details/53004699
https://www.jianshu.com/p/87d1d397d269

#支付：
//内购
概述：如果你的App中销售的商品与App的功能有关必须通过内购方式购买；
特点：1.不允许自定义价格；
2.消耗型项目/非消耗型项目/自动续订订阅；
https://blog.csdn.net/xiaoxiangzhu660810/article/details/17434907#0-qzone-1-51422-d020d2d2a4e8d1a374a433f596ad1440
//第三方支付：
http://www.cocoachina.com/ios/20151008/13506.html#0-qzone-1-88885-d020d2d2a4e8d1a374a433f596ad1440
1.支付宝：
https://blog.yayuanzi.com/12276.html
https://openhome.alipay.com/platform/document.htm#down
http://www.cnblogs.com/siyuan123/p/4872378.html?from=timeline&isappinstalled=0
2.微信：
https://www.jianshu.com/p/af8cbc9d51b0
https://www.jianshu.com/p/162ece335b31
3.银联：NO
4.平台币：NO
5.集成三方平台支付：海马、同步推、爱思

#断点续传：
定义：指任务在上传/下载的时候被人为划分为几个部分：每个部分采用一个线程进行上传/下载，如果遇到网络故障可以
继承在未完成的部分继续开始，没必要从头开始下载。
//原理
https://www.cnblogs.com/wangzehuaw/p/5610851.html
https://www.cnblogs.com/findumars/p/5745345.html
//实现
https://www.jianshu.com/p/0e6deea7de87
https://www.jianshu.com/p/01390c7a4957
https://blog.csdn.net/stree7cleaner/article/details/51440774
https://blog.csdn.net/lcg910978041/article/details/51487485

#即时通讯IM：
//底层原理：
1.协议：XMPP协议(基于xml的协议，具有超强的可扩展性)
2.XMPP的三个部分：服务器、网关、客户端(可以任意两者双向发生)
3.XMPP优缺点：
//优点：
1).XMPP协议是自由开源的，而且在C/S都有多种实现；
2).任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接；
3).利用XMPP技术开发软件，资源以及支持的来源都是多样的，这样就不会被“绑架”；
4).XMPP以TCP传递XML数据流，没有中央主服务器，任何人都可以运行自己的XMPP服务器；
5).XMPP基于XML具有很强的扩展性；
//缺点：
1).XMPP协议的服务器流量存在着被重复转发，数据负载太重；
2).XMPP协议基于XML文件(编码成单一的XML文件)，因此无法提供修改二进制数据；
//上层实现：环信
概述：环信通过云端开放的Rest api或者客户端SDK，摆脱IM底层开发，使App内置聊天功能；
步骤：1.制作推送证书、登录环信后台、创建应用生成AppKey；
2.通过cocoapods下载SDK：
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件：#import <EaseMobSDKFull/EaseMob.h>
3.按照环信集成开发文档操作；

#iOS与H5的交互：NO
//iOS与H5的交互
https://blog.csdn.net/sandyloo/article/details/65630863
https://www.jianshu.com/p/b0c847dcea9c
//利用WebViewJavascriptBridge
https://blog.csdn.net/qq_20455399/article/details/80353164
https://www.jianshu.com/p/96e01aed250b

#Swift和Objective-C混合编程：
//Objective-C工程调用Swift代码
https://blog.csdn.net/u010407865/article/details/62886943
https://www.jianshu.com/p/9f757a09eacd
//Swift工程调用Objective-C代码
https://blog.csdn.net/pjk1129/article/details/39644477
/******************************实战操作******************************/
#svn：开源的集中式版本控制工具(trunk/branches/tags)
官网：https://subversion.apache.org/
客户端：SmartSVN、CornerStone
安装：NO
在mac环境下，自带svn服务端和客户端功能，只需要做简单配置；
svn help //查看svn所有命令
cd+工程目录 //进入工程目录
svn checkout 服务器地址 --username=xwj --password==xwj123456 //将服务器代码完整的下载到本地
------------------------------------------------------------
svn status //查看文件状态
' ' 没有修改
'A' 被添加到本地代码仓库
'C' 冲突
'D' 被删除
'I' 被忽略
'M' 被修改
'R' 被替换
'X' 外部定义创建的版本目录
'?' 文件没有被添加到本地版本库内,不在SVN的管理之下
'!' 文件丢失或者不完整(不识别该文件)
'~' 受控文件被其他文件阻隔
'U' 更新最新的代码到本地(本地有文件的情况下)
'G' 产生冲突后,更新操作去解决冲突,相当于进行合并
------------------------------------------------------------
svn add * //添加文件
svn commit -m "本地修改说明" //将本地修改的内容提交到服务器
svn update //将服务器最新代码更新到本地
svn remove person.h  //删除svn版本管理控制的person.h文件
//版本回退：
1.本地版本回退
svn update -r7 //回退到第7个版本：查看是否是需要的版本
svn update //更新到最新版本
svn merge -r7:6 person.h //person.h回退到第6个版本
2.服务器版本回退
svn update
//查看版本信息
svn update //更新
svn log //查看某个文件的日志
//遇到冲突
mc(mine side) //保留自己的修改，放弃别人的修改
tc(their side) //保留别人的修改，放弃自己的修改
p(post pone) //延迟解决冲突：展示所有冲突的文件，手动解决冲突
svn resolved 文件名 //解决了某个文件的冲突：必须写
//svn地址重定向：
cd ./workspace
/*
10.5.154.237 上次svn的地址
10.5.154.142 本次svn的地址
sally 你的用户名
sallyssecret 你的密码
*/
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --username sally --password secret
//svn恢复
svn revert . -R
注意：1.本地版本号<服务器版本号->则不允许提交；
2.如果使⽤静态库需要特别注意：必须使⽤命令⾏将静态库添加到svn的管理之下；svn add xxx.a
https://my.oschina.net/joanfen/blog/194491#0-qzone-1-42949-d020d2d2a4e8d1a374a433f596ad1440

#git：开源的分布式版本控制工具(master/branches/tags)
开发者：Linux操作系统的作者Linus Torvalds；
客户端：SourceTree
安装：NO
创建代码仓库：git init
配置身份：查看是否配置OK
git config --global user.name "Tony"
git config --global user.email "tony@gmail.com"
添加：git add 文件名
提交：git commit -m "说明.txt"
加入.gitignore-允许用户将指定的文件或目录排除在版本控制之外的机制；
查看状态：git status
查看修改内容：git diff
撤销修改：git checkout
查看提交内容：git log
删除person.m文件：git rm person.m
版本回退：git reset --hard HEAD //没有push
1.git reset --hard HEAD^ //有push、回到上一个版本
2.git push -f //强制推送：必须让同事也要版本回退、不然同事本地不是消失！！！
git reset --hard HEAD^^ //回到上上一个版本
git reset --hard HEAD~100 //回到前100个版本
git reset --hard HEAD 版本号(前5位) //回到指定版本
//git分支：
查看分支：git branch -a
创建分支：git branch 分支名
合并分支：git checkout master->git merge 分支名
删除分支：git branch -D 分支名
解决冲突：git无法帮助你；
#与远程版本库协作：NO
//.gitignore
https://github.com/github/gitignore
//忽略UserInterfaceState.xcuserstate的方法：
https://blog.csdn.net/lovenjoe/article/details/50053255
//打tag：发现bug可以直接把这个tag变成分支
git tag -a tag名 -m "你想要说你的话"
git tag
git push origin tag名
//ssh keys认证
1.公钥：存在github上用来解密的key
2.私钥：存在本地一个.ssh文件夹下用来加密

#CocoaPods：https://segmentfault.com/a/1190000011428874
//安装Cocoapods
1.安装Ruby
1>安装RVM:
curl -L get.rvm.io | bash -s stable
rvm -v
2>安装homebrew:
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew -v
3>安装xcode command line:
xcode-select --install
xcode-select -v
4>安装ruby:
rvm list known
rvm install 2.4.0
ruby -v
2.安装Cocoapods
sudo gem install cocoapods
教程：https://blog.csdn.net/zhanglizhi111/article/details/76657982
//使用Cocoapods
cd ./project
pod init
pod install --no-repo-update
#Podfile
platform :ios, '8.0'
target '项目名' do
use_frameworks!
pod 'NSLogger'
pod 'AFNetworking'
pod 'FMDB'
pod 'UICKeyChainStore'
pod 'SCLAlertView-Objective-C'
pod 'FTIndicator/FTProgressIndicator'
pod 'FTIndicator/FTToastIndicator'
pod 'IQKeyboardManager'
pod 'MKDropdownMenu'
pod 'CLGO', :git => 'ssh://git@git.changmeng.com/ios/sdk.v3.8.git', :branch => 'appstore-bt'
end
pod update --no-repo-update
//升级本机pod库
pod repo update master
//编写podspec文件：NO
//利用CocoaPods创建静态库：NO
//新建静态库
https://segmentfault.com/a/1190000011428874
//打包静态库
#sudo gem install cocoapods-packager
#cd ./CLGO.podspec
#pod package CLGO.podspec --force --verbose //常规打包
#pod package CLGO.podspec --force --no-mangle --verbose //含.a的打包
http://www.jianshu.com/p/605350a7b1dd

#真机调试：
//真机和模拟器的环境差异
1.内存环境和网络环境；
2.传感器：磁力计、陀螺仪、距离传感器不能再模拟器上使用；
3.特定功能：打电话、拍照、发短信、蓝牙不能在模拟器上使用；
//开发者账号
个人账号：99$ == 688¥
公司账号：99$ == 688¥
企业账号：299$
注意：1.bundle id使用通配符会有很多App服务不能选；
2.添加设备UUID一年只可以添加100次(不是100台)；
3..cer文件是身份证<-->.p12是复印件
4.免费账号(1822512598@qq.com)需要加入开发者计划(99$)；
5.Xcode7.0以后：只需要Apple ID(免费)、可以自动生成证书、开始真机调试；

#App版本：
/*
x-重构
y-大版本：加入新功能
z-修复bug
*/
iOS x.y.z

#应用发布：特别擅长
//App Store：主要渠道，占比超过95%
1.准备材料：
项目源代码；打包成ipa，直接上传；
关键字：5个、标点符号必须是英文
项目描述：标点符号必须是英文
iTunes图标：512*512\1024*1024两张
截图(5/5s 6 6s X)100%屏幕
2.步骤：
一.生成CSR文件：
1.应用程序—>实用工具—>钥匙串访问->证书助理—>从证书颁发机构请求证书；
2.填写电子邮箱地址—>存入到硬盘；
二.进入itunesconnect.apple.com：新建App
三.登录后台：developer.apple.com
1.上传CRS文件,生成证书dev/dis；
2.新建App ID：一般会有运营帮助新建完成；
3.配置Provisioning Profiles(配置文件)；
四.打包App；
五.提交App至后台；
六.提交App到App Store；
七.版本更新：加版本号、重新提交审核；
//越狱平台：逐渐消失
//企业签分发：工会等渠道
//TestFlight：测试分发、https://testflight.top
/******************************补充知识点******************************/
#PCH文件：参考Res/项目中常见的文件(PCH)

#正则表达式：
代码：NewNetworkViewController.h/m
搜索NSRegularExpression

#谓词： NSPredicate
概念：OC中谓词操作是针对于数组类型的，这样的好处是我们可以不需要编写很多代码就可以去操作数组、过滤数据；
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searcgString];
_ArrM = [NSMutableArray arrayWithArray:[_Arr filteredArrayUsingPredicate:predicate];//过滤数据

//僵尸对象：只要一个对象被释放了，我们就称这个对象为“僵尸对象”
开启监听“僵尸对象”：Edit Scheme->Run->Diagnostics->勾选Zombie Objects
//野指针：当一个指针指向一个僵尸对象，我们就称这个指针为“野指针”
//空指针nil：为了避免给野指针发送消息会报错，一般情况下，当一个对象被释放以后我们会将这个对象
的指针设置为空指针；
//控制器：凡是继承于UIViewController的对象都是控制器
特点：每个控制器都有一个UIView、本身不可见、每个控制器都有一个UIView属性、管理一个软件界面
//nil：0x0

//获取当前时间
NSString *currentTime = [NSString stringWithFormat@"%@",[NSDate date]];
//屏幕常亮不变暗
[UIApplication sharedApplication].idleTimerDisabled = YES;
//隐藏NavigationBar
[self.navigationController setNavigationBarHidden:YES animated:YES];
//plist转NSArray
NSString *path = [[NSBundle mainBundle] pathForResource:@"Flower" ofType:@"plist"];
NSArray *array = [NSArray arrayWithContentsOfFile:path];
//跳转：隐藏TabBar
TestViewController *vc = [[TestViewController alloc] init];
vc.hidesBottomBarWhenPushed = YES;
[self.navigationController pushViewController:vc animated:YES];
//添加Zapfino.ttf字体
UILabel *label = [[UILabel alloc] init];
label.text = @"sd¥ƒ∆®∞∂∆";
label.font = [UIFont fontWithName:@"Zapfino" size:15];
//跳转系统浏览器
if ([[UIApplication sharedApplication] respondsToSelector:@selector(openURL:options:completionHandler:)]) {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url] options:@{}
    completionHandler:^(BOOL success) {
    }];
} else {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
}
//时间格式
NSString *data = [NSString stringWithFormat:@"%.2d:%.2d:%.2d",self.hour,self.minute,self.second];
//读取文件内容：dict.txt
NSString *fileConent = [[NSString alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"dict" ofType:@"txt"] encoding:NSUTF8StringEncoding error:nil];
NSArray *words = [fileConent componentsSeparatedByString:@"\n"];//转换成NSArray
//近距离感应
[[UIDevice currentDevice] setProximityMonitoringEnabled:YES];//打开红外线开关
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeAction:) name:@"UIDevieceProximityState" object:nil];//添加监听
- (void)changeAction:(NSNotification *)notification {
    if([[UIDevice currentDevice] proximityState]) {
        NSLog(@"靠近");
    } else {
        NSLog(@"远离");
    }
}
//json转换成字典
NSDictionary *dict=[NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
//根据字体计算高度：一行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = [name sizeWithAttributes:nameAtt];
CGFloat width = nameSize.width;
//根据最大宽度计算高度：多行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = CGSizeMake(100, MAXFLOAT);//宽度固定100，高度不确定
CGSize textSize = [name boundingRectWithSize:nameSize options:NSStringDrawingUsesLineFragmentOrigin attributes:nameAtt context:nil].size;
CGFloat height = textSize.height;
//https://www.cnblogs.com/niit-soft-518/p/6373601.html

#常见第三方库(Swift)：
https://github.com/SnapKit/Snapkit //Snapkit：自动布局
https://github.com/dacaizhao/MJExtensionSwift //MJExtensionSwift：字典转模型
https://www.jianshu.com/p/f4282df18537
https://www.jianshu.com/p/c74f6abc2eb7
https://www.jianshu.com/p/68e12b966d86

#制作静态库SDK：
//打包.a：
https://www.jianshu.com/p/a1dc024a8a15
//打包framework：
https://blog.csdn.net/sadsadaadsd/article/details/77878279
//swift打包静态库：不支持静态库
https://blog.csdn.net/lvchenqiang_/article/details/79077679
#DrawRect：NO
概念：Quartz 2D是一个基于CoreGraphics框架来实现的二维绘制引擎，同时支持iOS和Mac系统；
作用：绘制图形、线、三角形、圆、弧形；绘制文字；绘制/生成pdf；截图/裁剪图片；自定义UI；
https://blog.csdn.net/potato512/article/details/56845385
https://blog.csdn.net/mangosnow/article/details/37054765#0-qzone-1-85099-d020d2d2a4e8d1a374a433f596ad1440
/******************************面试部分******************************/
#Instruments：NO

#Interface Builder介绍：用来管理xib、storyboard

//UITableView的性能：cell的复用机制
移动设备的内存有限，如果使用一个cell就创建一个cell对象将会耗尽设备的内存。解决该问题需要引入
cell的复用机制：当UITableView发生滚动的时候，部分cell会移出窗口，这时候系统会将窗口外的
cell放入cell对象池中，等待复用。当UITableView要求dataSource返回cell的时候，dataSource
会首先查看cell对象池，返回cell对象池中未使用的cell给UITableView，从而避免创建新cell对象。
//线程有几种状态：5种状态
新建New--就绪Runnable--运行Running--阻塞Blocked--死亡Dead
//http/https的区别：
http协议是明文协议、https是添加了加密和认证的协议
//常见的网络协议：
http协议、https协议、TCP/IP协议、FTP协议
//TCP/UDP的区别：
TCP是面向连接的，提供可靠的服务，UDP是无连接的，尽最大努力交付，不保证可靠服务；
TCP通过校验、重传控制、确认应答实现可靠传输，UDP具有较好的实时性；
TCP连接只能支持点对点，UDP支持交互通信；
//Internet采用哪种网络协议？该协议的主要层次结构？
tcp/ip协议，层次结构：应用层/传输层/网络层/数据链路层/物理层
//OSI七层网络模型：
应用层：为应用程序提供服务
表示层：数据格式转化、数据加密
会话层：建立、管理和维护会话
传输层：建立、管理和维护端到端的连接
网络层：IP选址及路由选择
数据链路层：提供介质访问和链路管理
物理层：物理设备标准
//产生死锁的原因：
死锁：多个进程在执行过程中，因为资源竞争而造成的阻塞现象；
1.互斥条件：xxx
2.请求和保持条件：xxx
3.不剥夺条件：xxx
4.环路等待条件：xxx
//处理死锁的办法：
1.预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件；
2.避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁；
3.检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉；
4.解除死锁：该方法与检测死锁配合使用；
//请列举几种源代码管理工具，并说明区别：
源代码管理工具：svn、git
区别：1.在很多情况下，git的速度远远比svn快；
2.svn是集中式管理，git是分布式管理；
3.svn必须联网才可以正常工作,git支持本地版本控制；
//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；
//KVC、KVO的底层实现：
xxx
//为什么加上__block就可以在block内部修改变量：
因为没有添加__block是值传递、加上__block是地址传递；
//[self class]|[self superclass]：
1.[self class]获取当前方法调用者的类；
2.[self superclass]获取当前方法调用者的父类；
//const和宏的区别：swift没有宏
1.编译时刻：const：编译、宏：预编译(Xcode打开项目的时候读条阶段)
2.编译检查：const有编译检查、宏没有编译检查
3.宏的好处：const不可以定义函数|方法、宏可以定义函数|方法
4.宏的坏处：大量使用宏导致预编译时间过长
blog：大量使用宏导致内存爆增！错误
//block怎么会导致循环引用：
xxx
//简述远程推送的步骤：
我们一般利用第三方极光推送完成远程推送功能：
1.登录苹果开发者后台，创建项目推送证书；
2.登录极光推送后台，上传证书，创建应用；
3.获取到AppKey、导入必要类库、按照开发文档操作；
//第三方登录总结：
xxx
//有哪些技术可以实现定位：
基站、GPS
//社会化分享总结：
1.对于系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：不需要集
成第三方库,不需要App Key;缺点：页面简单,不能自定制；
2.对于第三方分享：一般使用shareSDK，首先进入shareSDK官网获取App Key，集成shareSDK，
想要分享至哪些平台就去相应开放平台申请AppKey和AppSecret，然后按照文档构建分享内容。
//RSA加密算法：公钥加密算法
RSA加密算法除了可加密、解密之外，还可用来作签名校验：简单的说,RSA会生成一个私钥和
一个公钥，私钥你应该独自保管，公钥你可以分发出去；做签名验证时,你可以用私钥对需要传输
的数据做签名加密，生成一个签名值，之后分发数据,接收方通过公钥对签名值做校验，如果一致
则认为数据无篡改。
//参考：
http://blog.csdn.net/leaf8742
https://www.jianshu.com/p/1a94498de7f4
https://www.jianshu.com/p/2e1b3f54b4f3
