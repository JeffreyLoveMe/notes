// NSString为什么使用Strong而不使用Copy?
//runloop常驻线程NSURLConnection：为什么AF2.0使用常驻线程？AF3.0就抛弃了？
//App启动优化：有哪些建议？了解过dyld吗？
//符号是怎么绑定在地址上的？能写一个hotReload框架吗？
//iOS崩溃是什么导致的？如何监控不同类型的崩溃？
//如何获取详细的内存分配信息：比如不同线程的堆栈调用？
//Apple为什么设计元类？
//retain、copy/mutableCopy、release有什么区别？
1.retain引用计数+1，没有创建新对象；
2.copy（不可变对象）/mutableCopy（可变对象）引用计数+1，创建新对象；/不是所有
对象都具备copy功能：必须实现<NSCopying/NSMutableCoping>协议
3.release
//Xcode中选择模拟器编译，在 products 中生成的二进制文件后缀是什么？
/// 换一种通用写法
// 冒泡排序：将相邻元素两两排序让较大的数沉底、一共需要(N-1)轮排序
3 5 8 6 2  // 原始数据
3 5 6 2 8  // 第一轮排序
3 5 2 6 8  // 第二轮排序
3 2 5 6 8  // 第三轮排序
2 3 5 6 8  // 第四轮排序
#include <stdio.h>
int main() {
    int arr[5] = {3,5,8,6,2};
    int temp;
    //外层循环控制轮数
    for(int i = 0;i < 4;i++) {
        for(int j = 0;j < 4-i;j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
        for(int k = 0;k < 5;k++) {
            printf("%d ",arr[k]);
        }
        printf("\n");
    }
    return 0;
}
// 选择排序：从下标0开始，依次作为待比较的元素，从待比较的元素开始向后遍历数组找到最小的
元素与待比较的元素交换，一共需要(N-1)轮排序
4 8 7 2 6  // 原始数据
2 8 7 4 6  // 第一轮排序
2 4 7 8 6  // 第二轮排序
2 4 6 8 7  // 第三轮排序
2 4 6 7 8  // 第四轮排序
#include <stdio.h>
int main() {
    int arr[5]={4,8,7,2,6};
    int max;
    int pos;
    //外层循环控制排序轮数
    for(int i=0;i<4;i++) {
        max = arr[i];
        pos = i;
        //里层循环控制选择一个值最大的元素
        for(int j=i;j<5;j++) {
            if(max < arr[j]) {
                max = arr[j];
                pos = j;
            }
        }
        //用值最大的元素与待比较元素进行交换
        arr[pos] = arr[i];
        arr[i] = max;
    }
    printf("%d\n",arr[1]*arr[2]);
    return 0;
}
#快速排序：NO
#二分查找：NO
// 戴铭
https://github.com/ming1016
https://ming1016.github.io/categories/Programming
77.图片裁剪方法
107.版本控制
/*
1.在MAC环境下,自带了SVN服务器端和SVN客户端功能,所以只需做一下简单地配置
2.SVN的使用
更新数据:
cd  工程目录
svn update
 
上传数据:
将数据放到工程目录
svn commit -m '本次修改你要说的话'
 
上传失败:
svn status
? 表示没有被svn工具管理的文件（夹）
A 表示被标记为新文件（夹）
C 表示冲突的文件（夹）
! 表示已经被版本管理控制,但是在文件夹下边找不到
D 表示已经被标记为删除
 
没有被svn工具管理的文件（夹）:
如果文件是？,代表这个文件夹不被svn所管理。可以
svn add 文件   //表示这个文件夹以及下边的所有的子目录和文件,全部变成add状态
 
删除被svn版本管理控制的文件:
svn delete
 
遇到冲突:
mc(mine  side)   保留自己做的修改,放弃别人做的修改
tc(their side)   保留别人做的修改,放弃自己做的修改
p(postpone)      保留冲突状态,手动解决
 
手动解决冲突:
在<<< === >>>有两个区间,每一个区间代表谁做的修改。解决冲突：要把左尖括号、右尖括
号、等号删除！
手动解决完了所有的冲突(一定要注意解决完了所有的冲突,可以在代码里边搜索======,都没
有的情况下,才算是解决完了所有的冲突)把已经标记为冲突的文件标记为已解决

svn地址重定向:
cd  工作目录
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --
username sally --password sallyssecret
10.5.154.237  上次svn的地址
10.5.154.142  本次svn的地址
sally         你的用户名
sallyssecret  你的密码
 
svn恢复:
svn revert . -R
svn地址重定向

cd 进入工作目录

svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --username sally --password sallyssecret
SVN客户端
SmartSVN
Versions
CornerStone

svn批量添加、批量删除
将所有状态为问号的，使用svn add批量添加
svn st | grep '^\?' | tr '^\?' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn add
将所有状态为叹号的，使用svn delete --force批量删除
svn st | grep '^!' | tr '^!' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn delete --force
*/
108.消息推送、本地推送
/*
推送功能一般分为两种:本地推送和远程推送
1.对于本地推送(UILocalNotification),我们可以先注册通知,然后新建本地推送
,设置本地推送的属性,最后我们执行推送（会调用一个方法）
2.对于远程推送,我们使用第三方极光推送。登录注册极光推送（创建iOS应用开发证
书,在极光推送递交证书创建应用,获取AppKey）
3.下载SDK,添加到项目中。最后按照极光推送官方文档操作
*/
109.第三方登陆、分享
/*
第三方登陆面试总结：
*/
/*
分享面试总结：
1.系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：
不需要集成第三方库,不需要App Key;缺点：页面简单,不能自定制。
2.对于第三方分享：我一般使用shareSDK,首先进入mob.com官网添加应用获取App
Key;然后利用cocoapods集成shareSDK,想要集成那些平台就去那些开放平台申请
AppKey和AppSecret;最后按照文档：首先导入头文件,然后添加各平台应用,最后构建
分享内容,分享~~~~
*/
110.支付
/*
iOS集成支付宝的步骤
1.下载支付宝SDK：https://openhome.alipay.com/platform/document.htm#down
2.提取支付宝SDK以下文件：
AlipaySDK.bundle
AlipaySDK.framework
libcrypto.a
libssl.a
openssl
Order.h
Order.m
Util
3.需要添加的依赖库：
Foundation.framework
UIKit.framework
CoreGraphice.framework
CoreText.framework
QuartzCore.framework
CoreTelephony.framework
SystemConfiguration.framework
libz.tbd
4.添加支付逻辑代码
1）填写商户App申请：商户ID 账号ID 私钥
2）生成订单信息以及签名
3）跳转支付宝钱包由支付宝客户端跟支付宝安全服务器打交道
4）支付完成返回给商户客户端和服务器
*/
112.即时通讯
/*
即时通讯（IM）
一.底层原理
1）用于IM的协议：XMPP（基于XML的协议,具有超强的可扩展性）
2）XMPP有三个部分：服务器 网关 客户端（可以任意两个双向发生）
2）XMPP的优缺点
1.优点：
XMPP协议是自由开源的,而且在C/S都有多种实现
任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接
我们用XMPP技术开发软件,资源以及支持的来源都是多样的,这样就不会被“绑架”
XMPP以TCP传递XML数据流,没有中央主服务器,任何人都可以运行自己的XMPP服务器
XMPP基于XML具有很强的扩展性
2.缺点
XMPP协议的服务器流量存在着被重复转发,使数据负载太重
XMPP协议是基于XML文件的（编码成单一的XML文件）,因此无法提供修改二进制数据
 
二.上层实现（利用环信）
1.环信：通过云端开放的Rest api或者客户端SDK包（摆脱了IM底层开发）,使APP内置聊天功能
2.步骤
1）注册登录“环信”
2）创建应用（应用名称会存在你的AppKey）,生成AppKey和相关配置文件
3）制作并上传推送证书
1.进入developer.apple.com
2.点击Member Center,进入Certificates,Identifiers&Profiles,制作证书
3.选择对应的App ID
4.根据Certificate Assistant的提示,创建Certificate Request
5.上传上一步中创建的Certificate Request文件
6.下载下来这个证书,并双击导入系统
4)上传证书
1.打开Application-Utilities-Keychain Access应用,我们会看到有刚刚制作
好的推送证书
2.选中证书对应的私钥,点右键,选择导出,并设定密码
3.登录环信后台
4.选择对应的App,填写证书名称
5.上传（选择的是开发环境证书还是生产证书）
5）通过cocoapods下载SDK
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件： #import <EaseMobSDKFull/EaseMob.h>
6）设置工程属性
1.导入SDK依赖库（Xcode7.0,后缀是tbd）
MobileCoreServices.framework
CFNetwork.framework
libEaseMobClientSDKLite.a
libsqlite3.dylib
libstdc++.6.0.9.dylib
libz.dylib
libiconv.dylib
libresolv.dylib
libxml2.dylib
2.向Build Settings-Linking-Other Linker Flags中添加-ObjC(注意大小
写）
如果项目中使用-ObjC有冲突,可以添加-force_load来解决：
格式：-force_load[空格]EaseMobSDK/lib/libEaseMobClientSDKLite.a(静
态库的路径-SDK lib里面拖过来) 在-force_load下面
3.编译没错误则说明集成SDK成功
*/
122.瀑布流
/*
1.简单地说:我们利用3个UITableView联动就可以实现瀑布流效果
2.我们利用UIScrollView的代理方法让3个UITableView的偏移量都等于
UIScrollView的偏移量实现联动
3.最好做法：一个cell超过屏幕,我们不要release,而是回收到复用队列,创建cell首先去
复用队列去取,如果没有我们在创建
*/

#指针：
定义：变量的地址(唯一标识一块内存的索引)；
int a;//a变量名、&a变量地址
int *p;//定义一个指针变量p：p指针变量名、*指向
指针变量p的作用：用来存储地址；
*p：指p指向的内容；
p = &a;//将整型变量a的地址赋给指针变量p
*p = a;//*p是p指向的变量
int *p;//变量p是int*类型、int是p指向变量的基类型
int *p = NULL;//指针变量p初始化为空、不能使用空指针
int *p;//未初始化的指针称为野指针、不能使用野指针
printf("&a=%p",&a);//输出变量a的地址：％p地址格式符
注意：1.定义指针时，一定要初始化为空；
2.指针做为参数或者已经赋值，则无需初始化为空；
3.使用指针前，一定要给指针赋值；
4.使用指针时，一定要判空；
if(p == NULL) {
    return;
}
//指针大小：固定4个字节-因为地址在内存中都是以整型的方式分配的

#数组和指针：
概述：数组名作为函数参数，代表数组的首地址；
int *p = NULL;
int a = 5;
p = &a;
p++;//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
//指针数组
int *p[10];//数组：每个元素都是个指向整型的指针
//指向数组的指针
int (*p)[10];//指针：指向10个int元素的数组
//指向指针的指针
int **p;//指针：指向指针
//指向函数的指针
int (*p)(int a);//指向函数的指针
//指针作为函数返回值
格式：数据类型* 函数名(形参列表) {//...}
//交换两个变量？
1.传值：无法实现交换；
2.传地址：交换指针指向，无法实现交换；
3.传地址：交换指针指向变量的值，可以实现交换；

#结构体：
定义：相同或者不同数据类型变量的集合，自定义的数据类型；
格式：放在头文件下面、所有函数上面
//结构体定义用struct关键字，名字为data
struct data {
    //成员变量
    int a;
    char b;
    short c;
};
//结构体别名：wm_data
typedef struct data {
    int a;
    char b;
    short c;
}wm_data;
//难点：结构体指针？

#枚举：枚举就是一串宏
定义：如果变量只有几种可能的值，可以使用枚举；
//枚举可以有无数个：不推荐使用
typedef enum direction {
    枚举1,
    枚举2,
    枚举3
} direction_t;
//定义通用枚举：只能同时存在一个枚举值
typedef NS_ENUM(NSInteger,WMDirection) {
    枚举1,
    枚举2,
    枚举3
};
//定义位移枚举：可以同时存在多个枚举值
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    枚举1,
    枚举2,
    枚举3
};

#共用体：使几个不同变量共同占用一段内存的结构
union date {
    int a;
    char b;
    short c;
};
大小：1.共用体变量所占内存长度等于最长成员的长度；
2.共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种；
3.共用体变量中起作用的成员是最后一次存放的成员；
/******************************Objective-C语言基础******************************/
#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？
/******************************iOS进阶******************************/
#数据持久化的方法
1.数据库：
//sql语句：结构化查询语言
1.创建表
create table if not exists sso (
id integer primary key autoincrement,//将id设为主键
author text,//文本
price real,//浮点型
pages integer);//整型
2.插入
insert into sso (author,price,pages) values(?,?,?);
3.更新
update sso set price = ?,pages = ? where author = ?;
4.删除
delete from sso where pages > ?;
5.查询
select * from sso;
//FMDB
代码：SqliteViewController.h/m
//MagicalRecord：
一.Core Data：
1.新建Core Data；
2.新建表：写上需要存储的文件；
3.关联生成属性类；
二.导入数据：
4.导入MagicalRecord；
三.app启动：
5.设置数据库存放的文件名；
6.让Magical Record支持数据库版本管理；
7.查询所有的数据库内容，如果有内容则送到数据源；
if([MusicInfo MR_findAll].count) {
    for(MusicInfo *music in [MusicInfo MR_findAll]) {
        MusicInformation *musicInfo = [[MusicInformation alloc] init];
        musicInfo.songUrl = music.songUrl;
        musicInfo.songName = music.songName;
        musicInfo.songId = music.songId;
        musicInfo.userName = music.userName;
        musicInfo.albumName = music.albumName;
        musicInfo.albumPic = music.albumPic;
        [[MusicManager sharedIntance].selectMusics addObject:musicInfo];//把对象加到数据源
    }
}
四.app杀掉：
8.删除数据库里的表，将数据源保存；
for(MusicInfo *music in [MusicInfo MR_findAll]) {
    [music MR_deleteEntity];//删除数据表
}
[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
9.新建数据库的表，将数据源所有内容放到数据库，保存；
for(MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
    MusicInfo *zNewMusic = [MusicInfo MR_createEntity];//新建数据表
    zNewMusic.songName = newMusic.songName;
    zNewMusic.songUrl = newMusic.songName;
    zNewMusic.songId = newMusic.songId;
    zNewMusic.userName = newMusic.userName;
    zNewMusic.albumName = newMusic.albumName;
    zNewMusic.albumPic = newMusic.albumPic;
}
/*
1.数据的增删改查
2.多表的链接查询
3.数据回滚
*/
http://hao.jobbole.com/magicalrecord
/******************************补充知识点******************************/
//汉字转码
NSString *oriString = @"\u67aa\u738b";
NSString *escapedString = [oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
//隐藏NavigationBar
[self.navigationController setNavigationBarHidden:YES animated:YES];
//跳转：隐藏TabBar
TestViewController *vc = [[TestViewController alloc] init];
vc.hidesBottomBarWhenPushed = YES;
[self.navigationController pushViewController:vc animated:YES];
//时间格式
NSString *data = [NSString stringWithFormat:@"%.2d:%.2d:%.2d",self.hour,self.minute,self.second];
//读取文件内容：dict.txt
NSString *fileConent = [[NSString alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"dict" ofType:@"txt"] encoding:NSUTF8StringEncoding error:nil];
NSArray *words = [fileConent componentsSeparatedByString:@"\n"];//转换成NSArray
//json转换成字典
NSDictionary *dict=[NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
//根据字体计算高度：一行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = [name sizeWithAttributes:nameAtt];
CGFloat width = nameSize.width;
//根据最大宽度计算高度：多行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = CGSizeMake(100, MAXFLOAT);//宽度固定100，高度不确定
CGSize textSize = [name boundingRectWithSize:nameSize options:NSStringDrawingUsesLineFragmentOrigin attributes:nameAtt context:nil].size;
CGFloat height = textSize.height;
//https://www.cnblogs.com/niit-soft-518/p/6373601.html
CGRectGetMaxX(self.view.size) //矩形中最大x值：布局简单多啦

#RunLoop：底层
作用：1.保持程序的持续运行；
2.处理App中各种事件(触摸事件、定时器事件)；
3.节省CPU资源，提高程序性能；
实质：RunLoop实质是一个死循环，由于main函数中启动了RunLoop才保证了程序不会马上退出，可以
保持持续运行状态；
//CFRunLoopRef
//NSRunLoop：基于CFRunLoopRef的封装
//RunLoop与线程
1.每条线程都有唯一与之对应的RunLoop对象；
2.主线程的RunLoop已经自动创建、子线程的RunLoop需要主动创建；
3.RunLoop在第一次获取线程时创建、在线程结束时销毁；
//RunLoop的运行模式：见Res
http://www.cocoana.com/ios/20150601/11970.html#0-qzone-1-74697-d020d2d2a4e8d1a374a433f596ad1440
/******************************补充知识点******************************/
#函数式编程思想(高聚合：代码聚合、方便管理)：把很多功能放在一个函数块(block)去处理
int a = ({
b = 2;
c = 3;
d = 4;
b + c + d; //最后一句设置返回什么
});
UIButton *btn = ({
UIButton *btn = [UIButton alloc]init];
btn.tag = 1;
btn;//最后一句设置返回什么
});

#马甲包：
//单机游戏和h5链接切换
//2d-x和Unity3d切换
https://github.com/klaus01/KLGenerateSpamCode
https://github.com/2361496651/AutoCreateSpamCode

#第三方服务商：
http://www.mob.com/ //掌淘科技：验证码
https://www.umeng.com/ //友盟：移动统计、消息推送、社会化分享
https://www.xfyun.cn/ //科大讯飞：语音识别、语音转写、语音唤醒

#H5游戏加速器引擎：
https://www.layabox.com/
https://www.egret.com/

#Model：字典转模型
好处：字典的key不会提示错误、Model的属性会提示错误；
//1.实现：需要封装
Shop *shop = [[Shop alloc]init];
shop.icon = dict[@"icon"];
shop.name = dict[@"name"];
[_arrM addObject:shop];
//2.实现：最终方案
//Shop *shop = [Shop alloc] initWithDict:dict];
Shop *shop = [Shop shopWithDict:dict];
/******************************Objective-C语言基础******************************/
#类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#内存管理：
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；
#内存管理
//Objective-C语言：管理对象、基本数据类型不需要管理
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；
/******************************UI基础******************************/
#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#数据源：
实质：数据源实质就是一个数组(NSArray、NSMutableArray)；
Model类必须是单例：全局都可能使用这个Model；
VC需要网络请求，可以委托(PostStore类)来进行网络请求；
PostStore类网络请求完成，需要告诉VC网络请求操作完成；

#瀑布流：
//实现原理：
我们利用多个UITableView联动就可以实现瀑布流效果：调用UIScrollView的代理方法
让多个UITableView的偏移量都等于UIScrollView的偏移量实现联动，当一个cell超过屏
幕，我们不要release，而是回收到复用队列，然后在创建cell的时候首先去复用队列中
取，如果没有我们在创建。
//代码：见WaterFall

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#实现画折线图：利用第三方库
1.加入tk库文件；
2.添加QuartzCore.framework；
/******************************iOS高级******************************/
#多语言：en/tw/cn
定义：根据用户设置的Language and Region Format(语言和区域格式)修改应用
本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html //特别详细
https://www.jianshu.com/p/c7a6408410aa

#多线程：三种形式
线程锁NSLock：百度
信号量：指同时可以执行几个多线程
//多线程：并发执行是假象，实质是CPU快速的在多条线程之间调度
1.使用场景：ASI网络请求、SDWebImage图片下载
2.使用目的：为了使界面流畅，防止界面假死；
3.原理：1s---1000个0.001s
//主线程(UI线程)：程序一启动，系统就会默认创建一条线程
作用：显示刷新UI界面、处理与用户的交互事件；
注意：1.不要处理耗时操作；
2.程序默认开启、程序员不能手动开启主线程；
//线程的状态
新建New-->就绪Runnable-->运行状态Running-->阻塞Blocked
//线程间通信：
定义：在一个进程中，多个线程往往不是彼此独立，需要经常进行通信；
体现：1.一个线程传递数据给另一个线程；
2.一个线程中执行完特定任务后，转到另一个线程继续执行任务；
//实现方案
三.NSOperation：基于GCD、任务为导向的多线程模型、需要管理线程
//1.创建多线程：NSOperation是抽象类，两个子类都可以创建对象
NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self
selector:@selector(downloadImage:) object:nil];
NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    //3.先加载、再更新UI
}]
//2.添加到队列：即可以并行、也可以串行，默认是并发队列、默认_queue.maxConcurrentOperationCount为8
_queue = [[NSOperationQueue alloc]init];//创建NSOperationQueue的队列
_queue.maxConcurrentOperationCount = 2;//设置队列的最大并发数量：同一时间最多有多少任务可以执行
[_queue setSuspended:YES];//暂停：可以恢复、不能暂停当前正在处于执行状态的任务
[_queue setSuspended:NO];//继续执行
[_queue cancelAllOperations];//取消：不可以恢复
[_queue addOperation:operation];
[_queue addOperation:blockOperation];//多线程加到队列中
//可以跨队列依赖
[blockOperation addDependency:operation];//操作依赖：不能循环依赖、blockOperation依赖于operation
//操作监听
blockOperation.completionBlock = ^{
    //注意：执行该block块代码的线程和执行blockOperation操作的线程不一定一致，因为使用GCD和NSOperation技术线程的分配是系统内部决定的
    NSLog(@"任务已经执行完毕--%@",[NSThread currentThread]);
};
//3.先加载、再更新UI
-(void)downloadImage:(NSOperation*)operation {
    //1.加载线程代码
    //2.在主线程更新UI
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];
}
/*
串行执行：不代表只开一条线程(线程同步)
maxConcurrentOperationCount = 0 不会执行任务
maxConcurrentOperationCount = 1 串行队列
maxConcurrentOperationCount > 1 并发队列
maxConcurrentOperationCount = -1 特殊意义：最大值、表示不受限制
*/
_queue.maxConcurrentOperationCount = 1;
94.多线程（三种）
/*
 /// NSOperation:任务为导向的多线程模型
 //创建线程数组
 self.orderThread=[[NSMutableArray alloc]init];
 //创建NSOperationQueue的队列
 self.queue=[[NSOperationQueue alloc]init];
 //设置队列的最大并发数量
 self.queue.maxConcurrentOperationCount=2;
 //创建多线程
 NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
 //执行多线程
 }];
 //多线程加到队列中
 [self.queue addOperation:blockOperation];
 //多线程加到线程数组中
 [self.orderThread addObject:blockOperation];
 //blockOperation.isCancelled
 //blockOperation.isExecuting
 //blockOperation.isFinished
 
 /// GCD:block版本的线程模型
 //创建GCD组别（记录有多少主线程之外的线程）
 dispatch_group_t group=dispatch_group_create();
 //将GCD组别+1(执行异步线程之前)
 dispatch_group_enter(group);
 //执行异步线程
 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0),^{
 //执行线程
 [self.lock lock];
 [self.lock unlock];
 //将GCD组别-1（异步线程执行外后）
 dispatch_group_leave(group);
 });
 //GCD组别为0时
 dispatch_group_notify(group, dispatch_get_main_queue(), ^{
 if(group==0){
 //刷新UI主线程
 }
});
//NSOperation两个子类
NSOperation是一个多线程任务，用于把它放到队里边当中执行
NSInvocationOperation
新建一个任务，在这个任务当中会执行target的selector方法
NSBlockOperation
新建一个任务，在这个任务当中会执行block里边的代码块
NSOperation的cancel消息，直接让Operation取消
在任务内部，不需要自己写isCancel的处理了
NSOperationQueue
// 向队列当中，添加任务
addOperation
// 队列的最大并发数量
maxConcurrentOperationCount
// GCD
用来维护一个计数器
当这个计数器回到0的时候，会触发notify的block
dispatch_group_t
dispatch_group_create
dispatch_group_enter
dispatch_group_leave
当group计数器回到0的时候，在指定的queue里边，执行block
dispatch_group_notify(group, queue, block)
信号量
dispatch_semaphore_t
dispatch_semaphore_create
dispatch_semaphore_wait
dispatch_semaphore_signal
信号量
跟线程锁(NSLock)概念差不多
将线程锁，理解成来回两车道，同方向前车在那停着，后车必须等
其实就是信号量为1的时候
信号量可以定义堵塞的数量
比如说信号定义了堵塞数量为2，同方向前车在那堵着，但是另外一条车道有一个空的，所以后车可以选择绕过去
但是如果同方向两车道都有车在那停着，后车必须也等待，等待到有任何一个车被释放，才可以继续往前开
*/

#用户通知：
//概述：
推送功能一般分为两种：本地推送和远程推送；
1.对于本地推送(UILocalNotification)，我们可以先注册通知；
然后新建本地推送，设置属性；最后执行推送(会调用某个方法)；
2.对于远程推送，我们使用第三方极光推送，按照极光推送文档操作；
//本地通知(本地推送)：
定义：由App发送到当前设备，不需要网络支持；
问题：什么时候使用本地通知？App在前台需要与客户交互的时候使用本地通知；
本地通知怎么在AppDelegate.m中使用？
代码：AppDelegate.m
//远程通知(远程推送)：由App服务端->APNs服务器->设备
https://www.jianshu.com/p/ad43bc1a970a

#基于位置的服务LBS：
//系统定位
1.导入MapKit.framework，创建MKMapView
2.显示用户位置，把MKMapkit加到self.view，设置代理
3.导入CoreLocation.framework，创建CLLocationManager(定位对象)设置属性
4.问用户是否允许更新用户信息：开始更新
5.设置代理
6.需要在Info里边添加两项:
1)当APP在前台的时候才使用,会跟用户弹出一个确认框：
NSLocationWhenInUseUsageDescription
2)当APP总是请求用户定位的时候,会跟用户弹出一个确认框：
NSLocationAlwaysUsageDescription
代码：MapViewController.h/m
//大头针：知道经纬度就可以标注位置
1.导入两个框架 MapKit.framework、CoreLocation.framework；
2.创建MKMapView把地图显示出来；
3.定义显示标注的类(MyAnnotation类)，实现MKAnnotation协议；
4.从协议复制属性，初始化协议属性；
5.给地图添加标注：MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
6.给地图添加标注：[self.mapview addAnnotation:a];
代码：MKAnnotation.h/m
//高德地图
1.登录LBS开放平台，申请Key；
2.下载相关SDK和实例代码；
https://blog.csdn.net/a910577347/article/details/73499515
//百度地图
1.登录LBS开放平台，获取密钥；
2.下载相关SDK和实例代码；
https://www.jianshu.com/p/b0169d332918
//腾讯地图
1.登录LBS开放平台，获取参数；
2.下载相关SDK和实例代码；
https://blog.csdn.net/liyun123gx/article/details/44222255
96.map（大头针）
/*
1.有哪些技术可以实现定位：GPS 基站
2.系统提供两个框架：MapKit.framework   CoreLocation.framework
3.MKMapView可以加载地图
4.有三种地图类型
typedef NS_ENUM(NSUInteger, MKMapType) {
MKMapTypeStandard = 0,
MKMapTypeSatellite,
MKMapTypeHybrid,
MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
} NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED;
5.设置代理
*/
/*
1.CL-CoreLocation框架
2.导入CoreLocation框架,使用CLLocationManager核心类
3.创建CLLocationManager核心类
4.[self.locationmanager locationServicesEnabled]为YES-GPS服务可用
*/
/*
在地图上标注位置
1.导入两个框架 MapKit.framework   CoreLocation.framework
2.创建MKMapView把地图显示出来
3.定义显示标注的类（MyAnnotation类）,实现MKAnnotation协议
1）从协议复制属性
2）初始化协议属性：
4.给地图添加标注
MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
//给地图添加标注
[self.mapview addAnnotation:a];
//平移
MKCoordinateRegion region;
region.center.latitude=30.5;
region.center.longitude=116.8;
region.span.latitudeDelta=10;
region.span.longitudeDelta=10;
self.mapview.region=region;
5.知道经纬度就可以标注位置（具体位置借助API）
//定位
需要在Info里边添加两项
当APP在前台的时候才使用，会跟用户弹出一个确认框
NSLocationWhenInUseUsageDescription
当APP总是请求用户定位的时候，会跟用户弹出一个确认框
NSLocationAlwaysUsageDescription
*/
97.地图导航
/*
 高德地图：
 1.高德LBS开放平台：LBS-基于位置的服务
 2.申请Key
 3.下载相关SDK和示例代码
 百度地图：
 1.百度LBS开放平台：
 2.获取密钥（一个密钥对应一个bundle identifier）
 3.相关下载-全部下载
 */

#多媒体：图片、音乐、录音、视频
//上传照片：UIImagePickerController-选择图片类(代理类)
注意：保存图片、UIAlertController打不开
//音频：流的形式
音频录音机-AVAudioRecorder
音频播放器-AVAudioPlayer
//视频：vitamio
视频播放器-MPMoviePlayerController
代码：MediaViewController.h/m
练习：找出实用的第三方框架开发出商用级别项目；
https://blog.csdn.net/Dreamandpassion/article/details/82459246
https://www.jianshu.com/p/d8062b1856f3
92.多媒体（图片、音乐、录音、视频）
/*
1.多媒体：图片,声音,录音,视频
2.UIImagePickerController 选择图片类（代理类）
3.AVFoundation  音乐类（代理类）
1）导入第三方库
2）定义声音对象,创建声音对象
3)创建播放对象,需要传入一个URL,此URL指定了媒体文件的位置,从包里求出MP3的路径是个
字符串
4)设置代理
4.图片：
判断传入的参数(照相机、相册)是否被当前的设备所支持
创建选择图片的对象
设置图片对象打开相册还是照相机
设置控件的代理
显示控件
当选择了一张图片时,会进入到这个代理函数
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
     //被选择的图片,以UIImage对象封装起来,在info的UIImagePickerControllerOriginalImage key值里边
    UIImage *pickImage = info[UIImagePickerControllerOriginalImage];
    self.imageView.image = pickImage;
    //实现了此函数,就需要自己手动地隐藏控件
    [picker dismissViewControllerAnimated:YES completion:^{
    }];
}
//音乐播放
 - (void)play:(id)sender {
 //播放之前,先准备播放
 if ([self.player prepareToPlay]) {
 //准备播放没问题,开始播放
 [self.player play];
 }
}
 - (void)pause:(id)sender {
 //暂停
 [self.player pause];
}
 - (void)stop:(id)sender {
 //停止
 [self.player stop];
 }
 currentTime:当前播放的位置(以秒为单位)(可读写)
 duration:声音的总长度(以秒为单位)(只读)
 - (NSString *)formatTimeWithTimeInterval:(NSTimeInterval)interval {
 NSInteger minute = interval / 60;
 NSInteger second = (NSInteger)interval % 60;
 return [NSString stringWithFormat:@"%ld:%02ld", minute, second];
 }
 - (void)timer:(id)sender {
 self.currentTime.text = [self formatTimeWithTimeInterval:self.player.currentTime];
 if (!self.slider.tracking) {
 self.slider.value = self.player.currentTime / self.player.duration;
 }
}
*/

#分享：
//原生分享
https://blog.csdn.net/qq_28009573/article/details/77744001
//shareSDK集成
注意：1.在Xcode7.0以上，需要在info.plist中设置访问权限；
https://www.cnblogs.com/xubojoy/p/3885932.html
https://www.jianshu.com/p/71499300a133

#第三方登录：基于OAuth2.0协议构建的OAuth2.0授权登录系统
1.微信登录：只提供原生登录方式(必须安装客户端)，所有使用之前必须判断；
https://www.cnblogs.com/sunfuyou/p/7843612.html
2.QQ登录：xxx
https://blog.csdn.net/alexander_wei/article/details/72626396
https://www.jianshu.com/p/133d84042483
3.微博登录：xxx
https://blog.csdn.net/zhonggaorong/article/details/51724810
https://blog.csdn.net/u010545480/article/details/53004699
https://www.jianshu.com/p/87d1d397d269

#支付：
//内购
概述：如果你的App中销售的商品与App的功能有关必须通过内购方式购买；
特点：1.不允许自定义价格；
2.消耗型项目/非消耗型项目/自动续订订阅；
https://blog.csdn.net/xiaoxiangzhu660810/article/details/17434907#0-qzone-1-51422-d020d2d2a4e8d1a374a433f596ad1440
//第三方支付：
http://www.cocoachina.com/ios/20151008/13506.html#0-qzone-1-88885-d020d2d2a4e8d1a374a433f596ad1440
1.支付宝：
https://blog.yayuanzi.com/12276.html
https://openhome.alipay.com/platform/document.htm#down
http://www.cnblogs.com/siyuan123/p/4872378.html?from=timeline&isappinstalled=0
2.微信：
https://www.jianshu.com/p/af8cbc9d51b0
https://www.jianshu.com/p/162ece335b31
3.银联：NO
4.平台币：NO
5.集成三方平台支付：海马、同步推、爱思

#断点续传：
定义：指任务在上传/下载的时候被人为划分为几个部分：每个部分采用一个线程进行上传/下载，如果遇到网络故障可以
继承在未完成的部分继续开始，没必要从头开始下载。
//原理
https://www.cnblogs.com/wangzehuaw/p/5610851.html
https://www.cnblogs.com/findumars/p/5745345.html
//实现
https://www.jianshu.com/p/0e6deea7de87
https://www.jianshu.com/p/01390c7a4957
https://blog.csdn.net/stree7cleaner/article/details/51440774
https://blog.csdn.net/lcg910978041/article/details/51487485

#即时通讯IM：
//底层原理：
1.协议：XMPP协议(基于xml的协议，具有超强的可扩展性)
2.XMPP的三个部分：服务器、网关、客户端(可以任意两者双向发生)
3.XMPP优缺点：
//优点：
1).XMPP协议是自由开源的，而且在C/S都有多种实现；
2).任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接；
3).利用XMPP技术开发软件，资源以及支持的来源都是多样的，这样就不会被“绑架”；
4).XMPP以TCP传递XML数据流，没有中央主服务器，任何人都可以运行自己的XMPP服务器；
5).XMPP基于XML具有很强的扩展性；
//缺点：
1).XMPP协议的服务器流量存在着被重复转发，数据负载太重；
2).XMPP协议基于XML文件(编码成单一的XML文件)，因此无法提供修改二进制数据；
//上层实现：环信
概述：环信通过云端开放的Rest api或者客户端SDK，摆脱IM底层开发，使App内置聊天功能；
步骤：1.制作推送证书、登录环信后台、创建应用生成AppKey；
2.通过cocoapods下载SDK：
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件：#import <EaseMobSDKFull/EaseMob.h>
3.按照环信集成开发文档操作；

#二维码：
应用：ZBarSDK第三方库
https://blog.csdn.net/he_jiabin/article/details/47786031

#App换肤：
http://www.cocoachina.com/ios/20171012/20762.html

#图文混排：
https://blog.csdn.net/qcx321/article/details/52194835

#webview混排：
https://blog.csdn.net/u010960265/article/details/80563668

#iPad开发：
//iPad和iPhone开发的异同
https://blog.csdn.net/wujakf/article/details/80223046
//iPad项目开发总结
https://www.jianshu.com/p/522c8993572b
/******************************实战操作******************************/
#svn：开源的集中式版本控制工具(trunk/branches/tags)
官网：https://subversion.apache.org/
客户端：SmartSVN、CornerStone
安装：NO
在mac环境下，自带svn服务端和客户端功能，只需要做简单配置；
svn help //查看svn所有命令
cd+工程目录 //进入工程目录
svn checkout 服务器地址 --username=xwj --password==xwj123456 //将服务器代码完整的下载到本地
------------------------------------------------------------
svn status //查看文件状态
' ' 没有修改
'A' 被添加到本地代码仓库
'C' 冲突
'D' 被删除
'I' 被忽略
'M' 被修改
'R' 被替换
'X' 外部定义创建的版本目录
'?' 文件没有被添加到本地版本库内,不在SVN的管理之下
'!' 文件丢失或者不完整(不识别该文件)
'~' 受控文件被其他文件阻隔
'U' 更新最新的代码到本地(本地有文件的情况下)
'G' 产生冲突后,更新操作去解决冲突,相当于进行合并
------------------------------------------------------------
svn add * //添加文件
svn commit -m "本地修改说明" //将本地修改的内容提交到服务器
svn update //将服务器最新代码更新到本地
svn remove person.h  //删除svn版本管理控制的person.h文件
//版本回退：
1.本地版本回退
svn update -r7 //回退到第7个版本：查看是否是需要的版本
svn update //更新到最新版本
svn merge -r7:6 person.h //person.h回退到第6个版本
2.服务器版本回退
svn update
//查看版本信息
svn update //更新
svn log //查看某个文件的日志
//遇到冲突
mc(mine side) //保留自己的修改，放弃别人的修改
tc(their side) //保留别人的修改，放弃自己的修改
p(post pone) //延迟解决冲突：展示所有冲突的文件，手动解决冲突
svn resolved 文件名 //解决了某个文件的冲突：必须写
//svn地址重定向：
cd ./workspace
/*
10.5.154.237 上次svn的地址
10.5.154.142 本次svn的地址
sally 你的用户名
sallyssecret 你的密码
*/
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --username sally --password secret
//svn恢复
svn revert . -R
注意：1.本地版本号<服务器版本号->则不允许提交；
2.如果使⽤静态库需要特别注意：必须使⽤命令⾏将静态库添加到svn的管理之下；svn add xxx.a
https://my.oschina.net/joanfen/blog/194491#0-qzone-1-42949-d020d2d2a4e8d1a374a433f596ad1440

#git：开源的分布式版本控制工具(master/branches/tags)
开发者：Linux操作系统的作者Linus Torvalds；
客户端：SourceTree
安装：NO
创建代码仓库：git init
配置身份：查看是否配置OK
git config --global user.name "Tony"
git config --global user.email "tony@gmail.com"
添加：git add 文件名
提交：git commit -m "说明.txt"
加入.gitignore-允许用户将指定的文件或目录排除在版本控制之外的机制；
查看状态：git status
查看修改内容：git diff
撤销修改：git checkout
查看提交内容：git log
删除person.m文件：git rm person.m
版本回退：git reset --hard HEAD //没有push
1.git reset --hard HEAD^ //有push、回到上一个版本
2.git push -f //强制推送：必须让同事也要版本回退、不然同事本地不是消失！！！
git reset --hard HEAD^^ //回到上上一个版本
git reset --hard HEAD~100 //回到前100个版本
git reset --hard HEAD 版本号(前5位) //回到指定版本
//git分支：
查看分支：git branch -a
创建分支：git branch 分支名
合并分支：git checkout master->git merge 分支名
删除分支：git branch -D 分支名
解决冲突：git无法帮助你；
#与远程版本库协作：NO
//.gitignore
https://github.com/github/gitignore
//忽略UserInterfaceState.xcuserstate的方法：
https://blog.csdn.net/lovenjoe/article/details/50053255
//打tag：发现bug可以直接把这个tag变成分支
git tag -a tag名 -m "你想要说你的话"
git tag
git push origin tag名
//ssh keys认证
1.公钥：存在github上用来解密的key
2.私钥：存在本地一个.ssh文件夹下用来加密

#CocoaPods：https://segmentfault.com/a/1190000011428874
//安装Cocoapods
1.安装Ruby
1>安装RVM:
curl -L get.rvm.io | bash -s stable
rvm -v
2>安装homebrew:
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew -v
3>安装xcode command line:
xcode-select --install
xcode-select -v
4>安装ruby:
rvm list known
rvm install 2.4.0
ruby -v
2.安装Cocoapods
sudo gem install cocoapods
教程：https://blog.csdn.net/zhanglizhi111/article/details/76657982
//使用Cocoapods
cd ./project
pod init
pod install --no-repo-update
#Podfile
platform :ios, '8.0'
target '项目名' do
use_frameworks!
pod 'NSLogger'
pod 'AFNetworking'
pod 'FMDB'
pod 'UICKeyChainStore'
pod 'SCLAlertView-Objective-C'
pod 'FTIndicator/FTProgressIndicator'
pod 'FTIndicator/FTToastIndicator'
pod 'IQKeyboardManager'
pod 'MKDropdownMenu'
pod 'CLGO', :git => 'ssh://git@git.changmeng.com/ios/sdk.v3.8.git', :branch => 'appstore-bt'
end
pod update --no-repo-update
//升级本机pod库
pod repo update master
//编写podspec文件：NO
//利用CocoaPods创建静态库：NO
//新建静态库
https://segmentfault.com/a/1190000011428874
//打包静态库
#sudo gem install cocoapods-packager
#cd ./CLGO.podspec
#pod package CLGO.podspec --force --verbose //常规打包
#pod package CLGO.podspec --force --no-mangle --verbose //含.a的打包
http://www.jianshu.com/p/605350a7b1dd
/******************************补充知识点******************************/
#PCH文件：参考Res/项目中常见的文件(PCH)

#正则表达式：
代码：NewNetworkViewController.h/m
搜索NSRegularExpression

#谓词： NSPredicate
概念：OC中谓词操作是针对于数组类型的，这样的好处是我们可以不需要编写很多代码就可以去操作数组、过滤数据；
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searcgString];
_ArrM = [NSMutableArray arrayWithArray:[_Arr filteredArrayUsingPredicate:predicate];//过滤数据

#深拷贝/浅拷贝：
//定义
深拷贝：生成值一样，内存地址不一样的全新对象-内容拷贝
浅拷贝：使原对象的引用计数+1，没有创建全新的对象，直接返回被拷贝对象的地址-指针拷贝
//不可变字符串：右侧如果是copy，那么就是浅拷贝；右侧如果是mutableCopy,那么就是深拷贝
NSString *msg0 = @"";
NSString *msg2 = [msg1 mutableCopy];//深拷贝
NSString *msg1 = [msg0 copy];//浅拷贝：对原对象进行一次retain、对拷贝出来的对象进行一次release
//可变字符串：右侧无论是copy还是mutableCopy，都是深拷贝
NSMutableString *msg3 = [NSMutableString stringWithString:@""];
NSString *msg1 = [msg0 copy];//深拷贝
NSString *msg2 = [msg1 mutableCopy];//深拷贝
注意：1.浅拷贝类似retain，深拷贝类似copy；
2.参考：https://blog.csdn.net/chenyufeng1991/article/details/51771728
-(id)copyWithZone:(NSZone *)zone {

}
-(id)mutableCopyWithZone:(NSZone *)zone {

}

#DrawRect：NO
概念：Quartz 2D是一个基于CoreGraphics框架来实现的二维绘制引擎，同时支持iOS和Mac系统；
作用：绘制图形、线、三角形、圆、弧形；绘制文字；绘制/生成pdf；截图/裁剪图片；自定义UI；
https://blog.csdn.net/potato512/article/details/56845385
https://blog.csdn.net/mangosnow/article/details/37054765#0-qzone-1-85099-d020d2d2a4e8d1a374a433f596ad1440

#iOS11/12新特性：
https://www.jianshu.com/p/39a5aee18778
/******************************面试部分******************************/
//self.name和_name的区别：
self.name是对set/get方法的简单操作，引用计数+1；
_name是直接操作变量，引用计数不+1；
//UITableView的性能：cell的复用机制
移动设备的内存有限，如果使用一个cell就创建一个cell对象将会耗尽设备的内存。解决该问题需要引入
cell的复用机制：当UITableView发生滚动的时候，部分cell会移出窗口，这时候系统会将窗口外的
cell放入cell对象池中，等待复用。当UITableView要求dataSource返回cell的时候，dataSource
会首先查看cell对象池，返回cell对象池中未使用的cell给UITableView，从而避免创建新cell对象。
//线程有几种状态：5种状态
新建New--就绪Runnable--运行Running--阻塞Blocked--死亡Dead
//http/https的区别：
http协议是明文协议、https是添加了加密和认证的协议
//get/post的区别：
1.get获取数据、post更新数据
2.get请求的数据会明文出现在url上、post请求的数据会封装在请求体种。 相对安全
3.get请求的数据受到浏览器/服务器对url长度的限制、post没有限制
//常见的网络协议：
http协议、https协议、TCP/IP协议、FTP协议
//TCP/UDP的区别：
TCP是面向连接的，提供可靠的服务，UDP是无连接的，尽最大努力交付，不保证可靠服务；
TCP通过校验、重传控制、确认应答实现可靠传输，UDP具有较好的实时性；
TCP连接只能支持点对点，UDP支持交互通信；
//Internet采用哪种网络协议？该协议的主要层次结构？
tcp/ip协议，层次结构：应用层/传输层/网络层/数据链路层/物理层
//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；
//请列举几种源代码管理工具，并说明区别：
源代码管理工具：svn、git
区别：1.在很多情况下，git的速度远远比svn快；
2.svn是集中式管理，git是分布式管理；
3.svn必须联网才可以正常工作,git支持本地版本控制；
//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；
//为什么加上__block就可以在block内部修改变量：
因为没有添加__block是值传递、加上__block是地址传递；
//[self class]|[self superclass]：
1.[self class]获取当前方法调用者的类；
2.[self superclass]获取当前方法调用者的父类；
//简述远程推送的步骤：
我们一般利用第三方极光推送完成远程推送功能：
1.登录苹果开发者后台，创建项目推送证书；
2.登录极光推送后台，上传证书，创建应用；
3.获取到AppKey、导入必要类库、按照开发文档操作；
//第三方登录总结：
xxx
//有哪些技术可以实现定位：
基站、GPS
//社会化分享总结：
1.对于系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：不需要集
成第三方库,不需要App Key;缺点：页面简单,不能自定制；
2.对于第三方分享：一般使用shareSDK，首先进入shareSDK官网获取App Key，集成shareSDK，
想要分享至哪些平台就去相应开放平台申请AppKey和AppSecret，然后按照文档构建分享内容。
//参考：
http://blog.csdn.net/leaf8742
https://www.jianshu.com/p/1a94498de7f4
https://www.jianshu.com/p/2e1b3f54b4f3
/******************************swift基础******************************/
#补充知识点：WMGame/swift

#选择器SEL：一个数据类型，内部是消息，类似于函数指针
原理：1.Objective-C在编译的时候，会根据方法的名字(包括参数序列)，生成用来区分这个方法的唯一ID，这个ID就是SEL类型；
2.SEL就是对方法的一种包装。包装的SEL类型数据对应相应的方法地址，找到方法地址就可以调用方法。在内存中每个类的方法都存储在类对象中，每个方法都有一个与之对应的SEL类型的数据，根据一个SEL数据就可以找到对应的方法地址，进而调用方法。
作用：提高执行的效率、增强程序的灵活性；
//创建
@selector 方法选择器
@selector (方法名)
//获取
SEL s1 = @selector(onClick:);
//将一个字符串转换为一个SEL类型
SEL s2 = NSSelectorFromString(@"onRun:");
/**
通过@selector方法获取
SEL s1 = @selector(compare:);
//这个方法用于编译时就能确定调用的方法

通过NSSelectorFromString将一个字符串转换为一个SEL类型
SEL s2 = NSSelectorFromString(@“run:”);
//这个方法用于运行时就能确定调用的方法
*/
//执行SEL
Dog *dog = [[Dog alloc]init];
[dog performSelector:s1];
[dog performSelector:@selector(setName:) withObject:@"Tom"];//最多支持两个参数
//使用@selector对数组排序：
代码：SelViewController.h/m
//在ARC(自动内存管理)的条件下，使用选择器很可能会报警：参照该方式去除报警
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
//执行代码
Dog *dog = [[Dog alloc]init];
SEL s1 = @selector(onClick:);
[dog performSelector:@selector(setName:) withObject:@"Tom"];
#pragma clang diagnostic pop

1.二维数组
1）定义：元素是一维数组的数组称为二维数组
int arr[4][4];

2）二维数组的初始化
int arr[4][4]={   {1,2,3,4},
               {2,3,4,5},
               {3,4,5,6},
               {4,5,6,7} };

3）二维数组的赋值
arr[0][0] = 4;
arr[2][1] = 4;


1.指针
1）指针就是变量的地址；地址就是唯一标识一块内存的索引
int  a;
a         //a是变量名
&a     //a的地址
&       //取地址符

2）指针变量
1.int  *p;   //定义一个指针变量p
   p           //p是指针变量名
  ＊        //指向
指针变量p的作用：指针变量时用来存储地址的
*p: 指p所指向的内容

2.给指针变量赋值
 p=&a;    // 将整型变量a的地址赋给指针变量p
               //p指向变量a，指针变量p同一时刻只能指向一个变量
  a＝3;    //直接的改变了变量a的值
 *p=5;   //间接的改变了变量a的值
            //＊p是p指向的变量

3.指针作为函数参数的使用
int *p; //变量p是int*类型
            //int是p指向的变量的基类型

4.空指针和野指针
int *p = NULL；   //指针变量p初始化为空
                              //NULL代表空，值为0；
                             //不能使用空指针

int  *p；     //未初始化的指针称为野指针
                   //不能使用野指针
3）printf("&a=%p,&b=%p\n",&a ,&b );   //输出变量a,b的地址，％p地址格式符
int *p=NULL;        //p初始化为空，不能使用空指针
4）使用指针注意事项：
1）定义指针时，一定要初始化为空；
int *p=NULL;//指针作为参数或者已经赋值，则无需初始化为空。
2）使用指针前，一定要给指针赋值；
3）使用指针时，一定要判空
if(p==NULL) {
    return;
}

5)指针大小
固定4个字节（因为地址在内存里都是一整型的方式分配的）
char *p
int *q
//p和q都是4个字节。

例如：交换两个变量
#include "jiaohuan.h"
//传值，无法实现交换
void Swap1(int a,int b)
{
    printf("swap1：%p,%p\n",&a,&b);
    int t;
    t = a;
    a = b;
    b = t;
}
//传地址，交换指针指向，无法实现交换
void Swap2(int *c,int *d)
{
    printf("swap2：%p,%p\n",c,d);
    int *t;
    t = c;
    c = d;
    d = t;
}
//传地址，交换指针指向变量的值，可以实现交换
void Swap3(int *e,int *f) {
    printf("swap3：%p,%p\n",e,f);
    int t;
    t = *e;
    *e = *f;
    *f = t;
}
#include <stdio.h>
void Swap1(int a,int b);
void Swap2(int *a,int *b);
void Swap3(int *a,int *b);

#include <stdio.h>
#include "jiaohuan.h"
int main(int argc, const char * argv[]) {
    // insert code here...
    int a = 3;
    int b = 5;
    printf("主函数:%p,%p\n",&a,&b);
    Swap1(a, b);
    printf("a=%d,b=%d\n",a,b);
    
    int c = 3;
    int d = 5;
    printf("主函数:%p,%p\n",&c,&d);
    Swap2(&c, &d);
    printf("c=%d,d=%d\n",c,d);
    
    int e = 3;
    int f = 5;
    printf("主函数:%p,%p\n",&e,&f);
    Swap3(&e, &f);
    printf("e=%d,f=%d\n",e,f);
}

1.指针
1） 数组和指针
数组名作为函数的参数
数组名代表数组的首地址

2）指针++
int *p=NULL;
int a=5;
p=&a;
p++;
//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数。
//指针的移动：必须赋值地址才可以实现指针的移动，不可以赋值指针所指的内容
 q=p  //正确；
q=*p  //错误；
*q=*p//错误；

2.理解内容：
指针数组
int *p[10];
//这是一个数组，10个元素，每个元素都是个指向整型的指针。
//元素为指针的数组
练习：
快速的声明20个int *指针，分别指向int a[20]中的每个元素
指向数组的指针
int (*p)[10];
//这是一个指针，指向10个int元素的数组。
//指向数组的指针
指向指针的指针
int * * p;
//这是一个指针，指向指针
//二级指针
指向函数的指针
int (*p)(int a);//指向函数的指针
//这是一个指针，指向一个函数。
//函数指针
函数指针的声明方法为：
返回值类型 ( * 指针变量名) (形参列表);

3.字符串
1.认识字符串:字符串就是一串字符。
由一对双引号括起来，双引号里面可以写一串字符 。
//“hello world!”是字符串常量。
//字符串中的每个字符占1个字节，字符的个数，比可视的字符多一个。在字符串结尾处有一个’\0’，称作尾零，其ASCII值就是0.
//如上述字符串中有13个字符，12个有效字符。
例如：int arr[5] = {3,4,5,6,7};
char arr[10] = “hello”;   //长度10
char arr[] = “hello”;     //长度6

2.指向字符串的指针：
char * p = "1234567";
//当我们程序中写下"1234567"，就是在【只读数据段】存储了8个字符。
//"1234567”的值只代表第一个字符的所在空间的地址。
练习：
主函数定义一个字符串，编写函数，传递字符串，统计一下字符串中字母的个数；将统计结果返回给主函数。

3.指针作为函数返回值
数据类型＊  函数名（形参列表）
char * MyStr(char * const str,char c);
在字符串str中查找字符c，返回第一次找到c的首地址，如果找不到，则返回NULL；
#include <stdio.h>
char * MyStr(char * str,char c) {
    if(NULL == str) {
        return NULL;
    }
    
    while (*str != '\0') {
        if(*str == c)
        {
            break;
        }
        str++;
    }
    if (*str == '\0') {
        return NULL;
    } else {
        return str;
    }
}
int main(int argc, const char * argv[]) {
     char *p = "hello c dddworld!";
     char *r = MyStr2(p, 'c');
    printf("%s\n",r);
    return 0;
}

char * MyStr2(char * str,char c);


2.结构体
定义：相同或不同数据类型变量的集合
1.结构体的定义
struct data {
    int a;
    char c;
    short b;
};
 
#include <stdio.h>
//结构体定义用struct关键字，结构体名字为data
//结构体命名遵循标示符的定义
//定义一个结构体后，一个新的数据类型诞生了，结构体是自定义的数据类型
//结构体的声明一般放在头文件内，或者 .c 文件的最上面(放在include定义的下面，放在所有函数的上面)
struct data {
    //{}里是定义结构体的成员变量，成员变量可以有无数个，成员变量的数据类型可以相同或不同
    //结构体的成员变量也叫做结构体的属性
    int i;
    char c;
    short b;
};

//结构体取别名
//方式1：在定义结构体时直接取别名，用typedef关键字
//如下定义相当于给struct student取别名为stu
typedef struct student {
    int age;
    char name[10];
    int num;
}stu;

//方式2：定义结构体之后，另起一行取别名
struct class {
    int a;
    short b;
};
//完成给struct class取别名为cla
typedef struct class  cla;

int main(int argc, const char * argv[]) {
    // insert code here...
    //定义一个结构体类型的变量d(也叫做创建一个结构体对象d)
    //struct data是一个结构体类型，相当于int
    //结构体变量也叫做结构体对象
    struct data d;
    //结构体的初始化
    //结构体初始化要分别对每个成员变量进行初始化
    struct data d1 = {5,'a',3};
    
    int a;
    a = 3;
    
    //结构体对象的赋值
    //通过对象访问结构体成员变量用 . 进行访问
    struct data d2;
    d2.i = 4;
    d2.c = 'x';
    d2.b = 3;
    
    //结构体指针
    int *p;
    p = &a;
    *p = 4;
    
    //定义一个结构体指针
    struct data *pst;
    pst = &d2;

    //结构体指针通过 -> 来访问成员变量
    pst->i = 5;
    pst->c = 't';
    
    //结构体数组
    int arr[5];
    
    //定义一个长度为5的结构体数组
    struct data sct[5];
    
    //通过结构体数组访问成员变量
    sct[0].i = 7;
    sct[0].c = 'u';
    sct[3].i = 6;
    
    return 0;
}

2)OC的内存管理
1.引用计数(Reference Count)/保留计数(retain Count)
对于一块动态申请的内存，有一个人（指针）使用，就给这个内存的计数器加1，使用完成后，就给这个计数器减1，当这个内存的引用计数为0了，我们再释放他，这样，上面的问题就解决了。OC，就是使用引用计数这种方式来管理内存的。

3. MRC
1)内存管理的黄金法则
对于引用计数来说，有一套内存管理的黄金法则:
The basic rule to apply is everything that increases the reference counter with alloc, [mutable]copy[withZone:] or retain is in charge of the corresponding [auto]release.
凡是用alloc，retain，new，copy，mutableCopy或者以copy开头，以mutableCopy开头的方法[创建]的对象，都需要用release或autorelease进行释放。
通俗一点的说法就是谁污染谁治理(谁创建谁释放)。
2)alloc与release
ARC模式下创建一个Dog类
@interface Dog : NSObject
@end
@implementation Dog
 - (void)dealloc {
    NSLog(@"dog dealloc");
    //[super dealloc];
}
  @end
dealloc是析构函数，当对象销毁的时候，会自动调用这个方法，我们在这里重写这个方法。

 在main函数里，写入如下代码：
  int main(int argc, const char * argv[]) {
          @autoreleasepool {
           Dog *dog = [[Dog alloc] init];
             }
           NSLog(@"程序即将退出");
           return 0;
      }
 从终端打印信息来看，“程序即将退出”这条打印之前，已经打印dog dealloc，也就是说在程序运行结束前，dog对象已经销毁了。这个是ARC，由Xcode帮我们管理dog对象。
 将ARC改为MRC，再执行程序，dog对象并没有销毁，因为我们现在是手动管理了，我们需要遵守内存管理的黄金法则，Dog *dog = [[Dog alloc] init]; 我们需要对dog进行release。
将main函数代码改为如下形式：
 int main(int argc, const char * argv[]) {
    @autoreleasepool {
       Dog *dog = [[Dog alloc] init];
       [dog release];
       }
    NSLog(@"程序即将退出");
    return 0;
     }
 再次执行程序，从打印可以看出，dog对象已经销毁。这就是黄金法则，我们对dog进行alloc，就要对dog进行release。
注意：release 并不是销毁对象，让对象的引用计数减1，当对象的引用计数为0的时候，自动调用dealloc方法，销毁对象。
3）retain与retainCount
retain：将对象进行保留操作，也就是使对象的引用计数加1。
retainCount：打印一个对象的引用计数。
4）类的组合中使用
在上面代码中，增加Person类
@interface Person : NSObject {
 // 一个人，养了一条狗（持有一条狗）
Dog *_dog;
 }
 - (void)setDog:(Dog *)dog;
  - (Dog *)dog;
 @end
 @implementation Person
/* 版本1 （有问题） 人并没有真正持有狗，如果在main函数里[dog release]，让dog的引用计数减1，就变为0，dog就销毁了。
  - (void)setDog:(Dog *)dog
 {
       _dog = dog;
 }*/

/* 版本2 （有问题） 如果人再持有别的狗，就会造成第一条狗得不到释放，内存泄露。
- (void)setDog:(Dog *)dog
  {
       _dog = [dog retain];
  }*/

 /* 版本3 （有问题） 如果本来持有一条狗，又重新设置这条狗，先进行release，这个时候，很可能dog就销毁了，然后，就没法再次retain了。
 - (void)setDog:(Dog *)dog {
      [_dog release];
      _dog = [dog retain];
}*/
 // 版本4 OK!，标准写法
- (void)setDog:(Dog *)dog {
    if (_dog != dog) {
     [_dog release];
      _dog = [dog retain];
      }
}
  - (Dog *)dog {
      return _dog;
 }
    - (void)dealloc {
    NSLog(@"person dealloc");
     // 人在销毁的时候，一并将持有的dog对象销毁
    [_dog release];
    [super dealloc];
}
7 数组的内存管理
1）当我们创建数组的时候，数组会对每个对象进行引用计数加1
 2）当数组销毁的时候，数组会对每个对象进行引用计数减1
 3）当我们给数组添加对象的时候，会对对象进行引用计数加1
 4）当我们给数组删除对象的时候，会对对象进行引用计数减1
总之，谁污染谁治理，管好自己就可以了（数组内部也遵守内存管理）。
8 ) autorelease与autoreleasepool
        在main函数里写如下代码:
        int main(int argc, const char * argv[]){
            @autoreleasepool {
                          Dog *dog = [[Dog alloc] init];

        //dog并没有马上销毁，而是延迟销毁，将dog对象的拥有权交给了autoreleasepool
            [dog autorelease];

        //这个是可以打印的，因为打印完dog的引用计数后，dog对象才销毁
            NSLog(@"retainCount = %lu",dog.retainCount);
             }
            NSLog(@"程序即将退出");
            return 0;
      }
 autoreleasepool相当于一个数组，如果哪个对象发送autorelease消息，实际将对象的拥有权交给了autoreleasepool；当autoreleasepool销毁的时候，autoreleasepool里持有的对象都发送一个release消息。
4.ARC
1）从Xcode5以后，默认自动内存管理
2）自动引用计数
简单点说就是让编译器完成堆空间的引用计数加减，自动释放。程序员不再写 retain release等方法
3）OC的自动内存管理，不同于JAVA垃圾回收。而是在预处理时，直接在应该保留的地方，添加retain，在应该释放的地方，添加release。是直接添加代码。
从效率上，ARC优于手动内存管理。
    
文件操作
1.数据持久化的方法
通常程序在运行中或者程序结束之后，需要保存一些信息，而且需要持久化存储信息,比如登陆信息、视频播放记录、收藏记录等等,那么我们可以采用以下几种方式对数据进行持久化保存。1.文件    2.plist    3.数据库
2.常用文件操作类
1）NSFileManager（文件管理类）
<1>创建文件管理器单例对象
[NSFileManager defaultManager];

<2>遍历目录下的内容
//浅度遍历当前目录下的文件
[manager contentsOfDirectoryAtPath:path error:&error]

//深度遍历
[manager subpathsOfDirectoryAtPath:path error:&error]

<3>判断文件是否存在
[manager fileExistsAtPath:path]

<4>创建文件
//创建文件
/*参数1：创建文件的路径
参数2：内容，如果nil表示创建一个内容为空的文件。
参数3：nil表示采用默认的设置*/
//如果文件已经存在，会覆盖原来文件。
[manager createFileAtPath:path contents:data attributes:nil];
    
//创建目录
/*参数1：文件夹路径
参数2：是否有中间目录(YES针对所有的情况)
参数3：nil表示采用默认设置
参数4：错误*/

//不会覆盖文件夹内容
[manager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];

<5>拷贝文件/目录
//从哪个路径copy
NSString *fromPath = @"/Users/qianfeng/Desktop/文件夹/testff.txt";
//copy哪个路径
NSString *toPath = @"/Users/qianfeng/Desktop/文件夹/新建文件夹/testff.txt";
//如果文件已经存在是copy不成功的
[manager copyItemAtPath:fromPath toPath:toPath error:&error];

<6>移动文件/目录
[manager moveItemAtPath:fromPath toPath:toPath error:&error];

<7>删除文件/目录
[manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件夹/新建文件夹" error:nil]

<8>获取文件属性    (返回的是字典)
[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件夹/testff.txt" error:nil];

2.3 NSFileHandle（文件句柄类）
对文件进行读写首先需要NSFileHandle打开文件,NSFileHandle对文件进行读写都是NSData类型的二进制数据.
                
<1>打开文件方法
//以只读方式打开
NSFileHandle *readOnlyHandle =  [NSFileHandle fileHandleForReadingAtPath:path]
//以只写方式打开
NSFileHandle *writeOnlyHandle = [NSFileHandle fileHandleForWritingAtPath:path]
//以读写方式打开
NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:path]

<2>读指定长度的数据（单位为字节)
[readOnlyHandle readDataOfLength:5]或者 [readWriteHandle readDataOfLength:5]

<3>从当前偏移量读到文件尾
[readOnlyHandle readDataToEndOfFile];

<4>设置文件偏移量（单位为字节)
[readOnlyHandle seekToFileOffset:5];

<5>将文件偏移量定位到文件尾
[readOnlyHandle seekToEndOfFile];

//如果希望这次写入的数据完全覆盖掉原有数据
//常规做法，短的写入，无法覆盖长的数据
//可以截断原来数据
[readWriteHandle truncateFileAtOffset:0];
//截断到0字节长，即清空原有数据。

<6>写文件(不会覆盖的时候需要设置偏移量)
//当前偏移量指到文件最后
[readWriteHandle seekToEndOfFile];
//写入数据
[readWriteHandle writeData:data];

[readWriteHandle writeData:[@"12345678945343543534543" dataUsingEncoding:NSUTF8StringEncoding]];

 <7>关闭文件句柄
//关闭文件句柄,关闭后(不需要)就不能再操作文件了
[readOnlyHandle closeFile];
[readWriteHandle closeFile];
[writeOnlyHandle closeFile];


#json解析：JavaScript Object Notification
定义：json可以将js对象中表示的一组数据转换为字符串；
格式：
//字典：key是：字符串、value可以是：字符串&数值&true&false&null&对象&数组
{
    key1:value1,
    key1:value1,
    ...
}
//数组
[
    {
        key1:value1,
        key1:value1,
    },
    {
        key1:value1,
        key1:value1,
    }
]
解析：见AnalyzeViewController.h/m
第三方库：JSONKit
4.json数据解析
(JavaScript Object Notation)
简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是JavaScript很容易解释它，而且 JSON 可以表示比"名称 / 值对"更复杂的结构。例如，可以表示数组和复杂的对象，而不仅仅是键和值的简单列表。

<1>Json数据的格式
JSON有两种表示结构
{}中表示一个字典  []中表示一个数组
对象结构以”{”大括号开始，以”}”大括号结束。中间部分多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码。
{
    key1:value1,
    key2:value2,
    ...
}
关键字是字符串，值可以是字符串，数值，true,false,null,对象或数组
数组结构以”[”开始，”]”结束。中间多个以”，”分隔的值列表组成，语法结构如代码。
[
    {
        key1:value1,
        key2:value2
    },
    {
         key3:value3,
         key4:value4
    }
]

<2> 如何解析
NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&error];


1.什么是XML？
extensible Markup Language   可扩展性标记语言
特点：1.可扩展性   2.标记
标记：A.就是标签 成对出现（有开始，有结束）   B.标签区分大小写
例如：
<students>董佳迪</students>
students是标签，董佳迪是标签的值
可扩展性：1.体现在标签的名字用户自己随意命名
                    2.XML中的标签是可以嵌套的，嵌套的结构也是随意的。
示例：
<?xml version="1.0" encoding="utf-8" ?>
<Students>
  <Student id="1" >
    <name>王也</name>
    <age>18</age>
  </Student>

  <Student id="2">
    <name>孟凡路</name>
    <age>17</age>
  </Student>

  <Student id="3">
    <name>高家兴</name>
    <age>48</age>
  </Student>

</Students>

XML的相关概念：
XML经常被理解成倒挂一棵树
根节点:只能有一对根节点，位于嵌套结构中最外层的节点
在本例中 Students为根节点。
id为属性     1为属性值（属性值必须加“”）
注意点：
1.文档扩展名  .XML
2.XML跨平台。
3.主要用途就是网络传输数据
4.声明，是整个XML的第一条语句
 <?xml version="1.0" encoding="utf-8" ?>
 属性：属性值必须加""；
 注意：文档扩展名.xml、跨平台
 作用：网络传输数据
 区别：json/xml的对比
 1.目前90%的使用json、10%的使用xml；
 2.json解析简单，但是结构不易理解、xml结构容易理解，但是数据冗余；
 解析：见AnalyzeViewController.h/m
 https://blog.csdn.net/qxuewei/article/details/52369067
 
2.XML和JSON的对比
1）90%使用JSON   10%使用XML
2）JSON解析简单   XML解析复杂
3）JSON阅读时结构不易理解  ， XML容易理解，但是有数据冗余

3.XML解析
Google的GData ——第三方库
使用Google的GData解析XML

1）相关类和方法
GDataXMLNode
//获取当前节点的值
- (NSString *)stringValue;

GDataXMLElement : GDataXMLNode
//根据子节点名字获取所有的节点名为name的子节点数组
- (NSArray *)elementsForName:(NSString *)name;
//获取节点的属性
- (NSArray *)attributes;
//根据属性名获取属性节点
- (GDataXMLNode *)attributeForName:(NSString *)name;

GDataXMLDocument    //XML节点树
//创建文档节点
- (id)initWithData:(NSData *)data options:(unsigned int)mask error:(NSError **)error;
//获取跟节点
- (GDataXMLElement *)rootElement;
//根据xpath 语法 获取 指定的节点数组
- (NSArray *)nodesForXPath:(NSString *)xpath error:(NSError **)error;

2）本地解析
//读取数据
NSData *data = [[NSData alloc]initWithContentsOfFile:PATH];
        
//建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];


3）网络解析
转换为URL类型网址
NSURL * url = [NSURL URLWithString:@"http://mps.manzuo.com/mps/cate?sid=(null)&id=0&cc=beijing&pt=all&ffst=1&mnt=10&st=-1&hs=1"];

向服务器请求数据，并获得数据
NSData * data = [NSData dataWithContentsOfURL:url];

建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];

数据接口
http://www.k780.com/api

xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)
练习：
<1>http://www.oschina.net/action/api/news_detail?id=44392
xml解析
Google的GData 第三方库

今日内容：
XPath语法的使用
//XML路径语法
作用：快速的锁定某一级的节点。可以免去一层层复杂的节点搜索
XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。掌握MVC设计模式

1.选择器
#import <Foundation/Foundation.h>

@interface Person : NSObject

@property NSInteger num;
@property NSString *name;
@property NSInteger age;

-(BOOL)shortreules:(Person*)person;

@end


#import "Person.h"

@implementation Person

-(BOOL)shortreules:(Person *)person {
    BOOL a=self.age>person.age;
    if(self.age==person.age) {
        if(NSOrderedDescending==[self.name compare:person.name])
            a=YES;
    }
    return a;
}

@end


#import <Foundation/Foundation.h>
#import "Person.h"
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                Person *person1=[[Person alloc]init];
                person1.num=001;
                person1.name=@"xiaoming";
                person1.age=12;
                
                Person *person2=[[Person alloc]init];
                person2.num=002;
                person2.name=@"xiaohong";
                person2.age=12;
                
                Person *person3=[[Person alloc]init];
                person3.num=003;
                person3.name=@"hanmeimei";
                person3.age=12;
                
                NSMutableArray *arr=[[NSMutableArray alloc]initWithObjects:person1,person2,person3, nil];
                SEL sel=@selector(shortreules:);
                //NSArray *arr1 = [arr sortedArrayUsingSelector:sel];
                
                [arr sortUsingSelector:sel];
                for (Person *person in arr) {
                    NSLog(@"学号：%lu 姓名：%@ 年龄：%lu",person.num,person.name,person.age);
                }
            }
    return 0;
}


2.文件NSFileManager
#import <Foundation/Foundation.h>

#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //创建文件管理单例对象
        //NSFileManager *file = [NSFileManager defaultManager];
        NSError *error = nil;
        
        NSFileManager *manager=[[NSFileManager alloc]init];
        /*浅度遍历
        NSArray *arr =  [file contentsOfDirectoryAtPath:PATH error:&error];
        if (error != nil) {
            NSLog(@"%@",error);
        }
        NSLog(@"%@",arr);
        
         深度遍历
       arr = [file subpathsOfDirectoryAtPath:PATH error:&error];
       NSLog(@"%@",arr);*/
        
        //判断文件是否存在
        NSLog(@"%d",[manager fileExistsAtPath:PATH]);
        
        //创建文件
        NSString *str=@"飞流直下三千尺";
        
        NSData *data=[str dataUsingEncoding:NSUTF8StringEncoding];
        
        [manager createFileAtPath:PATH contents:data attributes:nil];/*参数1：创建文件的路径
                   参数2：内容，如果nil表示创建一个内容为空的文件。
                   参数3：nil表示采用默认的设置
                   如果文件已经存在，会覆盖原来文件*/
        
       NSString *fromPath =@"/Users/qianfeng/Desktop/文件/文件/main.m";
        
       NSString *toPath =@"/Users/qianfeng/Desktop/文件/Manager.h";
      
        [manager copyItemAtPath:fromPath toPath:toPath error:&error];

        [manager moveItemAtPath:fromPath toPath:toPath error:&error];
        
        [manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件/Manager.h" error:nil];
        
        //获取文件属性,返回的是字典
      NSDictionary *dic=[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件/文件/main.m" error:nil];
        for(NSString *key in dic) {
            NSLog(@"%@",[dic objectForKey:key]);
        }
    }
    return 0;
}


3.文件NSHandle
#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str = @"飞流直下三千尺，不及汪伦送我情";
        
        NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
       
        [data writeToFile:PATH atomically:YES];
        
        //创建一个可读可写的文件句柄
        NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:PATH];
        
        //设置偏移量
        [readWriteHandle seekToFileOffset:9];
        
        //读取指定长度数据
        data = [readWriteHandle readDataOfLength:6];
        
        NSString *str1 = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        
        NSLog(@"%@",str1);
        
        //设置偏移量到文件尾
        [readWriteHandle seekToEndOfFile];
        
        //从当前偏移量读取到文件尾
        data = [readWriteHandle readDataToEndOfFile];
        
        //关闭句柄
        [readWriteHandle closeFile];
        
    }
    return 0;
}


12.Json解析
1.本地解析
JSON:
{
    "error": 0,
    "status": "success",
    "date": "2015-08-24",
    "results": [
        {
            "currentCity": "北京市",
            "pm25": "30",
            "index": [
                {
                    "title": "穿衣",
                    "zs": "热",
                    "tipt": "穿衣指数",
                    "des": "天气热，建议着短裙、短裤、短薄外套、T恤等夏季服装。"
                },
                {
                    "title": "洗车",
                    "zs": "较适宜",
                    "tipt": "洗车指数",
                    "des": "较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。"
                },
                {
                    "title": "旅游",
                    "zs": "适宜",
                    "tipt": "旅游指数",
                    "des": "天气较好，但丝毫不会影响您的心情。微风，虽天气稍热，却仍适宜旅游，不要错过机会呦！"
                },
                {
                    "title": "感冒",
                    "zs": "少发",
                    "tipt": "感冒指数",
                    "des": "各项气象条件适宜，发生感冒机率较低。但请避免长期处于空调房间中，以防感冒。"
                },
                {
                    "title": "运动",
                    "zs": "适宜",
                    "tipt": "运动指数",
                    "des": "天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。"
                },
                {
                    "title": "紫外线强度",
                    "zs": "中等",
                    "tipt": "紫外线强度指数",
                    "des": "属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。"
                }
            ],
            "weather_data": [
                {
                    "date": "周一 08月24日 (实时：28℃)",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周二",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周三",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 20℃"
                },
                {
                    "date": "周四",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 21℃"
                }
            ]
        }
    ]
}


#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *zs;
@property NSString *tipt;
@property NSString *des;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"
#define PATH @"/Users/qianfeng/Desktop/本地解析/解析/2.json"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data=[[NSData alloc]initWithContentsOfFile:PATH];
        NSMutableDictionary *dic=[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        NSArray *arr=dic[@"results"];
        NSMutableDictionary *dic1=arr[0];
        NSArray *arr1=dic1[@"index"];
        NSDictionary *dic2=arr1[0];
        
        NSMutableArray *array=[[NSMutableArray alloc]init];
        Model *m=[[Model alloc]init];
        
        for(int i=0;i<[arr1 count];i++) {
            dic2=arr1[i];
            m.title=dic2[@"title"];
            m.zs=dic2[@"zs"];
            m.tipt=dic2[@"tipt"];
            m.des=dic2[@"des"];
            [array addObject:m];
        }
        
        for(Model *m in array) {
            NSLog(@"title:%@ zs:%@ tipt:%@ des:%@",m.title,m.zs,m.tipt,m.des);
        }
    }
    return 0;
}


2。网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString*uid;
@property NSString*username;
@property NSString*groupid;
@property NSString*credit;
@property NSString*experience;
@property NSString*viewnum;
@property NSString*friendnum;
@property NSString*lastactivity;
@property NSString*headimage;
@property NSString*realname;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //定义字符串网址
        NSString *strUrl = @"http://10.0.8.8/sns/my/user_list.php?number=20&page=1";
        
        //将网址转换为URL类型
        //string类型的字符串网址需要做一个转换
        //转换为NSURL类型的网址，才可以进行申请数据操作
        NSURL *url = [NSURL URLWithString:strUrl];
        
        //向网络服务器请求数据
        //同步请求数据，当服务器响应数据之前，线程一直处于卡死状态
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        
        //网络请求的数据都存储在data里了
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        //到这一步，所有的json数据都存储在字典里了
        NSArray *arr= dic[@"users"];
        NSDictionary *dic1=arr[0];
        NSMutableArray *array=[[NSMutableArray alloc]init];
        
        for(int i=0;i<[arr count];i++) {
            Model *m=[[Model alloc]init];
            dic1=[arr objectAtIndex:i];
            m.uid=dic1[@"uid"];
            m.username=dic1[@"username"];
            m.groupid=dic1[@"groupid"];
            m.credit=dic1[@"credit"];
            m.experience=dic1[@"experience"];
            m.viewnum=dic1[@"viewnum"];
            m.friendnum=dic1[@"friendnum"];
            m.lastactivity=dic1[@"lastactivity"];
            m.headimage=dic1[@"headimage"];
            m.realname=dic1[@"realname"];
            
            [array addObject:m];
        }
        for(Model *m in array) {
            NSLog(@"uid:%@ username:%@ groupid:%@ credit:%@ experience:%@ viewnum:%@ friendnum:%@ lastactivity:%@ headimage%@ realname:%@",m.uid,m.username,m.groupid,m.credit,m.experience,m.viewnum,m.friendnum,m.lastactivity,m.headimage,m.realname);
        }
    }
    return 0;
}


13.XML解析
1.本地解析
xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)

#import <Foundation/Foundation.h>

@interface Book : NSObject

@property NSString *ID;
@property NSString *lag;
@property NSString *name;
@property NSString *authorName;
@property NSInteger price;
@property NSString *summary;

@end


#import <Foundation/Foundation.h>
#import "Book.h"

@interface Manager : NSObject {
    NSMutableArray *arr;
}

- (void)addBook:(Book *)book;

- (void)show;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        arr = [[NSMutableArray alloc]init];
    }
    return self;
}

- (void)addBook:(Book *)book {
    [arr addObject:book];
}

- (void)show {
    for (Book *b in arr) {
        NSLog(@"%@",b.summary);
    }
}
@end


#import "Book.h"

@implementation Book

@end


#import <Foundation/Foundation.h>
#import "Book.h"
#import "Manager.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/demo/xml本地解析4/xml本地解析4/GData/book.xml"];
        GDataXMLDocument *doct = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootElement = [doct rootElement];
        
        //取books节点
        GDataXMLElement *booksElement = [rootElement elementsForName:@"books"].firstObject;
        
        Manager *m=[[Manager alloc]init];
        
        //取book节点
        NSArray *arr = [booksElement elementsForName:@"book"];
        
        for (GDataXMLElement *bookElement in arr) {
            GDataXMLNode *ID = [bookElement attributeForName:@"id"];
            GDataXMLNode *language = [bookElement attributeForName:@"language"];
            GDataXMLElement *nameElement = [bookElement elementsForName:@"name"].firstObject;
            GDataXMLElement *autherElement = [bookElement elementsForName:@"auther"].firstObject;
            GDataXMLElement *autNameElement = [autherElement elementsForName:@"name"].firstObject;
            GDataXMLElement *priceElement = [bookElement elementsForName:@"price"].firstObject;
            GDataXMLElement *summaryElement = [bookElement elementsForName:@"summary"].firstObject;
            
            Book *book = [[Book alloc]init];
            book.ID = [ID stringValue];
            book.lag = [language stringValue];
            book.name = [nameElement stringValue];
            book.authorName = [autNameElement stringValue];
            book.price = [[priceElement stringValue] doubleValue];
            book.summary = [summaryElement stringValue];

            [m addBook:book];
        }
        [m show];
    }
    return 0;
}


2.XML:
<?xml version="1.0" encoding="UTF-8"?>
<root name="中国">
  <province name="天津市" postcode="120000" >
    <city name="市辖区" postcode="120100" >
        <area name="和平区" postcode="120101" />
        <area name="河东区" postcode="120102" />
        <area name="河西区" postcode="120103" />
        <area name="南开区" postcode="120104" />
        <area name="河北区" postcode="120105" />
        <area name="红桥区" postcode="120106" />
        <area name="塘沽区" postcode="120107" />
        <area name="汉沽区" postcode="120108" />
        <area name="大港区" postcode="120109" />
        <area name="东丽区" postcode="120110" />
        <area name="西青区" postcode="120111" />
        <area name="津南区" postcode="120112" />
        <area name="北辰区" postcode="120113" />
        <area name="武清区" postcode="120114" />
        <area name="宝坻区" postcode="120115" />
    </city>
  </province>
</root>


#import <Foundation/Foundation.h>

@interface Area : NSObject

@property NSString *name;
@property NSString *postcode;

@end


#import "Area.h"

@implementation Area

@end


#import <Foundation/Foundation.h>
#import "Area.h"
@interface Manager : NSObject {
    NSMutableArray *_arr;
}

- (void)addArea:(Area *)area;

- (void)showAll;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        _arr = [[NSMutableArray alloc]init];
    }
    return self;
}

-(void)addArea:(Area *)area {
    [_arr addObject:area];
}

-(void)showAll {
    for (Area *area in _arr) {
        NSLog(@"name:%@,postcode:%@",area.name,area.postcode);
    }
}

@end


#import <Foundation/Foundation.h>
#import "GDataXMLNode.h"
#import "Manager.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Manager *m = [[Manager alloc]init];
        
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/伯明利－下午 /2.t/tianjin.xml"];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        
        GDataXMLElement *rootElement = [doc rootElement];
        GDataXMLNode *rootNameElement = [rootElement attributeForName:@"name"];
        Area *area1 = [[Area alloc]init];
        area1.name = rootNameElement.stringValue;
        [m addArea:area1];
        
        GDataXMLElement *provinceElement = [rootElement elementsForName:@"province"].firstObject;
        GDataXMLNode *provinceName = [provinceElement attributeForName:@"name"];
        GDataXMLNode *provincePostcode = [provinceElement attributeForName:@"postcode"];
        Area *area2 = [[Area alloc]init];
        area2.name =provinceName.stringValue;
        area2.postcode =provincePostcode.stringValue;
        [m addArea:area2];
        
        GDataXMLElement *cityElement = [provinceElement elementsForName:@"city"].firstObject;
        GDataXMLNode *cityName = [cityElement attributeForName:@"name"];
        GDataXMLNode *cityPostcode = [cityElement attributeForName:@"postcode"];
        Area *area3 = [[Area alloc]init];
        area3.name = cityName.stringValue;
        area3.postcode = cityPostcode.stringValue;
        [m addArea:area3];
        
        NSArray *arr = [cityElement elementsForName:@"area"];
        for (GDataXMLElement *areaElement in arr) {
            GDataXMLNode *name = [areaElement attributeForName:@"name"];
            GDataXMLNode *postcode = [areaElement attributeForName:@"postcode"];
            Area *area = [[Area alloc]init];
            area.name = name.stringValue;
            area.postcode = postcode.stringValue;
            [m addArea:area];
        }
        [m showAll];
    }
    return 0;
}

3.网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *url;

@end


#import "Model.h"

@implementation Model

@end

#import <Foundation/Foundation.h>
#import "Model.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSURL *url = [NSURL URLWithString:@"http://www.oschina.net/action/api/news_detail?id=44392"];
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootEle = [doc rootElement];
        GDataXMLElement *newsEle = [rootEle elementsForName:@"news"][0];
        GDataXMLElement *relEle = [newsEle elementsForName:@"relativies"][0];

        NSArray *arr = [relEle elementsForName:@"relative"];
        NSMutableArray *mArr = [[NSMutableArray alloc]init];
        
        for (GDataXMLElement *releEle in arr) {
            GDataXMLElement *titleEle = [releEle elementsForName:@"rtitle"][0];
            GDataXMLElement *urlEle = [releEle elementsForName:@"rurl"][0];
            
            Model *m = [[Model alloc]init];
            m.title = [titleEle stringValue];
            m.url = [urlEle stringValue];
            [mArr addObject:m];
        }
        for (Model *m in mArr) {
            NSLog(@"title=%@,url=%@",m.title,m.url);
        }
    }
    return 0;
}

#异步网络请求：
//分类：
网络请求：get
网络上传：post
下载：NO
//原生网络请求：
CFNetwork：纯C语言
NSURLConnection：iOS7.0被废弃
NSURLSession：NO
https://www.jianshu.com/p/b0ddadd34037
//ASIHttpRequest：不在更新
//MKNetworkKit：简单易用，使用者较少
//AFNetworking：
1.概述：2.0使用的是NSURLConnection、3.0使用NSURLSession；
2.代码：NetworkViewController.h/m
注意：不要在子线程中更新UI；
//利用KVO、KVC进行网络请求：参考2015-10-13
1.新建数据模型PostInfo.h/m
2.新建数据源：必须初始化
3.设置单例：全局使用
3.监测数据源变化：KVO
4.新建下拉控件：进入VC->开始下拉加载->网络请求：改变数据源->加载UITableView
5.在View中更新UI
代码：NetworkViewController.h/m
//设置应用支持https
Xcode7.0以后：NSAppTransportSecurity->NSAllowsArbitraryLoads->YES

#网络编程需要掌握的内容：NO
0.实时监测网络变化
1.数据请求、数据上传、下载
2.原生网络请求的原理
3.网络请求第三方库的使用
4.KVC在网络请求中的应用
5.进入VC以后怎么加载操作

今日项目需求(参考2015-10-13/org.mobiletrain.afnetworking-sample)
0 ViewController当中的所有数据，都是来源于Model，但不在ViewController当中保存，是存放在单独的Model类。其他的类也会使用到这一个Model，所以Model必须是单例
1 ViewController当中，不进行网络请求，不使用AFNetworking。
2 ViewController当中，要进行网络请求，委托另外一个类(PostStore)来进行请求
3 PostStore进行网络请求之后，需要告诉ViewController，请求和数据操作都已经完成
4ViewController是一个列表视图控制器，既然委托PostStore进行网络请求，并且PostStore会在网络请求完成之后，操作Model，所以要观察Model([PostList sharedInstance].posts)
5PostStore在网络请求的方法内，需要外部传入两个block，这两个block，会在PostStore网络请求完成并且数据解析完成之后调回去
6PostStore内部需要做3件事：数据下载；唯一性判断；排序。所以应该在最后一步，也就是排序的时候，告诉观察者，数据(Model)已经更新了
7ViewController当中的cell，需要显示Model当中的text，这个text会被改变(DetailViewController)，所以cell需要添加对于这个Model(NSMutableDictionary)的观察者
8 因为有复用机制，所以当设置观察者之前，需要将之前的观察者删除掉
9 ViewController和DetailViewController不应该传输数据，所以，当前被选中的PostInfo，需要放到Model当中([PostList sharedInstance].selectedPost)，设置好之后，再进入下一级页面

MacVim脚本：将GET请求的URL，使用OC的方式，做成字典
%s/[?&]\([^=]*\)=\([^&]*\)/[dict setValue:@"\2" forKey:@"\1"];^M/g


// 项目类
1.项目的技术要点/功能模块实现/项目中的难点有哪些，怎么解决的/项目中有哪些你不满意的地方/如果现在让你做，你可以怎么做？/做过最得意的是什么项目/
2.关于版本控制系统：一般可以讲svn/git就行/优缺点/怎么使用/具体命令行又什么区别和作用？
3.你通常用什么数据格式与服务端交互：json/xml|json、xml解析方式的底层是如何处理的？
7.代码复用、封装、重构、敏捷开发、快速迭代、codeReview
8.如何让imageNamed同时兼容3.x/4.x系统/以及不去缓存
11.怎么把敏感字段变成**
16.self/self.有什么区别？
17.id/nil代表是什么？
1.定义属性：什么时候使用copy/什么时候使用assign、retain ///为什么要使用定义属性：什么时候使用copy？？？
2.什么时候需要使用delegate/什么时候需要使用notification /// delegate/block/notification有什么不同点？？？
9.深拷贝/浅拷贝的区别？
12.代理delegate/通知/block之间有什么区别？
13.iOS怎么做数据持久化？coredata/sqlite之间又什么联系？coredata是关系型数据库吗？
15.说说iOS中常用的多线程？最好能结合代码好好说；在哪里用到了多线程？三种多线程哪种会比较全面一些，
然后谈一谈线程安全问题的解决方案？
16.block在ARC/MRC中用法有什么区别和联系？
17.常用的iOS设计模式有哪些？
19.使用过哪些第三方库？jsonKit/AFNetworking/SnapKit/MJRefresh///要有针对性，涉及到每个方面；
20.怎么实现UITableView的懒加载？
21.iOS开发中常见的异常有哪些？
22.什么时候使用栈/队列？什么时候使用链表/数组？
23.什么是LRU算法？实现缓存/怎么操作？
24.UITableView的重用机制：描述/好处
25.简述objc的内存管理：这个真的是重点/需要好好理解组织语言
26.你理解的MVC是什么？你理解的MMVVM又是什么？
27.NSURLConnection/ASIHTTPRequest哪个更好？
28.写入一个插入排序：一般使用C语言/Java写
29.obj-c有私用方法吗？有私有变量吗？没有私用方法/有私有变量
30.什么是目标-动作机制？
33.iOS有哪些性能分析工具？（这些基本没有接触过）
34.性能优化：重点
35.静态初始化什么场合可以使用？什么场合不能使用？
36.导致app异常假死的情况有哪些？有什么解决方案？
37.NSNotifacation(通知)是同步/异步？
38.怎么为App设计缓存？
40.obj中可修改/不可修改类型？
41.与property结合的时候怎么有效的避免内存泄漏？
42.Objective-C可以多重继承吗？不能/可以实现多个接口吗？能
47.iOS中类有哪些通讯方式？
48.alloc/dealloc...retain/release之间的区别是什么？
49.简述Objective-C的内存管理机制：如何检测内存泄漏？
50.iOS中视图控制器的生命周期有哪些？
51.通知/代理/block之间的区别和联系？
52.简述assign/retain/copy/weak/strong的区别？
53.消息推送中心的过程？
54.如何检测一个iOS设备的性能？
55.指针函数和函数指针有什么区别？
56.怎样才能一次遍历就能确认链表中存在环？
62.为什么category只能为对象添加方法？却不能添加成员方法？
63.简述NSInteger* a/NSInteger a的区别？
64.block和gcd的并发执行？
65.Xib/代码方法创建界面的优缺点？
66.关于Objective的异常处理？
68.在iOS开发中，https通讯在什么位置来保障安全？NSURLRequest/NSURLConnection；
69.block和gcd的并发执行；
70.app一个页面crash、你可以用什么工具去查内存之类的状态；
关于View的一些高级动画：目前是一点都不会
//笔试题
1.给定链表的头指针和一个结点指针，在O(1)时间删除该结点。
链表结点的定义如下：
struct ListNode {
    int m_nKey;
    ListNode* m_pNext;
}
函数的声明：void DeleteNode(ListNode* pListHead, ListNode* pToBeDeleted);
2.语句倒序：I am Bruch；（语言随意：不能使用伪代码）
3.手写“冒泡排序”/“堆排序”/“选择排序”/“插入排序”/“二分查找”
4.将一个链表逆序？/输出一个字符串是否对称？/输出树的深度？
5.定义一个标准宏MIN：输入两个参数并返回最小值？
6.C语言中默认的随机数random()是从x->y?
7.IBOutlet UIView *view;
@property (nonatomic,retain) UIView *view;
以上view对象需要release吗？
8.手写Objective-C的单例？
9.id obj = [[NSMutableArray alloc]init];/id obj = [NSMutableArray array];初始化
有什么不同？
10.在ARC模式下，autoreleasepool的使用？（使用伪代码）/autoreleasepool的作用？
11.id obj = [[[NSMutableArray alloc]init] autorelease];obj在什么时候释放？有什么
方法可以让obj马上释放？（用伪代码表示）
12.for(int index = 0; index < 20; index++) {
    NSString *tempStr = @"tempStr";
    NSLog(tempStr)
    NSNumber *tempNumber = [NSNumber numberWithInt:2];
    NSLog(tempNumber)
}
这段代码有什么问题？会不会导致内存泄漏(多线程)/在内存紧张的设备上做大循环时
简述自动释放池的工作原理/工作过程？自动释放池是写在循环内好还是循环外好？为什么？
13.使用loadView/viewDidLoad/viewDidUnload分别在什么地方调用？做什么工作？
Q.当view为nil的时候调用loadView()->view完成加载调用viewDidLoad()->view释放
时调用viewDidUnload()方法；
14.编写函数：输入Array从小到大排序后输出
15.编写函数：输入数组、判断每个元素出现的次数
16.输入一个函数：v1>v2 返回1/v1==v2 返回0/v1<v2 返回-1
17.NSString *name; [name release]; // 执行代码会出现什么结果？简述原因
18.@property (copy) NSString *name; // 给出name的setting方法

14.程序运行报错：请找出错误并改正
#include <stdio.h>
#include <malloc.h>

typedef struct {
    TNode* left;
    TNode* right;
    int value;
} TNode;
14.写出以下操作以后person的retain count是多少？
Person *person = [Person alloc] init]；
[person retain];
[person release];
[person release];
15.如何判断一个字典是空的？
16.用宏写一个MIN：求两个数中的最小值。

//面试题：技术部分
2.iOS程序在执行main函数之前做了哪些操作？
Q.
3.一个App可以有几个UIWindow？
Q.
7.NSOperation什么时候从queue中移除？
Q.
9.NSInteger|int和CGFloat|double有什么区别？
Q.
16.MVC和MVVM的联系和区别：哈哈哈
17.iOS中常见的单例有哪些？弄懂每一个作用
Q.应用程序实例：UIApplication|消息中心：NSNotificationCenter|文件管理：NSFileManager|应用
程序设置：NSUserDefaults|请求缓存：NSURLCache|应用程序Cookies池：NSHTTPCookieStorage
18.怎么提高客户端的性能？（这点需要深入研究一番）
21.自动释放池是什么？如果工作？
22.关键字const/volatile有什么含义？
23.普通屏幕/Retina屏幕适配有什么好方法？
25.有哪些方法可以启动一个线程？
26.xib/nib之间的区别？
27.@synthesize xxx是怎么实现的？
28.json解析内部是怎么实现的？
29.试说明SEL和@selector的用途、有什么作用？
30.iOS中App数据持久化机制有哪几种方案？（详细说明）
31.请说明Touch和非Touch事件发生时在系统中的传递过程？（事件传递hitest）
32.怎么获取磁盘空间（How to get disk space left）
34.如果开启异步线程？如果想要延迟执行某个线程怎么实现？
36.什么是动态绑定？
38.self.name/_name之间有什么区别？
42.iOS应用是如何实现后台多任务处理？
43.category是怎么样一个机制？一般什么时候使用？
//参考网站：
http://www.cnblogs.com/Piosa/archive/2012/02/22/2363234.html
//难点部分
1.Objective-C项目怎么设置可以全局设置头文件；
数据结构/数据库/操作系统/openGL/ES/计算机网络/软件工程(工作中重要)
编译原理：Xcode/OC/Swift
// iOS的设计模式
1.代理模式
应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合
敏捷原则：开放-封闭原则
实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate
2.观察者模式
应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。
优势：解耦合
敏捷原则：接口隔离原则，开放-封闭原则
实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
kvo，键值对改变通知的观察者，平时基本没用过。
3.MVC模式
应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
优势：使系统，层次清晰，职责分明，易于维护
敏捷原则：对扩展开放-对修改封闭
实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。
4.单例模式
应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。
优势：使用简单，延时求值，易于跨模块
敏捷原则：单一职责原则
实例：[UIApplication sharedApplication]。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。
object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，
返回的也只是此单例类的唯一静态变量。
5.策略模式
应用场景：定义算法族，封装起来，使他们之间可以相互替换。
优势：使算法的变化独立于使用算法的用户
敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。
实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。
注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类
2，变化的行为抽象基类为，所有可变变化的父类
3，用户类的最终实例，通过注入行为实例的方式，设定易变行为
防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。
6.工厂模式
应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。
优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。
敏捷原则：DIP依赖倒置原则
实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换
注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，
增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。
MVC是一个框架模式 Model View Controller  模型--视图--控制器  各自处理自己的任务
    M是指数据模型  V是指用户界面  C是指控制器 使用MVC的目的是将M和V的实现代码分离 C存在的目的则是确保M和V的同步
    耦合性低   重用性高  生命周期成本低

CGFloat/Float之间的区别？
NSInteger/int之间的区别？
总结一下UITableView的重用机制？//重点说明
总结一下iOS的内存管理：
1.release/autorelease分别在什么情况下使用？
2.block的内存管理需要注意什么？
3.对象在什么时候会被release？
//谈谈UITableView的优化
1.利用cell的复用：可以不用每次都创建cell、表述一下cell的复用机制、场景；//最基础的
2.设计尽量统一cell的样式；//这个没办法避免
3.布局方面：可以提前计算并缓存cell高度、不用每次调用delegate都去计算；
4.遇到复杂页面：可以考虑异步绘制、减少子视图的层级关系；
5.尽量不要动态add/remove子控件、可以在init()中就加载完毕，然后通过hidden控制显示/隐藏；
6.使用调试工具分析问题；

赶集网的面试：1.传值 2.推送 3.数据存储 4.代理/单例
第一轮：推送机制->多线程->开发流程
第二轮：支付

重点：手动内存管理/自动内存管理的原理&步骤&应用

1.读写文件的例子？
2.读写数据库的例子？
3.异步加载网络图片的例子？

总结苹果开发者相关：
1.开发者账号生成的测试证书有效期：1年
关于苹果上架流程：企业证书/个人证书/testflight等

总结推送：
1.从APNS获取device token作为设备唯一标识符

UIImage读取图片：怎么可以避免内存

数据结构；树

一般来讲...一个项目你需要从哪里开始做起：这点很重要...
你需要先写什么、在写什么、
一般来讲：业务相关的可以后来扩充
底层的必须要先写好

//RunTime  运行时：NSString  编译时：NSData
1.NSData *data = [NSString stringWithFormat:@"%d", 12];
2.运行时多态有什么好处？

1.runloop的理解；

//iOS推送原理机制：

//网络部分
1.http请求分几部分？

UITableView调用reloadData()会发生什么问题？

- 面试的时候不建议过多评价还有透漏上家公司信息；仅仅限于人事/使用ceo

### 面试题
1. 定义属性的时候，什么情况下使用copy、assign和retain？
4. 同一个游戏包(GameID相同)怎么区分下载来自哪一个渠道？
5. UITableView怎么做预加载？
6. 懂不懂OpenGL？
7. 知道多线程吗？介绍一下iOS中多线程的情况？平时你喜欢使用哪种？在哪些开发中使用到了多线程？
8. swift中结构体和类之间的区别？
11. keyWindow和一般Window的区别？
12. delegate/通知/block之间的区别？
13. AF2.0和AF3.0之间的区别？AF2.0有常驻子线程而AF3.0没有是什么原因？
14. git rebase/git merge的区别？
15. Int/NSInteger的区别？<br>
int是短整型、NSInteger也是基本数据类型:CGFloat一样、但是NSInteger会根据操作系统(32/64)的位数判断，最大数值是int/long|NSNumber是类。
16. 数组指针/指针数组的区别？
17. 三种动画？各种动画的区别联系？
18. block的循环引用：渐变动画会出现循环引用吗？
19. atomic一定是安全的吗？
20. ViewDidLoad()/loadView()的区别？
21. if(self=[super init]) { //...}为什么需要这样写？[super init]按照常理
只是初始化父类的空间、为什么self可以调用子类的方法？
22. ARC是什么？工作机制详细讲下？
23. 常见的第三方库你见过那些多线程？/有盟、高德地图、AFNetWorking、SDWebImage、FMDB
24. 为什么需要用到单例模式/不使用会怎么样？
25. 简述UITableCell的复用机制。
26. 简述多线程GCD、NSThread、NSOprate; //需要总结
27. 什么是多态？为什么需要使用多态？
28. OC数据对象有哪些？与基本数据类型有什么区别？
29. 简述动态绑定。
30. 在Instruments工具中，用于检查内存泄漏的工具是什么？
31. 在iOS中有哪些常见第三方库：实现的功能是什么？你看过第三方库的源码吗？有过根据需求修改过源码吗？
32. 写一个NSString类的实现；
33. 描述OC和swift的联系和不同；
34. 描述ARC机制的原理和实现；
35. 描述controller和view之间的关系。为什么要使用viewController；
36. 描述SQLite.swift的大致实现原理；
37. 描述IP/TCP/UDP/HTTP几种协议的理解；
38. 描述web Service和Web Api的区别；（发展思路和应用场景）；
39. 描述web后端Session在什么时候产生、什么时候结束？Cookie又是什么关系？
40. iOS的后台运行是什么原理和机制？
41. 创建一个对象、放在可变数组中。释放整个对象会发生什么？释放数组会发生什么？
42. 你常用的设计模式、第三方库？
43. 进程空间中的数据区、代码区、栈区、堆区有什么不同？
44. WWDC是什么？你有关注过WWDC吗？
45. Xcode选择模拟器编译：在Products中生成的二进制文件后缀是什么？
46. 重点理解SEL的用法；

//数据持久化
1.NSCache和数据持久化使用场景有什么区别？
2.常用的数据持久化方法有哪些？各自有什么利弊？

//正则表达式

// 数据库开发：sql语句/连表查询
例1.有两张表，用户表(Z_User)和黑名单表(Z_Blackuser)，userid是Z_User的
主键，Z_BlackUser的外键。现在需要查询用户表中不在黑名单表中的数据，请写出sql语句。

开发中做的事情：软件编码/单元测试/技术难点
面向对象的编程思想

是否参与过GitHubiOS开源项目?
请描述一下你的iOS应用开发流程？
是否熟知CocoaPods?它是什么?如何运行的?
请描述一下Instruments及其作用？

//UI问题
layer和UIView、UIWindow的区别是什么？

5.怎么实现连表查询？ //重点中的重点！！！

//数据库方面
1.什么是视图？
2.使用索引查询一定可以提高查询性能呢？为什么？
3.内联接和外联接的区别？

//类方法
1.类方法随着类的加载而加载、所以类方法不能访问成员变量、
self在对象方法中代表对象、self在类方法中代表类、
self.age = 10代表set方法[self setAge:10];

//单例模式
一般单例模式只能保证跳用类方法的时候、创建的对象是不变的；
参考sdkv3.8可以保证无论什么情况创建的对象都是唯一的；
1.解释一下block、使用block应该注意什么;
2.block的用法？
3.如何避免使用block引起循环引用问题？
1.dispatch_get_current_queue会引起什么问题？
1.CoreAnimation/CoreGraphics是否使用过？
Xcode支持在一个工程里面新建多个项目
1.怎么开启异步线程、如果需要线程过段时间再开启、如果实现？
1.列举常见使用到多线程的地方、2.多线程安全的几种解决办法？
//App的发布流程
1.创建一个单例并实现？有一种很特别的方式创建
//数据存储
1.单例保存的数据App杀死、数据清空
2.数据库/NSUserDefaults保存的数据在App被杀死数据不会清空、App被卸载数据会清空

###人事问题
1.今年的目标是什么？5年的规划是什么？
2.希望从我们公司学习到什么？
3.住哪里？有没有女朋友？上家工资多少？//按照实际回答即可
4.为什么离职？//这个总结一下
5.公司有多少人？iOS部门有多少人？具体是怎么样的工作流程？
6.App哪些模块是你做的？
7.你投简历投了几家？拿到几个offer；//这个想一下具体回答
8.工作中遇到什么技术难点（这个一般不是人事问题、但是需要好好总结）

//链表/数组的不同

//nullable、__nullable、__Nullable之间的关系？
1.目的：为了兼容swift
2.三者之间没有任何的区别？就是书写的时候位置有不同
3.-(nullable NSString*)method;nonNull表示对象不应该为空、nullable表示对象可以为空?
4.不带下划线在类的前面、写下划线的在类的后面
参考：https://blog.csdn.net/conglin1991/article/details/77159652
建议：使用nullable这样符合属性修饰符的位置、跟copy、strong一样

关于数据结构：一定需要自己好好梳理知识点：
1.二叉树
2.链表
3.哈希表

//重点
1.多线程/数据库/网络编程

//网络相关方面
1.有没有用过socket、一般怎么使用？如果预防socket丢包？

//加密算法
1.MD5-概念、应用场景、

//相关网址
https://blog.csdn.net/leaf8742/article/details/50960827

//附加
1.访问Stack Overflow
2.开源类库、代码片段；//命名规范、最佳实践和设计模式

###趣味问答
//这一块最好需要有人帮你总结：因为你感觉很自豪的事情在别人看来就是很垃圾！！！
//你最引以为豪的项目是什么？你做的最成功的项目是什么？
你项目有哪些不足？如果是现在给你修改、你可以怎么修改？
Xcode有哪些可以改进的地方、你最爱使用什么方法检查某种新技术是否好用？

///iOS职位要求
### 必须项：
1.丰富的客户端App架构经验、可以独立承担架构设计、主导项目；
2.熟悉iOS的调试工具和方法、crash追踪；
3.精通Objective-C语言/swift语言；
4.精通UI、动画、网络编程(Socket、https/web)、数据库、多线程、
h5/js交互；
5.熟悉常用软件架构模式、算法与数据结构；
6.熟悉CocoaPods、git、svn等工具；
7.至少参加两款商业应用开发并上架AppStore；
8.学习能力强、工作积极主动、有强烈责任心和严谨作风、协作沟通能力、解决问题能力；
### 加分项：
1.提供github账号或者技术博客账号(为开源项目做过贡献)；
2.深入了解iOS动画机制、音频、视频开发经验；
3.熟悉C/C++语言、前端、后端、RN、Weex、H5混合开发；
4.内存泄漏、App性能调优经验优先；
5.了解常用的设计模式，有架构和组件化经验；
6.扎实的计算机基础，了解数据结构和常见算法；
7.有移动端(iOS/Android)脱壳、反混淆相关经验；
8.深入研究AR相关技术的优先；
9.良好的产品和业务sense；
10.有App Store上架作品优先；

### 项目细节
1.自己的事情自己做：
1).业务参数最好在model中先处理好，直接赋值
2).View需要改变状态最好在View内部先处理好逻辑，外部使用数据去驱动

swift中enum/struct都是比类更厉害

App中哪些需要存放在本机|App中的缓存机制

隐藏View：1.使用隐藏属性、2.将View的宽和高设置为0

如果是数组就是dateList

如果是字典就是DateModel

safeArea // 这是什么意思
constrain to magins //没有作用：为了plus/iPhone X布局尽量到中间

对于swift:我们对所有的view都需要lazy

对于oc:我们也可以lazy

对于cell 我们一般不需要把model传进去 再传出来 我们一般是把cell传出来 然后通过cell拿到indexPath 再通过indexPath拿到model

- 创建UILabel/UIButton有固定方法(不使用系统方法)；
- 封装可以使用的BadgeView；
- 学习snapkit使用方法；
- UIView中不能跳转：使用代理让实现在VC中进行；让View具有公用型

## snapkit中有三个方法
- makeConstraints  //设置布局
- remakeConstraints  //移除以前的布局、重新布局
- updateConstraints //更新布局

App开发不能限制用户的操作
/***********************json按页下载数据******************************/
//1.声明当前页数、总页数
self.page = 1
self.maxPage = 1
//2.首次加载
page传入1-开始网络请求
//3.请求完成：开始赋值
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
//4.再次网络请求：
page++ //判断是否大于最大页面：大于停止刷新
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
/////CommunityCommentDetailController.swift

iOS中每个专有名词的读音都需要学会

15.什么是"Jenkins"/TabBar这么实现动画效果/hook

1. 一般项目都是使用cocoaPods管理：更加方便；
2. 一般使用Assets管理图片：自己试试；
3. 一般技术用来看后台接口的工具App是什么？？？
4. 一般App不需要什么都写在服务端
5. //这个坐标是在哪里开始算起的：状态栏？导航栏头部、导航栏底部
    _topView = [[UIView alloc]initWithFrame:CGRectMake(0, 20, self.view.frame.size.width, 40)];
read Base value to memory

App哪些信息需要存储在本地：可能会涉及到多表查询

学会了怎么设置cell自适应：配合设置控件高度为0一起使用；/需要预估高度/可以把内部的高度传出来

一般使用svn管理资源文件、使用git管理代码文件

YYText怎么使用、有什么作用？？？

对json的格式还不是很熟悉

//使用SnapKit给控件添加约束常见错误：https://blog.csdn.net/Haikuotiankong11111/article/details/51800761
1.简单的约束冲突不能有：比如控制了左边和把右边就不能在设置宽度

CGFloat的意思是什么？

iOS中关于图片缓存和缓存cell的高度

系统适配
iphone尺寸
iPad尺寸

UILabel在Autolayout中可以自动设置高度

cell内部如果某一个控件不需要我们可以更新布局为0

//项目中：如果Model中需要新的数据：可以直接在Model中创建->然后拿出来使用
如果某个ui需要改变：可以在内部改变->vc中可以调用方法告诉view你的view显示需要改变

在开发中，我们一般UIButton会使用custom、而不使用system

看控制器会不会走 deinit方法，有内存泄漏 deinit这个方法是不会走的

NSNotFound
int和NSInteger都是基本数据类型、一般OC使用NSInteger代替int/Swift使用Int、然后需要放在
字典中的话：需要包装：@(NSInteger)

自定义UI：如果你希望整个UI都可以点击：可以直接在整个UI上面添加touch方法

Xcode中有：打开"Main Thread Checker"可以判断线程是否使用合理

swift中：如果是String = ""
如果是类：一般会怎么样？？
一般会声明+实现

给对象赋值不需要初始化

1.什么时候更新model?
1).网络加载数据：更新model；2).本地上传数据：之后更新model；

一般对象我们都设置var
对象赋值不需要init
给对象属性赋值：必须要init

不能欺骗Apple

对于布局：一般不建议写死
一般先把左上角|中点控制好；
然后把宽|高控制好
间距：一般不用up|all
尺寸：一般使用up|all
如果对于5s的屏幕：太小了  间距也可以使用up|all
自己的代码必须有足够的兼容性

git上面的：stash
fir的使用：怎么使用
一般公司打包：怎么打包

SnapKit布局：我们不用按顺序布局|可以直接先布局底下的样式、再布局上部的样式

可以规定约束的优先级

// 组件化开发实践
https://www.jianshu.com/p/f472fa9f0616

swift中一般都需要init|对于Int等数据类型、默认赋值等于-1
为什么是-1呢？？？？因为-1代表着不正确

自己的问题自己把关：不能让别人给自己把关

找问题一定要从外向内找、找不到在找旁边的
千万不要还没有找进去  就开始在旁边找
这样很能迷失方向：让人很烦躁、不安   然后找不到答案、一定要静下心来

写代码一定要细心  超级细心

pod repo update // 更新电脑本地保存的版本库中的版本信息

遇到{就会给它分配一个存储空间、直到遇到}该存储空间会被释放

如果只需要上拉加载、不需要下拉刷新

这时候可以把下拉刷新不写：直接在viewDidLoad() {
    中网络请求：然后执行上拉加载：最开始的网络请求可以设置为page = 1
}

swift怎么写网络请求：

OC怎么处理网络请求：

// 将一个图片位于什么部位开始拉伸(以原点为中心点)
// 返回一个UIImage
UIImage.resiezableImage(with: UIImage(named: "calendar_bg_white"), edgeInsets: UIEdgeInsets(top: 0.5, left: 0.5, bottom: 0.5, right: 0.5))

拿到页面首先分析UI布局  写出UI界面    然后再分析要不要分页加载

每次写代码如果有疑问  或者测试改了代码   都需要做标记：// FIXME  然后最重要的是
必须在发版的时候全局搜索FIXME

1.严格按照设计稿设计UI
2.一般设置UI的时候一定要想到怎么当文字过长会怎么样

如果UI显示不正确  变小了    考虑可能的原因   图片压缩了   图片有边角   但是UI没有给图片   这样一般让图片和UI一样大

如果App的跳转比较像（就是model不一样）
我们可以对model进行赋值
新建一个model   对model进行赋值

在xib中，command选中两个控件   可以让他们等宽、然后修改比例

数据库问的问题：数据的增删改查、多表的链接查询、数据回滚

内部用的什么类型数据
外部就必须用什么类型的数据接受

不能内部是字典/外部是数组

如果json是一个model   你就用字典接受
然后传出来的必须也是model
"data":{
    // 这是一个字典
}
外层也必须使用model去接收->然后取出来model里面的list->如果需要分页还需要拼接list

如果json是数组的话。必须用数组接受
"data"[{
    // 这是一个数组
},{
    
}]
必须使用数组去接受-> 然后外层也必须使用数组来接受：可以直接等于

swift中main函数消失：https://blog.csdn.net/zhao18933/article/details/46640657

command + D   //收藏书签

1.修复线上bug/增加线上内容...base分支
2.新功能/新需求_01...新建分支 <br>
3.新功能/新需求_02...新建分支 <br>
4.新功能/新需求_03...新建分支 <br>
发版本...把1，2，3，4合并到发版分支->新建v3.3.x发版本分支

cell因为是复用的、所以cell有if/就必须有else
不让做不到让数据->驱动->UI

国际化：文字的国际化、图片的国际化

// UICollectionViewCell的自适应：
1.我们可以现在外部给cell一个预估的宽/高
2.然后在内部给cell进行内容向外部撑开
3.cell内部的UILabel不要设置高度

//写App之前
1.确定App的整体框架；
2.封装各种UI（图片+文字的btn/toast/alert）
3.网络请求封装
4.确定各种数字/文字等UI显示
5.确定开发需要的适配代码(怎么做适配)
6.设置BaseViewController
以上就是最基本的一些封装和前期准备。。。然后再考虑你要写App。。。你要做业务开发

通过基本UI去渲染控件和直接用图片去渲染界面对性能而言谁更优异

在vc中不要初始化UI相关的逻辑：
1.因为在init里面、self.view还没有被创建、直接在
初始化中调用会导致loadView()/viewDidLoad()提前被调用、
2.加载xib的时候关联的IBOutlet组件未被加载到内存的时候直接
调用会导致nil
//self.view被使用会调用loadView()创建并执行viewDidLoad()

占位图：全局占位图、底部占位图
实现方式不一样：全局占位图隐藏UITableView、底部占位图直接使用cell

UICollectionViewCell如果需要等间距显示的话：需要重写UICollectionFlowLayout

对象想要使用：要不初始化/要不直接赋值、不然不能是使用
如果一个对象没有被销毁、则这个对象带着的属性和方法一致存在、保持不变

id/Class/SEL之间的区别？分别代表什么意思？
格式化：obj/String -> %@ / float -> %f
NSPredicate //过滤
NSAssert //代码调试

积分墙
iOS中的指令集是什么意思？
符号表：xxx

// 组件化开发
基础组件库-category
基础UI库-UI样式
基础网络库-网络请求
基础数据库-数据库
基础埋点库-数据埋点
业务逻辑库-业务逻辑
链式编程-简易编程
路由-简易跳

### 上架注意点
1.不能导致手机故障(包括崩溃、UI问题)
2.不要使用任何SDK的私有API
3.不要提及用户设备上不存在的硬件功能
4.如果App需要网络连接、在没有网络的情况下需要告知用户
5.不要模仿/山寨某一个App(马甲包)
6.不要恶搞知名公众人物/不要包含敏感政治话题
7.不要包含执行下载文件的脚本解释器/插件/runtime(不能包含热更新)
8.仅在连接wifi的情况下才可以播放视频和下载其他大型文件
9.不要偷偷使用摄像头/话筒/GPS(可以给用户带来切实好处、需要提前告知用户)

# 提交注意点
1.程序文件名和iTunes应用商店里面显示的名称必须一致(缩写也行)
2.iTunes中描述力求描述应用功能准确、不需要包含价格、Android
3.iTunes关键词要与应用程序功能相匹配、不包含其他App名称
4.App截图不能包含错误状态、UI布局错乱
5.App分类与其功能相符、含有彩蛋必须在演示账号中透漏
6.能够提供各种尺寸图标、不同尺寸图标都包含同样的内容
7.版本号>=1.0
8.info.plist中所需要的设备功能和应用的实际需求相符
9.NSZombieEnabled设置为fasle
10.如果使用推送通知，需要在xxx.entitlements中添加用于
aps-enviroment授权信息、你的appID必须激活推送通知功能
11.更新App的时候当前版本号>上个版本、内容描述和App实际变化相符
12.应用不能够是一个简单的浏览器窗口的网站
13.如果你的App需要登录、需要提供测试账号
14.其他存在的版权信息
