//App启动优化：有哪些建议？了解过dyld吗？
//符号是怎么绑定在地址上的？能写一个hotReload框架吗？
//iOS崩溃是什么导致的？如何监控不同类型的崩溃？
//如何获取详细的内存分配信息：比如不同线程的堆栈调用？
//Apple为什么设计元类？
//Xcode中选择模拟器编译，在 products 中生成的二进制文件后缀是什么？
77.图片裁剪方法
112.即时通讯
/*
即时通讯（IM）
一.底层原理
1）用于IM的协议：XMPP（基于XML的协议,具有超强的可扩展性）
2）XMPP有三个部分：服务器 网关 客户端（可以任意两个双向发生）
2）XMPP的优缺点
1.优点：
XMPP协议是自由开源的,而且在C/S都有多种实现
任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接
我们用XMPP技术开发软件,资源以及支持的来源都是多样的,这样就不会被“绑架”
XMPP以TCP传递XML数据流,没有中央主服务器,任何人都可以运行自己的XMPP服务器
XMPP基于XML具有很强的扩展性
2.缺点
XMPP协议的服务器流量存在着被重复转发,使数据负载太重
XMPP协议是基于XML文件的（编码成单一的XML文件）,因此无法提供修改二进制数据
 
二.上层实现（利用环信）
1.环信：通过云端开放的Rest api或者客户端SDK包（摆脱了IM底层开发）,使APP内置聊天功能
2.步骤
1）注册登录“环信”
2）创建应用（应用名称会存在你的AppKey）,生成AppKey和相关配置文件
3）制作并上传推送证书
1.进入developer.apple.com
2.点击Member Center,进入Certificates,Identifiers&Profiles,制作证书
3.选择对应的App ID
4.根据Certificate Assistant的提示,创建Certificate Request
5.上传上一步中创建的Certificate Request文件
6.下载下来这个证书,并双击导入系统
4)上传证书
1.打开Application-Utilities-Keychain Access应用,我们会看到有刚刚制作
好的推送证书
2.选中证书对应的私钥,点右键,选择导出,并设定密码
3.登录环信后台
4.选择对应的App,填写证书名称
5.上传（选择的是开发环境证书还是生产证书）
5）通过cocoapods下载SDK
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件： #import <EaseMobSDKFull/EaseMob.h>
6）设置工程属性
1.导入SDK依赖库（Xcode7.0,后缀是tbd）
MobileCoreServices.framework
CFNetwork.framework
libEaseMobClientSDKLite.a
libsqlite3.dylib
libstdc++.6.0.9.dylib
libz.dylib
libiconv.dylib
libresolv.dylib
libxml2.dylib
2.向Build Settings-Linking-Other Linker Flags中添加-ObjC(注意大小
写）
如果项目中使用-ObjC有冲突,可以添加-force_load来解决：
格式：-force_load[空格]EaseMobSDK/lib/libEaseMobClientSDKLite.a(静
态库的路径-SDK lib里面拖过来) 在-force_load下面
3.编译没错误则说明集成SDK成功
*/
122.瀑布流
/******************************Objective-C语言基础******************************/
#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？

/******************************补充知识点******************************/
#函数式编程思想(高聚合：代码聚合、方便管理)：把很多功能放在一个函数块(block)去处理
int a = ({
b = 2;
c = 3;
d = 4;
b + c + d; //最后一句设置返回什么
});
UIButton *btn = ({
UIButton *btn = [UIButton alloc]init];
btn.tag = 1;
btn;//最后一句设置返回什么
})
/******************************Objective-C语言基础******************************/
#类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#基于位置的服务LBS：
//系统定位
1.导入MapKit.framework，创建MKMapView
2.显示用户位置，把MKMapkit加到self.view，设置代理
3.导入CoreLocation.framework，创建CLLocationManager(定位对象)设置属性
4.问用户是否允许更新用户信息：开始更新
5.设置代理
6.需要在Info里边添加两项:
1)当APP在前台的时候才使用,会跟用户弹出一个确认框：
NSLocationWhenInUseUsageDescription
2)当APP总是请求用户定位的时候,会跟用户弹出一个确认框：
NSLocationAlwaysUsageDescription
代码：MapViewController.h/m
//大头针：知道经纬度就可以标注位置
1.导入两个框架 MapKit.framework、CoreLocation.framework；
2.创建MKMapView把地图显示出来；
3.定义显示标注的类(MyAnnotation类)，实现MKAnnotation协议；
4.从协议复制属性，初始化协议属性；
5.给地图添加标注：MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
6.给地图添加标注：[self.mapview addAnnotation:a];
代码：MKAnnotation.h/m
//高德地图
1.登录LBS开放平台，申请Key；
2.下载相关SDK和实例代码；
https://blog.csdn.net/a910577347/article/details/73499515
//百度地图
1.登录LBS开放平台，获取密钥；
2.下载相关SDK和实例代码；
https://www.jianshu.com/p/b0169d332918
//腾讯地图
1.登录LBS开放平台，获取参数；
2.下载相关SDK和实例代码；
https://blog.csdn.net/liyun123gx/article/details/44222255

96.map（大头针）
/*
1.有哪些技术可以实现定位：GPS 基站
2.系统提供两个框架：MapKit.framework   CoreLocation.framework
3.MKMapView可以加载地图
4.有三种地图类型
typedef NS_ENUM(NSUInteger, MKMapType) {
MKMapTypeStandard = 0,
MKMapTypeSatellite,
MKMapTypeHybrid,
MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
} NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED;
5.设置代理
*/
/*
1.CL-CoreLocation框架
2.导入CoreLocation框架,使用CLLocationManager核心类
3.创建CLLocationManager核心类
4.[self.locationmanager locationServicesEnabled]为YES-GPS服务可用
*/
/*
在地图上标注位置
1.导入两个框架 MapKit.framework   CoreLocation.framework
2.创建MKMapView把地图显示出来
3.定义显示标注的类（MyAnnotation类）,实现MKAnnotation协议
1）从协议复制属性
2）初始化协议属性：
4.给地图添加标注
MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
//给地图添加标注
[self.mapview addAnnotation:a];
//平移
MKCoordinateRegion region;
region.center.latitude=30.5;
region.center.longitude=116.8;
region.span.latitudeDelta=10;
region.span.longitudeDelta=10;
self.mapview.region=region;
5.知道经纬度就可以标注位置（具体位置借助API）
//定位
需要在Info里边添加两项
当APP在前台的时候才使用，会跟用户弹出一个确认框
NSLocationWhenInUseUsageDescription
当APP总是请求用户定位的时候，会跟用户弹出一个确认框
NSLocationAlwaysUsageDescription
*/
97.地图导航
/*
 高德地图：
 1.高德LBS开放平台：LBS-基于位置的服务
 2.申请Key
 3.下载相关SDK和示例代码
 百度地图：
 1.百度LBS开放平台：
 2.获取密钥（一个密钥对应一个bundle identifier）
 3.相关下载-全部下载
 */

#多媒体：图片、音乐、录音、视频
//上传照片：UIImagePickerController-选择图片类(代理类)
注意：保存图片、UIAlertController打不开
//音频：流的形式
音频录音机-AVAudioRecorder
音频播放器-AVAudioPlayer
//视频：vitamio
视频播放器-MPMoviePlayerController
代码：MediaViewController.h/m
练习：找出实用的第三方框架开发出商用级别项目；
https://blog.csdn.net/Dreamandpassion/article/details/82459246
https://www.jianshu.com/p/d8062b1856f3

92.多媒体（图片、音乐、录音、视频）
/*
1.多媒体：图片,声音,录音,视频
2.UIImagePickerController 选择图片类（代理类）
3.AVFoundation  音乐类（代理类）
1）导入第三方库
2）定义声音对象,创建声音对象
3)创建播放对象,需要传入一个URL,此URL指定了媒体文件的位置,从包里求出MP3的路径是个
字符串
4)设置代理
4.图片：
判断传入的参数(照相机、相册)是否被当前的设备所支持
创建选择图片的对象
设置图片对象打开相册还是照相机
设置控件的代理
显示控件
当选择了一张图片时,会进入到这个代理函数
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
     //被选择的图片,以UIImage对象封装起来,在info的UIImagePickerControllerOriginalImage key值里边
    UIImage *pickImage = info[UIImagePickerControllerOriginalImage];
    self.imageView.image = pickImage;
    //实现了此函数,就需要自己手动地隐藏控件
    [picker dismissViewControllerAnimated:YES completion:^{
    }];
}
//音乐播放
 - (void)play:(id)sender {
 //播放之前,先准备播放
 if ([self.player prepareToPlay]) {
 //准备播放没问题,开始播放
 [self.player play];
 }
}
 - (void)pause:(id)sender {
 //暂停
 [self.player pause];
}
 - (void)stop:(id)sender {
 //停止
 [self.player stop];
 }
 currentTime:当前播放的位置(以秒为单位)(可读写)
 duration:声音的总长度(以秒为单位)(只读)
 - (NSString *)formatTimeWithTimeInterval:(NSTimeInterval)interval {
 NSInteger minute = interval / 60;
 NSInteger second = (NSInteger)interval % 60;
 return [NSString stringWithFormat:@"%ld:%02ld", minute, second];
 }
 - (void)timer:(id)sender {
 self.currentTime.text = [self formatTimeWithTimeInterval:self.player.currentTime];
 if (!self.slider.tracking) {
 self.slider.value = self.player.currentTime / self.player.duration;
 }
}
*/

#二维码：
应用：ZBarSDK第三方库
https://blog.csdn.net/he_jiabin/article/details/47786031

#App换肤：
http://www.cocoachina.com/ios/20171012/20762.html

#图文混排：
https://blog.csdn.net/qcx321/article/details/52194835

#webview混排：
https://blog.csdn.net/u010960265/article/details/80563668

#iPad开发：
//iPad和iPhone开发的异同
https://blog.csdn.net/wujakf/article/details/80223046
//iPad项目开发总结
https://www.jianshu.com/p/522c8993572b
/******************************补充知识点******************************/
#iOS11/12新特性：
https://www.jianshu.com/p/39a5aee18778

1.指针
1）指针就是变量的地址；地址就是唯一标识一块内存的索引
int  a;
a         //a是变量名
&a     //a的地址
&       //取地址符

2）指针变量
1.int  *p;   //定义一个指针变量p
   p           //p是指针变量名
  ＊        //指向
指针变量p的作用：指针变量时用来存储地址的
*p: 指p所指向的内容

2.给指针变量赋值
 p=&a;    // 将整型变量a的地址赋给指针变量p
               //p指向变量a，指针变量p同一时刻只能指向一个变量
  a＝3;    //直接的改变了变量a的值
 *p=5;   //间接的改变了变量a的值
            //＊p是p指向的变量

3.指针作为函数参数的使用
int *p; //变量p是int*类型
            //int是p指向的变量的基类型

4.空指针和野指针
int *p = NULL；   //指针变量p初始化为空
                              //NULL代表空，值为0；
                             //不能使用空指针

int  *p；     //未初始化的指针称为野指针
                   //不能使用野指针
3）printf("&a=%p,&b=%p\n",&a ,&b );   //输出变量a,b的地址，％p地址格式符
int *p=NULL;        //p初始化为空，不能使用空指针
4）使用指针注意事项：
1）定义指针时，一定要初始化为空；
int *p=NULL;//指针作为参数或者已经赋值，则无需初始化为空。
2）使用指针前，一定要给指针赋值；
3）使用指针时，一定要判空
if(p==NULL) {
    return;
}

5)指针大小
固定4个字节（因为地址在内存里都是一整型的方式分配的）
char *p
int *q
//p和q都是4个字节。

例如：交换两个变量
#include "jiaohuan.h"
//传值，无法实现交换
void Swap1(int a,int b)
{
    printf("swap1：%p,%p\n",&a,&b);
    int t;
    t = a;
    a = b;
    b = t;
}
//传地址，交换指针指向，无法实现交换
void Swap2(int *c,int *d)
{
    printf("swap2：%p,%p\n",c,d);
    int *t;
    t = c;
    c = d;
    d = t;
}
//传地址，交换指针指向变量的值，可以实现交换
void Swap3(int *e,int *f) {
    printf("swap3：%p,%p\n",e,f);
    int t;
    t = *e;
    *e = *f;
    *f = t;
}
#include <stdio.h>
void Swap1(int a,int b);
void Swap2(int *a,int *b);
void Swap3(int *a,int *b);

#include <stdio.h>
#include "jiaohuan.h"
int main(int argc, const char * argv[]) {
    // insert code here...
    int a = 3;
    int b = 5;
    printf("主函数:%p,%p\n",&a,&b);
    Swap1(a, b);
    printf("a=%d,b=%d\n",a,b);
    
    int c = 3;
    int d = 5;
    printf("主函数:%p,%p\n",&c,&d);
    Swap2(&c, &d);
    printf("c=%d,d=%d\n",c,d);
    
    int e = 3;
    int f = 5;
    printf("主函数:%p,%p\n",&e,&f);
    Swap3(&e, &f);
    printf("e=%d,f=%d\n",e,f);
}

1.指针
1） 数组和指针
数组名作为函数的参数
数组名代表数组的首地址

2）指针++
int *p=NULL;
int a=5;
p=&a;
p++;
//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数。
//指针的移动：必须赋值地址才可以实现指针的移动，不可以赋值指针所指的内容
 q=p  //正确；
q=*p  //错误；
*q=*p//错误；

2.理解内容：
指针数组
int *p[10];
//这是一个数组，10个元素，每个元素都是个指向整型的指针。
//元素为指针的数组
练习：
快速的声明20个int *指针，分别指向int a[20]中的每个元素
指向数组的指针
int (*p)[10];
//这是一个指针，指向10个int元素的数组。
//指向数组的指针
指向指针的指针
int * * p;
//这是一个指针，指向指针
//二级指针
指向函数的指针
int (*p)(int a);//指向函数的指针
//这是一个指针，指向一个函数。
//函数指针
函数指针的声明方法为：
返回值类型 ( * 指针变量名) (形参列表);

3.字符串
1.认识字符串:字符串就是一串字符。
由一对双引号括起来，双引号里面可以写一串字符 。
//“hello world!”是字符串常量。
//字符串中的每个字符占1个字节，字符的个数，比可视的字符多一个。在字符串结尾处有一个’\0’，称作尾零，其ASCII值就是0.
//如上述字符串中有13个字符，12个有效字符。
例如：int arr[5] = {3,4,5,6,7};
char arr[10] = “hello”;   //长度10
char arr[] = “hello”;     //长度6

2.指向字符串的指针：
char * p = "1234567";
//当我们程序中写下"1234567"，就是在【只读数据段】存储了8个字符。
//"1234567”的值只代表第一个字符的所在空间的地址。
练习：
主函数定义一个字符串，编写函数，传递字符串，统计一下字符串中字母的个数；将统计结果返回给主函数。

3.指针作为函数返回值
数据类型＊  函数名（形参列表）
char * MyStr(char * const str,char c);
在字符串str中查找字符c，返回第一次找到c的首地址，如果找不到，则返回NULL；
#include <stdio.h>
char * MyStr(char * str,char c) {
    if(NULL == str) {
        return NULL;
    }
    while (* != '\0') {
        if(*str == c)
        {
            break;
        }
        str++;
    }
    if (*str == '\0') {
        return NULL;
    } else {
        return str;
    }
}
int main(int argc, const char * argv[]) {
     char *p = "hello c dddworld!";
     char *r = MyStr2(p, 'c');
    printf("%s\n",r);
    return 0;
}

char * MyStr2(char * str,char c);

1.什么是XML？- 可扩展性标记语言
特点：1.可扩展性   2.标记
标记：A.就是标签 成对出现（有开始，有结束）   B.标签区分大小写
例如：
<students>董佳迪</students>
students是标签，董佳迪是标签的值
可扩展性：1.体现在标签的名字用户自己随意命名
2.XML中的标签是可以嵌套的，嵌套的结构也是随意的。
示例：
<?xml version="1.0" encoding="utf-8" ?>
<Students>
  <Student id="1" >
    <name>王也</name>
    <age>18</age>
  </Student>

  <Student id="2">
    <name>孟凡路</name>
    <age>17</age>
  </Student>

  <Student id="3">
    <name>高家兴</name>
    <age>48</age>
  </Student>
</Students>
XML的相关概念：
XML经常被理解成倒挂一棵树
根节点:只能有一对根节点，位于嵌套结构中最外层的节点
在本例中 Students为根节点。
id为属性     1为属性值（属性值必须加“”）
注意点：
1.文档扩展名  .XML
2.XML跨平台。
3.主要用途就是网络传输数据
4.声明，是整个XML的第一条语句
 <?xml version="1.0" encoding="utf-8" ?>
 属性：属性值必须加""；
 注意：文档扩展名.xml、跨平台
 作用：网络传输数据
 区别：json/xml的对比
 1.目前90%的使用json、10%的使用xml；
 2.json解析简单，但是结构不易理解、xml结构容易理解，但是数据冗余；
 解析：见AnalyzeViewController.h/m
 https://blog.csdn.net/qxuewei/article/details/52369067
 
2.XML和JSON的对比
1）90%使用JSON   10%使用XML
2）JSON解析简单   XML解析复杂
3）JSON阅读时结构不易理解  ， XML容易理解，但是有数据冗余

3.XML解析
使用Google的GData解析XML

1）相关类和方法
GDataXMLNode
//获取当前节点的值
- (NSString *)stringValue;

GDataXMLElement : GDataXMLNode
//根据子节点名字获取所有的节点名为name的子节点数组
- (NSArray *)elementsForName:(NSString *)name;
//获取节点的属性
- (NSArray *)attributes;
//根据属性名获取属性节点
- (GDataXMLNode *)attributeForName:(NSString *)name;

GDataXMLDocument    //XML节点树
//创建文档节点
- (id)initWithData:(NSData *)data options:(unsigned int)mask error:(NSError **)error;
//获取跟节点
- (GDataXMLElement *)rootElement;
//根据xpath 语法 获取 指定的节点数组
- (NSArray *)nodesForXPath:(NSString *)xpath error:(NSError **)error;

2）本地解析
//读取数据
NSData *data = [[NSData alloc]initWithContentsOfFile:PATH];
        
//建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];

3）网络解析
转换为URL类型网址
NSURL * url = [NSURL URLWithString:@"http://mps.manzuo.com/mps/cate?sid=(null)&id=0&cc=beijing&pt=all&ffst=1&mnt=10&st=-1&hs=1"];

向服务器请求数据，并获得数据
NSData * data = [NSData dataWithContentsOfURL:url];

建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];

数据接口
http://www.k780.com/api

xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)
练习：
<1>http://www.oschina.net/action/api/news_detail?id=44392
xml解析
Google的GData 第三方库

今日内容：
XPath语法的使用
//XML路径语法
作用：快速的锁定某一级的节点。可以免去一层层复杂的节点搜索
XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。掌握MVC设计模式

3.文件NSHandle
#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str = @"飞流直下三千尺，不及汪伦送我情";
        
        NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
       
        [data writeToFile:PATH atomically:YES];
        
        //创建一个可读可写的文件句柄
        NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:PATH];
        
        //设置偏移量
        [readWriteHandle seekToFileOffset:9];
        
        //读取指定长度数据
        data = [readWriteHandle readDataOfLength:6];
        
        NSString *str1 = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        
        NSLog(@"%@",str1);
        
        //设置偏移量到文件尾
        [readWriteHandle seekToEndOfFile];
        
        //从当前偏移量读取到文件尾
        data = [readWriteHandle readDataToEndOfFile];
        
        //关闭句柄
        [readWriteHandle closeFile];
        
    }
    return 0;
}


12.Json解析
1.本地解析
JSON:
{
    "error": 0,
    "status": "success",
    "date": "2015-08-24",
    "results": [
        {
            "currentCity": "北京市",
            "pm25": "30",
            "index": [
                {
                    "title": "穿衣",
                    "zs": "热",
                    "tipt": "穿衣指数",
                    "des": "天气热，建议着短裙、短裤、短薄外套、T恤等夏季服装。"
                },
                {
                    "title": "洗车",
                    "zs": "较适宜",
                    "tipt": "洗车指数",
                    "des": "较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。"
                },
                {
                    "title": "旅游",
                    "zs": "适宜",
                    "tipt": "旅游指数",
                    "des": "天气较好，但丝毫不会影响您的心情。微风，虽天气稍热，却仍适宜旅游，不要错过机会呦！"
                },
                {
                    "title": "感冒",
                    "zs": "少发",
                    "tipt": "感冒指数",
                    "des": "各项气象条件适宜，发生感冒机率较低。但请避免长期处于空调房间中，以防感冒。"
                },
                {
                    "title": "运动",
                    "zs": "适宜",
                    "tipt": "运动指数",
                    "des": "天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。"
                },
                {
                    "title": "紫外线强度",
                    "zs": "中等",
                    "tipt": "紫外线强度指数",
                    "des": "属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。"
                }
            ],
            "weather_data": [
                {
                    "date": "周一 08月24日 (实时：28℃)",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周二",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周三",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 20℃"
                },
                {
                    "date": "周四",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 21℃"
                }
            ]
        }
    ]
}


#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *zs;
@property NSString *tipt;
@property NSString *des;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"
#define PATH @"/Users/qianfeng/Desktop/本地解析/解析/2.json"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data=[[NSData alloc]initWithContentsOfFile:PATH];
        NSMutableDictionary *dic=[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        NSArray *arr=dic[@"results"];
        NSMutableDictionary *dic1=arr[0];
        NSArray *arr1=dic1[@"index"];
        NSDictionary *dic2=arr1[0];
        
        NSMutableArray *array=[[NSMutableArray alloc]init];
        Model *m=[[Model alloc]init];
        
        for(int i=0;i<[arr1 count];i++) {
            dic2=arr1[i];
            m.title=dic2[@"title"];
            m.zs=dic2[@"zs"];
            m.tipt=dic2[@"tipt"];
            m.des=dic2[@"des"];
            [array addObject:m];
        }
        
        for(Model *m in array) {
            NSLog(@"title:%@ zs:%@ tipt:%@ des:%@",m.title,m.zs,m.tipt,m.des);
        }
    }
    return 0;
}


2。网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString*uid;
@property NSString*username;
@property NSString*groupid;
@property NSString*credit;
@property NSString*experience;
@property NSString*viewnum;
@property NSString*friendnum;
@property NSString*lastactivity;
@property NSString*headimage;
@property NSString*realname;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //定义字符串网址
        NSString *strUrl = @"http://10.0.8.8/sns/my/user_list.php?number=20&page=1";
        
        //将网址转换为URL类型
        //string类型的字符串网址需要做一个转换
        //转换为NSURL类型的网址，才可以进行申请数据操作
        NSURL *url = [NSURL URLWithString:strUrl];
        
        //向网络服务器请求数据
        //同步请求数据，当服务器响应数据之前，线程一直处于卡死状态
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        
        //网络请求的数据都存储在data里了
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        //到这一步，所有的json数据都存储在字典里了
        NSArray *arr= dic[@"users"];
        NSDictionary *dic1=arr[0];
        NSMutableArray *array=[[NSMutableArray alloc]init];
        
        for(int i=0;i<[arr count];i++) {
            Model *m=[[Model alloc]init];
            dic1=[arr objectAtIndex:i];
            m.uid=dic1[@"uid"];
            m.username=dic1[@"username"];
            m.groupid=dic1[@"groupid"];
            m.credit=dic1[@"credit"];
            m.experience=dic1[@"experience"];
            m.viewnum=dic1[@"viewnum"];
            m.friendnum=dic1[@"friendnum"];
            m.lastactivity=dic1[@"lastactivity"];
            m.headimage=dic1[@"headimage"];
            m.realname=dic1[@"realname"];
            
            [array addObject:m];
        }
        for(Model *m in array) {
            NSLog(@"uid:%@ username:%@ groupid:%@ credit:%@ experience:%@ viewnum:%@ friendnum:%@ lastactivity:%@ headimage%@ realname:%@",m.uid,m.username,m.groupid,m.credit,m.experience,m.viewnum,m.friendnum,m.lastactivity,m.headimage,m.realname);
        }
    }
    return 0;
}


13.XML解析
1.本地解析
xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)

#import <Foundation/Foundation.h>

@interface Book : NSObject

@property NSString *ID;
@property NSString *lag;
@property NSString *name;
@property NSString *authorName;
@property NSInteger price;
@property NSString *summary;

@end


#import <Foundation/Foundation.h>
#import "Book.h"

@interface Manager : NSObject {
    NSMutableArray *arr;
}

- (void)addBook:(Book *)book;

- (void)show;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        arr = [[NSMutableArray alloc]init];
    }
    return self;
}

- (void)addBook:(Book *)book {
    [arr addObject:book];
}

- (void)show {
    for (Book *b in arr) {
        NSLog(@"%@",b.summary);
    }
}
@end


#import "Book.h"

@implementation Book

@end


#import <Foundation/Foundation.h>
#import "Book.h"
#import "Manager.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/demo/xml本地解析4/xml本地解析4/GData/book.xml"];
        GDataXMLDocument *doct = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootElement = [doct rootElement];
        
        //取books节点
        GDataXMLElement *booksElement = [rootElement elementsForName:@"books"].firstObject;
        
        Manager *m=[[Manager alloc]init];
        
        //取book节点
        NSArray *arr = [booksElement elementsForName:@"book"];
        
        for (GDataXMLElement *bookElement in arr) {
            GDataXMLNode *ID = [bookElement attributeForName:@"id"];
            GDataXMLNode *language = [bookElement attributeForName:@"language"];
            GDataXMLElement *nameElement = [bookElement elementsForName:@"name"].firstObject;
            GDataXMLElement *autherElement = [bookElement elementsForName:@"auther"].firstObject;
            GDataXMLElement *autNameElement = [autherElement elementsForName:@"name"].firstObject;
            GDataXMLElement *priceElement = [bookElement elementsForName:@"price"].firstObject;
            GDataXMLElement *summaryElement = [bookElement elementsForName:@"summary"].firstObject;
            
            Book *book = [[Book alloc]init];
            book.ID = [ID stringValue];
            book.lag = [language stringValue];
            book.name = [nameElement stringValue];
            book.authorName = [autNameElement stringValue];
            book.price = [[priceElement stringValue] doubleValue];
            book.summary = [summaryElement stringValue];

            [m addBook:book];
        }
        [m show];
    }
    return 0;
}


2.XML:
<?xml version="1.0" encoding="UTF-8"?>
<root name="中国">
  <province name="天津市" postcode="120000" >
    <city name="市辖区" postcode="120100" >
        <area name="和平区" postcode="120101" />
        <area name="河东区" postcode="120102" />
        <area name="河西区" postcode="120103" />
        <area name="南开区" postcode="120104" />
        <area name="河北区" postcode="120105" />
        <area name="红桥区" postcode="120106" />
        <area name="塘沽区" postcode="120107" />
        <area name="汉沽区" postcode="120108" />
        <area name="大港区" postcode="120109" />
        <area name="东丽区" postcode="120110" />
        <area name="西青区" postcode="120111" />
        <area name="津南区" postcode="120112" />
        <area name="北辰区" postcode="120113" />
        <area name="武清区" postcode="120114" />
        <area name="宝坻区" postcode="120115" />
    </city>
  </province>
</root>


#import <Foundation/Foundation.h>

@interface Area : NSObject

@property NSString *name;
@property NSString *postcode;

@end


#import "Area.h"

@implementation Area

@end


#import <Foundation/Foundation.h>
#import "Area.h"
@interface Manager : NSObject {
    NSMutableArray *_arr;
}

- (void)addArea:(Area *)area;

- (void)showAll;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        _arr = [[NSMutableArray alloc]init];
    }
    return self;
}

-(void)addArea:(Area *)area {
    [_arr addObject:area];
}

-(void)showAll {
    for (Area *area in _arr) {
        NSLog(@"name:%@,postcode:%@",area.name,area.postcode);
    }
}

@end


#import <Foundation/Foundation.h>
#import "GDataXMLNode.h"
#import "Manager.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Manager *m = [[Manager alloc]init];
        
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/伯明利－下午 /2.t/tianjin.xml"];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        
        GDataXMLElement *rootElement = [doc rootElement];
        GDataXMLNode *rootNameElement = [rootElement attributeForName:@"name"];
        Area *area1 = [[Area alloc]init];
        area1.name = rootNameElement.stringValue;
        [m addArea:area1];
        
        GDataXMLElement *provinceElement = [rootElement elementsForName:@"province"].firstObject;
        GDataXMLNode *provinceName = [provinceElement attributeForName:@"name"];
        GDataXMLNode *provincePostcode = [provinceElement attributeForName:@"postcode"];
        Area *area2 = [[Area alloc]init];
        area2.name =provinceName.stringValue;
        area2.postcode =provincePostcode.stringValue;
        [m addArea:area2];
        
        GDataXMLElement *cityElement = [provinceElement elementsForName:@"city"].firstObject;
        GDataXMLNode *cityName = [cityElement attributeForName:@"name"];
        GDataXMLNode *cityPostcode = [cityElement attributeForName:@"postcode"];
        Area *area3 = [[Area alloc]init];
        area3.name = cityName.stringValue;
        area3.postcode = cityPostcode.stringValue;
        [m addArea:area3];
        
        NSArray *arr = [cityElement elementsForName:@"area"];
        for (GDataXMLElement *areaElement in arr) {
            GDataXMLNode *name = [areaElement attributeForName:@"name"];
            GDataXMLNode *postcode = [areaElement attributeForName:@"postcode"];
            Area *area = [[Area alloc]init];
            area.name = name.stringValue;
            area.postcode = postcode.stringValue;
            [m addArea:area];
        }
        [m showAll];
    }
    return 0;
}

3.网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *url;

@end


#import "Model.h"

@implementation Model

@end

#import <Foundation/Foundation.h>
#import "Model.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSURL *url = [NSURL URLWithString:@"http://www.oschina.net/action/api/news_detail?id=44392"];
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootEle = [doc rootElement];
        GDataXMLElement *newsEle = [rootEle elementsForName:@"news"][0];
        GDataXMLElement *relEle = [newsEle elementsForName:@"relativies"][0];

        NSArray *arr = [relEle elementsForName:@"relative"];
        NSMutableArray *mArr = [[NSMutableArray alloc]init];
        
        for (GDataXMLElement *releEle in arr) {
            GDataXMLElement *titleEle = [releEle elementsForName:@"rtitle"][0];
            GDataXMLElement *urlEle = [releEle elementsForName:@"rurl"][0];
            
            Model *m = [[Model alloc]init];
            m.title = [titleEle stringValue];
            m.url = [urlEle stringValue];
            [mArr addObject:m];
        }
        for (Model *m in mArr) {
            NSLog(@"title=%@,url=%@",m.title,m.url);
        }
    }
    return 0;
}

#网络编程需要掌握的内容：NO
0.实时监测网络变化
1.数据请求、数据上传、下载
2.原生网络请求的原理
3.网络请求第三方库的使用
4.KVC在网络请求中的应用
5.进入VC以后怎么加载操作

今日项目需求(参考2015-10-13/org.mobiletrain.afnetworking-sample)
0 ViewController当中的所有数据，都是来源于Model，但不在ViewController当中保存，是存放在单独的Model类。其他的类也会使用到这一个Model，所以Model必须是单例
1 ViewController当中，不进行网络请求，不使用AFNetworking。
2 ViewController当中，要进行网络请求，委托另外一个类(PostStore)来进行请求
3 PostStore进行网络请求之后，需要告诉ViewController，请求和数据操作都已经完成
4ViewController是一个列表视图控制器，既然委托PostStore进行网络请求，并且PostStore会在网络请求完成之后，操作Model，所以要观察Model([PostList sharedInstance].posts)
5PostStore在网络请求的方法内，需要外部传入两个block，这两个block，会在PostStore网络请求完成并且数据解析完成之后调回去
6PostStore内部需要做3件事：数据下载；唯一性判断；排序。所以应该在最后一步，也就是排序的时候，告诉观察者，数据(Model)已经更新了
7ViewController当中的cell，需要显示Model当中的text，这个text会被改变(DetailViewController)，所以cell需要添加对于这个Model(NSMutableDictionary)的观察者
8 因为有复用机制，所以当设置观察者之前，需要将之前的观察者删除掉
9 ViewController和DetailViewController不应该传输数据，所以，当前被选中的PostInfo，需要放到Model当中([PostList sharedInstance].selectedPost)，设置好之后，再进入下一级页面

1.项目的技术要点/功能模块实现/项目中的难点有哪些，怎么解决的/项目中有哪些你不满意的地方/如果现在让你做，
你可以怎么做？/做过最得意的是什么项目?
3.你通常用什么数据格式与服务端交互：json/xml|json、xml解析方式的底层是如何处理的？
2.什么时候需要使用delegate/什么时候需要使用notification
12.代理delegate/通知/block之间有什么区别？
19.使用过哪些第三方库？jsonKit/AFNetworking/SnapKit/MJRefresh///要有针对性，涉及到每个方面；
20.怎么实现UITableView的懒加载？
21.iOS开发中常见的异常有哪些？
22.什么时候使用栈/队列？什么时候使用链表/数组？
34.性能优化：重点
35.静态初始化什么场合可以使用？什么场合不能使用？
36.导致app异常假死的情况有哪些？有什么解决方案？
38.怎么为App设计缓存？
40.obj中可修改/不可修改类型？
47.iOS中类有哪些通讯方式？
53.消息推送中心的过程？
55.指针函数和函数指针有什么区别？
56.怎样才能一次遍历就能确认链表中存在环？
62.为什么category只能为对象添加方法？却不能添加成员变量？
63.简述NSInteger* a/NSInteger a的区别？
64.block和gcd的并发执行？
65.Xib/代码方法创建界面的优缺点？
66.关于Objective的异常处理？
70.app一个页面crash、你可以用什么工具去查内存之类的状态；
关于View的一些高级动画：目前是一点都不会

1.给定链表的头指针和一个结点指针，在O(1)时间删除该结点。
链表结点的定义如下：
struct ListNode {
    int m_nKey;
    ListNode* m_pNext;
}
函数的声明：void DeleteNode(ListNode* pListHead, ListNode* pToBeDeleted);
2.语句倒序：I am Bruch；（语言随意：不能使用伪代码）
4.将一个链表逆序？/输出一个字符串是否对称？/输出树的深度？
6.C语言中默认的随机数random()是从x->y?
9.id obj = [[NSMutableArray alloc]init];/id obj = [NSMutableArray array];初始化
有什么不同？
10.在ARC模式下，autoreleasepool的使用？（使用伪代码）/autoreleasepool的作用？
11.id obj = [[[NSMutableArray alloc]init] autorelease];obj在什么时候释放？有什么
方法可以让obj马上释放？（用伪代码表示）
12.for(int index = 0; index < 20; index++) {
    NSString *tempStr = @"tempStr";
    NSLog(tempStr)
    NSNumber *tempNumber = [NSNumber numberWithInt:2];
    NSLog(tempNumber)
}
这段代码有什么问题？会不会导致内存泄漏(多线程)/在内存紧张的设备上做大循环时

17.NSString *name; [name release]; // 执行代码会出现什么结果？简述原因

14.写出以下操作以后person的retain count是多少？
Person *person = [Person alloc] init]；
[person retain];
[person release];
[person release];

//面试题：技术部分
2.iOS程序在执行main函数之前做了哪些操作？
3.一个App可以有几个UIWindow？
7.NSOperation什么时候从queue中移除？
18.怎么提高客户端的性能？（这点需要深入研究一番）
25.有哪些方法可以启动一个线程？
26.xib/nib之间的区别？
28.json解析内部是怎么实现的？
29.试说明SEL和@selector的用途、有什么作用？
31.请说明Touch和非Touch事件发生时在系统中的传递过程？（事件传递hitest）
34.如果开启异步线程？如果想要延迟执行某个线程怎么实现？
42.iOS应用是如何实现后台多任务处理？
43.category是怎么样一个机制？一般什么时候使用？
//参考网站：
http://www.cnblogs.com/Piosa/archive/2012/02/22/2363234.html
CGFloat/Float之间的区别？
//谈谈UITableView的优化
1.利用cell的复用：可以不用每次都创建cell、表述一下cell的复用机制、场景；//最基础的
2.设计尽量统一cell的样式；//这个没办法避免
3.布局方面：可以提前计算并缓存cell高度、不用每次调用delegate都去计算；
4.遇到复杂页面：可以考虑异步绘制、减少子视图的层级关系；
5.尽量不要动态add/remove子控件、可以在init()中就加载完毕，然后通过hidden控制显示/隐藏；
6.使用调试工具分析问题；

1.读写文件的例子？
2.读写数据库的例子？
3.异步加载网络图片的例子？

总结推送：
1.从APNS获取device token作为设备唯一标识符

数据结构；树

//iOS推送原理机制：

//网络部分
1.http请求分几部分？

UITableView调用reloadData()会发生什么问题？

### 面试题
4. 同一个游戏包(GameID相同)怎么区分下载来自哪一个渠道？
5. UITableView怎么做预加载？
6. 懂不懂OpenGL？
7. 知道多线程吗？介绍一下iOS中多线程的情况？平时你喜欢使用哪种？在哪些开发中使用到了多线程？
8. swift中结构体和类之间的区别？
11. keyWindow和一般Window的区别？
12. delegate/通知/block之间的区别？
13. AF2.0和AF3.0之间的区别？AF2.0有常驻子线程而AF3.0没有是什么原因？
14. git rebase/git merge的区别？
16. 数组指针/指针数组的区别？
17. 三种动画？各种动画的区别联系？
18. block的循环引用：渐变动画会出现循环引用吗？
19. atomic一定是安全的吗？
21. if(self=[super init]) { //...}为什么需要这样写？[super init]按照常理
只是初始化父类的空间、为什么self可以调用子类的方法？
22. ARC是什么？工作机制详细讲下？
23. 常见的第三方库你见过那些多线程？/有盟、高德地图、AFNetWorking、SDWebImage、FMDB
31. 在iOS中有哪些常见第三方库：实现的功能是什么？你看过第三方库的源码吗？有过根据需求修改过源码吗？
32. 写一个NSString类的实现；
33. 描述OC和swift的联系和不同；
34. 描述ARC机制的原理和实现；
35. 描述controller和view之间的关系。为什么要使用viewController；
36. 描述SQLite.swift的大致实现原理；
37. 描述IP/TCP/UDP/HTTP几种协议的理解；
38. 描述web Service和Web Api的区别；（发展思路和应用场景）；
39. 描述web后端Session在什么时候产生、什么时候结束？Cookie又是什么关系？
40. iOS的后台运行是什么原理和机制？
41. 创建一个对象、放在可变数组中。释放整个对象会发生什么？释放数组会发生什么？
44. WWDC是什么？你有关注过WWDC吗？
45. Xcode选择模拟器编译：在Products中生成的二进制文件后缀是什么？
46. 重点理解SEL的用法；

// 数据库开发：sql语句/连表查询
例1.有两张表，用户表(Z_User)和黑名单表(Z_Blackuser)，userid是Z_User的
主键，Z_BlackUser的外键。现在需要查询用户表中不在黑名单表中的数据，请写出sql语句。

//UI问题
layer和UIView、UIWindow的区别是什么？

5.怎么实现连表查询？ //重点中的重点！！！

//数据库方面
1.什么是视图？
2.使用索引查询一定可以提高查询性能呢？为什么？
3.内联接和外联接的区别？

1.解释一下block、使用block应该注意什么;
2.block的用法？
3.如何避免使用block引起循环引用问题？
1.dispatch_get_current_queue会引起什么问题？死锁（原因？？？）
1.CoreAnimation/CoreGraphics是否使用过？
Xcode支持在一个工程里面新建多个项目
//数据存储
1.单例保存的数据App杀死、数据清空
2.数据库/NSUserDefaults保存的数据在App被杀死数据不会清空、App被卸载数据会清空

###人事问题
1.今年的目标是什么？5年的规划是什么？
2.希望从我们公司学习到什么？
3.住哪里？有没有女朋友？上家工资多少？//按照实际回答即可
4.为什么离职？//这个总结一下
5.公司有多少人？iOS部门有多少人？具体是怎么样的工作流程？
6.App哪些模块是你做的？
7.你投简历投了几家？拿到几个offer；//这个想一下具体回答
8.工作中遇到什么技术难点（这个一般不是人事问题、但是需要好好总结）

//链表/数组的不同

//nullable、__nullable、__Nullable之间的关系？
1.目的：为了兼容swift
2.三者之间没有任何的区别？就是书写的时候位置有不同
3.-(nullable NSString*)method;nonNull表示对象不应该为空、nullable表示对象可以为空?
4.不带下划线在类的前面、写下划线的在类的后面
参考：https://blog.csdn.net/conglin1991/article/details/77159652
建议：使用nullable这样符合属性修饰符的位置、跟copy、strong一样

关于数据结构：一定需要自己好好梳理知识点：
1.二叉树
2.链表
3.哈希表

//网络相关方面
1.有没有用过socket、一般怎么使用？如果预防socket丢包？

//加密算法
1.MD5-概念、应用场景、

//你最引以为豪的项目是什么？你做的最成功的项目是什么？
你项目有哪些不足？如果是现在给你修改、你可以怎么修改？
Xcode有哪些可以改进的地方、你最爱使用什么方法检查某种新技术是否好用？

swift中enum/struct都是比类更厉害

App中哪些需要存放在本机|App中的缓存机制
/***********************json按页下载数据******************************/
//1.声明当前页数、总页数
self.page = 1
self.maxPage = 1
//2.首次加载
page传入1-开始网络请求
//3.请求完成：开始赋值
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
//4.再次网络请求：
page++ //判断是否大于最大页面：大于停止刷新
self.page = model.page
self.maxPage = self.maxPage(byTotalSize: model.total, pageSize: model.size)
判断当前页面是否大于最大页面：大于停止刷新
/////CommunityCommentDetailController.swift
15.什么是"Jenkins"/TabBar这么实现动画效果/hook

App哪些信息需要存储在本地：可能会涉及到多表查询

学会了怎么设置cell自适应：配合设置控件高度为0一起使用；/需要预估高度/可以把内部的高度传出来

YYText怎么使用、有什么作用？？？

iOS中关于图片缓存和缓存cell的高度

cell内部如果某一个控件不需要我们可以更新布局为0

//项目中：如果Model中需要新的数据：可以直接在Model中创建->然后拿出来使用
如果某个ui需要改变：可以在内部改变->vc中可以调用方法告诉view你的view显示需要改变

在开发中，我们一般UIButton会使用custom、而不使用system

看控制器会不会走 deinit方法，有内存泄漏 deinit这个方法是不会走的

NSNotFound
int和NSInteger都是基本数据类型、一般OC使用NSInteger代替int/Swift使用Int、然后需要放在字典中的话：需要包装：@(NSInteger)

给对象赋值不需要初始化

1.什么时候更新model?
1).网络加载数据：更新model；2).本地上传数据：之后更新model；

一般对象我们都设置var
对象赋值不需要init
给对象属性赋值：必须要init

对于布局：一般不建议写死
一般先把左上角|中点控制好；
然后把宽|高控制好
间距：一般不用up|all
尺寸：一般使用up|all
如果对于5s的屏幕：太小了  间距也可以使用up|all
自己的代码必须有足够的兼容性

git上面的：stash
fir的使用：怎么使用
一般公司打包：怎么打包

// 组件化开发实践
https://www.jianshu.com/p/f472fa9f0616

找问题一定要从外向内找、找不到在找旁边的
千万不要还没有找进去  就开始在旁边找
这样很能迷失方向：让人很烦躁、不安   然后找不到答案、一定要静下心来

pod repo update // 更新电脑本地保存的版本库中的版本信息

遇到{就会给它分配一个存储空间、直到遇到}该存储空间会被释放

如果只需要上拉加载、不需要下拉刷新

这时候可以把下拉刷新不写：直接在viewDidLoad() {
    中网络请求：然后执行上拉加载：最开始的网络请求可以设置为page = 1
}

swift怎么写网络请求：

OC怎么处理网络请求：

// 将一个图片位于什么部位开始拉伸(以原点为中心点)
// 返回一个UIImage
UIImage.resiezableImage(with: UIImage(named: "calendar_bg_white"), edgeInsets: UIEdgeInsets(top: 0.5, left: 0.5, bottom: 0.5, right: 0.5))

1.严格按照设计稿设计UI
2.一般设置UI的时候一定要想到怎么当文字过长会怎么样

如果App的跳转比较像（就是model不一样）
我们可以对model进行赋值
新建一个model   对model进行赋值

在xib中，command选中两个控件   可以让他们等宽、然后修改比例

数据库问的问题：数据的增删改查、多表的链接查询、数据回滚

内部用的什么类型数据
外部就必须用什么类型的数据接受

不能内部是字典/外部是数组

如果json是一个model   你就用字典接受
然后传出来的必须也是model
"data":{
    // 这是一个字典
}
外层也必须使用model去接收->然后取出来model里面的list->如果需要分页还需要拼接list

如果json是数组的话。必须用数组接受
"data"[{
    // 这是一个数组
},{
    
}]
必须使用数组去接受-> 然后外层也必须使用数组来接受：可以直接等于

swift中main函数消失：https://blog.csdn.net/zhao18933/article/details/46640657

国际化：文字的国际化、图片的国际化

// UICollectionViewCell的自适应：
1.我们可以现在外部给cell一个预估的宽/高
2.然后在内部给cell进行内容向外部撑开
3.cell内部的UILabel不要设置高度

//写App之前
1.确定App的整体框架；
2.封装各种UI（图片+文字的btn/toast/alert）
3.网络请求封装
4.确定各种数字/文字等UI显示
5.确定开发需要的适配代码(怎么做适配)
6.设置BaseViewController
以上就是最基本的一些封装和前期准备。。。然后再考虑你要写App。。。你要做业务开发

通过基本UI去渲染控件和直接用图片去渲染界面对性能而言谁更优异

在vc中不要初始化UI相关的逻辑：
1.因为在init里面、self.view还没有被创建、直接在
初始化中调用会导致loadView()/viewDidLoad()提前被调用、
2.加载xib的时候关联的IBOutlet组件未被加载到内存的时候直接
调用会导致nil
//self.view被使用会调用loadView()创建并执行viewDidLoad()

占位图：全局占位图、底部占位图
实现方式不一样：全局占位图隐藏UITableView、底部占位图直接使用cell

UICollectionViewCell如果需要等间距显示的话：需要重写UICollectionFlowLayout

对象想要使用：要不初始化/要不直接赋值、不然不能是使用
如果一个对象没有被销毁、则这个对象带着的属性和方法一致存在、保持不变

id/Class/SEL之间的区别？分别代表什么意思？
格式化：obj/String -> %@ / float -> %f
NSPredicate //过滤
NSAssert //代码调试

积分墙
iOS中的指令集是什么意思？
符号表：xxx

// 组件化开发
基础组件库-category
基础UI库-UI样式
基础网络库-网络请求
基础数据库-数据库
基础埋点库-数据埋点
业务逻辑库-业务逻辑
链式编程-简易编程
路由-简易跳

### 上架注意点
1.不能导致手机故障(包括崩溃、UI问题)
2.不要使用任何SDK的私有API
3.不要提及用户设备上不存在的硬件功能
4.如果App需要网络连接、在没有网络的情况下需要告知用户
5.不要模仿/山寨某一个App(马甲包)
6.不要恶搞知名公众人物/不要包含敏感政治话题
7.不要包含执行下载文件的脚本解释器/插件/runtime(不能包含热更新)
8.仅在连接wifi的情况下才可以播放视频和下载其他大型文件
9.不要偷偷使用摄像头/话筒/GPS(可以给用户带来切实好处、需要提前告知用户)

# 提交注意点
1.程序文件名和iTunes应用商店里面显示的名称必须一致(缩写也行)
2.iTunes中描述力求描述应用功能准确、不需要包含价格、Android
3.iTunes关键词要与应用程序功能相匹配、不包含其他App名称
4.App截图不能包含错误状态、UI布局错乱
5.App分类与其功能相符、含有彩蛋必须在演示账号中透漏
6.能够提供各种尺寸图标、不同尺寸图标都包含同样的内容
7.版本号>=1.0
8.info.plist中所需要的设备功能和应用的实际需求相符
9.NSZombieEnabled设置为fasle
10.如果使用推送通知，需要在xxx.entitlements中添加用于
aps-enviroment授权信息、你的appID必须激活推送通知功能
11.更新App的时候当前版本号>上个版本、内容描述和App实际变化相符
12.应用不能够是一个简单的浏览器窗口的网站
13.如果你的App需要登录、需要提供测试账号
14.其他存在的版权信息

1.看下面的程序,三次NSLog会输出什么？为什么？
NSMutableArray* ary = [[NSMutableArray array] retain];
NSString *str = [NSString stringWithFormat:@"test"];  // 1
[str retain];   // 2
[ary addObject:str]; // 3
NSLog(@"%d", [str retainCount]);
[str retain];  // 4
[str release];   // 3
[str release];   // 2
NSLog(@"%d", [str retainCount]);
[ary removeAllObjects]; // 1
NSLog(@"%d", [str retainCount]);
结果：3、2、1

2.KVC底层实现?
  setValue:obj forKeyPath:key的底层实现:
  1.它会调用这个属性的set方法.
  2.如果没有set方法,它会去判断有没有跟key值同名的成员属性.如果有,就直接赋值.icon = obj.
  3.如果没有,那么它还会去判断有没有跟key值名相同带有下划线的成员属性,如果有,就直接赋值,_icon = obj.
  4.如果都没有, 就直接报错.找不到对应的成员属性.
        
4.导航控制器管理原则?
  当调用导航控制器的push方法时, 就会把一个控制器压入到导航控制器的栈中.
  压入栈中是, 那么刚压入栈中的这个导航控制器就在栈的最顶部.
  它就会把原来导航控制器View当中存放的子控制器View的内容移除,
  然后把导航控制器栈顶控制器的View添加到导航控制器专门存放子控制器View当中.
  注意:只是把控制器的View从导航控制器存放子控制器的View当中移除,并没有把控制器从栈中移除.所以上一个控制器还在.
  当调用pop当方法时, 就会把导航控制器存放子控制器View当中控制器的View移除,并且会把该控制器从栈里面移除.
  此时该控制器就会被销毁.接着它就会把上一个控制器的View添加到导航控制器专门存放子控制器的View当中.
  
  1.CGAffineTransformMake与CGAffineTransform的区别?

Core Animation
通过 CoreAnimation，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。

Core Audio
Core Audio是播放，你知道ios。处理和录制音频，能够轻松为您的应用程序添加强大的音频效用。

Core Data
提供了一个面向对象的数据管理解决计划，它易于使用和理解，以至可处理任何应用或大或小的数据模型。

信号量
dispatch_semaphore_t
dispatch_semaphore_create
dispatch_semaphore_wait
dispatch_semaphore_signal
信号量
跟线程锁(NSLock)概念差不多
将线程锁，理解成来回两车道，同方向前车在那停着，后车必须等
其实就是信号量为1的时候
信号量可以定义堵塞的数量
比如说信号定义了堵塞数量为2，同方向前车在那堵着，但是另外一条车道有一个空的，所以后车可以选择绕过去
但是如果同方向两车道都有车在那停着，后车必须也等待，等待到有任何一个车被释放，才可以继续往前开

//// 使用 copy 外部修改了字符串不会影响内部
//// copy 会判断字符串是不可变字符串还是可变字符串
//// 不可变字符串直接赋值
//// 可变字符串生成新的对象
//@property (copy, nonatomic) NSString *name;

1.WWDC是什么？你关注过哪些？
7.数据保存怎么实现？
8.block和gcd的并发执行
9.app的优化,你用什么工具去优化一个qpp,例如,例如一个页面,万一崩了,你用什么工具去查内存之类的状态
10.你项目遇到的问题,怎么解决的
11.你用过的认为好的app,为什么
12.其他的一些基础的知识
13,项目中你觉得好的动画什么的,可以show一下
3. 异步线程如何开启，如果想线程过一段时间再执行，如何实现？
 5. 如何测试一个iOS设备的性能？

1：ARC是什么？工作机制详细讲下。
2：三方库里面的你见过那些多线程，讲一下。
5：GCD
6：还有就是把你的项目下载下来，问你功能的实现问题
2、写一个view动画从顶到底部再消失，
5、输出数组不同元素的组合。
14.什么时候使用delegate什么时候使用Notification？

关于算法 - 我们是实用主义， iOS 开发中很少需要自己写复杂的算法，所以不在面试考核标准中

什么情况使用 weak 关键字，相比 assign 有什么不同?
怎么用 copy 关键字?
这个写法会出什么问题: @property (copy) NSMutableArray *array;
如何让自己的类用 copy 修饰符?如何重写带 copy 关键字的 setter? 这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的

ARC 下，不显示指定任何属性关键字时，默认的关键字都有哪些?
用 @property 声明的 NSString (或 NSArray ，NSDictionary )经常使用 copy 关键字，
为什么?如果改用 strong 关键字，可能造成什么问题?
objc 中向一个 nil 对象发送消息将会发生什么?
objc 中向一个对象发送消息 [obj foo] 和 objc_msgSend() 函数之间有什么关系? 什么时候会报 unrecognized selector 的异常?
一个 objc 对象的 isa的指针指向什么?有什么作用?
runtime 如何通过 selector 找到对应的 IMP 地址?(分别考虑类方法和实例方法)
使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么? [※※※※※ ]objc 中的类方法和实例方法有什么本质区别和联系?
runtime 如何实现 weak 变量的自动置 nil ?
能否向编译后得到的类中增加实例变量?能否向运行时创建的类中添加实例
//objc 使用什么机制管理对象内存?
ARC 通过什么方式帮助开发者管理内存?
不手动指定 autoreleasepool 的前提下， 一个 autorealese 对象在什么时刻释放? (比 如在一个 vc 的 viewDidLoad 中创建)
BAD_ACCESS 在什么情况下出现?
苹果是如何实现 autoreleasepool 的?
使用 block 时什么情况会发生引用循环，如何解决?
在 block 内如何修改 block 外部变量?
使用系统的某些 block api (如 UIView 的 block 版本写动画时) ，是否也考虑引用循 环问题?
GCD 的队列( dispatch_queue_t)分哪两种类型?
如何用 GCD 同步若干个异步调用? (如根据若干个 url 异步加载多张图片， 然后在都下载完成后合成一张整图)
addObserver:forKeyPath:options:context: 实现哪个方法才能获得 KVO 回调?
各个参数的作用分别是什么，
observer 中需要
如何手动触发一个 value 的 KVO
若一个类有实例变量 NSString *_foo ，调用 setValue:forKey: 时，可以以 foo 还是 _foo
作为 key?
KVC 的 keyPath 中的集合运算符如何使用?
KVC 和 KVO 的 keyPath 一定是属性么?
如何关闭默认的 KVO 的默认实现，并进入自定义的 [※※※※※ ]apple 用什么方式实现对一个对象的 KVO ?
IBOutlet 连出来的视图属性为什么可以被设置成 weak?
IB 中 User Defined Runtime Attributes 如何使用? 如何调试 BAD_ACCESS 错误
lldb (gdb)常用的调试命令?
KVO 实现?
这些小题可以做为讨论的入口， 根据面试者的回答再继续聊下去。 是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。
业务能力
其中一些题比较底层，
毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法， 80% 的时 间都是和搭建页面、写业务逻辑、网络请求打交道。
要求面试者能够熟练构建 UI ，我会找一个面试者做过的页面让他分析下页面结构、约 束或者 frame 布局的连法和计算方法;有时也会让面试者说说 UITableView 常用的几个
delegate 和 data source 代理方法， 动态 Cell 高度计算什么的; 接下来， 在手机里随便找一 个 App 的页面， 让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。 问几个
问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout ，假如面试者依然 使用代码码 UI 也到没关系，有“从良”意愿就很好 ~
程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说
Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现?
架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有 正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到UIView 的子类里面干。
网络请求、 数据库等各家都有成熟的封装，基本知道咋用就行。除此之外， 带的问下除了 iOS 开发外， 还会什么其他编程语言、 或者熟悉哪种脚本语言和 作等，甚至还问问是如何翻墙 - -，相信这些技能都是很重要的。
大家都是写程序的， 没啥必要用奇怪的、 很难的问题难为对方，更关键的还是性格， 和Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表 达要正常， 经常遇到问一个问题后一两分钟一直处于沉思状态， 一句话不说， 交流像挤牙膏
一样，很是憋屈;还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪 口上就别怪不客气了 。决定要不要一个人基本上聊 5 分钟就可以确定了， 喜欢水到渠成 的感觉，看对眼了挡都挡不住。
招聘告一段落， 后面将会有更精彩的事情发生。 最后， 再次感谢大家的支持和对我的信 任。

谈谈你对代理设计模式的理解?
25、 谈谈你对 Socket 的理解? TCP 和 UDP 协议有什么区别
26、 你常用的数据存储方式有哪些?
27、 通知中心和代理都可以用来发送消息和数据，两者有什么区别?

如何判断字典元素为空

请描述IOS的动画机制

6. NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？

7.什么是安全释放？
 
12.委托是什么？委托的property声明用什么属性？为什么？
 
16.for(int index = 0; index < 20; index ++){
    NSString *tempStr = @”tempStr”;
    NSLog(tempStr);
    NSNumber *tempNumber = [NSNumber numberWithInt:2];
    NSLog(tempNumber);
}
这段代码有什么问题.？会不会造成内存泄露（多线程）？在内存紧张的设备上做大循环时自动释放池是写在循环内好还是循环外好？为什么？
 
18.在一个对象释放前.如果他被加到了notificationCenter 中.不在notificationcenter中remove这个对象可能会出现什么问题？

20.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.

25.阐述一个nil对象从interface bulider产生，到载入程序运行空间，最后被释放时所经历的生命周期.
 
26.notification是同步还是异步? kvo是同步还是异步？notification是全进程空间的通知吗？kvo呢？
 
30.timer的间隔周期准吗？为什么？怎样实现一个精准的timer?
 
31.UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？
 
3. OC中 SEL是什么，有什么作用?
4. 如何在 OC的字典或数组中存取一个基本数据类型的值?如何把字典或数组中的
  值转换成基本数据类型的值?
5. IOS 中界面间传值的方式有哪些?
6. OC中通知有哪几类?请简述苹果推送的流程?
8. 什么是 block ? block 如何使用?
程中使用非 ARC的类和开源框架?
10.简要说明下 OC的延展和分类的作用和区别 11.OC中多线程的实现方式有哪些?如何实现在一个异步线程中使用一个定时器? 12. 请例举常用的网络请求开源框架、 JSON解析开源框架、 UI 开源框架。
14. 请列举出你所知道的设计模式及各种设计模式的特点。
2. 什么情况使用 weak 关键字， weak和 assign 的区别是什么?
3.@synthesize 和@dynamic分别有什么作用?
4. 列举几种反向传值的方法
5.ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些?
11. 简述 iOS 常使用的几种设计模式
13.objc 使用什么机制管理对象内存?
14.ARC通过什么方式帮助开发者管理内存?
15.BAD_ACCES在S什么情况下出现?
17. 什么时候用代理，什么时候用通知?
18.Category (类别)和 extension (扩展)有什么区别?
19. 网络图片处理问题中怎么解决一个相同的网络地址重复请求的问 题?
20. SDWebImage的原理以及实现机制。如何解决 卡的问题
总结了一下:新浪微博爱问 UI ，数据缓存应用方面的实现，腾讯爱问原理，坑 爹的百度就喜欢拿算法来得瑟。
面试制胜之招: 1.原理性的知识，必须背下来，代码不需要会写，没人要求写原理、底层的代码 (这是一个空子，可以钻 )
2.链表操作，排序算法最好是能默写 3.面试始终保持平静，冷静，镇静，面试再刁难也要保持端坐，面带一丝微笑
4.对喜欢的公司最好能表现出对加入目标公司的渴望，对技术的追求 5.加分的地方:对简历上的项目很熟悉，技术点都有所研究，包括封装，细节实现;最好能把 MJExtension 框架多敲几遍，包装成自己开发的工具(显示自 己大神的威力)

7.请简述 KVO 内部的实现，使用条件 --- 新浪微博
8.请用代码描述错误消息处理 ---腾讯，百度 9.消息转发内部原理(结构指针，方法选择器， forwarding... 一串破玩意儿) -- 百度
9.iOS 消息传递机制都有什么?如何传递? --- 腾讯，百度，新浪微博
10.有网络或无网络情况下两个 APP之间如何通信 ---新浪微博
11.将 UIButton 添加到 UIView 上，如果 UIButton 的 frame 的(0,0)不在 UIView 上， UIButton 能不能被点击，为什么?， UIButton 如果被添加到 UILabel 上， 点击能响应吗? ---新浪微博
12.如果每个 View 上都想增加一个时间播放控件，如何实现? ---新浪微博
13.利用 UIScrollView 缩放性，如何实现地图上商家地理位置的动态显示 14.运行时的工作原理， OC动态行 ---腾讯，百度，新浪微博
15.AFN 与 asi 的本质区别 ---腾讯，百度，新浪微博(主要问底层实现) 16.clayer 的坐标与 frame 的坐标如何转化 ---腾讯，百度，新浪微博
17.循环引用 ---腾讯，百度，新浪微博
18.runloop 原理---腾讯，百度，新浪微博

3.下面程序有什么错误
for(int i =0; i< someLageNumber; i++) {
    NSString * str = @"ABC";
    str = [str lowercaseString];
    str = [str stringByAppendingString:@"123"];
    NSLog(@"%@",str);
}
1.autorelease和垃圾回收机制(gc)有什么关系？
2,ifndef/define/endif左右
33、线程理解，有什么好处 

30、什么是KVC和KVO？
31、Notification和KVO有什么不同？
32、KVO在ObjC中是怎么实现的？  
14、delegate和notification区别，分别在什么情况下使用？
15.单项链表逆序

NSThread  NSLock 等实现线程锁，即当一个线程说话时锁定另一个线程，说完后再解锁

3、tableView加载大量图片时应该注意什么？
    应该使用多线程和异步加载数据
    - (void)updateImageForCellAtIndexPath:(NSIndexPath *)indexPath
    {
        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
        UIImage *image = [self getImageForCellAtIndexPath:indexPath];
        UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath];
        [cell.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];
        [pool release];
}
    然后再新开一个线程去做这件事情
    - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
    {
        [NSThread detachNewThreadSelector:@selector(updateImageForCellAtIndexPath:) toTarget:self withObject:indexPath];
    }
    同理当我们需要长时间的计算时,也要新开一个线程 去做这个计算以避免程序处于假死状态

系统相机照相之后图片怎么压缩
cell很乱的情况下怎么办，有几种方法
sorket套接字    http   tcp
地图api
网络加载大图片时应该怎么做
        
4.XML有哪些解析方式，有何优缺点？XML解析有哪些解析技术，区别是什么？
12.IphoneOS有没有垃圾回收?
13.什么是Notification模式？
14.什么时候使用delegate什么时候使用Notification？

1.分别以下列序列构造二叉排序树，与用其他三个序列所构造的结果不同的是( )。 
A．(100，80，90，60，120，110，130) 
B．(100，120，110，130，80，60，90) 
C．(100，60，80，90，120，110，130) 
D．(100，80，60，90，120，130，110) 
字典是一个二叉树吗？为什么?

6.arc 中unsafe_unretained 是作用。一个@property (strong) NSString *string1 默认是什么操作。 
8、多线程是什么，多线程同步是什么，异步？ 写一个NSOPENRATION队列，体现初始化和填入队列方法 
9、block的作用，不用block可以用什么实现?
10、在多线程中,下面代码有什么问题? 怎么改 
interface a:NSobject { 
NSmutableArray *array; 
} 
-(void)add:(*item item){ 
[array addObject :item]; 
} 
-(void)rem:(*item item){ 
[array removeobject:item]; 
} 

1、如何定义实现notification，参数如何传递？
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeLabel:) name:@"changeLabel" object:nil];

- (void)changeLabel:(nsnotifcation *)_notification
{
id a = [_notifcation object];
}

用的时候[[NSNotificationCenter defaultCenter] postNotificationName:@"changeLabel"  object:self];

0.AsyncSocket套接字
Socket描述了一个IP、端口对。它简化了程序员的操作，知道对方的IP以及PORT就可以给对方发送消息，再由服务器端来处理发送的这些消息。所以，Socket一定包含了通信的双发，即客户端（Client）与服务端（server）。
1）服务端利用Socket监听端口；
2）客户端发起连接；
3）服务端返回信息，建立连接，开始通信；
4）客户端，服务端断开连接。

1套接字（socket）概念
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
2 建立socket连接
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

4、SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

5、Socket连接与HTTP连接
由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很多情况下，需要服务器端主动向客户端推送

iphone 的标准推荐CFNetwork C库编程.但是编程比较烦躁。在其它OS往往用类来封装的对Socket函数的处理。比如MFC的CAsysncSocket.在iphone也有类似于 开源项目.cocoa AsyncSocket库, 官方网站:http://code.google.com/p/cocoaasyncsocket/ 它用来简化 CFnetwork的调用.
一.在项目引入ASyncSocket库
 1.下载ASyncSocket库源码
 2.把ASyncSocket库源码加入项目：只需要增加RunLoop目录中的AsyncSocket.h、AsyncSocket.m、AsyncUdpSocket.h和AsyncUdpSocket.m四个文件。
 3.在项目增加CFNetwork框架
      在Framework目录右健,选择Add-->Existing Files...    , 选择 CFNetwork.framework

二.TCP客户端
 1. 在controller头文件定义AsyncSocket对象
#import <UIKit/UIKit.h>
#import "AsyncSocket.h"

@interface HelloiPhoneViewController : UIViewController {
   UITextField    * textField;
   AsyncSocket * asyncSocket;
}
@property (retain, nonatomic) IBOutlet UITextField *textField;
- (IBAction) buttonPressed: (id)sender;
- (IBAction) textFieldDoneEditing: (id)sender;
@end

 2.在需要联接地方使用connectToHost联接服务器
 其中initWithDelegate的参数中self是必须。这个对象指针中的各个Socket响应的函数将被ASyncSocket所调用.

   asyncSocket = [[AsyncSocket alloc] initWithDelegate:self];
   NSError *err = nil;
   if(![asyncSocket connectToHost:host on:port error:&err])
   {
       NSLog(@"Error: %@", err);
   }

3.增加Socket响应事件
    因为initWithDelegate把将当前对象传递进去，这样只要在当前对象方法实现相应方法.

4.关于NSData对象
   无论SOCKET收发都采用NSData对象.它的定义是 http://developer.apple.com/library/mac /#documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/Reference/Reference.html
  NSData主要是带一个(id)data指向的数据空间和长度 length.
   NSString 转换成NSData 对象

     NSData* xmlData = [@"testdata" dataUsingEncoding:NSUTF8StringEncoding];

  NSData 转换成NSString对象

  NSData * data;
  NSString *result = [[NSString alloc] initWithData:data  encoding:NSUTF8StringEncoding];

4.发送数据
    AsyncSocket  writeData    方法来发送数据，它有如下定义
   - (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;

以下是一个实例语句.
    NSData* aData= [@"test data" dataUsingEncoding: NSUTF8StringEncoding];
    [sock writeData:aData withTimeout:-1 tag:1];
在onSocket重载函数，有如定义采用是专门用来处理SOCKET的发送数据的：
   -(void)onSocket(AsyncSocket *)sock didWriteDataWithTag:(long)tag
{
     NSLog(@"thread(%),onSocket:%p didWriteDataWithTag:%d",[[NSThread currentThread] name],
    sock,tag);
}

5.接收Socket数据.
   在onSocket重载函数，有如定义采用是专门用来处理SOCKET的接收数据的.
   -(void) onSocket:(AsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag
在中间将其转换成NSString进行显示.

   NSString* aStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
   NSLog(@"===%@",aStr);
   [aStr release];

11. 数据库能否存放图片
    可以
    在iOS下用sqlite数据库存储图片，先把你的图片转换成NSData形式，然后再数据库中加一行blob数据。
12. 如何连接数据库
13. 如何关闭数据库
14. cell如何复用/复用的工作原理
    1.）每一行中都有一个Cell
    2.）有100行不代表有100个Cell的实力
    3.）如果在Cell标签相同的情况下，一个屏幕上最多看到多少行就有多少个Cell的实力
    4.）当TableView滚动式，被完全遮盖的行中的Cell会进入到当前TableViewCell复用池中，当有新的行进入屏幕显示时会先从TableViewCell池中寻找对应标签的闲置的Cell如果有直接拿来使用，如果没有再实例化新的Cell
    5.）Cell的复用机制的优点是节省内存，缺点是会造成数据的混乱(由于是复用之前已经实例化好的Cell，在复用时也会把之前设置好的内容得到由此造成数据的混乱，为了避免数据的混乱每次取出Cell后先进行数据的清空再使用)

16、 cell行数太多，如何滑动流畅
 
18.自动释放池是什么如何工作  当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。
它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。
当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。 1.  ojc-c 是通过一种"referring counting"(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一, 以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁 2. NSAutoreleasePool 就是用来做引用计数的管理工作的,这个东西一般不用你管的 3. autorelease和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一.

26.什么是push(了解一下）。
客户端程序留下后门端口，客户端总是监听针对这个后门的请求，于是 服务器可以主动像这个端口推送消息。
28.fmmpeg框架(了解一下）
（音视频编解码框架，内部使用UDP协议针对流媒体开发，内部开辟了六个端口来接受流媒体数据，完成快速接受之目的）.
29.fmdb框架(了解一下)
（数据库框架，对sqllite的数据操作进行了封装，使用着可把精力都放在sql语句上面）。
30.320框架（了解一下）
（ui框架，导入320工程作为框架包如同添加一个普通框架一样）。cover(open)   flower框架 (2d 仿射技术)，内部核心类是CATransform3D.

2、Notification封装了哪3个内容
    1.）(NSString *)name;
    2.）(id)object;
    3.）(NSDictionary *)userInfo;

3.     你如何理解代理/委托
    委托代理（delegate），顾名思义，把某个对象要做的事情委托给别的对象去做，那么别的对象就是这个对象的代理，代替它来打理要做的事。
    在cocoa框架中的Delegate模式中，委托人往往是框架中的对象（视图中的控件、表视图神马的），代理人往往是视图控制器对象。

7.     网络你如何下载图片

18、tableview滑动时图片加载缓慢解决办法
    使图片异步加载
    在
    -(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath函数中加载图片的时候使用
    [cell.imageView setImageWithURL:[NSURL URLWithString:url] placeholderImage:nil ];
    这里的nil也可以换成默认的一张图片，这样系统运行起来就比较流畅，因为图片是异步加载的，加载好了直接放到缓存里，下次的时候就不再去跟服务器通讯了。

下面的代码存在的潜在的问题，请指出来，并纠正它
for(int i=0;i<someLargeNumber;i++){
NSMutableString*string=[ NSMutableString  stringWithString:@”a long long text…….”];
string=[ string lowercaseString];
string=[ string stringByAppendingString:…….];
NSLog(@”%@”, string);
}
10.请扩展NSString类，增加一个isEmpty方法，要求字符串有内容是返回YES无内容时返回NO

程序运行的时候内存分几个区？各区的用途？
C中分配内存的方式有哪些？
Kvo/kvc的机制？
阐述以下推送功能的原理机制？
Object-c中用什么修饰私有变量？
Object-c中创建一个工程需要用到那两个框架？
写一个委托Delegate的interface

写出下面a的含义：
 int a，int *a，int a[10]，int *a[10]，int (*a)[10]， int (*a)(int)， int (*a[10])(int);

3、用换行符合并字符串
    NSString * str1 = @"asdfas";
       NSString * str2 = @"zxcv";
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
        NSString * str3 = [array componentsJoinedByString:@"\n"];
        NSLog(@"str3 is %@",str3);

4、查找拼接的字符串是否有换行符，有则log出它的位置，并以换行符为界，log其前后两段字符串，没有则return空。
    -(NSString *)logStr1:(NSString *)str1 andStr2:(NSString *)str2
{
    NSArray * array = [[NSArray alloc] initWithObjects:str1,str2, nil];
    NSString * str3 = [array componentsJoinedByString:@"\n"];
    NSLog(@"str3 is %@",str3);

    NSRange range = [str3 rangeOfString:@"\n"];
    if (range.location != NSNotFound)
     {
        NSLog(@"range is %d",range.location);
        NSLog(@"str length is %d",[str3 length]);
        NSString * str = [str3 substringToIndex:range.location];
        NSLog(@"%d",[str length]);
        NSString * hou = [str3 substringFromIndex:range.location+1];
        NSLog(@"hou is %d",[hou length]);
    }
    else
    {
    return nil;
        }
}

category 和 extension 的区别
* 分类有名字，类扩展没有分类名字，是一种特殊的分类
* 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法

block和weak修饰符的区别？
* __block不管是ARC还是MRC模式下都可以使用，可以修饰对象，也可以修饰基本数据类型
* __weak只能在ARC模式下使用，只能修饰对象（NSString），不能修饰基本数据类型
* block修饰的对象可以在block中被重新赋值，weak修饰的对象不可以

KVO内部实现原理
* KVO是基于runtime机制实现的
* 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制
* 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person
* 每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法
* 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。
    •    补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类
￼
*
如何手动触发一个value的KVO
* 自动触发的场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了
* 想知道如何手动触发，必须知道自动触发 KVO 的原理，见上面的描述
* 手动触发演示
@property (nonatomic, strong) NSDate *now;

- (void)viewDidLoad
{
    [super viewDidLoad];

    // “手动触发self.now的KVO”，必写。
    [self willChangeValueForKey:@"now"];

    // “手动触发self.now的KVO”，必写。
    [self didChangeValueForKey:@"now"];
}

若一个类有实例变量NSString *_foo，调用setValue:forKey:时，是以foo还是_foo作为key？
* 都可以
KVC的keyPath中的集合运算符如何使用？
* 必须用在集合对象上或普通对象的集合属性上
* 简单集合运算符有@avg， @count ， @max ， @min ，@sum
* 格式 @"@sum.age" 或 @"集合属性.@max.age"？？？
KVC和KVO的keyPath一定是属性么？
* 可以是成员变量
如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？
* 如何自己动手实现 KVO
apple用什么方式实现对一个对象的KVO？
* 此题就是问KVO的实现原理

Size Classes 具体使用
* 对屏幕进行分类
UIView和CALayer是什么关系?
* UIView显示在屏幕上归功于CALayer，通过调用drawRect方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承自UIResponder，比起CALayer可以响应用户事件，Xcode6之后可以方便的通过视图调试功能查看图层之间的关系
* UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它内部是由Core Animation来实现的，它真正的绘图部分，是由一个叫CALayer(Core Animation Layer)的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性
* UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，如：
- (class) layerClass {
    // 使某个UIView的子类使用GL来进行绘制
    return ([CAEAGLLayer class]);
}

 UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的显示。例如下面的代码会在目标View上敷上一层黑色的透明薄膜。
grayCover = [[CALayer alloc]init];
grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor;
[self.layer addSubLayer:grayCover];

* 补充部分，这部分有深度了，大致了解一下吧，UIView的layer树形在系统内部被系统维护着三份copy
    * 逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份
    * 动画树，这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作
    * 显示树，这棵树的内容是当前正被显示在屏幕上的内容
    * 这三棵树的逻辑结构都是一样的，区别只有各自的属性
IBOutlet连出来的视图属性为什么可以被设置成weak?
* 因为父控件的subViews数组已经对它有一个强引用
IB中User Defined Runtime Attributes如何使用？
* User Defined Runtime Attributes是一个不被看重但功能非常强大的的特性，它能够通过KVC的方式配置一些你在interface builder中不能配置的属性
* 当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller
pushViewController和presentViewController有什么区别
* 两者都是在多个试图控制器间跳转的函数
* presentViewController提供的是一个模态视图控制器(modal)
* pushViewController提供一个栈控制器数组，push/pop
请简述UITableView的复用机制
* 每次创建cell的时候通过dequeueReusableCellWithIdentifier:方法创建cell，它先到缓存池中找指定标识的cell，如果没有就直接返回nil
* 如果没有找到指定标识的cell，那么会通过initWithStyle:reuseIdentifier:创建一个cell
* 当cell离开界面就会被放到缓存池中，以供下次复用
如何高性能的给 UIImageView 加个圆角?
* 不好的解决方案
    * 使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现 self.view.layer.cornerRadius = 5;
    * self.view.layer.masksToBounds = YES;

* 正确的解决方案：使用绘图技术 
- (UIImage *)circleImage
{
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);

    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();

    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);

    // 裁剪
    CGContextClip(ctx);

    // 将图片画上去
    [self drawInRect:rect];

    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();

    // 关闭上下文
    UIGraphicsEndImageContext();

    return image;
}

* 还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];

使用drawRect有什么影响？
* drawRect方法依赖Core Graphics框架来进行自定义的绘制
* 缺点：它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了
* 这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前图层标记为dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将标记为 dirty 的图层重新建立Core Graphics上下文,然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制
描述下SDWebImage里面给UIImageView加载图片的逻辑
* SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后在替换占位图片
* 加载图片的过程大致如下：
    * 首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存
    * 如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来
    * 如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片
    * 下载后的图片会加入缓存中，并写入磁盘中
    * 整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来
设计个简单的图片内存缓存器
* 类似上面SDWebImage实现原理即可
* 一定要有移除策略：释放数据模型对象


如何渲染UILabel的文字？
* 通过NSAttributedString/NSMutableAttributedString（富文本）
UIScrollView的contentSize能否在viewDidLoad中设置？
* 能
* 因为UIScrollView的内容尺寸是根据其内部的内容来决定的，所以是可以在viewDidLoad中设置的
* 补充：（这仅仅是一种特殊情况）
    * 前提，控制器B是控制器A的一个子控制器，且控制器B的内容只在控制器A的view的部分区域中显示
    * 假设控制器B的view中有一个UIScrollView这样一个子控件
    * 如果此时在控制器B的viewDidLoad中设置UIScrollView的contentSize的话会导致不准确的问题
    * 因为任何控制器的view在viewDidLoad的时候的尺寸都是不准确的，如果有子控件的尺寸依赖父控件的尺寸，在这个方法中设置会导致子控件的frame不准确，所以这时应该在下面的方法中设置子控件的尺寸
-(void)viewDidLayoutSubviews;

如何实现类似QQ的三角形头像
* Quartz2D
* 使用coreGraphics裁剪出一个三角形
核心动画里包含什么？
* 基本动画
* 回头自己总结吧
如何使用核心动画？
* 创建
* 设置相关属性
* 添加到CALayer上，会自动执行动画

14. UITableViewCell怎样使用更流畅？
首先cell的复用机制节约了系统资源；其次应当注意有些复杂的大数据或网络数据应采用异步加载的方式进行加载，以免cell刷出时发生卡顿。

16. 关于图文混排是如何排版的？
图文混排应当以图片为起点，首先明确图片的位置，文字可以选择位于图片的下方，或者是环绕效果。环绕效果可以采用2个以上label或textView来实现；也可以通过AttributeString的属性设置，或者CoreText重绘UIVIew，添加文字的方式，修改文字间的间隔，达到让出图片的效果。如果图文显示在高度可变的视图中，如tableView的Cell中，可以计算文字占位Rect，动态修改视图或cell的高度。

17. @property (nonatomic, retain) IBOutlet UIView * view这个对象需要release吗，如果需要，如何做?
其实XIB文件所生成的视图对象是无法真正释放的，因此关联XIB的属性也可以设置为assign属性，而视图不会释放。从这个角度上讲，这个对象不释放也可以，但是既然用retain做修饰符，出于尊重内存管理法则，理应进行释放，最简单的方式就是将视图在dealloc方法中设为nil，适用于非ARC，但ARC中这样写也没关系。

18. 两种传输协议在什么时候使用？
所谓的两种传输协议，是指网络协议中的传输层协议，即TCP协议和UDP协议。TCP协议会在收发数据的两端建立稳定可靠，有序的链接，传输数据稳定可靠，但系统资源消耗较大，适合，数据或文件的下载或上传，Http网络协议就是采用TCP传输协议传输数据的。UDP是通俗讲得漂流瓶协议，发出协议的主机就像扔出漂流瓶的鲁滨逊一样，不再负责数据的跟踪和校验，优点是系统资源占用低，缺陷是没有在收发两端建立稳定的传输路线，数据有丢包，损坏或后发先至等缺陷，优秀的UDP传输服务器，会反复发送校验序列，以保证数据的正确。

19. push推送机制
iOS 在系统级别有一个推送服务程序使用 5223 端口。使用这个端口的协议源于 Jabber 后来发展为 XMPP ，被用于 Gtalk 等 IM 软件中。所以， iOS 的推送，可以不严谨的理解为：
苹果服务器朝手机后台挂的一个 IM 服务程序发送的消息。
然后，系统根据该 IM 消息识别告诉哪个 Apps 具体发生了什么事。
然后，系统分别通知这些 Apps 。

20. iOS 播放音频的几种方法?
iPhone OS 主要提供以下了几种播放音频的方法：
System Sound Services
AVAudioPlayer 类
Audio Queue Services
OpenAL

21. 代理的作用
代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为java中的回调监听机制的一种类似。
22. int  retVal=UIApplication(argc,argv,nil,nil):是什么意思

对UIApplication对象进行了初始化，这个方法除了argc 和argv 参数外，另外这个函数还有2个两个字符串参数来识别UIApplication类和UIApplication代理类，在这里默认是2个nil,第一个参数为nil就默认把UIApplication类作为缺省值进行初始化，可以在这里不填nil而是使用自己定义的UIApplication子类。至于第二个参数nil就设置为nil就把模板生成的HelloWorldAppdelegate类作为默认值。

23. 保存一个变量到本地，列举两个简单的方法
    1，用NSUserDefaults存储小量数据
    2，直接writeTofF ile
    3，存数据库
    4，归档
    反正也没有什么钱（我怎么学会）

29. XML有哪几种解析方式，他们各有什么优点
答：有Sax和Dom两种解析方式，sax是逐行解析。dom是一次性全部加载xml文件，然后解析

1、给定字符串的长度，还有换行方式 算出高度。
UIFont *font = [UIFont systemFontOfSize:14];
CGSize size = [text sizeWithFont:font constrainedToSize:CGSizeMake(140, 1000) lineBreakMode:UILineBreakModeCharacterWrap];

1. 如何实现Push 通知的机制（大致写下）
首先应用程序把要发送的消息、目的iPhone的标识打包，发给苹果服务器，苹果服务器在自身的已注册Push服务的iPhone列表中，查找有相应标识的iPhone，并把消息发送到iPhone，最后，iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。

加分题:
1. 如何实现一个实现渲染自定义格式字符串的 UILabel
自定义一个MyLabel继承于UILabel，然后复写drawRect:方法。

2. Protocol 与 performSelector: 的相同与区别，哪个更好（基础参数类型传递）
二者都可以调用相关方法，可进行函数回调。
Protocol是用来定义对象的属性，行为和用于回调的。必须遵守其协议方可使用其方法。
performSelector:可自定义进行函数回调，可调用实现在其后的方法。

17.使用coredata有哪几种持久化存储机制？
答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。
kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];

9.通知和协议的不同之处？
答案：协议有控制链(has-a)的关系，通知没有。
首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。

30.timer 的间隔周期准吗?为什么?怎样实现一个精准的
notification 是全进程空间的通知吗? kvo 呢?
timer?
库中找到类似的吗?
32 如果要开发一个类似 eclipse 的软件，支持插件结构。且开放给第三方开发。你会怎样去设计它?(大概思路)
这篇文章先记录一下题目，下一篇开始从第一题解答 .
下面从第一题开始解答 :
题目 :1.Object -c 的类可以多重继承么?可以实现多个接口么? Category
类好?为什么? 关于多继承 :
首先 object-c 不能够多继承 , 类似下面代码的这种方式是绝对通不过编译的 再试试，呵呵 !
是什么?重写一个类的方式用继承好还是分
. 当然 , 你也可以把 NSString 前面的 ":" 去掉

 那么有没有别的方式来替代呢?有，一种我们称之为伪继承，另一种我们可以通过 ios 中无处不在的 @protocol 委托方 式来实现 .
1. 伪继承
尽管再 objtive-C 中不提供多继承， 但它提供了另外一种解决方案 , 使对象可以响应在其它类中实现的消息 ( 别的语言中，
一般叫方法，两者无差别 ). 这种解决方案叫做消息转发，它可以使一个类响应另外一个类中实现的消息。
在一般情况下， 发送一个无法识别的消息会产生一个运行时的错误， 导致应用程序崩溃 , 但是注意， 在崩溃之前， iphone
运行时对象为每个对象提供了第二次机会来处理消息。捕捉到一条消息后可以把它重定向到可以响应该消息的对象。 这个功能完全通过消息转发来实现，发送消息给一个无法处理该选择器的对象时，这个选择器就会被转发给
forwardInvocation 方法 . 接收这条消息的对象， 用一个 NSInvocation 的实例保存原始的选择器和被请求的参数 我们可以覆盖 forwardInvocation 方法，并把消息转发给另外一个对象 .
. 所以，
。
将选
1.1 实现消息转发功能
在给程序添加消息转发功能以前，必须覆盖两个方法，即 methodSignatureForSelector:
methodSignatureForSelector: 的作用在于为另一个类实现的消息创建一个有效的方法签名。 择器转发给一个真正实现了该消息的对象 .
例子 : 1.
1 - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector 2{
和 forwardInvocation: forwardInvocation:
3 4 5 6 7 8 9}
2.
NSMethodSignature* signature = [super methodSignatureForSelector:selector];
if (!signature)
signature = [self.carInfo methodSignatureForSelector:selector];
return signature;

 1 - (
void )forwardInvocation:(NSInvocation *)invocation
2{
3
4
5 6{ 7 8} 9}
SEL selector = [invocation selector];
if ([self.carInfo respondsToSelector:selector])
[invocation invokeWithTarget:self.carInfo];
3. 调用
1 Car *myCar = [Car car]; //Car 为一个类
2 [(NSString *)myCar UTF8String] // 这里调用 NSString 中的 UTF8String 方, 注意 Car 中并未实现该方法
解释 : 这里借 iphone 开发秘籍的例子来说明 , self.carInfo 是一个只读的 NSString 对象 , 存在于 Car 类中 . 例子中 实例是无法正确的为另外一个对象 (NSString) 实现的选择器创建一个有效的签名。运行时当检查到当前没有有效的签名
即进入该对象 ( 这里是 myCar) 的 methodSignatureForSelector: 方法中 , 此时，将在这个方法中对每个伪继承进行迭代并 尝试构建一个有效的方法签名的机会 . 例如代码中 , 当 myCar 调用 UTF8String 时, 由于无法从当前对象中获得消息，转入 第二次机会捕捉消息， 首先进入 methodSignatureForSelector: 方法 , 采用迭代的方式为当前被调用的方法创建一个有效 的签名，得到签名后，转入 forwardInvocation: 方法对其调用的方法 (UTF8String) 进行实现 . forwardInvocation: 首先获得调用的方法 (UTF8String), 判断 self.carInfo( 一个 nsstring 对象 ) 能否响应该方法，如果可以，将调用 UTF8String 对象的目标转换为 self.carInfo 对象 . 这样 ，我们就实现了多继承，呵呵!!
?
注 : 如果您仍有疑问，可访问苹果的官方文档查询消息转发相关内容 : 地址
http://www.apple.com.cn/developer/mac/library/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ chapter_6_section_1.html#//<br> apple_ref/doc/uid/TP40008048-CH105-SW1
2. 委托
Car ,
中，
在 IOS 中委托通过一种 @protocol 的方式实现 , 所以又称为协议 . 协议是多个类共享的一个方法列表 , 在协议中所列出的方 法没有响应的实现，由其它人来实现 . 这叫好比我想买个手机，所以我有个 buyIphone 方法 , 但是我不知道谁那买手机 , 所以把这个需求发布出去 ( 比如公布在网站上 ), 如果有卖手机的商人 ( 也就是说他能实现 buyIphone 这个方法 ) 看到，他 就会接受我的委托 ,( 在商人自己的类中实现 <XXXdelegate>), 那么我的委托对象就指向了这个商人 .. 当我要买手机的时 候，直接找他就行了 .
例如 :
@protocol MyDelegate
-( void )buyIphone:(NSString *)iphoneType money:(NSString *)money;

 @end
@interface My : NSObject {
id <MyDelegate> deleage; }
@property(assign,nonatomic) @end
代码中声明了一个协议 名叫
通过 delegate 调用 BuyIphone 方法即可 .
如下 :
-( void )willbuy
{
}
[ delegate buyIphone: @"iphone 4s"
money: @"4888"];
id <MyDelegate> delegate ;
Mydelegate,
在其中有一个
buyIphone
方法， 即一个委托项。
当我要购买手机的时候只需要
我不必关心谁现实了这一委托，只要实现了这个委托的类，并且 定能够得到结果 .
例如 : 商人类实现了这一委托 ( 用<Mydelegate> 表示实现 ) #import <Foundation/Foundation.h>
#import "My.h"
@interface Business : NSObject<MyDelegate>
@end
然后在 @implementation Business 中调用 buyIphone 方法
#import "Business.h"
@implementation Business
-( void )buyIphone:(NSString *)iphoneType money:(NSString *)money {
NSLog( @"手机有货，这个价钱卖你了，发货中 !!" ); }
@end
buyIphone 是声明的委托中必须实现的方法，那么就一
就 ok 啦。这样是不是也模拟了多继承呢?通过委托，其实你也就摆脱了去考虑多继承方面的事情，从而关注当前类。 汗，一道题才写了一半，下一篇继续。。。。手打字酸了!

Objective-C 学习笔记 :
数据类型和表达式
1. 数据类型和常量 :
在 Objective-c 中提供了 4 种基本的数据类型 :int float double 以及 char. 声明为 int 的变量只能用于保存整形值
声明为 float 类型的变量可存储浮点类型值 ( 即包含小数位数 .).
double 类型和 float 类型一样，只不过前者的精度大约是后者的 2 倍。
最后是 char 数据类型 ,char 类型可用来存储单个字符，例如字母 a, 数字 6 ，或是一个分号。
在 OBJ 中 ( 为了打字快点， 以下 Objective-C 都简称 OBJ) 中，任何的数字、 单个字符或者字符串， 都称为常量。 例如: 数字 58 为一个整数常量，字符串 @"this is OBJ!\n" 表示一个常量的字符串对象。完全又常量组成的表达式我们就称 为常量表达式。
所以，表达式 :

 128+7-17
是一个常量表达式，这是因为其表达式的每一项都是一个常量值。但是如果把
128+7-i
就不是一个常量表达式了 . 下面说说关于 4 个数据类型的情况 ..
2.int 类型
i 声明为了整形的变量，那么表达式:
在 OBJ 中，整数常量是又一个或多个数字的序列所组成。 序列前的负号表面该值是一个负数。 合法值例如: 10 、-10 、 158. 切记数字之间不能出现空格，且大于 999 的值不适用逗号来表示。比如: 11000 是一个合法的整数常量，但 11
000 是一个非法的常量 .
OBJ 中存在两种特殊的格式，它们用于非十进制方式保存整数常量。第一种:如果整形值的第一位为 0，那么这个整数 将用八进制的方式表示，也就是说用基数 8 来表示。这种情况下改值的其他余位的值必须都是合法的八进制数字，即必
须是 0 到 7 之间的数字。例如在 OBJ 八进制表示的值 50 ，表示的方式为 050 ，等价于十进制表示的值 40.
同理，八进制的常量 0177 表示为十进制的值 127 ，算法为 1*64+7*8+7 =127.
可以通过在 NSLog( 如果不理解 NSLog, 暂时可以把它想象为 C# 的 message.show() 或者 js 的 alert()) 中调用的格式
字符串中使用格式符号 %o, 可在终端上用八进制显示整型值: 例:
1 int a =177
2 NSLog(@"int is : %o\n",a);
在上面例子的情况下，输出的八进制值不带有前导
1 inta=177;
2 NSLog(@"%#o" ,a);
第二种情况 :
如果整形常量以 0 和字母 x(x 无论大写还是小写
0 ，输出带有
0 的写法如下:
) 开头，那么这个值都将采用十六进制
0 到 9 之间的任意数字或 a 到 f(A 到 F) 之间的字母组成。字母表示
格式符号 %x 表示显示一个十六进制的值，该值不会带有前导 0x, 都是用 a--f 的小写字母表示十六进制的数字，需要带 有前导 0x, 使用格式字符 %#x 表示 :
( 即以
的数字分别为 10 到 15 。因此，给一个名为 rgbColor 的整型常量指派一个十六进制的值 FFEF0D, 可以使用以下语句:
紧跟在字母 x 后面的是十六进制的的数字，它可由
1 rgbColor = 0xFFEF0D;
16 为基数 ) 计数法里表示。

34.UIscrollVew 用到了什么设计模式?还能再 组合模式 composition ，所有的 container view
NSWindow对象作为结束，虽然其它对象也可以作为下一个响应者被加入
foundation 库中找到类似的吗? 都用了这个模式
观察者模式 observer ，所有的 UIResponder 都用了这个模式。
模板 (Template) 模式，所有 datasource 和 delegate 接口都是模板模式的典型应用
33. .timer 的间隔周期准吗?为什么?怎样实现一个精准的 timer?
NSTimer 可以精确到 50-100 毫秒 .
NSTimer 不是绝对准确的 , 而且中间耗时或阻塞错过下一个点 , 那么下一个点就 pass 过去了

代理的作用? 答案:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.oc中可修改和不可以修改类型。
答案:可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。
8.我们说的 oc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。
这个问题其实浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类( life )都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只需调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 eat 这个选择器)。
因此也可以说，运行时机制是多态的基础? ~~~
9.通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。
首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
kvc 机制的道理是一样的。
首先查找对象是否带有
someKey -(id) valueForUndefinedKey:

17.NSOperation queue? 答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发的问题。
网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。 这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。 但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认为这还是一个队列。 但是后来看到一票关于这操作队列话题的文章，其中有一句提到 “因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”
瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
18.What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。
也可以理解成延时加载。
我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。
20.一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案:首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。
因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示?
本身这个 ios 面试题集绵有 40 个题目，但是后面的 20 个基本都没答案，那位 lz 直接是:”后面的太简单，就不多说了 ~~~“ 并且答案的话也是概述性而非直接可以定义的。
因此，下礼拜我抽空把剩下 20 个题觉得有点意思的挑出来，然后在找找其他的，准备再凑 20 题。

1. 一般静态方法中返回的结果对象，是否需要手动释放
A. 需要 B. 不需要 C.都可以
3. 如何判断一个对象是否实现了某一个方法
二、 简答题
2. 静态变量和实例变量的区别是什么 ?
3. 如果要实现后台线程进行文件下载，应使用哪些类或框架来进行，请简述。
4. 写出你的团队中使用的版本控制系统，和版本控制系统的作用?
5. 你还了解哪些其它语言，技术或框架?
三、 程序与设计
 4.敏捷原则: 开放 --封闭原则 工厂模式优缺点
 优点: 简单工厂模式的优点是客户端可以直接消费产品， 而不必关心具体产品的实现， 消除了客 户端直接创建产品对象的责任，实现了对责任的分割。
 缺点是工厂类几种了所有产品的创建逻辑， 一旦不能正常工作， 整个系统都会受到影响， 产品类多结构复杂的时候，把所有创建工作放进一个工厂中来，回事后期程序的扩展较为困难。
 通过优缺点的分析，我们可以再如下场景中使用简单工厂模式:
 (1 )工厂类负责创建的对象较少时;
 (2 )客户端只知道传入工厂类的参数，对于如何创建对象的逻辑不必关心时。
 5. 观察者模式 Observer 观察者模式完美的将观察者和被观察者分离开。
 观察者模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态 发生变化时，所有依赖它的对象都得到通知并自动刷新。
 在IOS 开发中经典观察者模式的实现方式有: NSNotificationCenter 、KVO 等
 优势: 解耦合
 解耦合: 把原来引用很紧密的对象通过中间一层的分离，
 敏捷原则: 开放 —封闭原则
 而且当不直接引用
 通知 NSNotificationCenter :
 一般为 model 层对 controller 和 view 进行的通知方式，不关心
 谁去接收，只负责发布信息。
 通知可以是一对一，也可以是一对多。 实例: Notification 通 知中心，注册通知中心，任何位置可以发送消息，注册观察 者的对象可以接收。
 kvo 键 -值观察机制 Key-Value Observing :
 当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
 键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
 是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。
 6. 代理模式 代理的目的是改变或传递控制链。
 允许一个类在某些特定时刻通知到其他类，而不需要获取到 那些类的指针。可以减少框架复杂度。
  应用场景: 当一个类的某些功能需要由别的类实现，但是又 不确定由哪个类实现，可以使用代理实现。
 实例: tableview 、 Scrollview 等中的 delegete

14、tableview的优化:
1.1 正确的复用 cell 。
1.2 减少在返回每个 cell 里面的处理逻辑和处理时间。尽量将数据进行缓存和复用。
1.3，尽量减少处理加载和计算的时间，不阻塞 1.4 ，尽量使用绘制每个 cell 。
1.5 ，设置每个 cell 的 opaque 属性。 1.6，尽量返回每行固定的 height 。
1.7 ，在每个 cell 减少图形效果。 1.8、分段加载数据。

24. 通知消息和代理的区别 通知:分为本地和远程通知。接受通知的接受者需要进行注册改通知。这样通知被
NSNotificationCenter 发送出来后会被注册的接受者所接受。 远程通知需要借助苹果的 服务器去实现通知的中转。
代理: 把某个对象要做的事情委托给别的对象去做。 两者区别:
delegate 针对 one-to-one 关系，用于 sender 接受到 reciever 的某个功能反馈值。
notification 针对 one-to-one/many/none,reciver, 只是负责把 notification 发送出去。

28. 类继承，类的扩展( extension )，类别( category )
10个人坑死...钱进去一分钱都不出来
发布时需发布证书签名
)，该文件包含信息:调
category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能 删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有 更高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。
category 和 extensions 的不同在于后者可以添加属性。另外后者添加的方法是必须要实 现的。
extensions 可以认为是一个私有的 Category 。 29.CAlayer 介绍
一个 UIView 包含 CALayer 树， CALayer 是一个数据模型。包含了一些用来显示的对象，
在 UIView 的子类中都可以找到层这个组件， 层是位于固定的画布上的一个子片， 可以被覆 盖。层是彼此堆叠在一起的最终产生一个界面。除此之层可以包含多个层，通过层可以操 作位于此层上面的其他内容，例如旋转，动画，翻页等。
30.ios 怎么实现多继承
IOS 通过实现 protocol 委托代理，实现多个接口来实现多继承。

 31.app 性能测试方式
通过 Xcode 提供的工具如 Instrument ，测试 CPU ，Mermory 性能。也可以适用一些开源
的自动化测试工具:如 Frank ，KIF 等。
32.NSArray 可以放基本数据类型不( int ， float ， nil )怎么放进一个结构体 NSArray 只能存放 objective -c 对象数据模型，这些基本数据类型需要先转化为
NSNumber 对象再存放进数组中。
33.objective-c 和 c，c++混合编写
在 Objective-C++ 中，可以用 C++ 代码调用方法也可以从 Objective-C
调用方法。在这两 Objective-C 对象
Xcode 需要源
种语言里对象都是指针，可以在任何地方使用。例 的指针作为数据成员， Objective-C 类也可以有 文件以 ".mm" 为扩展名，这样才能启动编译器的
如， C++ 类可以使用 C++ 对象指针做实例变量。
Objective-C++ 扩展。

23. 使用自动释放池( Use AutoRelease Pool )
24. 缓存图像( Cache Images-Or not )
25. 尽可能避免日期格式化器

40.IOS6 AutoLayout
AutoLayout 是 IOS6 之后引进的自动布局功能，有点类型有 android 的相对布局属性。通过勾选 AutoLayout 设置各种 Constraint 约束来实现在不同设备和不同方向上的自动布局。 autosizing
mask 也就是 “ springs and struts 模式”。 autosizing mask 决定了一个 view 会发生什么 当它的 superview 改变大小的时候。而 autolayout 不仅可以设置 superview 改变时 view 所做的变化，还支持当相邻 view 变化时自己所做的变化。

1. 回答person的retainCount值,并解释为什么 Person * per = [[Person alloc] init]; 此时 person
的 retainCount的值是 1 self.person = per; 在 self.person 时,如果是assign,person的 retainCount
的值不变 ,仍为 1 若是 :retain person的 retainCount的 值加 1,变为 2 若是 :copy person的 retainCount值不 变,仍为1
2、 这段代码有什么问题吗 : @implementation Person - (void)setAge:(int)newAge {
self.age = newAge; }
@end
会死循环 ,会重复调用自己 !self.age 改为 _age即可 ;
并且书写不规范 :setter方法中的 newAge应该为 age
3、这段代码有什么问题 ,如何修改 for (int i = 0; i < someLargeNumber; i++) { NSString *string =
@” Abc”;string = [string lowercaseString]; string = [string stringByAppendingString:@"xyz"];
NSLog(@“ %@” , string); } 会出现内存泄露修改之后 : for(int i = 0; i<1000;i++){
NSAutoreleasePool * pool1 = [[NSAutoreleasePool alloc] init]; NSString *string = @"Abc"; string = [string lowercaseString]; string = [string stringByAppendingString:@"xyz"]; NSLog(@"%@",string);
// 释放池
[pool1 drain]; }
延伸:堆栈的区别 :
(1)管理方式 :对于栈来讲 ,是由编译器自动管理 ,无 需我们手工控制 ;对于堆来说 ,释放工作由程序员控 制,容易产生 memory leak。 (2)申请大小 :能从栈获 得的空间较小 ,堆是向高地址扩展的数据结构 ,是不 连续的内存区域。堆的大小受限于计算机系统中 有效的虚拟内存。由此可见 ,堆获得的空间比较灵 活,也比较大。 (3)碎片问题 :对于堆来讲 ,频繁的
new/delete势必会造成内存空间的不连续 ,从而造成 大量的碎片 ,使程序效率降低。 对于栈来讲 ,则不会 存在这个问题 ,因为栈是先进后出的队列 ,他们是如
此的一一对应 ,以至于永远都不可能有一个内存块 从栈中间弹出 (4)分配方式 :堆都是动态分配的 ,没 有静态分配的堆。 栈有2种分配方式 :静态分配和动 态分配。 静态分配是编译器完成 的,比如局部变量 的分配。动态分配由 alloc函数进行分配 ,但是栈 的动态分配和堆是不同的 ,他的动态分配是由编译 器 进行释放 ,无需我们手工实现。 (5)分配效率 :栈 是机器系统提供的数据结构 ,计算机会在底层对栈提供支持 :分配专门的寄存器存放栈的地址 ,压栈出 栈 都有专门的指令执行 ,这就决定了栈的效率比 较高。堆则是 C/C++函数库提供的 ,它的机制是很复 杂的。

7、简述你对 UIView 、UIWindow 和CALayer的理解 UIView: 属于 UIkit.framework 框架 ,负责渲染矩形区 域的内容 ,为矩形区域添加动画 ,响应区域的触摸事
件,布局和管 理一个或多个子视图 UIWindow: 属 于UIKit.framework框架,是一种特殊的 UIView,通 常在一个程序中只会有一个 UIWindow, 但可以手 动创建多个 UIWindow, 同时加到程序里面。 UIWindow 在程序中主要起到三个作用 :
1、作为容器 ,包含 app所要显示的所有视图 2、传 递触摸消息到程序中 view和其他对象 3、与 UIViewController 协同工作 ,方便完成设备方向旋转 的支持
CAlayer:属于 QuartzCore.framework,是用来绘制内 容的 ,对内容进行动画处理依赖与 UIView 来进行显 示,不能处 理用户事件。 UIView和CALayer是相互 依赖的 ,UIView 依赖 CALayer提供内容 ,CALayer依 赖 UIView 一共容器显示 绘制内容。 延伸 : UIViewController: 管理视图的几成熟 ,每个视图控 制器都有一个自带的视图 ,并且负责这个视图相关 的一切事务。方便 管理视图中的子视图 ,负责 model与view的通信 ;检测设备旋转以及内存警告 ; 是所有视图控制类的积累 ,定义了控制器 的基本 功能。

27、什么是 Protocol?什么是代理 ?写一个委托的 interface?委托的 property声明用什么属性 ?为什么 ?
Protocol:一个方法签名的列表 ,在其中可以定义若 干个方法。根据配臵 ,遵守协议的类 ,会实现这个协 议中的若干个方 法。
代理 :实现这个协议中的方法的类 委托的 interface: 声明一个某协议的属性 delagate 用 assgin属性 ,原 因是 ,为了避免循环引用。 28、分别描述类别 (categories)和延展 (extensions)是什么 ?以及两者的 区别 ?继承和类别在实现中有何区
别 ?为什么 Category只能为对象添加方法 ,却不能添 加成员变量 ?
类别:在没有原类 .m文件的基础上 ,给该类添加方法 ; 延展 :一种特殊形式的类别 ,主要在一个类的 .m文件
里声明和实现延展的作用 ,就是给某类添加私有方 法或是私有变量。 两个的区别 :延展可以添加属性 并且它添加的方法是必须要实现的。 延展可以认为 是一个私有的类目。 继承和类别在实现中的区别 : 类别可以在不获悉 ,不改变原来代码的情况下往里面添加新的方法 ,只能添加 ,不能删除修 改。并且如 果类别和原来类中的方法产生名称冲突 ,则类别将
覆盖原来的方法 ,因为类别具有更高的优先级。 Category只能为对象添加方法 ,却不能添加成员变
量的原因 :如果可以添加成员变量 ,添加的成员变量 没有办法初始 化----这是语言规则 29、写一个
NSString类的实现 + (id)initWithCString:(constchar *)nullTerminatedCString encoding:
(NSStringEncoding)encoding;
{ NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWithCString: nullTerminatedCString encoding: encoding]; return [obj autorelease];
}

74、什么是序列化或者 Acrchiving,可以用来做什么 , 怎样与 copy结合 ,原理是什么 ?. 序列化就是 :归档

75、runloop是什么 ?在主线程中的某个函数里调用 了异步函数 ,怎么样block当前线程 ,且还能响应当 前线程的timer事件 ,touch事件等 .---NSRunLoop,NSTimer 需 要自己实现 ----GCD 的返回主线程的方法 ,看前面的题runloop,正如其名称所示 ,是线程进入和被线程用 来响应事件以及调用事件处理函数的地方。 需要在 代码中使用控制语 句实现 run loop的循环 ,也就是 说 ,需要代码提供 while 或者 for 循环来驱动 run loop。在这个循环中 ,使用一个 runloop对象 [NSRunloop currentRunloop]执行接收消息 ,调用对 应的处理函数。

13 、什么是 Notification ?
答:观察者模式， controller 向 defaultNotificationCenter 添加自己的 notification ，其他类注 册这个 notification 就可以收到通知，这些类可以在收到通知时做自己的操作(多观察者默认随机 顺序发通知给观察者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到他来操作，
可以用 NotificationQueue 的方式安排观察者的反应顺序，也可以在添加观察者中设定反映时间， 取消观察需要在 viewDidUnload 跟 dealloc 中都要注销)
14 、什么时候用 delegate ，什么时候用 Notification ?
15 、什么是 KVC 和KVO ?
答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 法名找到运行方法的时候所需要的环境参数。( 2 )他会从自己
方法实现的接口。( 3)再直接查找得来的具体的方法实现。 KVO (Key-Value-Observing ):当 观察者为一个对象的属性进行了注册，被观察对象的 isa 指针被修改的时候， isa 指针就会指向一个 中间类，而不是真实的类。所以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不 要依赖于 isa 指针。在调用类的方法的时候，最好要明确对象实例的类名。
1.objective-c 中是所有对象间的交互是如何实现的 ?(深圳皆凯科技有限公司笔试题)
2. 如何将产品进行多语言发布?
3.objective-c 中是如何实现线程同步的 ?
4.编写函数 _memmove 说明如下:实现 C 语言库函数 memmove 的功能:将一块缓冲区中的数据移 动到另一块缓冲区中。可能有重复。
5. 什么叫数据结构?(面试顺风快递 iphone 开发) 6. 编程中，保存数据有哪几种方式?
7.Sizeof 与 strlen 的区别和联系?
8. 什么是抽象类?抽象类有什么作用?能实例化吗?
9. 线程中有哪些函数?写出来
10. 有没有写过自定义的控件
11. 调用一个类的静态方法需不需要 12.do-while 与 while-do 的区别?
13. 写出几个死循环?
14. 考察对 @interface 和@property
15. Iphone 开发中控制类有什么作用?
16. 用 Objective-C 写冒泡法.
Object-C 有多继承吗?没有的话用什么代替?
cocoa 中所有的类都是 NSObject 的子类 多继承在这里是用 protocol 委托代理 来实现的 你不用去考虑繁琐的多继承 ,虚基类的概念 . ood 的多态特性 在 obj-c 中通过委托来实现 .
Object-C 有私有方法吗?私有变量呢?
release ?
的理解?
setValue 的时候，( 1 )首先根据方 isa 指针结合环境参数，找到具体的
还应该重载重写 viewDidUnload 来释放对 view 的任何索引 viewDidLoad 后调用数 据 Model
viewDidUnload 方法 当系统内存吃紧的时候会调用该方法(注: viewController 没有被 dealloc ) 内存吃紧时， 在 iPhone OS 3.0 之前 didReceiveMemoryWarning 是释放无用内存的唯一方式， 但是 OS 3.0 及以后 viewDidUnload 方法是更好的方式 在该方法中将所有 IBOutlet (无论是 property 还是实例变量)置为 nil (系统 release view 时已经将其 release 掉了)
在该方法中释放其他与 view 有关的对象、其他在运行时创建(但非系统必须)的对
象、在 viewDidLoad 中被创建的对象、缓存数据等 release 对象后，将对象置为 nil
( IBOutlet 只需要将其置为 nil ，系统 release view 时已经将其 release 掉了) 一般认为 viewDidUnload 是 viewDidLoad 的镜像，因为当 view 被重新请求时，
viewDidLoad 还会重新被执行
viewDidUnload 中被release 的对象 必须是很容易被 重新创 建的对象 (比如在
viewDidLoad 或其他方法中创建的对象) ，不要 release 用户数据或其他很难被重新创 建的对象
dealloc 方法 viewDidUnload 和dealloc 方法没有关联， dealloc 还是继续做它该做 的事情
ViewController 的 didReceiveMemoryWarning 是在什么时候调用的?默认的操作是什 么?
当程序接到内存警告时 View Controller 将会收到这个消息: didReceiveMemoryWarning 从iOS3.0 开始，不需要重载这个函数，把释放内存的代码放到 viewDidUnload 中去。 这个函数的默认实现是 :检查 controller 是否可以安全地释放它的 view( 这里加粗的 view 指的是 controller 的view 属性 )，比如 view 本身没有 superview 并且可以被很容易地重建(从 nib 或者 loadView 函数)。
如果 view 可以被释放，那么这个函数释放
你可以重载这个函数来释放 controller
来允许父类(一般是 UIVIewController
如果你的 ViewController 保存着 view 的子 view 的引用，那么，在早期的 iOS 版本中，你应该在 这个函数中来释放这些引用。而在 iOS3.0 或更高版本中，你应该在 viewDidUnload 中释放这些引用。
delegate 和 notification 区别，分别在什么情况下使用?
view 并调用 viewDidUnload 。 中使用的其他内存。但要记得调用这个函数的 super 实现
)释放 view 。

KVC(Key-Value-Coding) KVO (Key-Value-Observing ) 理解 KVC 与 KVO (键 -值-编码与键 -值-监看)
当通过 KVC调用对象时，比如: [vsaellufeForKey:@ 试图通过几种不同的方式解析这个调用。首先查找对象是否带有 法，如果没找到，会继续查找对象是否带有 someKey 这个实例变量( iVar )，如果还 没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个 方法还是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。
(Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey 以及 _getsomeKey 这几种
形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从 对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。

21. 自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对 象的一个引用放入到最新的 自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送
消息。 当程序执行到作用域结束的位置 时，自动释放池就会被释放， 池中的所有对象也就被释放。
[[MyClass alloc] init]
)的方式来创建对象，您就拥
NSObject 的便利方法 new 时也同样适

2.CALayer 和 View 的关系
一个 UIView 包含 CALayer 树， CALayer
为啥离开团队?
1. 针对第一个问题，可以看看下面的教程
是一个数据模型，包含了一些用于显示的对象，但本
身不用于显示。
CALayer 相当于 photoshop 的一个层，很多动画可以通过设置 CALayer 来实现。据说有人用
CALayer 显示图片来播放视频。
Core animation 应该是用 CAlayer 来实现各种动画。

用继承好还是分类好?为什么?
7. 什么是安全释放?
10. 异常 exception 怎么捕获?不同的 CPU 结构上开销怎样? C 中又什么类似的方法?
11.property 中属性 retain,copy,assgin 的含义分别是什么?有什么区别?将其转换成 get /set方 法怎么做?有什么注意事项?
12. 委托是什么?委托的 property 声明用什么属性?为什么?
14.Cocoa 中与虚基类的概念么?怎么简洁的实现?
18. 在一个对象释放前 .如果他被加到了 notificationCenter 中 .不在 notificationcenter 中 remove 这个对象可能会出现什么问题?
19. 怎样实现一个 singleton 的类 .给出思路。
20. 什么是序列化或者 Acrchiving, 可以用来做什么 ,怎样与 copy 结合 ,原理是什么 ?.
22. 在 iphone 上有两件事情要做 ,请问是在一个线程里按顺序做效率高还是两个线程里做效率高? 为什么?

19. (Key-Value-Observing
KVC,KVO Ewe KVC(Key-Value-Coding) KVO
- 值- 监看)
) 理解 KVC 与 KVO (键 - 值- 编码与键 http://www.cocoachina.com/macdev/cocoa/2009/0611/221.html
k-v-o 扫盲
http://www.cnblogs.com/scorpiozj/archive/2011/03/14/1983643.ht ml
当通过 KVC 调用对象时，比如: [self valueForKey:@ 序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有
someKey 这个方法， 如果没找到， 会继续查找对象是否带有 someKey 这个实 例变量(iVar )，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。 如果这个方法还是没有被实现的话， 程序 会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey 以及 _getsomeKey 这几种形式。 同时， 查找实例变量的时候也会不 仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 时，对象能够在错误发生前，有最后的机会响应这个请求。

19. 什么是 KVO 和 KVC?
20. 代理的作用 ?
答:代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类，
而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
21. oc 中可修改和不可以修改类型。
答:可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可
动态添加修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不 可变的，后者可以添加等，可以动态申请新的内存空间。

三、类别 (Category) 和类扩展 (Extension) 的区别?
1、相同点:都可以给类添加额外的方法
2 、不同点:类扩展是分类的一个特例，或者说是一个私有的分类、匿名类， Extension 中的方法必须在 @implementation 中实现，否则编译会报警告
分类只能添加方法不能添加属性，且方法的实现不一定在 @implementation 实现。
四、什么是 KVO和KVC?
1、KVO:即:Key-Value Observing，它提供一种机制，当指定的对象的属性被 修改后，则对象就会接受到通知。 简单的说就是每次指定的被观察的对象的属性 被修改后， KVO就会自动通知相应的观察者，极大的简化了代码! 2、KVC:即:KeyValueCoding 的简称，它是一种可以直接通过字符串的名字 (key) 来访问类属性的机制。而不是通过调用 Setter、Getter 方法访问，也可以简化代 码!
五、代理的作用?
1、代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。 可以减少框架复杂程度。另外一点， 代理和 java 中的回调监听机制比较类似。
六、 OC中的可修改和不可修改类型?
1、个人理解为可变和不可变，如 NSAray、NSString、NSDictionary 等是不可变 的，一旦初始化完毕，里面的内容就是固定不变的，既不能删除，也不能添加;
而 NSMutableArray 、NSMutableString 、NSMutableDictionary 等是可变的， 即能 添加也能删除，在内存中的存储空间和内容都不固定!
七、 OC中的动态运行时语言是什么意思? 1、多态。主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实
浅涉及到两个概念，运行时和多态。 简单来说，运行时机制使我们直到运行时 才去决定一个对象的类别，以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。如: Person 和 Dog 都继承自生物 Life 类，且都有一个 eat 方法，但是调用时只需要调用各自的 eat 方法，就是说不同对象以自己的方式响应相同的方法和消息! 因此也可以说， 运行时机制是多态的基础。
八、通知和代理的异同?
1、相同点:利用通知和代理都能完成对象之间的通信
2、不同点:代理是一对一的关系，通知是多对多的关系。一般来说代理是两个 类之间的关系，通知可以一对多，也可以多对一，还可以多对多，就是一个发布 者一个监听者， 一个发布者多个监听者， 多个发布者多个多个监听者， 代理需要 有协议、要声明协议、实现协议中方法、设置代理;通知需要设置通知中心、设 置发布者和监听者。
十二、 ios 中的垃圾回收机制?
1、Objective-c 2.0 后提供了垃圾回收机制 Garbage Collection，但是 ios 移动端不 支持垃圾回收机制，需要注意的是 ARC 并不是垃圾回收机制， ARC 也是需要管 理内存的，只不过是隐式的管理内存， 编译器会在适当的位置添加 retain 、release、 autorelease 等消息!
二十五、自动释放池什么时候被创建和销毁?有什么作用?底层如何实现?
1、作用:自动释放对象;所有 autorelease 的对象，在出了作用域之后，会被自 动添加到最近创建的自动释放池中; 自动释放池被销毁或者耗尽时， 会向池中所 有对象发送 release 消息，释放池中对象;自动释放池，在 ARC & MRC程序中都 有效 2、生命周期:运行循环检测到事件并启动后，就会创建自动释放池;一次完整 的运行循环结束之前，会被销毁
3、底层实现:自动释放池以栈的形式实现 :当你创建一个新的自动释放池时，它 将被添加到栈顶。当一个对象收到 autorelease 消息时 ,该对象会被添加到这个处 于栈顶的自动释放池中 ,当自动释放池被回收时 ,它们会从栈中被删除 , 并且会给 池子里面所有的对象都会做一次 release 操作。
二十六、简要说明工厂方法?
1、概念:在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂 方法让一个类的实例化延迟到子类中进行 ，工厂方法要解决的问题是对象的创 建时机，它提供了一种扩展的策略，很好地符合了开放封闭原则。 2、何时使用:一个类不知道它所必须创建的对象的类时，一个类希望有它的子 类决定所创建的对象时
三十、图层 CALayer 和 UIView 的区别?
1、UIView 是 iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本
身完全是由 CoreAnimation 来实现的。真正的绘图部分，是由 CALayer类来管理。 UIView 本身更像是一个 CALayer 的管理器。
2、UIView 继承结构为:UIResponder---------NSObject ，直接父类为 UIResponder， 直接父类是用来响应用户事件的，所以 UIView 可以响应用户事件
CALayer 的继承结构为: NSObject，直接父类没有 UIResponder ，所以 CALayer 不能响应任何用户事件
3、UIView 属于 UIKit 框架,CALayer属于 QuartzCore 框架 三十一、简要说明 GCD?
1、全称: Grand Central Dispatch ，纯 C 语言，提供了非常强大的函数 2、优势: a、是苹果公司为多核的并发运算提出的解决方法
毁线程 ) 线程管理的代码
b、会自动利用更多得 CPU内核(双核、四核 ) c、自动管理线程的生命周期 ( 创建线程、调度任务、销
d、程序员只需告诉 GCD 要执行什么任务，不需要编写
3、核心概念:将任务添加到队列， 并指定执行任务的函数， 任务用 block 封装， 执行函数分同步和异步，队列分串行、并发和主队列
三十二、什么是 TCP 连接的三次握手?
1、第一次握手:客户端发送 syn( 同步序列编号 )包 (syn=j) 到服务器，并进入 SYN_SEND状态，等待服务器确认;
2、第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1 )，同时自 己也发送一个 SYN包(syn=k)，即 SYN+ACK包，此时服务器进入 SYN_RECV状态;
3、第三次握手:客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成 三次握手。 4、如果要断开连接，就需要任意一方主动发起请求，可以理解为第四次握手!
三十三、利用 Socket 建立网络连接的步骤 ( 等同于 Socket 间如何通信 ) ? 1、创建套接字，建立地址和套接字之间的联系
2、服务器监听客户端的请求，之后建立客户端和服务器的连接 3、发送和接受数据
4、关闭套接字 三十四、什么是指针的释放?
1、其实是释放指针指向的内存空间，指针是一个变量，程序结束时才会销毁， 并且只有堆上的内存才需要我们手动管理
2、将该指针初始化为 NULL 三十五、指针和地址的区别?
1、指针意味着已经有一个指针变量存在 ,他的值是一个地址 ,指针变量本身也存放 在一个长度为 8 个字节的地址当中 ,而地址概念本身并不代表有任何变量存在 .
2 、指针的值 ,如果没有限制 ,通常是可以变化的 ,也可以指向另外一个地址 . 地址表 示内存空间的一个位置点 ,他是用来赋给指针的 ,地址本身是没有大小概念 ,指针指向变量的大小 ,取决于地址后面存放的变量类型 .
三十八、语句 for( ; 1 ; ) 有什么问题?它是什么意思?
1、死循环
三十九、 do,, 1、前一个循环一遍再判断，后一个判断以后再循环、 四十、针对 APP显示 webView 时的内存问题应该如果优化?
1、后端程序员做优化 2、专门针对手机做页面，需要精简内容
3、优化框架，有些后端的框架非常消耗内存，需要精简框架 4、优化网络统计 js
5、针对手机提供定制的图片
四十一、谈谈运行时 Runtime 机制，适用范围是什么，并写出相关的头文件和 方法名?
1、runtime 是一套 C 语言比较底层的 API，属于一个 C 语言库， 平时编写的 OC 代码在程序运行过程中都转成了 runtime 的 C 语言代码
2、适用范围: A 、动态获取类的属性，常见于字典转模型的框架 B、利用关联对象为分类动态添加属性
C、利用交换方法拦截系统或框架的方法
D、动态给某个类添加属性和方法
3、相关应用: A、NSCoding(归档和解档，利用 runtime 遍历模型对象的所有属性)
B、字典转模型 ( 利用 runtime 遍历模型对象的所有属性，根号属性 名从字典中取出对应的值，设置到模型属性上 )
C、KVO(利用 runtime 动态产生一个类 )
D、用于封装框架
4、头文件: #import <objc/runtime.h> #import<objc/message.h> 5、方法名:获取类的属性 :class_copyPropertyList()
关联对象: objc_getAssociatedObject() 和 objc_setAssociatedObject() 交换方法: class_getInstanceMethod()
四十二、简述 KVO 的底层实现原理?
1、KVO(Key Value Observing)是观察者模式在 Foundation 中的实现，是基于runtime 实现的
2、原理:以 Person *p = [[Person alloc]init] 为例 ;
a、当给对象 p 添加了观察者时，会动态创建这个 Person 类的子类 ( NSKVONotifying_Person)
b 、对被观察对象 p 的属性重写其 set 方法
c、在重写的 set 方法中调用 willChangeValueForKey 和 didChangeValueForKey 方法通知观察者进行观察
d、当属性没有观察者时就会删除重写的 set 方法，当没有观察者观察任何 一个属性时，就会动态删除这个类的子类
四十三、写一个标准的宏定义求三个数最小值和最大值? 1、最小值: #define Min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c))
2、最大值: #define Max(a,b,c) (a>b?(a>c?a:c):(b>c?b:c)) 四十四、 KVC的底层实现 :setValuesForKeysWithDictionary:
1、逐个取出字典当中的 key,判断调用对象有没有 set 方法 ,如果有 ,直接赋值 ;
2、若没有，去对象中查找 ,有没有带下划线的成员属性 _key,如果有就直接赋值 ;
3 、若没有，去对象中查找 ,有没有不带下划线的成员属性 key,如果有就直接赋值;
4、若没有，表示没有找到对象里面的属性 ,就会直接报错 .
所以 ,我们在利用 KVC 的时候 ,要保证对象里面的属性和 Key 要一一对应 ;
四十五、这个写法会出什么问题: @property (atomic ， copy) NSMutableArray *array;
1、添加 ,删除 ,修改数组内的元素的时候 ,程序会因为找不到对应的方法而崩溃 .因为 copy 就是复制一个不可变 NSArray 的对象
2、atomic 应写成 nonatominc ，因为他会影响性能，该属性使用了同步锁，会在 创建时生成一些额外的代码用于帮助编写多线程程序， 这会带来性能问题， 通过 声明 nonatomic 可以节省这些虽然很小但是不必要额外开销，因此，开发 iOS 程序时一般都会使用 nonatomic 属性
四十七、交换两个数值的方法?
例如: int a = 6 b = 8 1、中间 变量 int temp;
temp = a; a = b;
b = temp;
2、加减法 a = a + b; b = a - b ; a = a - b;
3、按位异或 a = a ^ b; b = a ^ b; a = a ^ b;
四十八、MRC 和 ARC混合开发， 项目开发中遇到 MRC 开发的第三方库怎么办? 例如: ASI
1、首先尝试使用 Xcode的转换工具(但失败率比较高) Edit --> Convert --> To Objective-C ARC
2、在编译选项中，为 MRC 的程序添加 -fno-objc-arc 标记，表明在编译时，该文 件使用 MRC编译，如果要在 MRC 项目中添加 ARC的文件，可以使用 -fobjc-arc 标记
3、将 MRC的第三方库直接编译成静态库使用， 需要注意的是:在编译静态库时， 不能添加动态库引用， 在项目中，如果使用的静态库中包含分类， 则需要在 Other Link Flag 中添加 -ObjC 选项
五十、 Swift 和 OC的区别?
1、Swift 没有地址和指针的概念
2、Swift 对数据类型要求极为严谨 3、泛型，泛型代码能写出更加灵活清晰、可重复使用的函数
五十一、如何实现 OC 和 Javascript 交互?
1、ios 应用一般通过 UIWebView 实现 OC与 Javascript 的交互，具体如下 2、OC 调用 JS:在 UIWebView 的代理方法 webViewDidFinishLoad 中利用 WebView 唯一与 JS交互的方法
- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 3、JS调用 OC:利用 html 的重定向技术，使用下面方法截取重定向
-(BOOL)webView:(UIWebView *)webView
shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
五十二、 HTTP 和 Socket 通信之间的区别?
1、A > HTTP(超文本传输协议 )是建立在 TCP协议上的应用，简单、规模 小、通信速度快，用于定义网络数据传输的格式
B >最显著特点是客户端每次请求都需要服务器的响应，响应完成会主动 释放连接，节约传输时间
C >完整的 HTTP 通信必须包含请求 (请求头、请求行、请求体 ) 和响应 (状 态行、响应头、实体内容 )
2、A > Socket 是纯 C语言的，客户端与服务器使用 socket 套接字进行连接， 它是一种用于传输网络数据的工具
B > Scoket 是对 TCP/IP 协议的封装和应用 ,简单说，TCP/IP 协议是传输层 协议，主要解决数据如何在网络上传输， HTTP 是应用层协议，主要负责解决如
何包装数据
C > Socket 连接过程:建立连接、客户端请求数据、服务器回应数据、 结束连接
D > Socket 有长短连接和心跳包的概念 ( 短连接是数据请求结束立刻 断开;长连接是一旦建立连接始终保持; 心跳包是检测长连接的手段客户端和服 务器都可以发送 )
五十三、 TCP与 UDP 的区别?
1、概念:TCP(传输控制协议 )是基于连接的协议， 正式收发数据前必须建立可靠
的连接
UDF(用户数据报协议 )是基于非连接的协议，只管发送，不与对方建立 连接
2、数据传输大小: UDP 每个数据报大小在 64k 之内
TCP传输数据大小不受限， 所以对系统资源的要求要高于 UDP
3、可靠性: UDP无需建立连接故而不可靠，易丢包 TCP 需要三次握手才能建立连接，可靠
4、传输效率: UDP > TCP，因为 TCP多了建立连接的步骤 五十四、 SAX解析与 DOM 解析的区别?
1、SAX: 是只读的方式，从上向下的方式解析;是苹果提供的解析方式; 速度快;适合对大型的 XML 的解析;用 5 个代理方法解析
2、DOM:是在 MAC 使用的解析方式， 可读可写， 内存消耗极大， 解析速度慢， ios 默认不支持
五十五、多线程有什么优点和缺点?
1、优点:使应用程序响应速度更快，用户界面在进行其他工作时仍始终保持活 动状态，提高程序执行效率
  优化任务的执行，适当提高资源利用率
2、缺点:线程占用内存空间，管理内存需要额外的 cpu 开销，开启大量线程降 低程序的性能
    增加程序复杂程度，如线程间通信，多线程的资源共享
六十三、开发中哪些地方用到过多线程?
1、预先加载图像，用到 dispatch_group_enter ，利用通知统一监听
2、SQLite 的异步操作，使用串行队列顺序调度任务，保证数据的完整性 3、图像压缩，异步压缩，完成之后回调
六十四、 load 和 initialize 的异同? 1、相同点:方法只会被调用一次 ( 开发者不主动调用的前提下 )
2、不同点: A: load 是只要类所在文件被引用 (import) 的时候就会被调用 initialize 是在当前类第一次被执行到的时候会被调用
B:若自身未定义 initialize 会沿用父类的方法， load 不会沿用 六十五、block 属性为什么用 copy?使用时应注意什么?使用场景?原理是什么?
有什么优点?
1、A:使用 copy 可以将 block 从栈区复制到堆区，因为栈区由系统管理，存在 栈区随时可能被回收，或是出作用域即被回收!
B:block 用于保存代码，调用时才执行，但有时调用 block 时， block 中用到的其他对象可能已经被释放，使用 copy 可以保证调用 block 是外界对象
依然存在
2、注意:循环引用， block 中用到 self 可以用 __weak修饰防止循环引用 3、应用场景:动画、数组字典排序遍历、网络访问时错误回调、 GCD
4、原理:本质是指向结构体的指针，编译器会将 5、优点:代码思路更加清晰，易于阅读和维护
六十六、开发中最容易引起循环引用的场景?
1、声明代理属性要使用 weak
2、block 代码块中的 self 要换成 weakSelf
weakSelf = self)
3、NSTimer 定时器 self.timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(nextPage) userInfo:nil repeats:YES];// 类 持 有 timer ， timer 又持有 self( 即: target : self) ，所以每次需要将 timer 设置为无效 invalidate 并设置为 nil
block 内部代码生成对应函数
( __weak typeof(self)
六十九、用 @property 声明的 NSString 属性通常使用 copy 修饰，为什么?如果 换成 strong 会有什么影响?
1、因为父类指针可以指向子类对象 ,使用 copy 可以让对象的属性不受外界影响 , 使用 copy 后无论给属性传入是一个可变对象还是不可对象 ,属性本身持有的就是 一个不可变的副本 .
2、如果使用是 strong, 那么这个属性就有可能指向一个可变对象 ,如果这个可变对 象在外部被修改了 ,那么会影响该属性 .
注意:
1、类方法: A:类方法是属于类对象的 B;类方法只能通过类对象调用 C:类方法中的 self 是类对象 D:类方法可以调用其他的类方法 E:类方法不能直接访问成员变量 F:类方法中不能直接调用对象方法
2、对象方法:
A:对象方法属于实例对象 B;对象方法只能通过实例对象调用 C:对象方法中的 self 是实例对象 D:对象方法中可以访问成员变量 E:对象方法中可直接调用其他对象方法 F:对象方法中也可以调用类方法 ( 通过类 )
七十三、 OC中有哪几种遍历的方法?哪个效率比较高? 1、普通 for 循环
2、for 循环增强 for-in
3、block 代码块 enumrateObjectsUsingBlock
4、枚举器: NSEnumerator
效率: for -in 效率最高 2s 左右，其余都在 2.6~3.0s 之间
七十四、 runtime 如何实现将 weak 修饰的对象自动设置为 nil ? 1、runtime 对注册的类，会进行布局， 对于 weak 对象会放入一个
用 weak 指向的对象内存地址作为 key ，当此对象的引用计数为
dealloc，假如 weak 指向的对象内存地址是 a，那么就会以 a 为键，在这个 weak
表中搜索，找到所有以 a 为键的 weak 对象，并设置为 nil
七十九、 addObserver:forKeyPath:options:context: 各个参数的作用分别是什么， observer 中需要实现哪个方法才能获得 KVO回调?
1、添加观察者方法的参数:观察者、观察的属性、观察的选项、上下文 2、回调方法的参数:观察的属性、观察的对象、 change 属性变化的字典、上下 文(与添加时一致 )
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
八十、 IB 中 User Defined Runtime Attributes 如何使用?
1、它能够通过 KVC 的方式配置一些你在 interface builder 中不能配置的属性。 当你希望在 IB 中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的
viewcontroller ，只要响应的 attribute type 代表相同的数据类型，那么他们就可 以相互替换使用
八十一、 lldb 常用调试指令?
1、b:查看当前所有断点 c:继续 r:重新运行 n:下一步 p :打印 s:单步 po :打印对象 八十二、如何调试 BAD_ACCESS错误?
1、重写 object 的 respondsToSelector 方法，现实出现 EXEC_BAD_ACCES前S访 问的最后一个 object
2、通过开启 Edit Scheme 中的 Zombie 3、设置全局断点定位
4、Xcode 7 已经集成了 BAD_ACCESS捕获功能: Address Sanitizer 在配置中勾 选?Enable Address Sanitizer
八十八、对于 NSString *obj = [[NSData alloc] init];, 编译时和运行时 obj 分 别是什么类型?
1、编译时是 NSString 类型 2、运行时是 NSData 类型
八十九、常见的 OC数据类型有哪些?和 C 的基本数据类型有什么区别? 1、OC常用数据类型: NSString、NSSArray、NSDictionary 、NSData、NSNumber等；
2、区别: OC 对象需要手动管理内存， C 语言的基本数据类型不需要管理内存
 九十三、简述 NSURLSession?
1、ios7 之后推出，为了方便程序员使用，苹果提供了一个全局 代 NSURLConection
session，用于替
2、支持后台运行的网络任务，网络任务可以实现暂停、停止、重启
3、使用 URLSession后， NSURLRequest通常只用于指定 HTTP 请求方法，而其 他的额外信息都可以通过 NSURLSessionConfiguration 设置 4、默认所有任务都是挂起的状态，需要手动 resume 5、支持三种类型任务:加载数据、下载和上传
九十四、 ios 应用中地图是如何实现定位的?
1、ios 中通过 Core Location 框架进行定位操作，和地图开发框架 MapKit 完
全独立，二者可配合使用
2、Core Location 中包含定位、地理编码等功能
九十五、 obj-c 有多重继承吗?没有的话有什么代替?
1、Object-c 只支持单继承，如果要实现多继承可以通过类别和协议的方式实现
九十八、什么是 XMPP?工作原理是什么?
1、XMPP 是基于 XML 通讯的协议，基于 TCP 发送 XML 数据，一般用于即时通
讯(QQ/微信)
2、原理: A 、节点连接到服务器 B、服务器利用本地目录系统中的证书对其认证 C、节点指定目标地址，让服务器告知目标状态 D、服务器查找、连接并进行相互认证 E、节点之间进行交互
九十九、 http 中的 POST请求和 GET请求的区别和联系?如何选择? 1、GET 是从服务器获取数据， POST是向服务器发送数据
2、GET请求能够被缓存， POST请求不能被缓存 3、GET 请求对数据大小有限制， POST没有大小限制
4、使用 GET请求，参数会显示出来，而 POST则不会， POST更安全一些 5、GET 的效率要高于 POST，因为 POST多了一步解析二进制参数的过程 如何选择: 如果数据是中文数据而且是非敏感数据应该使用 GET，如果数据中包 含用户的隐私信息 (账户、密码
等)尽量使用 POST

iOS的远程消息推送 (Push)是怎么实现的?
1、[Client App] 注册消息推送 ( 通过设备唯一标示 UDID 和应用的唯一标示 Bundle ID) ;
2、[Client App] 跟[APNS Service]要 deviceToken, Client App 接收 deviceToken;
3、[Client App] 将 deviceToken 发送给 [Provider]Push 服务端程序;
4、当 Push 服务端程序满足发送消息条件时， [Provider] 将 deviceToken 和消息 体等打包向 [APNS Service]发送消息;
5、[APNS Service]会利用 deviceToken 找到对应的 [Client App] 并将消息体传达

// 数据持久化
1、 NSKeyedArchiver 采用归档的形式存储 ( 常用于 NSString, NSDictionary,
NSArray, NSData, NSNumber等类型 ) ，需遵守 NSCoding 协议 归档对象时:会调用 encodeWithCoder，一般在这个方法里面指定如何归档对象 中的每个实例变量 .可以使用 :encodeObject:forkey: 方法归档实例变量 解档对象时:会调用 initWithCoder ，一般在这个方法里面指定如何解码文件中 的数据为对象的实例变量 ,可以使用 decodeObject:forkey 方法解码实例变量
2、NSUserDefaults 偏好设置存储，常见保存用户名和密码，一般需要调用 synchronize 方法强制写入
存入:
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:@"JN521" forKey:@"username"];
[defaults setFloat:18.0f forKey:@"text_size"]; [defaults setBool:YES forKey:@"auto_login"];
读取:
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSString *username = [defaults stringForKey:@"username"];
float textSize = [defaults floatForKey:@"text_size"];
BOOL autoLogin = [defaults boolForKey:@"auto_login"];
3、write 写入的形式永久保存到磁盘
NSArray *docPath =
[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
NSUserDomainMask, YES) objectAtIndex:0]; NSString
stringByAppendingPathComponent:fileName] [data writeToFile:FileName atomically:YES];
// 获取文件即将保存的路径 *FileName=[documentDirectory
// 生成该路径下得文件 // 写入
4、属性列表 (plist 存储 )属性列表是一种 XML 格式的文件 ,拓展名为 plist 如果 对象是 NSString, NSDictionary, NSArray, NSData, NSNumber 等类型,就可以使 用:writeToFile:atomiclly: 方法直接将对象写到属性列表文件中 .
存入:
// 将数据封装成字典
NSMutableDictionary *dict = [NSMutableDictionary dictionary];
[dict setObject:@"15013141314" forKey:@"phone"];
[dict setObject:@"27" forKey:@"age"];
// 将字典持久化到 Documents/stu.plist 文件中
[dict writeToFile:path atomically:YES];
读取:
// 读取 Documents/stu.plist 的内容，实例化 NSDictionary NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path]; NSLog(@"phone:%@", [dict objectForKey:@"phone"]); NSLog(@"age:%@", [dict objectForKey:@"age"]);
5、数据库存储 SQLite
概念: SQLite 是一个进程内的库，本质上就是一个文件，是一个 SQL 数据库引擎
特点:自给自足不需要外部依赖、无需单独服务器、零配置、轻量级、占用 资源少、处理速度快

使用步骤:添加动态库 (libsqlite3.dylib) 、导头文件 sqlite3 、建立数据库、创 建数据表、利用 SQL 命令增删改查
  优点:将网络数据存到本地不用每次都加载，减少网络流量开销，可对本地
数据进行系统性查询
SQLite 命令: INSERT增/UPDATE 改/DELETE 删/SELECT 查
一零七、 block 在 ARC中和 MRC中的用法有什么区别 ,需要注意什么? 1、MRC中 block 默认在栈区， ARC中的 block 会被复制到堆区
2、对于没有引用外部变量的 Block ，无论在 ARC 还是 MRC 下，类型都是 __NSGlobalBlock_，_这种类型的block可以理解成一种全局的block，不需要考 虑作用域问题。同时，对他进行 Copy 或者 Retain 操作也是无效的
3、需要注意:循环引用
一零八、 Foundation 对象和 Core Foundation 对象有什么区别?
1、前者针对 OC对象，后者针对的是 C 语言对象 (结构体 )
2、ARC 机制下，只管理 OC 的对象，不能管理 CF 对象，需要手动 (CFRetain/CFRealease) 管 理 ， 所 以 需 要 使 用 到 __bridge,__bridge_retained 和 __bridge_transfer 三个转换关键字
3、__bridge_retained 后面跟 CF对象，会转让所有权， 将 OC对象转成 CF对象， 后续需要调用 CFRealease或相关方法释放对象;
__bridge_transfer 后面跟 OC 对象，也会转让所有权 ,将 CF 对象转成 OC 对象 ,转换后自动调用 CFRealease
一零九、简述客户端的缓存机制? 1、缓存可分为:内存数据缓存、数据库缓存、文件缓存
2、步骤: A:每次想获取数据时，先检查内存是否有缓存 B:再检查本地是否有缓存 ( 数据库、沙盒 )
C:最终发送网络请求去网络加载 D:将服务器返回的网络数据进行缓存以便再次使用
一一零、怎么解决缓存池满的问题 (cell) ?
1、一般情况下， ios 中不存在缓存池满的情况
2、因为通常我们 ios 中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在 UITableView 中一般只会创建刚开始出现在屏幕中的 cell， 之后都是从缓存池里取， 不会在创建新对象。 缓存池里最多也就一两个对象， 缓
存池满的这种情况一般在开发 java 中比较常见， java 中一般把最近最少使用的 对象先释放。
一一一、 iOS7之前，后台执行内容有几种形式，都是什么?
1、一般的应用在进入后台的时候可以获取一定的时间来运行相关任务，也就是 说可以在后台运行一小段时间 (10s 左右 )
2、后台播放音乐、后台 GPS跟踪、后台 voip 支持
一一二、简单说明 App 的启动过程?
1、第一种情况:有 storyboard
A:程序入口 main 函数
B: UIApplicationMain ;创建 UIApplication 对象，创建 UIApplication 的
delegate 对象
C:根据 info.plist 加载 Main storyboard file base name 所执行的 storyboard D:创建 UIWindow ，创建和设置 UIWindow 的根控制器 rootViewController ，显示窗口
2、第二种情况:没有 storyboard
A:程序入口 main 函数
B: UIApplicationMain ;创建 UIApplication 对象，创建 UIApplication 的
delegate 对象
C:delegate 对象开始监听系统事件，程序启动完毕时调用代理的
application:didFinishLaunchingWithOptions: 方法，在该方法中创建窗口，设置 根控制器，显示窗口
一一三、有些图片加载的比较慢如何处理?
1、图片下载要放下异步线程执行 2、图片下载过程中使用占位图片 3、如果图片较大，可以考虑使用断点下载
一一四、 你实现过一个框架或者库以供别人使用么?如果有， 或者库时候的经验;如果没有，请设想和设计框架的 public 的 API，并指出大概 需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架?
1、提供给外界的接口功能是否充足够用 2、别人使用我的框架时能够根据类名方法名猜出大概能实现的功能
3、别人调用框架的接口时提供的参数是否够用，调用起来是否简单
4、当使用我的框架时要不要依赖其他的框架，请谈一谈构建框架

五、App 需要加载大量的数据， 给服务器发送请求时， 服务器卡住了怎么解决?
1、设置请求超时 2、提示用户请求超时 3、根据用户操作再次请求数据

10.代理一般是什么时候用呢 ?
答 :自身不做实际的事 ,要求其它类做。 代理也可用来传值。 代理的目的是改变或传递 控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。 可以减 少框架复杂度。另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
11.有关 copy 和 retain 的区别
答: retain 是指针拷贝 ,copy 是内容拷贝

17.谈谈 KVO and KVC? 答案:
后者可以添加属性。
Category 。
kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用 存取方法，直接或通过实例变量访问的机制。很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。具体用看 到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。

2.SEL 和一个函数指针调用同一个方法的结果是不是相同
答:得到了 SEL 变量之后 ,可以通过下面的调用来给一个对象发送消息 :
[对象 performSelector:SEL 变量 withObject: 参数 1 withObject: 参数 2];
结论 :SEL 只是方法名标识 ,实际运行时需要通过消息发送来调用 ,IMP 是”
implementation”的缩 写,它是 objetive-C 方法 (method)实现代码块的地址 ,类似函数指针 ,通 过它可以 直接访问任意一个方法。免去发送消息的代价。

3.project workspace scheme 的区别 Project:
一般的某个应用单独新建一个 project 就可以了 ,然后把所有的程序文件都放在里面 ,这个可以满足大部分普通的需求。
Workspace:
项目有可能要使用其他的项目 文件 ,或者引入其他的静态库 文件 ,这个时候 workspace
就派上用场了 ,workspace 既可以单独管理多个项目 ,又可以通过配置 ,让各个项目相互依赖。 Scheme:
Xcode scheme 定义了编译集合中的若干 target,编译时的一些设置以及要执行的测试集 合。可以自定义若干个 scheme,但是同一时刻只能运行一个。

网络七层协议
应用层:
1. 用户接口、应用程序; 2.Application 典型设备网关;
3. 典型协议、标准和应用: TELNE、TFTP、HTTP
表示层:
1. 数据表示、压缩和加密 presentation
2. 典型设备:网关
3. 典型协议、标准和应用: ASCLL、PICT、TIFF、JPEG|MPEG
4. 表示层相当于一个东西的表示， 表示的一些协议， 比如图片、声音和视频 MPEG
会话层:
1. 会话的建立和结束;
2. 典型设备:网关;
3. 典型协议、标准和应用: RPC、SQL、NFS、X WINDOW、SASP
传输层:
1. 主要功能:端到端控制 Transport ;
2. 典型设备:网关;
3. 典型协议、标准和应用: TCP、UDP、SPX
网络层:
1. 主要功能:路由、寻址 Network ; 2. 典型设备:路由器;
3.典型协议、标准和应用: IP、IPX、APPLETAL、KICMP;
数据链路层:
1. 主要功能:保证无差错的疏忽链路的 data link ;
2. 典型设备:交换机、网桥、网卡;
3. 典型协议、标准和应用: 802.2 、 802.3ATM、HDLC、FRAME RELA;Y
物理层:
1. 主要功能:传输比特流 Physical ;
2. 典型设备:集线器、中继器
3. 典型协议、标准和应用: V.35、EIA/TIA-232.

对瀑布流的理解
首先图片的宽度都是一样的， 1. 将图片等比例压缩，让图片不变形; 2. 计算图片最低应该摆放的位置， 哪一列低就放在哪; 3. 进行最优排列， 在 ScrollView 的基础上添加两个 tableView ，然后将之前所计算的 scrollView 的高度通过 tableView 展示出来。
如何使用两个 TableView 产生联动:将两个 tableView 的滚动事件禁止掉， 最外层 scrollView 滚动时将两个 TableView 跟着滚动，并且更改 contentOffset ，这样产生效果滚动的两个 tableView 。

 内存的使用和优化的注意事项
重用问题:如 UITableViewCells 、UICollectionViewCells 、 UITableViewHeaderFooterViews 设置正确的 reuseIdentifier ，充分重用; 尽量把 views 设置为不透明:当 opque 为 NO的时候，图层的半透明取决 于图片和其本身合成的图层为结果，可提高性能;
不要使用太复杂的 XIB/Storyboard :载入时就会将 XIB/storyboard 需要 的所有资源， 包括图片全部载入内存， 即使未来很久才会使用。 那些相比 纯代码写的延迟加载，性能及内存就差了很多;
选择正确的数据结构: 学会选择对业务场景最合适的数组结构是写出高效 代码的基础。 比如，数组: 有序的一组值。 使用索引来查询很快， 使用值 查询很慢，插入 / 删除很慢。字典 : 存储键值对，用键来查找比较快。集
合: 无序的一组值，用值来查找很快，插入 / 删除很快。
gzip/zip 压缩:当从服务端下载相关附件时，可以通过 gzip/zip 压缩后 再下载，使得内存更小，下载速度也更快。
、
数据缓存: 对于 cell 的行高要缓存起来， 使得 reload 数据时， 效率也极 高。而对于那些网络数据， 不需要每次都请求的， 应该缓存起来， 可以写 入数据库，也可以通过 plist 文件存储。
处理内存警告: 一般在基类统一处理内存警告， 将相关不用资源立即释放
掉
重用大开销对象:一些 objects 的初始化很慢，比如 NSDateFormatter
和 NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起 来，防止反复创建。 避免反复处理数据:许多应用需要从服务器加载功能所需的常为 JSON或
者 XML格式的数据。在服务器端和客户端使用相同的数据结构很重要 使用 Autorelease Pool :在某些循环创建临时变量处理数据时，自动释 放池以保证能及时释放内存 ;
正确选择图片加载方式:详情阅读细读 UIImage 加载方式

16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系，并且 reciever 可以返回值 给sender ，notification 可 以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，
delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。

17什么是 KVC 和KVO ? 答: KVC(Key-Value-Coding) 内部的实现: 一个对象在调用 setValue 的时候，( 1)首先根据方法名找到运行方 法的时候所需要的环 境参数。( 2)他会从自己 isa指针结合环境参 数，找到具体的方法实现的接口。( 3)再直接查找得来的具体的方 法实现。 KVO (Key-Value- Observing ):当观察者为一个对象的属 性进行了注册，被观察对象的 isa 指针被修改的时候， isa 指针就会指 向一个中间类，而不是真实的类。所以 isa 指针其实不需要指向实例 对象真实的类。所以我们的程序最好不要依赖于 isa 指针。在调用类 的方法的时候，最好要明确对象实例的类名

47 HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方
式，适用于分布式超媒体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、 应用层的协议， 常基于 TCP 的连接方式， HTTP1.1 版本中给出一种持 续连接的机制，绝大多数的 Web 开发，都是构建在 HTTP 协议之上的 Web应用。 HTTP 协议的主要特点可概括如下: 1.支持客户 /服务 器模式。 2. 简单快速:客户向服务器请求服务时，只需传送请求方 法和路径。请求方法常用的有 GET 、 HEAD 、 POST 。每种方法规定 了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。 3. 灵活: HTTP 允许传 输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器 处理完客户的请求，并收到客户的应答后，即断开连接。 采用这种方
式可以节省传输时间。 5.无状态: HTTP 协议是无状态协议。无状 态是指协议对于事务处理没有记忆能力。 缺少状态意味着如果后续处 理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数 据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客
户和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接， 之后才能传输数据。 TCP 提供超时重发，丢弃重复数据，检验数据，
流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。
UDP 不提供可靠性，它只是把应用程序传给 IP层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在 客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接 的协议，也就是说，在正式收发数据前， 必须和对方建立可靠的连接。 一个 TCP 连接必须要经过三次 ―对话 ‖才能建立起来，我们来看看这三 次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包; 2. 主机 B 向主机 A发送同意连接和要求同步(同步就是两台主机一个在发送， 一个在接收，协调工作)的数据包; 3.主机 A再发出一个数据包确认 主机 B的要求同步: ―我现在就发，你接着吧! ‖，这是第三次对话。 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次 ―对话 ‖之 后，主机 A才向主机 B正式发送数据。
UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协 议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数 据包发送过去! UDP 适用于一次只传送少量数据、 对可靠性要求不 高的应用环境。
tcp 协议和 udp 协议的差别 是否连接 面向连接 面向非连接
传输可靠性 可靠 不可靠 应用场合 传输大量数据 少量数据 速度 慢 快
50socket 连接和http连接的区别
简单说，你浏览的网页(网址以 http:// 开头 )都是 http 协议传输到你的 浏览器的, 而http是基于socket之上的。socket是一套完成 tcp，udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ，HTTP 协议是基于 TCP 连接的
tcp 协议: 对应于传输层
ip协议: 对应于网络层 TCP/IP 是传输层协议，主要解决数据如
何在网络中传输;而 HTTP 是应用层协议，主要解决如何包装数据。
Socket是对TCP/IP协议的封装， Socket本身并不是协议，而是一个 调用接口( API )，通过 Socket ，我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一 次请求，服务器端响应后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器 端一旦建立起连接将不会主动断掉; 但是由于各种环境因素可能会是 连接断开，比如说:服务器端或客户端主机 down 了，网络故障，或 者两者之间长时间没有数据传输， 网络防火墙可能会断开该连接以释 放网络资源。 所以当一个 socket 连接中没有数据的传输，那么为了维 持连接需要发送心跳消息 ~~ 具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的， 那什么是 socket 呢?socket起源于Unix，而Unix/Linux 基本哲学之一就是 ―一切皆文 件‖，都可以用 ―打开open –> 读写write/read –> 关闭close ‖模式来操 作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一种特 殊的文件，一些 socket 函数就是对其进行的操作(读 /写IO、打开、 关闭)，这些函数我们在后面进行介绍。我们在传输数据时，可以只 使用(传输层) TCP/IP协议，但是那样的话，如果没有应用层，便 无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应 用层协议，应用层协议有很多，比如 HTTP、FTP、TELNET 等，也 可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议， 以封 装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口，你可以借助它建立TCP连接等等。而 TCP和UDP协议属于传输层 。 而http是个应用 层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发 动机，提供了网络通信的能力。 )
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是 一个调用接口(API)，通过Socket，我们才能使用 TCP/IP协议。Socket
的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND
状态，等待服务器确认; 第二次握手:服务器收到 syn 包，必须确 认客户的 SYN (ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )， 即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手: 客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务 器才正式开始传送数据。理想状态下， TCP 连接一旦建立，在通信双 方中的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。 断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断
开过程需要经过 ―四次握手 ‖(过程就不细写了，就是服务器和客户端 交互，最终确定断开)
52利用Socket 建立网络连接的步骤 建立Socket连接至少需要一对套接字， 其中一个运行于客户端， 称为
ClientSocket ，另一个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求， 连
接确认。
1。服务器监听:服务器端套接字并不定位具体的客户端套接字，而 是处于等待连接的状态， 实时监控网络状态， 等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是 服务器端的套接字。 为此，客户端的套接字必须首先描述它要连接的 服务器的套接字， 指出服务器端套接字的地址和端口号， 然后就向服 务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字 的连接请求时，就响应客户端套接字的请求， 建立一个新的线程，把 服务器端套接字的描述发给客户端， 一旦客户端确认了此描述， 双方 就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。

17 什么是 KVC 和 KVO ? 答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 setValue 的时候，(1)首先根据方法名找到运行方法的时候所需要的环 境参数。(2)他会 从自己 isa 指针结合环境参数，找到具体的方法实现的接口。 ( 3 )再直接查找得来的具体的 方法实现。 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，被观 察对象的 isa 指针被修改的时候， isa 指针就会指向一个中间类， 而不是真实的类。 所以 isa 指针其实不需要指向实例对象真实的类。 所以我们的程序最好不要依赖于 isa 指针。在调用 类的方法的时候，最好要明确对象实例的类名

28oc 中可修改和不可以修改类型。答案:可修改不可修改的集合类。这个我个人简单理解就 是可动态添加修改和不可动态添加修改一样。 比如 NSArray 和 NSMutableArray 。前者在初 始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动 态运行时语言是什么意思?答案:多态。 主要是将数据类型的确定由编译时，推迟到了运
行时。 这个问题其实浅涉及到两个概念， 运行时和多态。 简单来说，运行时机制使我们直到 运行时才去决定一个对象的类别， 以及调用该类别对象指定方法。 多态: 不同对象以自己的 方式响应相同的消息的能力叫做多态。意思就是假设生物类( life )都用有一个相同的方法 -eat;那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们 只需调用各自的 eat 方法。也就是不同的对象以自己的方式响应了相同的消息(响应了 eat 这个选择器) 。因此也可以说，运行时机制是多态的基础? ~~~
通知和协议的不同之处? (专业术语了 ~ )。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解简
30 what is difference between NSNotification and protocol?
答案:协议有控制链 (has-a) 的关系，通知没有。首先我一开始也不太明白，什么叫控制链

 单来说，通知的话， 它可以一对多， 一条消息可以发送给多个消息接受者。 代理按我们的理 解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候一个经济人负责 好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的， 一一对应， 不可 能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的发布会 了。但是通知就不一样， 他只关心发出通知， 而不关心多少接收到感兴趣要处理。 因此控制 链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。

36 NSOperation queue? 答案:存放 NSOperation 的集合类。操作和操作队列，基本可 以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发的问题。网上部分资料提
到一点是， 虽然是 queue ，但是却并不是带有队列的概念， 放入的操作并非是按照严格的先 进现出。这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也进入队列， Afunc 先执行这个是必然的，但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行， 因此队列的概念离乱上有点违背了多线程处理这个概念。 但是转念 一想其实可以参考银行的取票和叫号系统。因此对于 A 比 B 先排队取票但是 B 率先执行完 操作， 我们亦然可以感性认为这还是一个队列。 但是后来看到一票关于这操作队列话题的文章，其中有一句提到
“因为两个操作提交的时间间隔很近， 线程池中的线程， 谁先启动是不定的。 ”瞬间觉得这 个 queue 名字有点忽悠人了， 还不如 pool~ 综合一点， 我们知道他可以比较大的用处在于可 以帮组多线程编程就好了。
38 Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制
器中嵌入两个 tableview 控制器?答案:一个视图控制只提供了一个 View 视图，理论上一 个 tableViewController 也不能放吧，只能说可以嵌入一个 tableview 视图。当然，题目本身 也有歧义，如果不是我们定性思维认为的 UIViewController ，而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如
TabbarController 那样的感觉。
39 Can we use one tableview with two different datasources? How you will achieve
this? 一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?答案: 首先我们从代 码来看， 数据源如何关联上的， 其实是在数据源关联的代理方法里实现的。 因此我们并不关 心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的需要去设置如相关的数据源。 因此， 我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢?想让列表如何显 示，不同的数据源分区块显示?
40id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object 的一个指针，这 个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject )类的对象。需 要注意的是 id 是一个指针，所以你在使用 id 的时候不需要加星号。比如 id foo=nil 定义了 一个 nil 指针，这个指针指向 NSObject 的一个任意子类。而 id *foo=nil 则定义了一个指针， 这个指针指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C 语言的 NULL 相同，在 objc/objc.h 中定义。 nil 表示一个 Objctive-C 对象，这个对 象的指针指向空(没有东西就是空) 。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类(是 Class ，而不是对象) 。 SEL 是“ selector ”的一个类型，表示一个方法的名字
Method (我们常说的方法)表示一种类型，这种类型与 selector 和实现 (implementation) 相关
IMP 定义为 id (*IMP ) (id, SEL , , )。这样说来， IMP 是一个指向函数的指针，这个被指向 的函数包括 id( “ self ”指针 ) ，调用的 SEL (方法名) ，再加上一些其他参数 .说白了 IMP 就是实现方法。

41 层和 UIView 的区别是什么?
答:两者最大的区别是 ,图层不会直接渲染到屏幕上， UIView 是 iOS 系统中界面元素的基础， 所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图 部分，是由一个 CALayer 类来管理。UIView 本身更像是一个 CALayer 的管理器。一个 UIView 上可以有 n 个 CALayer ，每个 layer 显示一种东西，增强 UIView 的展现能力。

47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒 体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基
于 TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制， 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速: 客户向服务器请求服务时， 只需传送请求方法和路径。 HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于 得 HTTP 服务器的程序规模小，因而通信速度很快。
3.灵活: HTTP 允许传输任意类型的数据对象。正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

 http 表示要通过 HTTP 协议来定位网络资源; host 表示合法的 Internet 主机域名或者 IP 地 址; port 指定一个端口号，为空则使用缺省端口 80 ; abs_path 指定请求资源的 URI ;如果
URL 中没有给出 abs_path ，那么当它作为请求 URI 时，必须以“ /”的形式给出，通常这 个工作浏览器自动帮我们完成。
49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“对话”才
能建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包; 2. 主机 B 向主机 A 发送同意连接和要求同步(同步就是两台主机一个在发送，一个在接收，
协调工作)的数据包; 3.主机 A 再发出一个数据包确认主机 B 的要求同步:“我现在就发， 你接着吧! ”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步， 经过 三次“对话”之后，主机 A 才向主机 B 正式发送数据。
UDP ( User Data Protocol ，用户数据报协议)是与 TCP 协议，它不与对方建立连接，而是直接就把数据包发送过去! 量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接 面向连接 面向非连接 传输可靠性 可靠 不可靠
应用场合 传输大量数据 少量数据 速度 慢 快
50 socket 连接和 http 连接的区别
简单说，你浏览的网页(网址以 http:// 开头 )都是 http 协议传输到你的浏览器的 基于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层 ip 协议: 对应于网络层
, 而 http 是 连接的
相对应的协议。它是面向非连接的 UDP 适用于一次只传送少
 TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open – > 读写
write/read – > 关闭 close ”模式来操作。我的理解就是 Socket 就是该模式的一个实现，
socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO 、打开、关 闭)，这些函数我们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协 议，但是那样的话， 如果没有应用层， 便无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自 己定义应用层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使 用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车， 提供了封装或者显示数据的具体形式; Socket 是发动机， 提供了网络通信
的能力。 )
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;第二次握手:服务器收到 syn 包，必须确认客户的 SYN (ack=j+1 )，同时自己也发送 一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:
 客户端收到服务器的 SYN +ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包发送完毕， 客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过“四次握手” (过程就不细写了， 就是服务器和客户端交互， 最终确定断 开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字， 其中一个运行于客户端， 称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址 和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。

12 怎样防止指针的越界使用问题 ? 必须让指针指向一个有效的内存地址 ,
1 防止数组越界
2 防止向一块内存中拷贝过多的内容 3 防止使用空指针
4 防止改变 const 修改的指针
5 防止改变指向静态存储区的内容
6 防止两次释放一个指针
7 防止使用野指针
2. 设置变量的存储域
7. 引用与指针有什么区别?
1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。 2) 不存在指向空值的引用，但是存在指向空值的指针。
8. 描述实时系统的基本特性 在特定时间内完成特定的任务，实时性与可靠性
64 全局变量和局部变量在内存中是否有区别?如果有，是什么区别? 全局变量储存在静态数据库，局部变量在堆栈
10. 什么是平衡二叉树?
左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于
65 堆栈溢出一般是由什么原因导致的? 没有回收垃圾资源
12. 什么函数不能声明为虚函数? constructor
13. 冒泡排序算法的时间复杂度是什么?
O(n^2)
14. 写出 float x 与“零值”比较的 if 语句
if(x>0.000001&&x<-0.000001)
16. Internet 采用哪种网络协议?该协议的主要层次结构?
tcp/ip 应用层 /传输层 /网络层 / 数据链路层 / 物理层
17. Internet 物理地址和 IP 地址转换采用什么协议?
ARP (Address Resolution Protocol) (地址解析協議)
18.IP 地址的编码分为哪俩部分?
IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上
分哪些是网络位哪些是主机位。
3. 不能做 switch() 的参数类型是:
switch 的参数不能为实型。
華為
1 、局部变量能否和全局变量重名? 答:能，局部会屏蔽全局。要用全局变量，需要使用 "::" 局部变量可以与全局变量同名， 在函数内引用这个变量时，
量，比如在两个循环体内都定义一个同名的局部变量，
而那个局部变量的作用
个循环体内
2 、如何引用一个已经定义过的全局变量?
答: extern
可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式
在头文件中声明的全局变理， 假定你将那个变写错了， 那么在编译期间会报错， 用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，
间报错
3、全局变量可不可以定义在可被多个 .C 文件包含的头文件中?为什么? 答:可以，在不同的 C 文件中以 static 形式来声明同名全局变量。

3 int retVal = UIApplicationMain(argc, argv, nil, nil); 是什么意思？
答：对UIApplication对象进行了初始化，这个方法除了argc 和 argv 参数外，另外这个函数还有2个两个字符串参数来识别UIApplication类和UIApplication代理类，在这里默认是2个nil,第一个参数为nil就默认把UIApplication类作为缺省值进行初始化，可以在这里不填nil而是使用自己定义的UIApplication子类。至于第二个参数nil就设置为nil就把模板生成的HelloWorldAppdelegate类作为默认值。

8 当A类中的某个方法执行到某处时， 这时想在B类中执行某个方法，如何做，举出一个方法说明？
答 可以用委托方法来实现 在A类中初始化一个成员让他指向B类就可以调用B的方法了

11 类方法创造的对象要不要用release释放？
答：任何方法创建的对象对遵从内存管理原则 用alloc方法分配的对象就需要释放
如果用类方法创建对象时候，没有用到alloc，那么分配空间的问题，已经在方法内部做了处理，所以我们就不需要去释放了

12 下面请求数据用了什么协议，请求的数据格式是什么？
UIWebView *webView = [[UIWebView alloc] initWithFrame:self.view.frame];
[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:http://pzpromop.s3.amazonaws.com/PromoNeutral.html]]];
[self.view addSubview:webView];
答：使用了http协议请求的是html格式的数据

13 想传输一张图片，可以用什么协议传输？
答：可以用http/ftp等协议。

14 用NSURL初始化的NSData对象，用哪个类去解析？

答：这个需要根据NSData数据是什么类型 然后可以用对应的解析工具来解析。

[单选]平铺导航模式是在内容组织上没有层次关系，展示的内容都放置在一个主屏幕上，采用分屏或分页控制器进行导航，可以左右或者上下滑动屏幕查看内容。
A.对
B.错
答案：A
[单选]标签导航模式是在内容被分成几个功能模块，每个功能模块之间没有什么关系。通过标签管理各个功能模块，点击标签切换功能模块。
A.对
B.错
答案：B
[单选]模态视图是在导航过程中，有的时候需要放弃主要任务转而做其他次要任务，完成次要任务之后要再回到主要任务，这个“次要任务”就是在“模态视图”中完成的。
A.对
B.错
答案：B
[单选]在树形结构导航模型中，会有两个根视图控制器：一个是应用程序根视图控制器，它是UINavigationController的实例，通过self.window.rootViewController属性指定；另一个导航控制器根视图控制器，通过UINavigationController的构造方法initWithRootViewController:指定，用于提供和呈现导航控制器的一级视图，即我们看到的第一个界面。
A.对
B.错
答案：B
[单选]有些情况下，我们会将三种导航模式（平铺导航模式、标签导航模式、树形结构导航模式）综合到一起使用，其中还会用到模态视图。
A.对
B.错
答案：A
[单选]本地化目录en-US.lproj中en是语言代号，US是国家代号。
A.对
B.错
答案：A
[单选]genstrings命名的基本语法：genstrings[-a][-q][-o]sourcefile
A.对
B.错
答案：A
[单选]判断：从通讯录数据库查询联系人数据，可通过ABAddressBookCopyArrayOfAllPeople和ABAddressBookCopyPeopleWithName函数获得。
A.对
B.错
答案：A
[单选]UISplitViewController控制器可以呈现屏幕分栏视图的效果，MasterView占有320点的固定大小。
A.是
B.否
答案：A

[单选]floatx与“零值”比较的if语句为？
A.if(x==0)
B.if(x<0.00001f)
C.if(fabs(x)<0.00001f)
D.if(x>-0.00001f)
答案：C
1 NSStringa[]={@"abc",@"def"};
2 NSArray*a=@[@"abc",@"def"];
3 NSArray*a=[NSArrayarrayWithObjects:@"abc",@"def"];
4 NSArray*a=[NSMutableArrayarrayWithArray:@[@"abc"]];
上面的定义中，B.错误的个数为：____
A.0
B.1
C.2
D.3
答案：C
[多选]为什么说Object-C是runtimelanguage?
A.将数据类型的确定由编译时，推迟到了运行时
B.运行时机制使我们直到运行时才去决定一个A.对象的类别，以及调用该类别A.对象指定方法。
C.驾驶A继承了B类，那么在编译时就已经生成了A的实例
D.多态是指不同A.对象以自己的方式响应相同的消息的能力
答案：ABD
[多选]下列说法，正确的是?
A.category可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改
B.implement可以增加，修改或者删除方法，并且可以增加属性
C.extensions可以添加属性
D.extensions可以添加方法而不用实现
答案：ABC
[多选]在UIViewController类中与模态相关方法有哪些？
A.presentViewController:animated:completion:
B.dismissViewControllerAnimated:completion:
C.addChildViewController:
D.removeFromParentViewController
答案：AB
[多选]iOS中导航设计模式有几种？
A.平铺导航
B.标签导航
C.树形导航
D.模态视图导航
答案：ABC
[多选]NSURL的构造函数有？
A.+requestWithURL:
B.–initWithURL:
C.+URLWithString:
D.–initWithString:
答案：CD
[多选]使用genstring工具可以扫描的宏是有哪些？
A.CFCopyLocalizedString
B.CFCopyLocalizedStringFromTable
C.CFCopyLocalizedStringFromTableInBundle
D.CFCopyLocalizedStringWithDefaultValue
E.NSLocalizedString
F.NSLocalizedStringFromTable
G.NSLocalizedStringFromTableInBundle
H.NSLocalizedStringWithDefaultValue
答案：ABCDEFGH
[多选]表视图的相关类有哪些?
A.UITableView
B.UITableViewController
C.UITableViewDelegate
D.UITableViewDataSource
答案：AB
[多选]下面属于表视图内置的扩展视图常量如下？
A.UITableViewCellAccessoryNone
B.UITableViewCellAccessoryDisclosureIndicator
C.UITableViewCellAccessoryDetailDisclosureButton
D.UITableViewCellAccessoryCheckmark
答案：ABCD
[多选]NSURLRequest的构造函数有？
A.+requestWithURL:
B.–initWithURL:
C.+requestWithURL:cachePolicy:timeoutInterval:
D.–initWithURL:cachePolicy:timeoutInterval:
答案：ABCD
[多选]Objective-C有哪几种内存管理方法？
A.MRR（ManualRetainRelease）
B.MRC（ManualReferenceCounting）
C.ARC（AutomaticReferenceCounting）
D.GC（GarbageCollection）
答案：ABCD
[多选]AddressBook框架中常用类？
A.ABAddressBook
B.ABPerson
C.ABGroup
D.ABRecord
答案：ABCD
[多选]AddressBookUI框架中的视图控制器？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABNewPersonViewController
D.ABUnknownPersonViewController
答案：ABCD
[多选]创建联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABMultiValueCreateMutable
D.ABAddressBookSave
答案：ABCD
[多选]修改联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABAddressBookGetPersonWithRecordID
D.ABAddressBookAddRecord
答案：CD
[多选]删除联系人使用的函数有哪些？
A.ABPersonCreate
B.ABRecordSetValue
C.ABAddressBookGetPersonWithRecordID
D.ABAddressBookRemoveRecord
答案：CD
[多选]AddressBook高级API是在AddressBookUI框架中定义的，它为我们访问通讯录数据提供了UI界面。该框架提供了哪些视图控制器和委托协议？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABUnknownPersonViewController
D.ABNewPersonViewController
答案：ABCD
[多选]iOS中持久化方式有哪些？
A.属性列表文件
B.A.对象归档
C.SQLite数据库
D.CoreData
答案：ABCD
[多选]NSURLConnectionDelegate协议中的方法有哪些？
A.connection:didReceiveData:
B.connection:didFailWithError:
C.initWithRequest:delegate:
D.connectionDidFinishLoading:
答案：ABD
[多选]NSAssert类似的宏有哪些？
A.NSAssert1
B.NSAssert2
C.NSAssert3
D.NSAssert4
答案：ABCD
[多选]iOS单元测试框架有哪些？
A.OCUnit
B.GHUnit
C.OCMock
D.NSXML
答案：ABC
[多选]NSXMLParser构造方法有哪些？
A.initWithContentsOfURL
B.initWithData
C.initWithStream
D.initWithContentsOfFile
答案：ABC
[多选]UIPopoverController控制器的常用方法和属性？
A.presentPopoverFromBarButtonItem:permittedArrowDirections:animated:呈现Popover视图方法
B.dismissPopoverAnimated:关闭Popover视图方法
C.popoverVisible，判断Popover视图是否可见
D.popoverArrowDirection，判断Popover视图箭头的方向
答案：ABCD
[多选]模态视图专用属性有哪些？
A.UIModalPresentationFullScreen，全屏状态，是默认呈现样式，iPhone只能全屏呈现。
B.UIModalPresentationPageSheet，它的宽度是固定的768点，在iPad竖屏情况下则全屏呈现。
C.UIModalPresentationFormSheet，它的是固定的540x620点，无论是横屏还是竖屏情况下呈现尺寸都不会变化。
D.UIModalPresentationCurrentContext，它与父视图控制器有相同的呈现方式。
答案：ABCD
[多选]NSXML框架中核心的是NSXMLParser和它的委托协议NSXMLParserDelegate，NSXMLParserDelegate常用方法有哪些？
A.parserDidStartDocument
B.parser:foundCharacters
C.parser:didStartElement:namespaceURI:qualifiedName:attributes
D.parser:didEndElement:namespaceURI:qualifiedName
E.parserDidEndDocument
答案：ABCDE
[多选]UIView的以下哪些属性是Animatable的：_____
A.backgroundColor
B.opaque
C.transform
D.contentStretch
答案：ACD
[多选]应用申明一下哪些权限可以被系统授予后台运行的权限？_____
A.视频播放应用
B.音乐播放应用
C.地理位置应用
D.VolP应用
E.杂志新闻类需要更新内容的应用
答案：BCDE
[多选]AddressBook高级API是在AddressBookUI框架中定义的，它为我们访问通讯录数据提供了UI界面。该框架提供了哪些视图控制器和委托协议？
A.ABPeoplePickerNavigationController
B.ABPersonViewController
C.ABUnknownPersonViewController
D.ABNewPersonViewController
答案：ABCD

8.Objective-C 如何对内存管理的 ,说说你的看法和解决方法 ? Objective-C 的内存管理主要有三种方式 ARC( 自动内存计数 )、手
动内存计数、内存池。
1. (Garbage Collection) 自动内存计数:这种方式和 java类似，
在你的程序的执行过程中。 始终有一个高人在背后准确地帮你收拾垃 圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我 申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候， 我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是， 那个高人需要消耗一定的资源， 在携带设备里面， 资源是紧俏商品所 以iPhone 不支持这个功能。所以“Garbage Collection ”不是本入门指 南的范围，对“Garbage Collection ”内部机制感兴趣的同学可以参考 一些其他的资料，不过说老实话“ Garbage Collection ”不大适合适初 学者研究。
解决 : 通过 alloc –initial 方式创建的 , 创建后引用计数 +1, 此后 每 retain 一次引用计数 +1, 那么在程序中做相应次数的 release 就好 了.
2. (Reference Counted) 手动内存计数:就是说，从一段内存被 申请之后， 就存在一个变量用于保存这段内存被使用的次数， 我们暂
时把它称为计数器，当计数器变为 0的时候，那么就是释放这段内存 的时候。比如说，当在程序 A里面一段内存被成功申请完成之后，那 么这个计数器就从 0变成 1( 我们把这个过程叫做 alloc) ，然后程序 B也需要使用这个内存，那么计数器就从 1变成了 2( 我们把这个过程叫做 retain) 。紧接着程序 A不再需要这段内存了，那么程序 A就把这个计 数器减 1(我们把这个过程叫做 release); 程序 B也不再需要这段内存的 时候，那么也把计数器减 1(这个过程还是 release) 。当系统 (也就是 Foundation) 发现这个计数器变成了 0 ，那么就会调用内存回收程序把 这段内存回收 (我们把这个过程叫做 dealloc) 。顺便提一句，如果没有 Foundation ，那么维护计数器，释放内存等等工作需要你手工来完成。
解决 :一般是由类的静态方法创建的 , 函数名中不会出现 alloc 或 init字样, 如[NSString string] 和[NSArray arrayWithObject:], 创建后
引用计数 +0, 在函数出栈后释放 , 即相当于一个栈上的局部变量 . 当 然也可以通过 retain延长对象的生存期 .
3. (NSAutoRealeasePool) 内存池:可以通过创建和释放内存池 控制内存申请和回收的时机 .
解决:是由autorelease 加入系统内存池 , 内存池是可以嵌套的 , 每个内存池都需要有一个创建释放对 , 就像main函数中写的一样 . 使用也很简单 , 比如 [[[NSString alloc]initialWithFormat:@ ”Hey you! ”] autorelease], 即将一个 NSString 对象加入到最内层的系统内存池 , 当我们释放这个内存池时 , 其中的对象都会被释放 .

3. 关于多态性
答案:多态，子类指针可以赋值给父类。 这个题目其实可以出到一切面向对象语言中，
因此关于多态， 继承和封装基本最好都有个自我意识的理解， 也
并非一定要把书上资料上写的能背出来。 最重要的是转化成自我理解。

7. 是否在一个视图控制器中嵌入两个 tableview 控制器 ?
答案:一个视图控制只提供了一个 View 视图，理论上一个
tableViewController 也不能放吧，
只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，
如果不是我们定性思维认为的 UIViewController ， 而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图
控制者，它可以控制多个视图控制器，比如 TabbarController 那样的感觉。
8. 一个 tableView 是否可以关联两个不同的数据源 ?你会怎么处 理?
  答案:首先我们从代码来看，数据源如何关联上的，其实是在数
据源关联的代理方法里实现的。
因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我
返回根据自己的需要去设置如相关的数据源。 因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是
想干嘛呢 ?想让列表如何显示，不同的数据源分区块显示 ?

11. 什么是简便构造方法 ?
答案:简便构造方法一般由 CocoaTouch 框架提供，如NSNumber
的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法， 我们可以通过简便构 造方法，获得系统给我们创建好的对象，并且不需要手动释放。
14. 多线程是什么
多线程是个复杂的概念， 按字面意思是同步完成多项任务， 提高
了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看， 多线程被赋予不同的内涵， 对于硬件，现在市面上多数的 CPU都是多 核的，多核的 CPU运算多线程更为出色 ;从操作系统角度，是多任务， 现在用的主流操作系统都是多任务的，可以一边听歌、一边写博客 ; 对于应用来说，多线程可以让应用有更快的回应， 可以在网络下载时， 同时响应用户的触摸操作。在 iOS 应用中，对多线程最初的理解，就 是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成 烧水的同时去摘菜，最后去炒菜。

17. 什么是block
对于闭包 (block), 有很多定义，其中闭包就是能够读取其它函数
内部变量的函数， 这个定义即接近本质又较好理解。 对于刚接触 Block 的同学，会觉得有些绕，因为我们习惯写这样的程序 main(){ funA();} funA(){funB();} funB(){ ⋯..}; 就是函数 main调用函数 A，函数A调用函 数B⋯ 函数们依次顺序执行，但现实中不全是这样的，例如项目经 理M，手下有 3个程序员 A、B、C，当他给程序员 A安排实现功能 F1 时，他并不等着 A完成之后，再去安排 B去实现 F2，而是安排给 A功 能F1，B功能F2，C功能F3，然后可能去写技术文档，而当 A遇到问 题时，他会来找项目经理 M，当 B做完时，会通知 M，这就是一个异 步执行的例子。在这种情形下， Block 便可大显身手，因为在项目经理 M，给 A 安排工作时，同时会告诉 A 若果遇到困难，如何能找到他 报告问题 (例如打他手机号 )，这就是项目经理 M给A的一个回调接口， 要回掉的操作，比如接到电话，百度查询后，返回网页内容给 A ，这 就是一个 Block ，在 M交待工作时，已经定义好，并且取得了 F1的任 务号 (局部变量 )，却是在当 A遇到问题时，才调用执行，跨函数在项 目经理 M查询百度，获得结果后回调该 block 。

4、常见的出现内存循环引用的场景有哪些?
参考答案:
定时器( NSTimer ):NSTimer 经常会被作为某个类的成员变量，而 NSTimer初始化时要指定 self为target，容易造成循环引用
( self->timer->self )。 另外，若 timer 一直处于 validate 的状态，则 其引用计数将始终大于 0，因此在不再使用定时器以后，应该先调用 invalidate 方法
block 的使用:block 在copy 时都会对 block 内部用到的对象进行强引用 (ARC) 或者 retainCount 增1(非 ARC) 。在ARC 与非 ARC 环境下对 block 使用不当都会引起循环引用问题， 一般表现为，某个类将 block作为 自己的属性变量， 然后该类在 block的方法体里面又使用了该类本身， 简单说就是 self.someBlock = Type var{[self dosomething]; 或者 self.otherVar = XXX; 或者_otherVar = ⋯};出现循环的原因是: self->block->self 或者self->block->_ivar (成员变量)
代理( delegate ):在委托问题上出现循环引用问题已经是老生常谈 了，规避该问题的杀手锏也是简单到哭，一字诀:声明 delegate 时请
用assign(MRC) 或者weak(ARC) ，千万别手贱玩一下 retain或者 strong ，毕竟这基本逃不掉循环引用了!
5、 block 中的 weak self ，是任何时候都需要加的么?
参考答案: 不是什么任何时候都需要添加的，不过任何时候都添加似乎总是好 的。只要出现像 self->block->self.property/self->_ivar 这样的结构链 时，才会出现循环引用问题。好好分析一下， 就可以推断出是否会有 循环引用问题。
6、 GCD 的 queue 、main queue 中执行的代码一定是在 main thread 么?
参考答案:
对于 queue 中所执行的代码不一定在 main thread 中。如果 queue 是在 主线程中创建的， 那么所执行的代码就是在主线程中执行。 如果是在 子线程中创建的，那么就不会在 main thread 中执行。
对于 main queue 就是在主线程中的，因此一定会在主线程中执行。 获取 main queue 就可以了，不需要我们创建，获取方式通过调用方 法 dispatchgetmain_queue 来获取。 7、头文件中声明的成员变量(不是属性)，外部可直接访问么? 参考答案: 外部不能直接访问头文件所声明的成员变量，需要提供成员变量的 getter 方法才能在外部访问。 而属性已经直接给我们自动生成了 方法，因此外部可以直接访问属性。
getter

9、MD5 和Base64 的区别是什么，各自使用场景是什么?
参考答案:
做过加密相关的功能的，几乎都会使用到 MD5 和 Base64 ，它们两者 在实际开发中是最常用的。
MD5 :是一种不可逆的摘要算法， 用于生成摘要， 无法逆着破解得到 原文。常用的是生成 32位摘要，用于验证数据的有效性。比如，在网 络请求接口中， 通过将所有的参数生成摘要， 客户端和服务端采用同 样的规则生成摘要，这样可以防篡改。又如，下载文件时，通过生成 文件的摘要，用于验证文件是否损坏。
Base64 :属于加密算法，是可逆的，经过 encode 后，可以 decode 得到原文。在开发中，有的公司上传图片采用的是将图片转换成
base64 字符串，再上传。在做加密相关的功能时，通常会将数据进
行 base64 加密 /解密。
10、发送 10个网络请求，然后再接收到所有回应之后执行后续操作， 如何实现?

19、如何自动计算 cell的高度?
参考答案:
笔者喜欢纯代码自动布局， 一直使用 Masonry 这个第三方库来实现纯 代码自动布局的，使用起来非常简单，而且效率也很高。开发起来， 提高了开发效率。
关于 Masonry 自动计算行高，笔者提供了 swift 版和 oc版本的扩展，这 两个版本都提供了自动计算行高的功能， 并且带有缓存功能， 保证永 远只计算一次行高，效率就会很高，一般的应用也就不会卡屏了。 实现原理:通过数据模型的 id作为 key ，以确保唯一，如何才能保证 复用 cell 时不会出现混乱。在配置完数据后，通过更新约束，得到最 后一个控件的 frame，就只可以判断 cell实际需要的高度， 并且缓存下 来，下次再获取时，判断是否存在，若存在则直接返回。因此，只会 计算一遍。

20、UITableView 是如何计算内容高度的?为什么初始化时配置数据时，获取行高的代理方法会调用数据条数次?
参考答案:
UITableView 是继承于 UIScrollView 的，因此也有 contentSize 。要得 到tableview 的contentsize ，就需要得到所有 cell的高度，从而计算出
总高度，才能得到 contentsize 。因此，在 reloadData 时，就会调用该 代理方法数据条数次。 为了提高效率，笔者写了扩展用于自动计算行高的，并且带有缓存， 以保证只会计算一次， 防止卡屏。做到这一点， 一般的应用就可以解 决卡屏的问题了。 对于富文本比较多的应用， 还可以继续优 化哦。

1 、 objective-c 中是所有对象间的交互是如何实现的 ? (深圳皆凯科技有限公司笔试题) 通过代理去进行通讯，或者通过观察者消息模式 ,Blocks ， appdelegate
2 、如何将产品进行多语言发布，开发?
Xcode对多语言支持比较好，除了 h m 文件之外所有其它东西都可以多语言
3 、 objective-c 中是如何实现线程同步的 ? Mutexlock ， NSCondtion lock ，消息传送
4、 编写函数 _memmove说明如下: 实现 C语言库函数 memmove的功能: 将一块缓冲区中的数据移动 到另一块缓冲区中。可能有重复。
5、什么叫数据结构?(面试顺风快递 iphone 开发)
计算机 = 编程 +数据结构 6、编程中，保存数据有哪几种方式?数组、自定义类、文件操作、数据库如: 文件 plist NSUserDefaults sqlite
7、 Sizeof 与 strlen 的区别和联系? 8、什么是抽象类?抽象类有什么作用?能实例化吗?
NSOperation 没有完全实现的类叫抽象类 , C++,java
抽象类不能实例化 , 不能 NSOperation *a =[[NSOperation alloc] init];
9、 用 Objective-C 写冒泡法.
10、你对 @interface 和 @property 的理解?
@interface 申明一个类
@property 就是申明 2个函数， getter setter
retain, assign 是什么意思
11、 Iphone 开发中控制类有什么作用?
Controller, UIViewController, UINav, UITabBarController UIImagePickerController, UITableViewController
UIView 和UIViewController 的区别 container 12、线程中有哪些函数?写出来。
[NSThread detachNewXXXXX];
13、有没有写过自定义的控件?
SQLite
，编译器会自动产生 2个函数
2类， 1类比较多的就是类似
UIImageView 和UIImage UILabel
2. 用 CG CoreGraphics drawRect:
每个 UIView 都有一个 drawRect: 14、调用一个类的静态方法需不需要 release ?
静态方法就是类方法 , 不需要，类的方法
自己定义控件有
RatingView UIJewels : UIButton
{
int x, y;
int type;
UIImage *image; }
对象放在 autorelease 15、 do-while 与 while-do
16、写出几个死循环? while
中 的区别?
(1)， for (;;)，
和NSString
用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题) #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL

网络库 优点 缺点
ASIHTTPRequest 老牌、功能强大、文档丰富 停止更新、新特性少、厚重
AFNetWorking github 上比较火的项目、有稳定的两个主要负责人、能支持比较新的特性、一直
有更新 文档数目一般、有些功能貌似要自己写
MKNetworkKit 支持 ARC、号称要有 ASIHTTPRequest 的功能， AFNetWorking 的轻便 文档数目最 少、只有作者一个主要负责人
1 http 协议， get ， post 区别
get 是简单的 http 协议
post 是从客户端提交复杂的参数，包括文件
2. 如何判断一个 http 包结束
一般在 http 请求投有 content-length oc 中有 connectionDidFinishLoading 当然也可以根据接收多少了
3 http 协议如何实现断点下载的 使用 http Range 字段
可以把当前传输了多少存在文件中
是表示后面数据有多长
表示接受完成
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding;
+ (id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding{
NSString *obj;
obj = [self allocWithZone: NSDefaultMallocZone()];
obj = [obj initWIthCString: nullTerminatedCString encoding:
encoding];
return AUTORELEASE(obj);
}

13. 关于自定义 Cell 中，图片下载用到的方法 ?
如果有添加了第三方库 SDWebImage/AFNetWorkin，g可以使用 UIImageView的 类别方法 setImageWithURL:直接异步加载，如果没有的话可以使用 NSURLConnection发起 request 请求，或者使用 ASI将下载请求添加到下载队 列中，将图片下载之后，在回调方法里，回调主线程，设置图片。
14. UITableViewCell 怎样使用更流畅?
首先 cell 的复用机制节约了系统资源;其次应当注意有些复杂的大数据或网络 数据应采用异步加载的方式进行加载，以免 cell 刷出时发生卡顿。
15. 在 UIWebView上点击回复，如何使用 UITextField 进行回复? UIWebView有一个 stringByEvaluatingJavaScriptFromString 方法可以将 javascript 嵌入页面中，通过这个方法我们可以在 iOS中与 UIWebView中的网 页元素交互。通过 JAVAScript 获取点击时间，弹出 UITextField ，输入字符串 后，可以通过 post 请求发送回复。
16. 关于图文混排是如何排版的? 图文混排应当以图片为起点，首先明确图片的位置，文字可以选择位于图片的
下方，或者是环绕效果。环绕效果可以采用 2 个以上 label 或 textView 来实现; 也可以通过 AttributeString 的属性设置，或者 CoreText 重绘 UIVIew，添加 文字的方式，修改文字间的间隔，达到让出图片的效果。如果图文显示在高度
可变的视图中，如 tableView 的 Cell 中，可以计算文字占位 视图或 cell 的高度。

19. push 推送机制
iOS 在系统级别有一个推送服务程序使用 5223 端口。使用这个端口的协议源 于 Jabber 后来发展为 XMPP，被用于 Gtalk 等 IM 软件中。所以， iOS 的 推送，可以不严谨的理解为:
苹果服务器朝手机后台挂的一个 IM 服务程序发送的消息。
然后，系统根据该 IM 消息识别告诉哪个 Apps 具体发生了什么事。 然后，系统分别通知这些 Apps 。
20. iOS 播放音频的几种方法 ?
iPhone OS 主要提供以下了几种播放音频的方法: System Sound Services
AVAudioPlayer 类
Audio Queue Services
OpenAL
21.代理的作用代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，
而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
22. int retVal=UIApplication(argc,argv,nil,nil): 是什么意思
对 UIApplication 对象进行了初始化，这个方法除了 argc 和 argv 参数外，另 外这个函数还有 2 个两个字符串参数来识别 UIApplication 类和
UIApplication 代理类，在这里默认是 2 个 nil, 第一个参数为 nil 就默认把 UIApplication 类作为缺省值进行初始化，可以在这里不填 nil 而是使用自己 定义的 UIApplication 子类。至于第二个参数 nil 就设置为 nil 就把模板生成 的 HelloWorldAppdelegate 类作为默认值。
23. 保存一个变量到本地，列举两个简单的方法 1，用 NSUserDefaults 存储小量数据 2，直接 writeTofF ile存数据库、归档
24. 如果 UIView * view 已经实例化，在 view 仅添加了 n 个UIButton 类的实例， 这些 button 不是全局的，并且 button 已经用 tag 区分开，如何快速找出指定的一 个button 改变他的属性?
button=(UIButton*)[view viewWithTag:tag]

对UIApplication 对象进行了初始化，这个方法除了
这个函数还有 2个两个字符串参数来识别 UIApplication 类和 UIApplication 代理 类，在这里默认是 2个nil, 第一个参数为 nil 就默认把 UIApplication 类作为缺省 值进行初始化，可以在这里不填 nil 而是使用自己定义的 UIApplication 子类。 至于第二个参数 nil 就设置为 nil 就把模板生成的 HelloWorldAppdelegate 类作为 默认值。

36. ViewController 的loadView ，viewDidLoad ， viewDidUnload 分别是在什么 时候调用的?在自定义 ViewController 的时候这几个函数里面应该做做什么工 作?
loadView :
每次访问 UIViewController 的view( 比如controller.view 、self.view) 而且 view为nil ，loadView方法就会被调用。
自定义 UIViewController 的view 用的
viewDidLoad :
无论你是通过 xib 文件还是重写 loadView 方法创建 UIViewController 的view ，在 view 创建完毕后，最终都会调用 viewDidLoad 方法
一般我们会在这里做界面上的初始化操作，比如往 view 中添加一些子视图、从 数据库或者网络加载模型数据装配到子视图中。
viewDidUnload :
发出内存警告且 view 被释放的时候就会调用 viewDidUnload 方法，一般在此释放资源，主要是释放界面元素相关的资源，将相关的实例都赋值为nil

39. 简述一下 IOS 中线程同步机制
1:原子操作不同线程如果通过原子操作函数对同一变量进行操作，可以保证一 个线程的操作不会影响到其他线程内对此变量的操作，因为这些操作都是原子
式的。因为原子操作只能对内置类型进行操作，所以原子操作能够同步的线程 只能位于同一个进程的地址空间内。 2:锁 iOS 平台下的锁对象为 NSLock对象， 进入锁通过调用 lock 函数，解锁调用 unlock 函数(因为 iOS 中大部分的线程 同步类都继承自 NSLocking 协议，所以其加锁 / 解锁的操作基本都为
lock/unlock 函数)，同一个 NSLock对象成功调用 lock 函数后，在其显式 unlock 之前任何线程都不能再对此 NSLock 对象加锁，以达到互斥访问的目的。 3:事件 NSConditon 类型提供了 wait 与 signal 函数，分别代表了等待事件的 操作以及触发事件的操作。除了 wait 函数， NSCondition 还提供了 waitUntilDate 函数，其功能与 NSLock中的 lockBeforeDate 大致相同，简要 来说就是提供了一个带超时的 wait 函数。

45. 还有动画
在 iOS 中动画实现技术主要是: Core Animation 。
Core Animation 负责所有的滚动、旋转、缩小和放大以及所有的 iOS 动画效果。 其中 UIKit 类通常都有 animated :参数部分，它可以允许是否使用动画。
Core Animation 主要是使用
我们知道每个 UIView 都关联到一个 CALayer 对象， CALayer 是 Core Animation中的图层。
Core Animation 主要就是通过修改图层来改变 UI 的大小，位置，从而实现动 画效果。
可以说，任何一个应用程序都离不开动画!
就连苹果各个 UI 控件中的切换操作，都有它内在的动画。
了解一下，关于动画的一些知识。
任何知识点，都会迁出一系列的知识点。
[UIView beginAnimations:@"dropDownloadLabel"
context:UIGraphicsGetCurrentContext()];
[UIView setAnimationDuration: 0.5];
[UIView setAnimationBeginsFromCurrentState: NO];
// 执行的动画 code [UIView commitAnimations];
就将这段段代码作为知识的切入点，开始了解吧。
[UIView beginAnimations:@"dropDownloadLabel" context:UIGraphicsGetCurrentContext()];
[UIView commitAnimations];
这两句代码，标记了一个动画的开始和结束。在中间我们可以写我们的一些动 画操作!
beginAnimations 方法
+ (void)beginAnimations:(NSString *)animationID context:(void *)context用来，表示动画的开始。
animationID :作为动画的标识
context :自定义的一些动画数据，这些数据将发送给动画的代理方法: setAnimationWillStartSelector: 方法和 setAnimationDidStopSelector: 方法。
这个，参数，通常为 nil 。我们可以直接设置为 nil 。
这里，我们使用 UIGraphicsGetCurrentContext() ;因为此方法默认也会返回 nil 。
该方法告诉系统，我们将开始动画。并且，在该方法后，我们可以通过 setAnimationXXX (一系列方法)来设置我们进行的动画的一些参数。
完成动画后，调用 commitAnimations 方法来通知系统，动画结束。
至此，我们知道，就是设置动画的一些列参数的方法即
[UIView setAnimationDuration: 0.5];
[UIView setAnimationBeginsFromCurrentState: NO];
动画是可以嵌套的。
[UIView beginAnimations:@"animation_1" context:UIGraphicsGetCurrentContext()]; // code1
[UIView beginAnimations:@"animation_2" context:UIGraphicsGetCurrentContext()]; // code2
[UIView commitAnimations]; [UIView commitAnimations];
如果我们为动画设置了， setAnimationWillStartSelector: setAnimationDidStopSelector: 方法。
setAnimationXXX 方法。
方法和 那么当动画开始或者停止的时候，动画的 animationID 参数和 context 参数，
会传递给 setAnimationWillStartSelector: 方法和 setAnimationDidStopSelector:方法。
悲剧总是要发生的!
苹果 API 在最后的描述中，给了这么一句话:
Use of this method is discouraged in iOS 4.0 and later. You should use the block-based animation methods to specify your animations instead.
可见，在 iOS 4.0 后， block 语法，大大增多了。这种方式，是不建议的，需 要我们使用 block 的方式。
于是，动画的 block 方式:
[UIView animateWithDuration:0.3f delay:0.0f options:UIViewAnimationOptionCurveLinear
执行的动画 // 完成后执行 code
code}
animations:^{ // completion:^(BOOL finished){
}];
在尽量用 block 来完成动画，因为说不定啥时候，老的动画方式，将被废除。 到此，可以告一段落。但是，我想将这简单的动画代码，一查到底!
commitAnimations 方法: + (void)commitAnimations
标记动画结束。与 beginAnimations 方法成对使用。 例如:
[UIView commitAnimations];
一系列的 setAnimationXXX 方法: setAnimationDuration 方法:
+ (void)setAnimationDuration:(NSTimeInterval)duration
设置动画持续时间(秒)
例如:
[UIView setAnimationDuration: 0.5];
setAnimationBeginsFromCurrentState 方法
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState
设置动画开始时的状态。 我们构想一个场景:一般，我们按下一个按钮，将会执行动画一次。
当 YES时:当上一次动画正在执行中，那么当下一个动画开始时，上一次动画 的当前状态将成为下一次动画的开始状态。
当 NO时:当上一个动画正在执行中，那么当下一个动画开始时，上一次动画需 要先恢复到完成时的状态，然后在开始执行下一次动画。
setAnimationStartDate 方法
+ (void)setAnimationStartDate:(NSDate *)startTime
设置动画开始时间。 setAnimationDelay 方法
+ (void)setAnimationDelay:(NSTimeInterval)delay
设置画开始的延迟时间(秒)。
setAnimationCurve 方法
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve
设置动画的曲线方式(就是动画的总体变化的时间曲线:开始快最后慢，开始 慢最后快，最后慢，均匀线性)。
curve 参数如下:
typedef NS_ENUM(NSInteger, UIViewAnimationCurve) {
UIViewAnimationCurveEaseInOut, and end
UIViewAnimationCurveEaseIn, UIViewAnimationCurveEaseOut, UIViewAnimationCurveLinear
};
// slow at beginning
// slow at beginning // slow at end
setAnimationRepeatCount 方法
+ (void)setAnimationRepeatCount:(float)repeatCount
设置 动画重复次数
setAnimationRepeatAutoreverses 方法
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses
设置动画是否做一次反向的执行。
如果设置为 YES:动画将执行:动画初始状态》动画》动画完成状态》动画》 动画初始状态。
如果设置为 NO:默认值
setAnimationsEnabled 方法
+ (void)setAnimationsEnabled:(BOOL)enabled
设置动画是否可用!
YES:默认值。
NO:动画效果被禁用 注意:仅仅是动画是否可用，在动画中被改变的 是动画效果被禁用了。
areAnimationsEnabled 方法
+ (BOOL)areAnimationsEnabled 返回动画效果是否被禁用。
46. 还有一个按着导航栏颜色变亮的
UI 对象依然是起作用的。仅仅
_myNav.navigationBar.translucent = YES; _myNav.navigationBar.barStyle = UIBarStyleBlack;

6.pch 文件的作用
.pch 表示 "precompiled header", 这是一个你工程要用到的来自于外部框架的 头文件列表。 xcode 将编译这些头到文件，这将减少你在选择 Build 或 Build and Go 时编译项目的时间。通常用到的头文件已经自动包含了 pch，系统编译 每个 cpp 文件前，都会先 include 这个文件。这样就节省了添加 include 的时 间，相当于加速编译
还有就是可以再这里面放入宏，在整个工程中都可以用
7. 怎样解决重复编译 #ifndef _DEBUG #ifdef USE_MYLIB ................
#endif
8. awakeFromNib 与 viewDidLoad 区别 awakeFromNib
当.nib 文件被加载的时候，会发送一个 每个对象，每个对象都可以定义自己的
awakeFromNib的消息到 .nib 文件中的 awakeFromNib 函数来响应这个消息，
执行一些必要的操作。也就是说通过 awakeFromNib 。
viewDidLoad
当 view 对象被加载到内存是就会执行 是代码的方式创建对象都会执行 viewDidLoad 。
9. LayoutSubviews 何时会被调用
当要调整 subViews 时候，需要重写 layoutSubviews 方法。
1: 初始化 init 方法时候不会触发。
2: 滚动 UIScrollView 时会触发
3: 旋转 UIScreen 时会触发
4: 当改变 view 的值时候会触发，前提是 frame 前后值发生了变化 5: 当改变 UIview 的大小时候会触发
10. public/private/protected 的具体区别
public 公共，加上这个修饰的类或属性，可以在同一个包或者别的包里面访问 private 私有的，加上这个修饰的类或属性，只能在同类里访问，同包和别的 包不能访问
nib 文件创建 view 对象是执行
viewDidLoad ，所以不管通过
nib 文件还

protected 保护，加上这个修饰的类或属性，只能在类和同包访问，别的包不 能访问
11. ARC 是什么
ARC是 iOS 5 推出的新功能，全称叫 ARC(Automatic Reference Counting) 。
简单地说，就是代码中自动加入了 retain/release ，原先需要手动添加的用来 处理内存管理的引用计数的代码可以自动地由编译器完成了。
该机能在 iOS 5/ Mac OS X 10.7 开始导入，利用 Xcode4.2 可以使用该机能。 简单地理解 ARC，就是通过指定的语法，让编译器 (LLVM 3.0) 在编译代码时， 自动生成实例的引用计数管理部分代码。有一点， ARC并不是 GC，它只是一种 代码静态分析( Static Analyzer )工具。
13. Objective-c 中有多重继承么?不是的话有声明替代方式 ? 没有多继承，可以通过协议模拟多继承
14. Objective-c 中有私有方法吗?私有变量呢? 没有私有方法，但可以将方法直接实现在 .m 文件中不在 .h 文件中声明时，外部也不能访问。 有私有变量
18. 想 nil 对象发送消息会发生什么?
答:在 Objective-C 中向 nil 发送消息是完全有效的，只是在运行时不会有任 何作用。
19. 什么是 block ? block 实现原理?
答: block 是一个特殊的 OC对象 , 它建立在栈上 , 而不是堆上 , 这么做一个是
为性能考虑 , 还有就是方便访问局部变量。默认情况下 block 使用到的局部变量 都会被复制 , 而不是保留。所以它无法改变局部变量的值。如果在变量面前加上
__block, 那么编译器回去不会复制变量 , 而是去找变量的地址 , 通过地址来访 问变量 , 实际上就是直接操作变量。另外 block 是在栈上分配的 , 所以一旦离
开作用域 , 就会释放 , 因此如果你要把快用在别的地方 , 必须要复制一份。 block 是不能保留的 , retain 对块没有意义。
20. C++ 和 OC，JAVA和 OC之间的区别? C++是功能强大，丰富的面向对象编程语言，具有私有、公有、保护权限的三种 成员变量和成员方法，具有私有、公有、保护三种继承方式，具有重写，重载， 虚函数，虚基类等多态方式，通过虚基类实现代理回调。自定义类可以没有父 类。另外具备向量，模板，友元，重载运算符等多种独特语法
Obj-C 是针对 mac OS和 iOS 设备应用程序开发的专属编程语言，采用动态继承， 消息方法机制，没有真正的重写机制，没有私有方法，继承方式为公有，具备 协议，类别， Block 等独有的语法，万用父类为 NSObject JAVA是老牌的面向对象语言，编写的程序在 JAVA虚拟机上运行，真正实现了 一次编译到处运行，具有复杂的内存回收机制，单继承模式，接口语法类似
Obj-C 的协议
22. nil 与 NULL的区别?
从 Objective-C 语言的官方说法上看， nil 表示指向对象的指针即所谓对象的 引用为空， NULL表示指向基础类型变量即 C语言变量的指针为空。如果在非 ARC程序的编写过程中，两个空是可以互换的，但是在 ARC环境下，普通指针 和对象引用被严格限制，不能交换使用，因此也应尽量不互换使用 nil 与 NULL
23. BOOL 与 bool 的区别?
bool 是 C 语言 C99标准中增添的变量类型， Object-C 仅仅是从 C 语言继承了这
种类型，该类型有 true 和 false 两个值，表示真和假。 BOOL是 Obj-C 独有的布尔类型，有 YES和 NO两个值，分别是 1 和 0 的宏。 Obj-C 中同时认为所有非 0 的值都是真值， 0 为假值
26. NSString 和 NSMutableString 的区别
NSString 是一个不可变的字符串对象。这不是表示这个对象声明的变量的值不 可变，而是表示它初始化以后，你不能改变该变量所分配的内存中的值，但你 可以重新分配该变量所处的内存空间。而 NSMutableString 是可变的，意味着 你可以追加它的内存空间，或者修改它所分配的内存空间中的值。
27. . 关于语句 NSString * str= [NSData alloc]init, 编译和运行分别 str 代表什么对象 ?
首先，声明 NSString *str 是告诉编译器， str 是一个指向某个 Objective-C 对象的指针。因为不管指向的是什么类型的对象，一个指针所占的内存空间都 是固定的，所以这里声明成任何类型的对象，最终生成的可执行代码都是没有 区别的。这里限定了 NSString 只不过是告诉编译器，请把 str 当做一个 NSString 来检查，如果后面调用了非 NSString 的方法，会产生警告。 接着，你创建了一个 NSData 对象，然后把这个对象所在的内存地址保存在 str 里。那么运行时， str 指向的内存空间就是一个 NSData对象。你可以把 str 当 做一个 NSData对象来用。
28. socket 通信的几个关键步骤
面向连接的 socket 通信就像与对方打电话，首先需要通过电话建立一个连接， 连接建立好之后，彼此才能双向通信。它有几个关键步骤 服务器端通常以守护进程的方式实现 :
1: 创建守护进程
2:获取或注册服务
3:创建 socket 并绑定地址
4:开始监听
5:接收客户端连接请求
6:进行数据传输
客户端
1:获取或注册服务
2:创建 socket
3:发送连接请求
29. 类别意义?与继承的区别 当我们添加头文件以后，对已知的类，会自动提示你对这个类添加的方法 主要用途，对于原生不会造成破坏，使用原生就可以提示出你的方法
30. Core Foundation 中提供了哪几种操作 Socket 的方法? CFNetwork、CFSocket和 BSD Socket
31. 用 id 声明的对象有什么特性? ?没有* 号
? 动态数据类型
? 可以指向任何类的对象 ( 设置是 nil) ，而不关心其具体类型
? 在运行时检查其具体类型
? 可以对其发送任何(存在的)消息

34. 下面的数据结构中不属于线性结构的是:栈，链表，二叉树，线性表
  线性结构:栈，链表，线性表
  非线性结构:二叉树
35， oc中有没有多继承，如果没有用什么方法替代? 没有 用协议代替多继承
36. 常见的O bjective-C 的数据类型有哪些，和C的基本数据类型有什么区别 OC中常用数据类型有
NSArray,NSDictionary,NSData,NSString,NSMutbleString 等等，和C的最大区 别为 OC中的类型是类类型，需要实例化对象才能用。 C中是一般数据类型直接操 作内存空间
38.C 语言中指针与数组的区别 答:指针是变量可以修改指向的方向，数组名是地址常量，不能被修改 39.new delete malloc free 的含义
c++:new 申请内存， delete 释放掉指针指向的内存 c:malloc 动态申请内存， free 释放指针指向的内存
40. 常引用什么时候使用 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函
数中被改变，就要使用常引用 41.c/oc/c++ 有什么区别和联系
C相对于 C++和 OC而言更偏重于逻辑算法，这是因为 C是面向过程， C++ 和 OC都是面向对象。 C和 C++的联系: C是 C++的一个自洽子集， C++是 C的超
集， OC是 C的扩展， C++和 OC基本兼容 C的语法。 42.const 的用法
const 修饰变量表示该变量是只读变量(有些人管它叫常量)，即只能 引用而不能修改
const int *p; int *const p;
P 指向的数据不能改
P 的值不能该，或者说是指针 P 的指向不能
43.[pool release] drain
有什么区别
 表示指针变量
 表示指针变量
和[pool drain]
和 release 都会促使自动释放池对象向池内的每一个对
象发送 release 消息来释放池内对象的引用计数，但是 release 触发的这个操作， 不会考虑对象是否需要 release ，而 drain 会在自动释放池向池内对象发送
release 消息的时候，考虑对象是否需要 release
45.当A类 中的某个方法执行到某处时，这时想在 B类中执行某个方法，如何做? 并做简单说明
用代理执行代理方法
说明:在 b类中实现协议方法，设置 a的代理为 b，在指定方法内 调用代理 的协议方法
46. 类别的作用 ?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的
方法，只能添加，不能删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，
因为类别具有更高的优先级。
类别主要有 3个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。 (2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。

2，在最坏情况下排序速度最快的是:归并排序 复杂度最高的是:快排，冒泡，堆，归并

8、类别( category )的作用?继承和类别在实现中有何区 别?
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能 删除修改。 并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类
别具有更高的优先级。 类别主要有 3 个作用: (1) 将类的实现分散到多个不同文件或多个不同 框架中。 (2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。 继承可以增加，修改 或者删除方法，并且可以增加属性。
9 、类别 (category) 和类扩展 (extension) 的区别
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须要实现
的。 extensions 可以认为是一个私有的 Category。
10、Object -c 的类可以多重继承么?可以实现多个接口 么?重写一个类的方式用继承好
答案: Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现， cocoa 中所有的类都是 NSObject 的子类，多继承在这里是用 protocol 委托代理 来实现的。

12、delegate 和 notification 区别 答案: Delegate:
消息的发送者 (sender)告知接收者 (receiver) 某个事件将要发生， delegate 同意然然后发送者响应事 件， delegate 机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对 多的关系。
Notification:
消息的发送者告知接收者事件已经发生或者将要发送， 仅此而已， 接收者并不能反过来影响发送 者的行为。通常发送者和接收者的关系是间接的多对多关系。
13 、UITableView 的简单描述及功能介绍，如何实现一个 简单的列表?
答案: UITableView 继承自 UIScrollView ，可以表现为 Plain 和 Grouped 两种风格 UITableView 有两个 Delegate 分别为: dataSource 和 delegate
dataSource 是 UITableViewDataSource 类型，主要为 UITableView 提供显示用的数据 (UITableViewCell) ，指定 UITableViewCell 支持的编辑操作类型 (insert ， delete 和 reordering) ，并 根据用户的操作进行相应的数据更新操作， 如果数据没有更具操作进行正确的更新， 可能会导致 显示异常，甚至 crush 。
delegate 是 UITableViewDelegate 类型，主要提供一些可选的方法， 用来控制 tableView 的选 择、指定 section 的头和尾的显示以及协助完成 cell 的删除和排序等功能。

17 、 自动释放池是什么 ,如何工作
答案: 当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最 新的自动释放池。 它仍然是个正当的对象， 因此自动释放池定义的作用域内的其它对象可以向它 发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象也就被 释放。
1. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到有 copy,retain 的时候引用计数都会加一 , 每当碰到
release 和 autorelease 的时候引用计数就会减一 ,如果此对象的计数变为了 0, 就会被系统销毁 . 2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease 和 release 没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的使 用真正结束的时候才做引用计数减一 .

19 、什么是 TCP 连接的三次握手
答案:第一次握手:客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器 确认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN ( ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包 发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理 想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接都将被 一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需 要经过 ―四次握手 ‖(过程就不细写了，就是服务器和客户端交互，最终确定断开)
20 、 TCP/UDP 区别联系
答案: TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换
数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢弃 重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是 把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输 数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快
TCP(Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在正式收 发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能建立起来，我 们来看看这三次对话的简单过程: 1. 主机 A 向主机 B发出连接请求数据包; 2.主机 B 向主机 A 发送 同意连接和要求同步(同步就是两台主机一个在发送，一个在接收，协调工作)的数据包; 3. 主机 A再发出一个数据包确认主机 B的要求同步: ―我现在就发，你接着吧! ‖，这是第三次对话。 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次 ―对话 ‖之后，主机 A 才向主机 B 正式 发送数据。
UDP ( User Data Protocol ，用户数据报协议)是与 它不与对方建立连接，而是直接就把数据包发送过去!
靠性要求不高的应用环境。
tcp协议和 udp协议的差别 是否连接面向连接面向非连接
传输可靠性可靠不可靠
应用场合传输大量数据少量数据
速度慢快
21 、 socket 连接和 http 答案:简单说，你浏览的网页(网址以
基于 socket 之上的。 socket 是一套完成
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP 连接的
tcp 协议: 对应于传输层
TCP 相对应的协议。它是面向非连接的协议， UDP 适用于一次只传送少量数据、对可
连接的区别
http:// 开头 )都是 http 协议传输到你的浏览器的
, 而 http 是
tcp，udp 协议的接口。
ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解决如 何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，通过 Socket ， 我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连 接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主 动断掉;但是由于各种环境因素可能会是连接断开，比如说:服务器端或客户端主机 down 了，
网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。 所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心跳消息 ~~具体心跳消 息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ， 而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read –> 关闭
close 模‖式来操作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一种特殊的文件， 一些 socket 函数就是对其进行的操作(读 / 写 IO 、打开、关闭) ，这些函数我们在后面进行介绍。
我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样的话，如果没有应用层，便 无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用到应用层协议， 应用层协议有很 多，比如 HTTP 、FTP、TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用 层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。

(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信的能 力。)
2)Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通过
Socket，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数接口。
22、利用 Socket 建立网络连接的步骤
答案:建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为
一个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
TCP/IP 协议栈
ClientSocket ，另
1。服务器监听:服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实 时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此， 客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口 号，然后就向服务器端套接字提出连接请求。
3。 连接确认: 当服务器端套接字监听到或者说接收到客户端套接字的连接请求时， 端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认
了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其他客户端套 接字的连接请求。
23、简单描述下 同步请求、异步请求、 GET 请求、 POST 请求
答案:
1、同步请求可以从因特网请求数据，一旦发送同步请求，程序将停止用户交互，直至服务器返 回数据完成，才可以进行下一步操作，
2、异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以 对UI 进行操作，程序可以继续运行
3、 GET 请求，将参数直接写在访问路径上。操作简单，不过容易被外界看到，安全性不高，地 址最多 255字节;
4、POST请求，将参数放到 body里面。 POST请求操作相对复杂，需要将参数和地址分开，不过 安全性高，参数放在 body 里面，不易被捕获。
就响应客户

// json和xml

3 info.plist 和 Prefix.pch 的用处 info.plist
项目的配置属性
Prefix.pch
1.存放一些全局的宏 (整个项目中都用得上的宏 )

2. 用来包含一些全部的头文件 (整个项目中都用得上的头文件 ) 3.能自动打开或者关闭日志输出功能
4iOS中是否有多继承?怎么实现多态? 没有
分类和协议
5 多线程有哪些?主线程和次线程有什么区别?怎么通信? NSThread GCD NSOperation 主线程不需要创建就存在，子线程需要创建，初始时候不存在 更新 UI必须在主线程 而进行延时操作一般都在子线程
-(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait
dispatch_async(dispatch_get_main_queue(), <#^(void)block#>) 6 数据存储的方式

1 plist
2 归档
3 SOLite
4CoreData
7jason 解析遇到大量数据解析过程时，在内存上的优化办法
利用 json 的反序列话的几个代理方法， 实现大数据的分割， 解析， 拼接，保存，从而降低内存的消耗。
优化后台接口，使后台返回的数据大小更合理
在APP 中，一般不会出现大数据，因此注意接口的优化，尽量不 要使用数据分割的方式，因为可能引起数据解析错误

29. 请解释以下两种设计模式:工厂模式，单例模式
31.在.m文件Class Extension中声明的私有方法，其他类能否调用若强行调用会发生什么?
32.在调?用?支付宝接 ?口?支付p时ar，tner，seller，private分别是什么意思 ? 20 33.谈谈如何在 MVC模式中减轻 ViewController 的重量(减少代码) 20
34.为什么很多内置的类，如 TableViewController 的delegate的属性是assign不v是retain? 20
35.列举几个你曾经用过的第三方库?
37. Objective-C 的动态性体现在哪些方面?
40. 多线程中堆与栈分别是共有的还是私有的?(记住)
41.Objective-C 声明 ?一个类所有要 ?用到的编译指令是? 22 42.?用预编译指令#de?ne 声明?一个常数， ?用以表1?年示中有多少秒(忽略闰年问题) 22 43.解析XML?文件有哪 ?几种?方式? 22 44.下?面哪个 ?方法不属于NSObject 的内省( Introspection )?方法 22 45.iOS 开发中，开发证书根据 ?用途划分可以分为哪两 ?大类，分别作 ?用是什么?22?用途 46. 关键字 const 有什么含义? static 的作 ?用?还有extem C 的作 ?用? 23
47. 让 ?一个物体从界 ?面中的 ?一点运动到另外 ?一点，有哪些 ?方法?
48. 什么是多继承?
49.ViewController 的loadView,viewDidLoad,didReceiverMemoryWarning 分别是什么时候 调?用的,在初始化 ViewController 时在这 ?几个函数中应该做什么 ?工作?
53. 介绍下 KVC 和 KVO
55. 谈谈对 Block 的理解 ?
61. 描述 ?一下runtime 的概念 ,message send 理?
62.什么是 method swizzling? (了解)
63.Cocoa Touch 包含什么 ? 不包含什么 ?
64. 响应链 (Responder chain) 是什么 ? 它是如何发挥作 ?用的?
65. 如何获取项 ??目根路,径并在其下创建 ?一个名称为userData 66.iPhone5,6,6+ 以及iPad Air 2 的屏幕分辨率分别是多少 ? 67. 分辨率的计算单位是什么 ?
69. 请解释 ?一下Interface Bulder 的作 ?用以及NIB文件的概念？
70.选项卡 (Tab Bar)和?工具栏(Toolbar) 分别是什么？两者之间
71. 数据库中索引的作 ?用?和它的优缺点是什么
72.UIImageView 如何响应点击事件 ?
74.多线程中 ,访问同 ?一变量,如何加锁 ?
75. 写 ?一个委托的 interface
76.UITableview 的执 ?行流程是怎么样的?
77. 简述 XMPP 中有哪些节点，各个节点分别有什么作
78.使?用AVPlayer播放视频时，视频监听的 AVPlayerItem 状态有几种，分别是什么及作用?
11.链表与数组的区别
答:链表和数组都可 ?用来存放指定的数据类型。 链表的特性是在中间任意位置添加删除元素的都 ?非常的快，不需要移动其它的 元素。通常链表每 ?一个元素都要保存 ?一个指向下 ?一个元素的指针(单链表)。 双链表的话每个元素即要保存到下 ?一个元素的指针，还要保存 ?一个上 ?一个元素
的指针。循环链表则把最后 ?一个元素中保存下 ?一个元素指针指向第 ?一个元素。 数组是 ?一组具有相同类型和名称的变量的集合。这些变量称为数组的元素 ,每个
数组元素都有 ?一个编号,这个编号叫做下标 ,我们可以通过下标来区别这些元 素。数组元素的个数有时也称之为数组的 ?长度。
第?二部分Objective-C 与UI?面试试题选集
1.类别和类扩展的区别 ?
类别 (Category) 和类扩展 (Extensions) 都可 ?用来为类扩充功能。
类别:可以为有源代码的类和 ?无源代码的类扩充功能， ?而且只能添加 ?方法， ?方 法必须实现。 ?子类可继承，可直接访问。 类扩展:只能为有源代码的类扩充功能。不光可以扩充实例变量，也可以扩充 ?方法，但是 ?方法和实例变量都是私有的。 ?子类可继承，但是不可直接访问。
2.Objective-C 的类可以多重继承吗 ? 可以实现多个接 ?口?吗category 是什么?
Objective-c 的类不可以多重继承，只允许单根继承。
可以实现多个接 ?口，通过实现多个接 ?口可以完成多重继承;
Category 是类别，可以为有源代码的类和 ?无源代码的类扩充功能， ?而且只能添
加?方法，?方法必须实现。 ?子类可继承，可直接访问。

2在该类定义了代理属性，但是代理属性的语义特性为 retain 。 在代理对象类
中也定义了属性来存储该类的对象，语义特性也是 retain ，就会造成互相保 有，循环引 ?用。
3在 A中定义了 B类对象的属性，语义特性为 retain 。 并在 B类中定义了 A类对 象的属性，语义特性为 retain 。 当属性都存储对应的对象时，就产生的循环引用。

12.请简述 self.name = nil 的机制 ,以及与 [_name release] 的区别 ?
self.name = nil; 是调 ?用属性 ?生成s的etter ?方法，会先将原有对象释放 release ，
然后将实例变量的值置为 nil，以后在访问该实例变量不会出现任何内存问题。 ?而[_name release]; 只是简单的将对象的引 ?用计数减1,?而指针变量中依然存储
该对象的地址，如果此时该对象空间被系统回收了，再访问实例变量，就会产 ?生野指针异常。

16.Objective-C 中的数字对象有哪些 ,简述他们与基本数据类型的区别?
OC中的数字对象 NSNumber ，NSValue 。
NSNumber 是OC中的对象类型，能够实现将基本数据类型 int，?oat转成OC的 对象。
NSValue 是OC 中的对象类型，能够实现将结构体类型 CGPoint,NSRange 转成 OC 的对象。
17.Swift 和Object-C 分别是什么 ?两者 ?比有什么不同之处,?又有何联 系?
答:参考链接: http://www.imooc.com/wenda/detail/4752

19.iOS UI 的图像存储类型是什么 ? 答: UIImage

22. 同步调用和异步调用分别是什?么
同步:我们把异步环境下的一组并发进程因直接制约 ?而互相发送消息、进 ?行互 相合作、互相等待，使得各进程按 ?一定的顺序执 ?行的过程称为进程间的同步， 往往这种情况，任务与任务之间存在依赖关系，后 ?一个任务的执 ?行依赖于前 ?一 个任务的结束。
异步:任务与任务之间不存在任何依赖关系，任务并发执 ?行，最后执 ?行的任务 可能第 ?一个执 ?行结束。

23.NSString 和NSMutableString 有什么区别 ?
NSString 是?一个不可变的字符串对象。这不是表 ?示这个对象声明的变量的值不 可变， ?而是表 ?示它初始化以后，你不能改变该变量所分配的内存中的值，但你 可以重新分配该变量所处的内存空间。
?而NSMutableString 是可变的，意味着你可以追加它的内存空间，或者修改它 所分配的内存空间中的值。

29. 请解释以下两种设计模式:工厂模式，单例模式？
?工?厂模式: ?工?厂模式根据抽象程度的不同分为三种:
1?工?厂?方法: ?用来快速加 ?工对象?比。如:便利构造器。
2抽象 ?工?厂:抽象出 ?一个公共的 ?父类，提 ?高?子类公共的功能。 ?子类继承即可， 但是不会使 ?用该?父类去创建对象使 ?用。?比:?手如势,UIControl 3对象?工?厂:?用来根据需求 ?生成不同类型的对象?。比如:cell?工?厂。
?工?厂模式对调 ?用者屏蔽具体的产品类。如果使 ?用?工?厂模式，调 ?用者只关 ?心产品 的接 ?口就可以了， ?至于具体的实现，调 ?用者根本 ?无需关 ?心。即使变更了具体的 实现，对调 ?用者来说没有任何影响。

31.在.m文件Class Extension 中声明的私有 ?方法，其他类能否调
?用?若强 ?行调 ?用会发 ?生什么? 答:
延展中声明的是私有 ?方法，在其他类中 ?无法直接调 ?用。 内存环境区别:
MRC :在其他类中可直接调 ?用，只不过会提 ?示警告。 ARC :在其他类中 ?无法直接调 ?用，编译器报错。

60.实例化 ?一个UITableView 对象 ,要求写出关键语句 ? 答:
UITableView *tableView = [[UITableView alloc]initWithFrame:<(CGRect)frame> style:<(UITableViewStyle)style>];
tableView.dataSource = self;
tableView.delegate = self;
[superview addSubview:tableView];
?首先需要分配空间设置 表视图的样式
象,会如何进 ?行后续处理? 答:
运?行时刻是指 ?一个程序在运 ?行(或者在被执 ?行)的状态。也就是说，当你打开 ?一个程序使它在电脑上运 ?行的时候，那个程序就是处于运 ?行时刻。在 ?一些编程
语?言中，把某些可以重 ?用的程序或者实例打包或者重建成为“运?行库”。这些实 例可以在它们运 ?行的时候被连接或者被任何程序调 ?用。
如果 message send 如果寻找不到相应的对象
1该对象为空，则该消息失效。
2该对象不为空， ?而该类中没有该 ?方法，则程序异常，找不到对应的 ?方法执 ?行 3该对象不为空， ?而该类中有该 ?方法，调 ?用?方法。
62.什么是 method swizzling? (了解) 答:
Method swizzling 指的是改变 ?一个已存在的选择器对应的实现的过程，它依赖 于Objectvie-C 中?方法的调 ?用能够在运 ?行时进改—变— 通过改变类的调度表
(dispatch table )中选择器到最终函数间的映射关系。 63.Cocoa Touch 包含什么 ? 不包含什么 ?
参考链接: http://blog.csdn.net/iukey/article/details/7666430
64.响应链 (Responder chain) 是什么 ?它是如何发挥作 ?用?的 答:
dataSource 提供数据源， delegate 处理交 61.描述 ?一下runtime 的概念 ,message send 如果寻找不到相应的对
然后需要设置两个必须的委托对象，互和界面设置。
// 创建文件系统管理器
NSFileManager *manager = [NSFileManager defaultManager]; NSString *?lePath = [sandboxPath stringByAppendingPathComponent:@ “ userData"];
if (![manager ?leExistsAtPath:?lePath]) {
BOOL isSuccess = [manager createDirectoryAtPath:?lePath
withIntermediateDirectories:YES attributes:nil error:nil] ; NSLog(@"%@", isSuccess ? @" 创建成功 " : @"创建失败 ");
}

70.选项卡 (Tab Bar) 和?工具栏(Toolbar) 分别是什么 ?两者之间 有何共 同点和不同点
答:
Toolbar:提供 ?一种机制来显 ?示?一个 ?工具栏，在屏幕的底部和 ?支持显 ?示和选择的 ?工具栏项?U?目IBarButtonItem 的实例)。
Tab Bar: 提供 ?一种机制来显 ?示?一个选项, 位卡于屏幕底部的 ?工具栏和 ?支持显 ?示 和选择的选项卡栏项 (UIBarButtonItem 的实例)。
71. 数据库中索引的作 ??用和它的优缺点是什么 ? 答:
参考链接 http://blog.chinaunix.net/uid-20556037-id-2810995.html 72.UIImageView 如何响应点击事件 ?
答:
userInteractionEnabled 交互属性 ?至为YES ，再给 UIImageView 加
UITapGestureRecognizer 点击 ?手势。 73.如何实现 UIScrollView ?无限滚动?
默认的UIScrollView 滑动到底之后(假设往右)，就 ?无法继续往右滑了，但为 了更好的 ?用户体验，我们继续往右滑是 ?自动回到第 ?一?页。这 ?里提供 ?一个 ?方案。 假设有 5?页，其中分别放着1.jpg 2.jpg 3.jpg 4.jpg 5.jpg 五张图，为 ?支持 ?无限滚 动，我们把最后 ?一张图复制 ?一份追加到第 ?一张左边，把第 ?一张图复制 ?一份追加 到最后?一张图右边，即新的UIScrollView 有7?页，分别是
[1 号: 5.jpg][2 号: 1.jpg][3 号: 2.jpg][4 号: 3.jpg][5 号: 4.jpg][6 号: 5.jpg][7
号: 1.jpg]
然后把初始的位置移动到 2号。接下来，如果 ?用户滑动到7号位置，则 ?立刻把位
置更换到 2号，此时 ?用户并没有发现位置发 ?生了改变，从 ?而实现了 ?无限往右
滚。同理，如果 ?用户滑动到1号位置，则 ?立刻把位置更换到6号，实现 ?无限往左 滚。?至此，实现了 ?无限滚动。
74.多线程中 ,访问同 ?一变量,如何加锁 ? 答: ?方法 ?一，
@synchronized(id anObject),( 最简单的 ?方法) @synchronized(self) {
// 这段代码对其他 @synchronized(self) 都是互斥的 // self 指向同 ?一个对象
}
方法二 - NSLock
NSLock 对象实现了 NSLocking protocol ，包含 ?几个 ?方法: 25
lock ，加锁
unlock ，解锁
tryLock ，尝试加锁，如果失败了，并不会阻塞线程，只是 ?立即返N回O
lockBeforeDate: ，在指定的 date之前暂时阻塞线程(如果没有获取锁的话)， 如果到期还没有获取锁，则线程被唤醒，函数 ?立即返回NO
?方法三，NSRecursiveLock ，递归锁
NSRecursiveLock ，多次调 ?用不会阻塞已获取该锁的线程。
?方法四，NSConditionLock ，条件锁
NSConditionLock ，条件锁，可以设置条件
?方法五，NSDistributedLock ，分布锁
NSDistributedLock ，分布锁， ?文件?方式实现，可以跨进程
?用tryLock ?方法获取锁。
?用unlock ?方法释放锁。
如果 ?一个获取锁的进程在释放锁之前挂了，那么锁就
可以通过 breakLock 强?行获取锁。 75. 写 ?一个委托的 interface
@protocol MarryDelegate<NSObject> @required
- (void)earnMoney;
- (void)makeFood:(NSString *)foodName;
@end

77.简述 XMPP 中有哪些节点，各个节点分别有什么作 ?用? 答:
常?用的节点有IQ, Message, Presence;
IQ: Info/Query( 信息与查询 ), 它为 XMPP 通信提供请求与响应机制。
Message: 消息节点 , ?一种基本推送消息 ?方法，它不要求响应。 Presence: ?用来表明 ?用户的状态，如:online 、 away 、 dnd( 请勿打扰 )等。

78.使?用AVPlayer 播放视频时，视频监听的 AVPlayerItem 状态有 ?几
种，分别是什么及作 ?用? 答:
AVPlayerStatusUnknown, 代表视频未知的 AVPlayerStatusReadyToPlay: 代表视频已经可以播放了 AVPlayerStatusFailed, 代表视频播放错误的
79.简述使 ?用CLLocationManager 定位时，如何停 答: stopUpdatingLocation
?止定位?
?用(场很景全 ?面哦)
80.iOS 中有 ?几种消息机制，区别以及各种机制的使 答:参考链接: http://www.cocoachina.com/industry/20131216/7543.html
81.UI 布局的 ?几种 ?方式，各种 ?方式的利弊谈谈您的看法 答:
a.纯代码 , 通过代码 ?手动更改, ?比较 ?麻烦, 但是代码相对集中
b.可视化编程 , 通过 IB?工具, 使?用autolayout+sizeclasses 技术做布局 , 适配多种 屏幕 , 但是控件过多是约束会 ?比较多, 难以维护 .
82. 你用过NSOperationQueue吗?请描述它和 GCD 的区别和类似的地方
使?用NSOperationQueue ?用来管理 ?子类化的NSOperation 对象，控制其线程并
发数??目。GCD和NSOperation 都可以实现对线程的管理，区别是 NSOperation 和NSOperationQueue 是多线程的 ?面向对象抽象。项 ??目中使N?S用Operation 的 优点是 NSOperation 是对线程的 ?高度抽象，在项 ??目中使 ?用它，会使项 ??目的程序
结构更好， ?子类化NSOperation 的设计思路，是具有 ?面向对象的优点(复 ?用、 封装)，使得实现是多线程 ?支持， ?而接 ?口简单，建议在复杂项 ??目中使 ?用。 项??目中使 ?G用CD 的优点是 GCD 本?身?非常简单、易 ?用，对于不复杂的多线程操
作，会节省代码量， ?而Block参数的使?用，会是代码更为易读，建议在简单项 ??目中使 ?用。
83.HTTP 和Socket 的区别 ? 答:
Socket 连接和 HTTP 连接的区别
HTTP协议:超 ?文本传输协议，是基于请求和响应模式的应 ?用层协。议
Socket :不是协议，是套接字，由 IP和端 ?口两部分标识，是封装在传输层之上 的。
HTTP 连接: http 连接就是所谓的短连接，即客户端向服务器端发送 ?一次请求， 服务器端响应后连接即会断掉;
Socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端 ?一旦建 ?立起连接将不会主动断掉;但是由于各种环境因素可能会是连接断开， ?比如说: 服务器端或客户端主机 down 了， 网络故障，或者两者之间长时间没有数据传输,网络防火墙可能会断开该连接以释放 ??网络资源。

84.Core Foundation 中提供了哪 ?几种操作Socket 的 ?方法? 答: CFNetwork 、 CFSocket 和 BSD Socket 。
85.请描述 Xcode 打包签名机制中 Certi?cates & Identi?ers & Provisioning Pro?les 三者的关系?
Certi?cates :证书，分为开发证书和发布证书，是 ?一个开发者账号 ?身份的标 识，也是是否账号是否可 ?用的标识。
Identi?ers: 应 ?用程序唯 ?一标识识。如果是发布的项
起到唯 ?一标识的作 ?用。 ?而测试的标识可以是通配的。
Provisioning Pro?les :描述 ?文件是对证书和项 ??目标识的描述 ?文档。

90.Appcrash后有哪些调试方法？
1、断点单步调试/2、全局断点确定崩溃位置/3、僵尸调试查看崩溃日志原因/4、暴力调试
2. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在开始分配 内存 (alloc) 的时候引用计数为一 ,
以后每当碰到有 copy,retain 的时候引用计数都会加一 , 每当碰到 release和 autorelease 的时候引用计数就会减一 ,如果此
对象的计数变为了 0, 就会被系统销毁 .
2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease 和 release 没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象 的使用真正结束的时候才做引用计数减一 .
19.objc 优点: 1) Cateogies
2) Posing
3) 动态识别
4) 指标计算
5)弹性讯息传递
6) 不是一个过度复杂的

23.http 和 scoket 通信的区别。
http 是客户端用 http 协议进行请求， 发送请求时候需要封装 http 请求头，并绑定请求的数据，
服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发起请求， 服务器才能给响应， 一次请求完毕后则断开连接， 以节省资源。 服务器不能主动给客户端响 应(除非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket“套接字”进行连接，并没有规定连接后断开，所 以客户端和服务器可以保持连接通道， 双方都可以主动发送数据。 一般在游戏开发或股票开 发这种要求即时性很强并且保持发送数据量比较大的场合使用。 主要使用类是 CFSocketRef 。
TCP 全称是 Transmission Control Protocol，中文名为传输控制协议，它可以提供可靠的、面 向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能:
* 确保 IP 数据报的成功传递。
* 对程序发送的大块数据进行分段和重组。
* 确保正确排序及按顺序传递分段的数据。
* 通过计算校验和，进行传输数据的完整性检查。
6、TCP 和 UDP 的区别
TCP 提供的是面向连接的、可靠的数据流传输，而 靠的数据流传输。
UDP 提供的是非面向连接的、不可 简单的说， TCP 注重数据安全，而 UDP 数据传输快点，但安全性一般

57. 以下每行代码执行后， person 对象的 retain count 分别是多少? Person*person = [[Person alloc] init]; count 1
[person retain]; retain count 2
[person release];retain count 1
[person release];retain count = 0

9、为什什么代理理要⽤用weak?代理理的delegate和dataSource有什什么区别?block和代理理 的区别?
10、id和NSObject*的区别
14、UIView和 CALayer是什什么关系?
17、KVO基本原理理?
18、Swift 下的如何使⽤用 KVC?
19、:Swift有哪些模式匹配?
 42、内存管理的几条原则是什么?按照默认法则.那些关键字⽣生成的对象 需要⼿手动释放?在和property结合的时候怎样有效的避免内存泄露露?谁申请，谁释放

48、1.什什么⽅方式可以看到上架App的头⽂文件? 2.阅读过哪些框架的源码?能说说它的架构⽅方式吗 49、iOS iAP内购审核可能失败的问题 50、IAP内购中虚拟货币导致审核⽆无法通过的问题?

a. 从weak表中获取废弃对象的地址为键值的记录
b. 将包含在记录中的所有附有 weak修饰符变量量的地址，赋值为 nil c. 将weak表中该记录删除
d. 从引⽤用计数表中删除废弃对象的地址为键值的记录
3、题⽬目:Swift mutating关键字的使⽤用? 答案:在Swift中，包含三种类型(type): structure,enumeration,class
其中structure和enumeration是值类型(value type),class是引⽤用类型(reference type)
但是与Objective-C不不同的是，structure和enumeration也可以拥有⽅方法(method)， 其中⽅方法可以为实例例⽅方法(instance method)，也可以为类⽅方法(type method)，实例例 ⽅方法是和类型的⼀一个实例例绑定的。
在swift官⽅方教程中有这样⼀一句句话:
“Structures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods.”
⼤大致意思就是说，虽然结构体和枚举可以定义⾃自⼰己的⽅方法，但是默认情况下，实例例⽅方 法中是不不可以修改值类型的属性。

4、UIView和 CALayer是什什么关系?
UIView 显示在屏幕上归功于 CALayer，通过调⽤用 drawRect ⽅方法来渲染⾃自身的内容， 调节 CALayer 属性可以调整 UIView 的外观，UIView 继承⾃自 UIResponder，⽐比起 CALayer 可以响应⽤用户事件，Xcode6 之后可以⽅方便便的通过视图调试功能查看图层之 间的关系。
UIView 是 iOS 系统中界⾯面元素的基础，所有的界⾯面元素都继承⾃自它。它内部是由 Core Animation 来实现的，它真正的绘图部分，是由⼀一个叫 CALayer(Core Animation Layer)的类来管理理。UIView 本身，更更像是⼀一个 CALayer 的管理理器器，访问它的跟绘图 和坐标有关的属性，如 frame，bounds 等，实际上内部都是访问它所在 CALayer 的 相关属性。
UIView 有个 layer 属性，可以返回它的主 CALayer 实例例，UIView 有⼀一个layerClass
var a a.operatorTion()方法，返回主 layer所使⽤用的类，UIView 的⼦子类，可以通过重载这个⽅方法，来让 UIView 使⽤用不不同的 CALayer 来显示，如:
- (class) layerClass {
// 使某个 UIView的⼦子类使⽤用 GL来进⾏行行绘制
return ([CAEAGLLayer class]); }
UIView 的 CALayer 类似 UIView 的⼦子 View 树形结构，也可以向它的 layer 上添加⼦子 layer，来完成某些特殊的显示。例例如下⾯面的代码会在⽬目标 View 上敷上⼀一层⿊黑⾊色的透 明薄膜。
grayCover = [[CALayer alloc]init]; grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor; [self.layer addSubLayer:grayCover];
补充部分:这部分有深度了了，⼤大致了了解⼀一下吧，UIView 的 layer 树形在系统内部被系 统维护着三份 copy
1.逻辑树，就是代码⾥里里可以操纵的，例例如更更改 layer 的属性等等就在这⼀一份 2.动画树，这是⼀一个中间层，系统正是在这⼀一层上更更改属性，进⾏行行各种渲染操作。 3.显示树，这棵树的内容是当前正被显示在屏幕上的内容。这三棵树的逻辑结构都是 ⼀一样的，区别只有各⾃自的属性

8、、Category(类别)、 Extension(扩展)和继承的区别
区别:
1. 分类有名字，类扩展没有分类名字，是⼀一种特殊的分类。
2. 分类只能扩展⽅方法(属性仅仅是声明，并没真正实现)，类扩展可以扩展属性、成 员变量量和⽅方法。
3. 继承可以增加，修改或者删除⽅方法，并且可以增加属性。
9、为什什么代理理要⽤用weak?代理理的delegate和dataSource有什什么区别?block和代理理 的区别?
通过weak打破循环引⽤用。 delegate是⼀一个类委托另⼀一个类实现某个⽅方法，协议⾥里里⾯面的⽅方法主要是与操作相关 的。 datasource⼀一个类通过datasource将数据发送给需要接受委托的类，协议⾥里里⾯面的⽅方法 主要是跟内容有关的。 代理理和block的区别:代理理和block的共同特性是回调机制。不不同的是代理理的⽅方法⽐比较 多，block代码⽐比较集中;代理理的运⾏行行成本要低于block的运⾏行行成本，block的出站需要 从栈内存拷⻉贝到堆内存。公共接⼝口⽐比较多时，⽤用代理理解耦;简单回调和异步线程中使 ⽤用block。

11、如何令⾃自⼰己所写的对象具有拷⻉贝功能?
如果想让⾃自⼰己的类具备copy⽅方法，并返回不不可边类型，必须遵循nscopying协议，并 且实现
- (id)copyWithZone:(NSZone *)zone
如果让⾃自⼰己的类具备mutableCopy⽅方法，并且放回可变类型，必须遵守 NSMutableCopying，并实现- (id)mutableCopyWithZone:(nullable NSZone *)zone
注意:再此说的copy对应不不可边类型和mutableCopy对应不不可边类型⽅方法，都是遵从 系统规则⽽而已。如果你想实现⾃自⼰己的规则，也是可以的。

12、使⽤用系统的某些block api(如UIView的block版本写动画时)，是否也考虑引⽤用 循环问题?
系统的某些block api中，UIView的block版本写动画时不不需要考虑，但也有⼀一些api 需要考虑:
所谓“引⽤用循环”是指双向的强引⽤用，所以那些“单向的强引⽤用”(block 强引⽤用 self ) 没有问题，⽐比如这些:
[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }];
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }];
[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification"
object:nil queue:[NSOperationQueue mainQueue]
usingBlock:^(NSNotification * notification) { self.someProperty = xyz; }];
这些情况不不需要考虑“引⽤用循环”。
但如果你使⽤用⼀一些参数中可能含有 ivar 的系统 api ，如 GCD 、 NSNotificationCenter就要⼩小⼼心⼀一点:⽐比如GCD 内部如果引⽤用了了 self，⽽而且 GCD 的 其他参数是 ivar，则要考虑到循环引⽤用:
__weak __typeof__(self) weakSelf = self; dispatch_group_async(_operationsGroup, _operationsQueue, ^ {

__typeof__(self) strongSelf = weakSelf; [strongSelf doSomething];
[strongSelf doSomethingElse];
} );
类似的:
__weak __typeof__(self) weakSelf = self;
_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey"
object:nil queue:nil
usingBlock:^(NSNotification *note) { __typeof__(self) strongSelf = weakSelf;
[strongSelf dismissModalViewControllerAnimated:YES]; }];
self --> _observer --> block --> self 显然这也是⼀一个循环引用。

14、UIView和 CALayer是什什么关系?
UIView 显示在屏幕上归功于 CALayer，通过调⽤用 drawRect ⽅方法来渲染⾃自身的内 容，调节 CALayer 属性可以调整 UIView 的外观，UIView 继承⾃自 UIResponder，⽐比 起CALayer 可以响应⽤用户事件，Xcode6 之后可以⽅方便便的通过视图调试功能查看图层 之间的关系。UIView 是 iOS 系统中界⾯面元素的基础，所有的界⾯面元素都继承⾃自它。 它内部是由Core Animation 来实现的，它真正的绘图部分，是由⼀一个叫 CALayer(Core Animation Layer)的类来管理理。UIView 本身，更更像是⼀一个 CALayer 的管理理器器，访问它的跟绘图和坐标有关的属性，如 frame，bounds 等，实际上内部 都是访问它所在 CALayer 的相关属性。UIView 有个 layer 属性，可以返回它的主 CALayer 实例例，UIView 有⼀一个layerClass⽅方法，返回主 layer所使⽤用的类，UIView 的 ⼦子类，可以通过重载这个⽅方法，来让 UIView 使⽤用不不同的 CALayer 来显示，如:
- (class) layerClass {
// 使某个 UIView的⼦子类使⽤用 GL来进⾏行行绘制 return ([CAEAGLLayer class]);
}
UIView 的 CALayer 类似 UIView 的⼦子 View 树形结构，也可以向它的 layer 上添加 ⼦子layer，来完成某些特殊的显示。例例如下⾯面的代码会在⽬目标 View 上敷上⼀一层⿊黑⾊色的 透明薄膜。
grayCover = [[CALayer alloc]init]; grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor; [self.layer addSubLayer:grayCover];
补充部分:这部分有深度了了，⼤大致了了解⼀一下吧，UIView 的 layer 树形在系统内部被系 统维护着三份 copy1.逻辑树，就是代码⾥里里可以操纵的，例例如更更改 layer 的属性等等就 在这⼀一份2.动画树，这是⼀一个中间层，系统正是在这⼀一层上更更改属性，进⾏行行各种渲染 操作。3.显示树，这棵树的内容是当前正被显示在屏幕上的内容。这三棵树的逻辑结 构都是⼀一样的，区别只有各⾃自的属性

16、main()之前的过程有哪些?
1)dyld 开始将程序⼆二进制⽂文件初始化
2)交由ImageLoader 读取 image，其中包含了了我们的类，⽅方法等各种符号 (Class、Protocol 、Selector、 IMP)
3)由于runtime 向dyld 绑定了了回调，当image加载到内存后，dyld会通知runtime进 ⾏行行处理理
4)runtime 接⼿手后调⽤用map_images做解析和处理理
5)接下来load_images 中调⽤用call_load_methods⽅方法，遍历所有加载进来的 Class，按继承层次依次调⽤用Class的+load和其他Category的+load⽅方法
6)⾄至此 所有的信息都被加载到内存中
7)最后dyld调⽤用真正的main函数
注意:dyld会缓存上⼀一次把信息加载内存的缓存，所以第⼆二次⽐比第⼀一次启动快⼀一点
17、KVO基本原理理? 答:
1.KVO是基于runtime机制实现的
2.当某个类的属性对象第⼀一次被观察时，系统就会在运⾏行行期动态地创建该类的⼀一个 派⽣生类，在这个派⽣生类中重写基类中任何被观察属性的setter ⽅方法。派⽣生类在被重写 的setter⽅方法内实现真正的通知机制
3.如果原类为Person，那么⽣生成的派⽣生类名为NSKVONotifying_Person 4.每个类对象中都有⼀一个isa指针指向当前类，当⼀一个类对象的第⼀一次被观察，那么

系统会偷偷将isa指针指向动态⽣生成的派⽣生类，从⽽而在给被监控属性赋值时执⾏行行的是派 ⽣生类的setter⽅方法
5.键值观察通知依赖于NSObject 的两个⽅方法: willChangeValueForKey: 和 didChangevlueForKey:;在⼀一个被观察属性发⽣生改变之前， willChangeValueForKey:⼀一定会被调⽤用，这就 会记录旧的值。⽽而当改变发⽣生后， didChangeValueForKey:会被调⽤用，继⽽而 observeValueForKey:ofObject:change:context: 也会被调⽤用。
18、:Swift 下的如何使⽤用 KVC? 答:
/// 1. 定义⼀一个类 class Animal {
var name = "Animal" }
/// 2. 我们想使⽤用kvc的⽅方式改变实例例的名字的时候，发现并没有setValue这个⽅方法 let anim = Animal()
//anim.setValue 发现并没有setValue这个⽅方法
/// 3. 怎么像oc⼀一样可以使⽤用kvc的⽅方式来访问控制 // 步骤1: 继承NSObject
class Animal1 : NSObject {
var name = "Animal1" }
// 步骤2:调⽤用, 运⾏行行后发现报错 原因:swift4.0之前，这种⽅方式是可以的，4.0的 时候，减少隐式 @objc ⾃自动推断， 也就是说，如果你要调⽤用，必须显式声明，在⽅方 法前添加@objc, 或者在类前添加@objcMembers(这种情况会给所有的实例例变量量和⽅方 法都隐式的添加了了@objc)
Animal1().setValue("Dog", forKey: "name")
/// 4. 除了了这种可以实现KVC, 还有其它⽅方法么，答案肯定是有的， 如下 let anim = Animal()
let key = \Animal.name
anim[keyPath:key] = "Dog"
print("\(anim.name)")

20、objc在向⼀一个对象发送消息时，发⽣生了了什什么? 答案:objc在向⼀一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实 际所属的类，然后在该类中的⽅方法列列表以及其⽗父类⽅方法列列表中寻找⽅方法运⾏行行，然后在 发送消息的时候，objc_msgSend⽅方法不不会返回值，所谓的返回内容都是具体调⽤用时 执⾏行行的。
27、如何⼿手动触发⼀一个value的KVO 所谓的“⼿手动触发”是区别于“⾃自动触发”:
⾃自动触发是指类似这种场景:在注册 KVO 之前设置⼀一个初始值，注册之后，设置⼀一 个不不⼀一样的值，就可以触发了了。
想知道如何⼿手动触发，必须知道⾃自动触发 KVO 的原理理:
键值观察通知依赖于 NSObject 的两个⽅方法: willChangeValueForKey: 和 didChangevlueForKey: 。在⼀一个被观察属性发⽣生改变之前， willChangeValueForKey: ⼀一定会被调⽤用，这就 会记录旧的值。⽽而当改变发⽣生后， observeValueForKey:ofObject:change:context: 会被调⽤用，继⽽而 didChangeValueForKey: 也会被调⽤用。如果可以⼿手动实现这些调⽤用，就可以实现“⼿手 动触发”了了。
那么“⼿手动触发”的使⽤用场景是什什么?⼀一般我们只在希望能控制“回调的调⽤用时机”时才 会这么做。
具体做法如下:
如果这个 value 是 表示时间的 self.now ，那么代码如下:最后两⾏行行代码缺⼀一不不可。 相关代码已放在仓库⾥里里。
// .m⽂文件
// ⼿手动触发 value 的KVO，最后两⾏行行代码缺⼀一不不可。
//@property (nonatomic, strong) NSDate *now; - (void)viewDidLoad {
[super viewDidLoad];
_now = [NSDate date];
[self addObserver:self forKeyPath:@"now"
options:NSKeyValueObservingOptionNew context:nil];
NSLog(@"1");
[self willChangeValueForKey:@"now"]; // “⼿手动触发self.now的KVO”，必写。 NSLog(@"2");
[self didChangeValueForKey:@"now"]; // “⼿手动触发self.now的KVO”，必写。 NSLog(@"4");
} 但是平时我们⼀一般不不会这么⼲干，我们都是等系统去“⾃自动触发”。“⾃自动触发”的实现原 理理:
⽐比如调⽤用 setNow: 时，系统还会以某种⽅方式在中间插⼊入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的 调⽤用。
⼤大家可能以为这是因为 setNow: 是合成⽅方法，有时候我们也能看到有⼈人这么写代码:
- (void)setNow:(NSDate *)aDate {
[self willChangeValueForKey:@"now"]; // 没有必要 _now = aDate;
[self didChangeValueForKey:@"now"];// 没有必要
} 这完全没有必要，不不要这么做，这样的话，KVO代码会被调⽤用两次。KVO在调⽤用存取 ⽅方法之前总是调⽤用 willChangeValueForKey: ，之后总是调⽤用 didChangeValueForkey: 。怎么做到的呢?答案是通过 isa 混写(isa-swizzling)。 下⽂文《apple⽤用什什么⽅方式实现对⼀一个对象的KVO?》会有详述。
参考链接: Manual Change Notification—Apple 官⽅方⽂文档 https:// developer.apple.com/library/content/documentation/Cocoa/Conceptual/ KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/ 20002178-SW3
28、如何对定位和分析项⽬目中影响性能的地⽅方?以及如何进⾏行行性能优化? 定位⽅方法:
instruments   在iOS上进⾏行行性能分析的时候，⾸首先考虑借助instruments这个利利器器分析出问题出 在哪，不不要凭空想象，不不然你可能把精⼒力力花在了了1%的问题上，最后发现其实啥都没优 化，⽐比如要查看程序哪些部分最耗时，可以使⽤用Time Profiler，要查看内存是否泄漏漏 了了，可以使⽤用Leaks等。关于instruments⽹网上有很多资料料，作为⼀一个合格iOS开发 者，熟悉这个⼯工具还是很有必要的。
优化建议:
1.⽤用ARC管理理内存
* ARC(Automatic Reference Counting, ⾃自动引⽤用计数)和iOS5⼀一起发布，它避免了了 最常⻅见的也就是经常是由于我们忘记释放内存所造成的内存泄露露。它⾃自动为你管理理 retain和release的过程，所以你就不不必去⼿手动⼲干预了了。下⾯面是你会经常⽤用来去创建⼀一 个View的代码段: UIView *view = [[UIView alloc] init];
* // ...
* [self.view addSubview:view];
* [view release];
* 忘掉代码段结尾的release简直像记得吃饭⼀一样简单。⽽而ARC会⾃自动在底层为你做这 些⼯工作。除了了帮你避免内存泄露露，ARC还可以帮你提⾼高性能，它能保证释放掉不不再需 要的对象的内存。这都啥年年代了了，你应该在你的所有项⽬目⾥里里使⽤用ARC! 2.在正确的地⽅方使⽤用 reuseIdentifier
* ⼀一个开发中常⻅见的错误就是没有给UITableViewCells， UICollectionViewCells，甚 ⾄至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。
* 为了了性能最优化，table view⽤用 tableView:cellForRowAtIndexPath: 为rows分配 cells的时候，它的数据应该重⽤用⾃自UITableViewCell。 ⼀一个table view维持⼀一个队列列的 数据可重⽤用的UITableViewCell对象。不不使⽤用reuseIdentifier的话，每显示⼀一⾏行行table view就不不得不不设置全新的cell。这对性能的影响可是相当⼤大的，尤其会使app的滚动体 验⼤大打折扣。
* ⾃自iOS6起，除了了UICollectionView的cells和补充views，你也应该在header和footer views中使⽤用reuseIdentifiers
3.尽量量把views设置为完全不不透明
* 如果你有透明的Views你应该设置它们的opaque(不不透明)属性为YES。例例如⼀一个⿊黑⾊色 半透明的可以设置为⼀一个灰⾊色不不透明的View替代.原因是这会使系统⽤用⼀一个最优的⽅方式 渲染这些views。这个简单的属性在IB或者代码⾥里里都可以设定。
* Apple的⽂文档对于为图⽚片设置透明属性的描述是:
* (opaque)这个属性给渲染系统提供了了⼀一个如何处理理这个view的提示。如果设为
YES， 渲染系统就认为这个view是完全不不透明的，这使得渲染系统优化⼀一些渲染过程 和提⾼高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是 YES。
* 在相对⽐比较静⽌止的画⾯面中，设置这个属性不不会有太⼤大影响。然⽽而当这个view嵌在 scroll view⾥里里边，或者是⼀一个复杂动画的⼀一部分，不不设置这个属性的话会在很⼤大程度 上影响app的性能。
* 换种说法，⼤大家可能更更好理理解:只要⼀一个视图的不不透明度⼩小于1,就会导致 blending.blending操作在iOS的图形处理理器器(GPU)中完成的,blending主要指的是混 合像素颜⾊色的计算。举个例例⼦子,我们把两个图层叠加在⼀一起,如果第⼀一个图层的有透明效 果,则最终像素的颜⾊色计算需要将第⼆二个图层也考虑进来。这⼀一过程即为Blending。为 什什么Blending会导致性能的损失?原因是很直观的,如果⼀一个图层是完全不不透明的,则系 统直接显示该图层的颜⾊色即可。⽽而如果图层是带透明效果的,则会引⼊入更更多的计算,因为 需要把下⾯面的图层也包括进来,进⾏行行混合后颜⾊色的计算。
4. 避免过于庞⼤大的XIB
* iOS5中加⼊入的Storyboards(分镜)正在快速取代XIB。然⽽而XIB在⼀一些场景中仍然很有 ⽤用。⽐比如你的app需要适应iOS5之前的设备，或者你有⼀一个⾃自定义的可重⽤用的view,你 就不不可避免地要⽤用到他们。
* 如果你不不得不不XIB的话，使他们尽量量简单。尝试为每个Controller配置⼀一个单独的 XIB，尽可能把⼀一个View Controller的view层次结构分散到单独的XIB中去。
* 需要注意的是，当你加载⼀一个XIB的时候所有内容都被放在了了内存⾥里里，包括任何图 ⽚片。如果有⼀一个不不会即刻⽤用到的view，你这就是在浪费宝贵的内存资源了了。 Storyboards就是另⼀一码事⼉儿了了，storyboard仅在需要时实例例化⼀一个view controller.
* 当你加载⼀一个引⽤用了了图⽚片或者声⾳音资源的nib时，nib加载代码会把图⽚片和声⾳音⽂文件 写进内存。在OS X中，图⽚片和声⾳音资源被缓存在named cache中以便便将来⽤用到时获 取。在iOS中，仅图⽚片资源会被存进named caches。取决于你所在的平台，使⽤用 NSImage 或UIImage 的imageNamed:⽅方法来获取图⽚片资源。
5. 不不要阻塞主线程
* 永远不不要使主线程承担过多。因为UIKit在主线程上做所有⼯工作，渲染，管理理触摸反 应，回应输⼊入等都需要在它上⾯面完成。⼀一直使⽤用主线程的⻛风险就是如果你的代码真的 block了了主线程，你的app会失去反应
* ⼤大部分阻碍主进程的情形是你的app在做⼀一些牵涉到读写外部资源的I/O操作，⽐比如 存储或者⽹网络。或者使⽤用像 AFNetworking这样的框架来异步地做这些操作。如果你 需要做其它类型的需要耗费巨⼤大资源的操作(⽐比如时间敏敏感的计算或者存储读写)那就 ⽤用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.你可以使 ⽤用NSURLConnection异步地做⽹网络操作: + (void)sendAsynchronousRequest: (NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
6. 在Image Views中调整图⽚片⼤大⼩小
* 如果要在UIImageView中显示⼀一个来⾃自bundle的图⽚片，你应保证图⽚片的⼤大⼩小和

UIImageView的⼤大⼩小相同。在运⾏行行中缩放图⽚片是很耗费资源的，特别是UIImageView 嵌套在UIScrollView中的情况下。
* 如果图⽚片是从远端服务加载的你不不能控制图⽚片⼤大⼩小，⽐比如在下载前调整到合适⼤大⼩小 的话，你可以在下载完成后，最好是⽤用background thread，缩放⼀一次，然后在 UIImageView中使⽤用缩放后的图⽚片。
7. 选择正确的Collection 学会选择对业务场景最合适的类或者对象是写出能效⾼高的代码的基础。当处理理 collections时这句句话尤其正确。
Apple有⼀一个 Collections Programming Topics 的⽂文档详尽介绍了了可⽤用的classes间 的差别和你该在哪些场景中使⽤用它们。这对于任何使⽤用collections的⼈人来说是⼀一个必 读的⽂文档。
呵呵，我就知道你因为太⻓长没看...这是⼀一些常⻅见collection的总结:
* Arrays: 有序的⼀一组值。使⽤用index来lookup很快，使⽤用value lookup很慢， 插⼊入/删 除很慢。
* Dictionaries: 存储键值对。 ⽤用键来查找⽐比较快。
* Sets: ⽆无序的⼀一组值。⽤用值来查找很快，插⼊入/删除很快。
8. 打开gzip压缩
* ⼤大量量app依赖于远端资源和第三⽅方API，你可能会开发⼀一个需要从远端下载XML, JSON, HTML或者其它格式的app。
* 问题是我们的⽬目标是移动设备，因此你就不不能指望⽹网络状况有多好。⼀一个⽤用户现在 还在edge⽹网络，下⼀一分钟可能就切换到了了3G。不不论什什么场景，你肯定不不想让你的⽤用 户等太⻓长时间。
* 减⼩小⽂文档的⼀一个⽅方式就是在服务端和你的app中打开gzip。这对于⽂文字这种能有更更⾼高 压缩率的数据来说会有更更显著的效⽤用。好消息是，iOS已经在NSURLConnection中默 认⽀支持了了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经⽀支持了了压缩输出。
29、串串⾏行行并⾏行行，异步同步的区别?
先来说⼀一个队列列和任务:
队列列分为串串⾏行行和并⾏行行
任务的执⾏行行分为同步和异步 这两两组合就成为了了串串⾏行行队列列同步执⾏行行，串串⾏行行队列列异步执⾏行行，并⾏行行队列列同步执⾏行行，并 ⾏行行队列列异步执⾏行行 ⽽而异步是多线程的代名词，异步在实际引⽤用中会开启新的线程，执⾏行行耗时操作。
那我们先来知道⼀一个⾮非常重要的事情:
------- 队列列只是负责任务的调度，⽽而不不负责任务的执⾏行行 ---------

32、假设有⼀一个字符串串aabcad，请写⼀一段程序，去掉字符串串中不不相邻的重复字符 串串，即上述字符串串处理理之后的输出结果为:aabcd
答案:NSMutableString * str = [[NSMutableString alloc]initWithFormat;@“aabcad”];
for (int i = 0 ,i < str.length - 1 ;i++){ unsigned char a = [str characterAtIndex:i]; for (int j = i + 1 ,j < str.length ,j++){
unsigned char b = [str characterAtIndex:j]; if (a == b ){
if (j == i + 1){ }else{
[str deleteCharactersInRange:NSMakeRange(j, 1)];
} }
} }
NSLog(@“%@”,str);
33、@autoclosure(⾃自动闭包)
1:⾃自动闭包，顾名思义是⼀一种⾃自动创建的闭包，⽤用于包装函数参数的表达式，可以说 是⼀一种简便便语法.
2:⾃自动闭包不不接受任何参数，被调⽤用时会返回被包装在其中的表达式的值。
3:⾃自动闭包的好处之⼆二是让你能够延迟求值,因为代码段不不会被执⾏行行直到你调⽤用这个闭 包，这样你就可以控制代码什什么时候执⾏行行。
4:含有autoclosure特性的声明同时也具有noescape的特性，及默认是⾮非逃逸闭 包，除⾮非传递可选参数escaping.如果传递了了该参数，那么将可以在闭包之外进⾏行行操作 闭包,形式为:请使⽤用@autoclosure(escaping)。
实战操作理理解:

/// 我们定义有⼀一个⽅方法接受⼀一个闭包，当闭包执⾏行行的结果为true的时候进⾏行行打印: func method(result:() -> Bool) {
if result() { print("method")
} }
/// 1. 直接挑⽤用⽅方法 method { () -> Bool in
return true }
/// 2. 闭包在园括号⾥里里 method(result: {return true})
/// 3. 使⽤用尾部闭包⽅方式，闭包体在圆括号之外 method(){return true}
/// 4. 在 Swift 中对闭包的⽤用法可以进⾏行行⼀一些简化，在这种情况下我们可以省略略掉 return，写成:
method(){true}
/// 5:还可以更更近⼀一步，因为这个闭包是最后⼀一个参数，所以可以使⽤用尾随闭包 (trailing closure) 的⽅方式把⼤大括号拿出来，然后省略略括号，变成:
method {true}
//===========================================//
/// 但是不不管哪种⽅方式，表达上不不太清晰，看起来不不舒服。于是@autoclosure就登场 了了。我们可以改换⽅方法参数，在参数名前⾯面加上@autoclosure关键字:
func method1( result:@autoclosure ()->Bool) {
if result() { print("method1")
} }
/// 调⽤用下，我们看⼀一下
method1(result: true)
/// 上⾯面调⽤用是不不是舒服多了了，直接进⾏行行调⽤用了了，Swift 将会把 true 这个表达式⾃自动 转换为 () -> Bool。这样我们就得到了了⼀一个写法简单，表意清楚的式⼦子。

/// 1个闭包优势可能不不是那么的明显，如果有多个闭包，那么优势就明显了了，⽽而 @autoclosure是可以修饰任何位置的参数:
/// 我们先看看不不加@autoclosure，使⽤用时是什什么样⼦子
func method3(result1: ()->Bool, result2: ()->Bool) {
if result1() && result2() { print("method3 ... 0") return
}
print("method3 ... 1") }
method3(result1: {5 > 1}, result2: {4 > 3})
/// 我们加上@autoclosure之后对⽐比下:
func method4(result1: @autoclosure ()->Bool, result2: @autoclosure ()->Bool) {
if result1() && result2() { print("method4 ... 0") return
}
print("method4 ... 1") }
method4(result1: 5 > 1, result2: 4 > 3)
34、iOS app启动如何优化?
1. 我们可以通过在 Xcode 中 Edit scheme -> Run -> Auguments 将环境变量量 DYLD_PRINT_STATISTICS 设为 1,在控制台看到main()函数之前的启动时间。
2. 分解优化⽬目标 分步达到优化⽬目的 1). 耗时操作异步处理理
2). 如果启动流程依赖⽹网络请求回来才能继续,那么需要考虑⽹网络极差情况下的启动速度
3). 如果APP有loading⼴广告⻚页并且对分辨率的要求较⾼高,请尝试做缓存吧
4). 主⻚页⾯面Controller中的viewDidLoad和viewWillAppear⽅方法中尽量量少做事情 5). 排查清理理项⽬目中未使⽤用到的类库以及Framework
6). 删减合并⼀一些OC类,删减没有⽤用到或者可以不不⽤用的静态变量量、⽅方法等
7). 轻量量化+load⽅方法中的内容,可延迟到+initialize中
35、swift⾯面试题:
教育类的app, 显示分数的地⽅方，统计平均分的时候需要显示⼩小数位，并且不不能四舍五 ⼊入，同时为了了界⾯面美观，不不能出现⼩小数点后⾯面都为0的情况。
题⽬目:Float类型，转换成字符串串输出，要求保留留N位⼩小数, 特殊情况，如果转换之后 结果为XX.00(0的个数=保留留的⼩小数的个数), 则返回XX
例例⼦子: 11.11保留留1位 = "11.1" 11.01保留留1位 = "11" 11.001保留留2位 = "11"
36、怎样防⽌止反编译?
本地数据加密 对NSUserDefaults，sqlite存储⽂文件数据加密，保护帐号和关键信息 URL编码加密
对程序中出现的URL进⾏行行编码加密，防⽌止URL被静态分析 ⽹网络传输数据加密 对客户端传输数据提供加密⽅方案，有效防⽌止通过⽹网络接⼝口的拦截获取数据
方法体，⽅方法名⾼高级混淆 对应⽤用程序的⽅方法名和⽅方法体进⾏行行混淆，保证源码被逆向后⽆无法解析代码 程序结构混排加密 对应⽤用程序逻辑结构进⾏行行打乱混排，保证源码可读性降到最低
37、UITableView性能优化，超实⽤用
1. Cell重⽤用 1.1>数据源⽅方法优化
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
在可⻅见的⻚页⾯面会重复绘制⻚页⾯面，每次刷新显示都会去创建新的Cell，⾮非常耗费性 能。
解决⽅方案:⾸首先创建⼀一个静态变量量reuseID(代理理⽅方法返回Cell会调⽤用很多次，防⽌止 重复创建，static保证只会被创建⼀一次，提⾼高性能)，然后，从缓存池中取相应 identifier的Cell并更更新数据，如果没有，才开始alloc新的Cell，并⽤用identifier标识 Cell。每个Cell都会注册⼀一个identifier(重⽤用标识符)放⼊入缓存池，当需要调⽤用的时 候就直接从缓存池⾥里里找对应的id，当不不需要时就放⼊入缓存池等待调⽤用。(移出屏幕的 Cell才会放⼊入缓存池中，并不不会被release)所以在数据源⽅方法中做出如下优化:
// 调⽤用次数太多，static 保证只创建⼀一次reuseID，提⾼高性能
static NSString *reuseID = “reuseCellID”;
// 缓存池中取已经创建的cell
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];
1.2>缓存池的实现
当Cell要alloc时，UITableView会在堆中开辟⼀一段内存以供Cell缓存之⽤用。Cell的重 ⽤用通过identifier标识不不同类型的Cell，由此可以推断出，缓存池外层可能是⼀一个可变 字典，通过key来取出内部的Cell，⽽而缓存池为存储不不同⾼高度、不不同类型(包含图⽚片、 Label等)的Cell，可以推断出缓存池的字典内部可能是⼀一个可变数组，⽤用来存放不不同 类型的Cell，缓存池中只会保存已经被移出屏幕的不不同类型的Cell。
1.3>缓存池获取可重⽤用Cell两个⽅方法的区别
-(nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier: (NSString *)identifier;
这个⽅方法会查询可重⽤用Cell，如果注册了了原型Cell，能够查询到，否则，返回nil;⽽而 且需要判断if(cell == nil)，才会创建Cell，不不推荐
-(__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
使⽤用这个⽅方法之前，必须通过xib(storyboard)或是Class(纯代码)注册可重⽤用 Cell，⽽而且这个⽅方法⼀一定会返回⼀一个Cell
注册Cell
- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString*)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
好处:如果缓冲区 Cell 不不存在，会使⽤用原型 Cell 实例例化⼀一个新的 Cell，不不需要再判 断，同时代码结构更更清晰。
2. 定义⼀一种(尽量量少)类型的Cell及善⽤用hidden隐藏(显示)subviews
2.1>⼀一种类型的Cell
分析Cell结构，尽可能的将 相同内容的抽取到⼀一种样式Cell中，前⾯面已经提到了了
Cell的重⽤用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能 只⽐比屏幕显示的Cell多⼀一点。虽然Cell的’体积’可能会⼤大点，但是因为Cell的数量量不不会 很多，完全可以接受的。好处:
* 减少代码量量，减少Nib⽂文件的数量量，统⼀一⼀一个Nib⽂文件定义Cell，容易易修改、维护
* 基于Cell的重⽤用，真正运⾏行行时铺满屏幕所需的Cell数量量⼤大致是固定的，设为N个。所 以如果如果只有⼀一种Cell，那就是只有N个Cell的实例例;但是如果有M种Cell，那么运 ⾏行行时最多可能会是“M x N = MN”个Cell的实例例，虽然可能并不不会占⽤用太多内存，但是 能少点不不是更更好吗。
2.2>善⽤用hidden隐藏(显示)subviews
只定义⼀一种Cell，那该如何显示不不同类型的内容呢?答案就是，把所有不不同类型的 view都定义好，放在cell⾥里里⾯面，通过hidden显示、隐藏，来显示不不同类型的内容。毕 竟，在⽤用户快速滑动中，只是单纯的显示、隐藏subview⽐比实时创建要快得多。
3. 提前计算并缓存Cell的⾼高度 在iOS中，不不设UITableViewCell的预估⾏行行⾼高的情况下，会优先调
⽤用”tableView:heightForRowAtIndexPath:”⽅方法，获取每个Cell的即将显示的⾼高度， 从⽽而确定UITableView的布局，实际就是要获取contentSize(UITableView继承⾃自 UIScrollView,只有获取滚动区域，才能实现滚动),然后才调 ⽤用”tableView:cellForRowAtIndexPath”,获取每个Cell，进⾏行行赋值。如果项⽬目中模块有 10000个Cell需要显示，可想⽽而知...
解决⽅方案:我个⼈人认为，可以创建⼀一个frame模型，提前计算每个Cell的⾼高度。参考 其中⼀一篇博客的时候，在解决这个问题的时候，可以将计算Cell的⾼高度放⼊入数据模 型，但这与MVC设计模式可能稍微有点冲突，这个时候我就想到MVVM这种设计模 式，这个时候才能稍微有点MVVM这种设计模式的优点(其实还是很不不理理解的)，可 以讲计算Cell⾼高度放⼊入ViewModel(视图模型)中，让Model(数据模型)只负责处 理理数据。
4.异步绘制(⾃自定义Cell绘制) 遇到⽐比较复杂的界⾯面的时候，如复杂点的图⽂文混排，上⾯面的那种优化⾏行行⾼高的⽅方式可
能就不不能满⾜足要求了了，当然了了，由于我的开发经验尚短，说实话，还没遇到要将⾃自定 义的Cell重新绘制
5.滑动时，按需加载 开发的过程中，⾃自定义Cell的种类千奇百怪，但Cell本来就是⽤用来显示数据的，不说
100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其 ⽹网络不不好的时候，异步加载图⽚片是个程序员都会想到，但是如果给每个循环对象都加 上异步加载，开启的线程太多，⼀一样会卡顿，我记得好像线程条数⼀一般3-5条，最多 也就6条吧。这个时候利利⽤用UIScrollViewDelegate两个代理理⽅方法就能很好地解决这个问 题。
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate: (BOOL)decelerate
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView
6.缓存View
当Cell中的部分View是⾮非常独⽴立的，并且不不便便于重⽤用的，⽽而且“体积”⾮非常⼩小，在内 存可控的前提下，我们完全可以将这些view缓存起来。当然也是缓存在模型中。
7.避免⼤大量量的图⽚片缩放、颜⾊色渐变等，尽量量显示“⼤大⼩小刚好合适的图⽚片资源” 8.避免同步的从⽹网络、⽂文件获取数据，Cell内实现的内容来⾃自web，使⽤用异步加载，缓 存请求结果
9.渲染
9.1>减少subviews的个数和层级 ⼦子控件的层级越深，渲染到屏幕上所需要的计算量量就越⼤大;如多⽤用drawRect绘制
元素，替代⽤用view显示 9.2>少⽤用subviews的透明图层
对于不不透明的View，设置opaque为YES，这样在绘制该View时，就不不需要考虑 被View覆盖的其他内容(尽量量设置Cell的view为opaque，避免GPU对Cell下⾯面的内容 也进⾏行行绘制)
9.3>避免CALayer特效(shadowPath) 给Cell中View加阴影会引起性能问题，如下⾯面代码会导致滚动时有明显的卡顿:
view.layer.shadowColor = color.CGColor; view.layer.shadowOffset = offset; view.layer.shadowOpacity = 1; view.layer.shadowRadius = radius;
线程:
37、 不不要阻塞主线程
* 永远不不要使主线程承担过多。因为UIKit在主线程上做所有⼯工作，渲染，管理理触摸反 应，回应输⼊入等都需要在它上⾯面完成。⼀一直使⽤用主线程的⻛风险就是如果你的代码真的 block了了主线程，你的app会失去反应
* ⼤大部分阻碍主进程的情形是你的app在做⼀一些牵涉到读写外部资源的I/O操作，⽐比如 存储或者⽹网络。或者使⽤用像 AFNetworking这样的框架来异步地做这些操作。如果你 需要做其它类型的需要耗费巨⼤大资源的操作(⽐比如时间敏敏感的计算或者存储读写)那就 ⽤用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.你可以使 ⽤用NSURLConnection异步地做⽹网络操作: + (void)sendAsynchronousRequest:
(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
41、iOS 中的多线程 iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更更为⽅方 便便的使⽤用线程，做过C++的同学可能会对线程有更更多的理理解，⽐比如线程的创⽴立，信号 量量、共享变量量有认识，Cocoa框架下会⽅方便便很多，它对线程做了了封装，有些封装，可 以让我们创建的对象，本身便便拥有线程，也就是线程的对象化抽象，从⽽而减少我们的工程，提供程序的健壮性。
* GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的⼀一个易易⽤用地多线程类库，具有运⾏行行时的特点，能充分利利⽤用多核⼼心硬件。GCD的API接⼝口为C语⾔言的函数，函 数参数中多数有Block，关于Block的使⽤用参看这⾥里里，为我们提供强⼤大的“接⼝口”，对于 GCD的使⽤用参⻅见本⽂文
* NSOperation与Queue NSOperation是⼀一个抽象类，它封装了了线程的细节实现，我们可以通过⼦子类化该对 象，加上NSQueue来同⾯面向对象的思维，管理理多线程程序。具体可参看这⾥里里:⼀一个基 于NSOperation的多线程⽹网络访问的项⽬目。
* NSThread NSThread是⼀一个控制线程执⾏行行的对象，它不不如NSOperation抽象，通过它我们可以⽅方 便便的得到⼀一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们⾃自 ⼰己来控制的，可以通过NSCondition实现。
参看 iOS多线程编程之NSThread的使⽤用
42、内存管理理的⼏几条原则时什什么?按照默认法则.那些关键字⽣生成的对象 需要⼿手动释放?在和property结合的时候怎样有效的避免内存泄露露? 谁申请，谁释放
遵循Cocoa Touch的使⽤用原则; 内存管理理主要要避免“过早释放”和“内存泄漏漏”，对于“过早释放”需要注意@property 设置特性时，⼀一定要⽤用对特性关键字，对于“内存泄漏漏”，⼀一定要申请了了要负责释放， 要细⼼心。
关键字alloc 或new ⽣生成的对象需要⼿手动释放; 设置正确的property属性，对于retain需要在合适的地⽅方释放，

44、如何⽤用GCD同步若⼲干个异步调⽤用?(如根据若⼲干个url异步加载多张图⽚片，然后在 都下载完成后合成⼀一张整图)
使⽤用Dispatch Group追加block到Global Group Queue,这些block如果全部执⾏行行完 毕，就会执⾏行行Main Dispatch Queue中的结束处理理的block。
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ /*加载图⽚片1 */ }); dispatch_group_async(group, queue, ^{ /*加载图⽚片2 */ }); dispatch_group_async(group, queue, ^{ /*加载图⽚片3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{
// 合并图⽚片 });

47、服务器器能否知道APNS推送后有没有到达客户端的⽅方法? APNS是苹果提供的远程推送的服务，APP开发此功能之后，⽤用户允许推送之后，服务端可以向安 装了了此app的⽤用户推送信息。但是APNS推送⽆无法保证100%到达。目前关于APNS苹果更更新了了新的策略略，即 APNS/HTTP2.
 如果服务器器像APNS服务器器推送信息之后，服务器器能够接收到APNS是否真的成功像客户端推送成 功了了某个信息。这样在⼀一定程度上提⾼高了了APNS的成功概率。
48、1.什什么⽅方式可以看到上架App的头⽂文件? 2.阅读过哪些框架的源码?能说说它的架构⽅方式吗
  49、iOS iAP内购审核可能失败的问题
Guideline 3.1.1 - Business - Payments - In-App Purchase
We noticed that your app uses in-app purchase products to purchase credits or
currencies that are not consumed within the app, which is not appropriate for the App Store.
苹果提交iAP内购审核的时候，可能出现上⾯面的问题。出现这个问题有可能的原因 是因为你的app中在iAP内购中购买的商品，能够通过其他的渠道或者⽅方式购买。此处 在AppStore是不不允许的。⽐比如，你在安卓充值100元⼈人⺠民币，那么如果商品⼀一样能够 使⽤用在iOS设备上，苹果不不会允许你上线的。当然这⾥里里指的是虚拟类商品。
另外就是在审核的时候不不能以任何⽅方式，通过活动或者兑换码的形式，能够获取 到iAP内购中能够获取到的商品。
App上架后，如何修改app上显示的公司名称? 1.先修改开发者账号中填写的公司名称。
2.再提交更更新版本。
如何修改开发者账号中的公司名称:
登陆到Apple developer上⾯面，在people⾥里里⾯面的开发者列列表中找到agent，让agent的这 个⼈人直接拨打苹果开发部咨询电话，修改开发者账号上的公司名或者⽤用你注册的账号 的邮箱直接写邮件:“我需要更更改公司名称”到chinadev@asia.apple.com，让苹果开发 部客服来处理理。
50、IAP内购中虚拟货币导致审核⽆无法通过的问题?
有的时候需要在app中使⽤用虚拟货币，在我们的app中可以使⽤用虚拟货币进⾏行行购买道具 等，⽐比如直播中的礼物，游戏中的道具等。
苹果对于虚拟货币是需要提成的，提成的额度为30%。所以对于这块的审核⽐比较严 格。⾸首先你们的购买的道具在ios端和安卓端是需要分开的。如果⼤大家玩游戏的就会发 现游戏的数据在两端是分开的。 ⽤用户在安卓⼿手机上购买的道具在ios上不不能使⽤用。因为这样也间接的影响了了苹果的收 ⼊入。
另外就是在审核期间不不能有可以兑换在appStore可购买的商品，的任意活动或者兑 换码，这个也是苹果不不允许的。因为这个也会影响苹果的收⼊入。
另外就是可能有⼈人会在苹果审核之后隐藏ipa⽀支付，此处提醒下，苹果会扫描你的 app代码中是否有⽀支付宝，微信等关于⽀支付的字段。使⽤用开关加h5的⽅方式可以通过审 核，但是此处也有⻛风险，⻛风险就是⼀一旦被发现，可能的结果就是苹果直接封掉账号。 app⽆无法使⽤用。

一、 用一个属性引用 UI 控件的时候为什么可以用 weak?
controller 是被系统用强指针引用者， 只要它存在， 那么里面的子控件也就存在， controller
强引用着它的 view controller ，又强引用着它的数组对象 subviews ，数组对象又强引用着 它所包含的数组内容，那么创建出来的一个 UI 控件将其加入 subviews 的时候，那么就会 被一个强指针所引着它
对于内存的合理使用， 当我们需要控件的时候就已经有一个强引用在引用着它， 我们就不必 再弄一个强指针来强引用它;当我们不需要的时候， weak 直接释放掉，用 strong 的话就 还会保留它，这就占着内存了 .
三、什么是抽象类?有什么作用 ?能实例化吗 ?
1 、抽象类: abstract 修饰，它只能用来作父类，本身并没有生成实例的能力
它将一类最公有的属性和方法抽取出来抽象类是将类共有的方法抽取出来， 声明为抽象方法 , 抽象方法只有声明没有具体的实现 , 拥有抽象方法的类就是抽象类 ; 这样新增一种类型时候 只需要继承抽象类，实现抽象方法就可以了，降低了实现新类的难度。
抽象方法修饰符 abstract 抽象类不能被实现 如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类
2 、抽象类作用:
(1 )用于类型隐藏在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述， 但是这组行为却能够有任意个可能的具体实现方式。 这个抽象 描述就是抽象类。
(2 )用于拓展对象的行为功能
这一组任意个可能的具体实现则表现为所有可能的派生类(子类) ，模块可以操作一个抽象 体。由于模块依赖于一个固定的抽象体， 因此它可以是不允许修改的; 同时，通过从这个抽 象体派生，也可扩展此模块的行为功能。

九. 是否使用过 CoreText 或者 CoreImage 等?如果使用过，请谈谈你使用 CoreText 或 者 CoreImage 的体验?
用过CoreText 是用于处理文字和字体的底层技术。 Quartz 能够直接处理字体( font )和字形 (glyphs )，将文字渲染到界面上， 它是基础库中唯一能够处理字形的模块。 因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz 。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。
coreImage 是 IOS5 中新加入的一个
用来对基于像素的图像进行操作与分析
有 48 种，而到了最新的 IOS6 Filter
这些 Filter 提供了各种各样的效果，并且还可以通过滤镜链将各种效果的 Filter 叠加起来， 形成强大的自定义效果，如果你对该效果很满意，还可以子类化滤镜

(1 )函数无线递归
(2)运行时 ,找不到方法 (没实现 )
(3 )访问了某个已经被释放的对象
(4)程序占用内存或 CPU 过高
(5)子线程阻塞主 UI 线程过久
(6 )从 Bundle 加载了不存在或者不支持的对象
2 、如何定位闪退的位置 ?
(1 )在设置断点的地方 ,选 Add Exception Breakpoint. 之后 crash 就会停在出错的位置 . (2)如果是在测试阶段报错的话 ,可以在 (设置 - 通用 -关于本机 -诊断与用量 )里面看到崩 溃的堆栈信息 .
(3 )如果用 RAC 的话 ,访问到已经释放了的内存 ,和内存警告这
十四、 如何实现圆角矩形 ?有哪些方法可以实现扇形 View? 直接修改 view 的样式，系统提供好的了 view.layer.cornerRadius = 6;
view.layer.masksToBounds = YES;
用 layer 做就可以了 , 十分简单 . 需要库 QuartzCore.framework 画矩形直接利用 UIBezierPath 给我们封装好的路径方法
(x,y) 点决定了矩形左上角的点在哪个位置
2 种粗出错的几率高一些;
(width,height) 是矩形的宽度高度 bezierPathWithOvalInRect:CGRectMake(x, y, width, height)
[UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 50, 100, 100)]; 圆角矩形的画法多了一个参数 ,cornerRadius
cornerRadius 它是矩形的圆角半径 .
通过圆角矩形可以画一个圆 .当矩形是正方形的时候 ,把圆角半径设为宽度的一半 ,就是一个 圆。
UIBezierPath*path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50,50,100,100) cornerRadius:50]; 扇形 :
画扇形的方法为 : 先画一个圆孤再添加一个一根线到圆心 ,然后关闭路径 . 关闭路径就会自动从路径的终点到路径的起点封闭起下
用填充的话 ,它会默认做一个封闭路径 ,从路径的终点到起点 .
[path fill];
十五、 Cocoa Touch 提供了哪几种 CoreAnimation 过渡类型 ?
Cocoa Touch 提供了 4 中 Core Animation 分别是交叉淡化 推挤 显示和覆盖 .
十六、 能否向编译后得到的类中增加实例变量 ?能否向运行时创建的类中添加实例变量 ,为什 么?
不能向编译后得到的类中增加实例变量
因为编译后的类以及注册在 runtime 中 ,类结构同中 objc_ivar_list 实例变量的链表和 instance_size 实例变量的内存大小已经确定
同时 runtime 会调用 class_setlvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量 能向运行时创建的的类添加实例变量运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。
十七、 请写出你调试解决 crash 问题的思路及步骤 ?1 )把问题拆分成多个小问题，一步步 检验，直到找到问题的根源点
2 )程序运行后，查看 log 信息，找到错误的地方
3 )在错误的地方设置断点进行调试，可以加条件断点
4 )查看断点运行的信息，进行修改
5) 如果是在测试阶段报错的话，可以在(设置 - 通用 - 关于本机
的堆栈信息。
6) 如果用 rac 的话，访问到已经释放了的内存，和内存警告这
十八、 NSDictionary 类使用了哪些数据结构和算法 ? NSDictionary 使用 Hash 表实现 Key / Object 存储 ;
- 诊断与用量)里面看到崩溃
2 种出错几率要高些。
Hash 表是一种访问速度很快的数据结构，前提是 Hash 函数设计合理，能够使数据在各个 子节点均匀分布，这一点使用 NSString 对象可以保证，这是文档中的说明:
Classes such as NSString that are part of Foundation have a good hash function.
十九、 iOS 和 iPhone 做了哪些设计来降低功耗 ,延长续航时间 ?作为应用的开发者 ,又如何 避免费电 ?
1、iOS 的省电机制主要有以下几种:
(1 )强化的后台机制
(2 )墓碑式:伪多任务，应用推至后台后，虽然没有被关闭，但是所有活动都被冻结，只 能通过苹果服务器转发的推送来与用户交互
(3 )智能调度后台:在一些指定类别的 APP ，比如社交、新闻类的应 用中， iOS 系统会 根据应用启动频率、 时间和当前网络和电量的状况来智能分配每个应用的后台数据获取频率 和启动时长，开发者自己不能设置数据具体什么时候更新
(4 )真后台:苹果也提供一些有诸多限制的接口来保证真后台，只供特定应用行为调用， 比如后台音频，定位，上传下载等。
2 、作为开发者如何省电
(1 )首先当然优化代码，积极合理地使用 runloop ，多线程等技术。
(2 )其次是尽量少地调用一些费电的接口，比如频繁的定位，频繁的后台更新数据，如无 必要，尽量不用。

2.XML有哪几种解析方式，他们各有什么优点?
有Sax和Dom两种解析方式， sax是逐行解析。 dom是一次性全部加载 xml文件，然后解析
3. 本地储存方式有哪些
数据库， NSUserDefaults,File,Plist,Archieve
NSUserDefaults :储存比较小的数据，用户信息，配置信息 数据库:适合存储一条条的数据，存储大的数据。
File: 一般普通文件，图片，视频，音频等
Plist: 存放比NSUserDefaults 大一些的数据、 归档:可以存储一些对象，
4. 什么是通知中心? 通知中心是多对多的平等的通讯模式。主要用在多个对象之间松耦合的通讯模式，对象和对
象之间通过通知的名字就可以关联通讯。

10.KVO and KVC?
答: kvc: 键 - 值编码是一种间接访问对象的属性，使用字符串来标识属性，而不
是通过调用存取方法，直接或通过实例变量访问的机制。? 很多情况下可以简化程 序代码。 apple 文档其实给了一个很好的例子。?kvo:键值观察机制，他提供了观察
某一属性变化的方法，极大的简化了代码。? 具 体用看到用到过的一个地方是对于 按钮点击变化状态的的监控。
11.Object -c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式用 继承好还是分类好?为什么?
答:Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的 方式来实现，

AFN的直接操作对象 AFHTTPClient，是一个实现了 NSCoding和 NSCopying协议的 NSObject 子类。
13.SDWebImage如何实现图片缓存，
首先对图片进行下载由 SDImagerCache这个类检查内存中是否有图片缓存，如果有图片 缓存，回调Block将图片传递给SDWebImageMange类r，回调block将图片数据传递给 UIImageView+WebCache显示图片。如果没有就去请求网络下载
14.XML
os 中已有的 NSXMLParse 类,NSXMLParser 实现的是 sax 方法解析 xml 文件。

15. 什么是委托代理?
委托代理是 2 个对象之间的一种通讯方式，委托方 使用协议，声明自己的代理，代理方遵 守协议实现协议里的方法，类似于 blocks 等语法，目的是为了使软件设计低耦合便于维护
16. 通知中心 通知中心是多对多的平等的通讯模式，主要在多个对象之间松耦合的通讯模式。对象和对象 之间通过通知的名字就可以进行关联通讯。
17.KVC是路径访问的规范、 KVC是键值编码，即是指 NSKeyValueCoding，一个非正式的 Protocol ，提供一种机制来间接访问对象的属性。 ,它是一种使用字符串标识符，间接访问 对象属性的机制， KVO就是基于 KVC 实现的关键技术之一。
18.KVO, 即:Key-Value Observing ，它提供一种机制，当指定的对象的属性被修改后， 则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后， KVO就会 自动通知相应的观察者了。
19.http 协议 get post 的区别 POST是安全的 ,GET是不安全的。
GET 请求地址和参数全放在请求头中 ,POST请求地址和请求参数分离，地址放在请求头中， 参数拼接放入请求体。

20. 如何避免在 Block 里用 self 造成循环引用
分类: iOS 开发 Swift 开发 2014-07-29 18:59 3852 人阅读评论 (0) 收藏举报 iOSObjCSwift
一般来说我们总会在设置 Block 之后，在合适的时间回调 Block ，而不希望回调 Block 的时 候 Block 已经被释放了，所以我们需要对 Block 进行 copy，copy 到堆中，以便后用。
当一个 Block 被 Copy 的时候，如果你在 Block 里进行了一些调用，那么将会有一个强引用 指向这些调用方法的调用者，有两个规则: 如果你是通过引用来访问一个实例变量，那么将强引用至 self 如果你是通过值来访问一个实例变量，那么将直接强引用至这个“值”变量 苹果官方文档里有两个例子来说明这两种情况:
上面第一种情况相当于用 self.xxx 来访问实例变量，所以强引用指向了 self ;第二种情况 把实例变量变成了本地临时变量，强引用将直接指向这个本地的临时变量。大多数情况下，
我们只用处理第一种情况就行了，因为第二种情况虽然会造成循环引用，但是临时变量很快 就被释放了，不会造成真正的循环引用。要避免强引用到 self 的话，用 __weak把 self 重 新引用一下就行了，像这样:
__weakViewController *weakSelf = self;
21.block 实现原理?
block 是一个特殊的 OC对象 , 它建立在栈上 , 而不是堆上 , 这么做一个是为性能考虑 , 还有 就是方便访问局部变量。默认情况下 block 使用到的局部变量都会被复制 , 而不是保留。所 以它无法改变局部变量的值。如果在变量面前加上 __block, 那么编译器回去不会复制变量 , 而是去找变量的地址 , 通过地址来访问变量 , 实际上就是直接操作变量。另外 block 是在栈 上分配的 , 所以一旦离开作用域 , 就会释放 , 因此如果你要把快用在别的地方 , 必须要复制 一份。 block 是不能保留的 , retain 对块没有意义。
22.Object -c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式 用继承好还是分类好?为什么?
Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，
cocoa 中所有的类都是 NSObject 的子类，多继承在这里是用 protocol 委托代理 来实现的。
28. 内存泄露?
1、运行 Demo 直接找到 Crash 的地方
setter getter
是否是原子操作， atomic 表示
2、设置 NSZombieEnabled
这是一个 EXC_BAD_ACCESS 错误。我们打开 XCode 的选项: “NSZombieEnabled” 。在 crash 时可
能会给你更多的一些提示信息。
3，分析内存泄露 (shift+command+b)
app 不 crash 了，那看看有没有内存泄露。用 XCode 的 Analyze 就能分析到哪里有内存泄露
4、使用 Instruments 的leaks 工具
分析内存泄露不能把所有的内存泄露查出来，有的内存泄露是在运行时，用户操作时才产生的。那就需 要用到 Instruments 了。

2. 断点续传(了解原理)
要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来 打开文件。该函数取回一个顺序号，即文件句柄( file handle )，该文件句柄对于打开的文件是唯一的识 别依据在程序设计中，句柄是一种特殊的智能指针。当一个应用程序要引用其他系统(如数据库、操作 系统)所管理的内存块或对象时，就要使用句柄。句柄与普通指针的区别在于，指针包含的是引用对象
finished))completion
操作的函数执行部分的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这 种间接访问对象的模式增强了系统对引用对象的控制。下载文件时，我们首先要为文件找一个容纳的内
存空间。创建文件的句柄。在请求过程中，我们请求的大小是不断增加的，下载文件只不过是连续性请 求数据，我们可以把文件指针始终指向请求下来的文件的结束，设置每次的请求范围即每次求数据的大 小。每次我们通过文件指针指向文件结束可以记录出文件请求文件的大小。可以知道当前文件的下载进 度。当文件的大小等于请求文件的大小时，说明下载已经完成，当我们中途暂停下载时，我们可以记录 当前本次下载文件的大小，和文件指针指向的结尾位置空间。如果再点击下载时，我们可以从指针指向 的位置开始，根据当文件的已经下载大小，从网络中接着上次下载请求的位置，继续请求下载数据。

3. 数据请求策略下载管理类(了解原理)
就是当我们每个页面都有很多的数据请求时，当我们需要跳转的页面需要用到前边页面请求回来的数据
时，例如 TableView , 点击 cell 跳转到详情，需要向详情页面传一个新闻详情的 ID 然后下一页面需要拼 接这个 iD 进行详情数据的请求，或者需要传输其他的参数。但是当前我们用属性传递，或者其他方法传 输时，其原理都是用指针指向下一页面的一个属性变量空间，然后把值传过去。但是很多时候，网速条 件不好，当我们 TabLeView 页面时，数据还没请求完，就点击 cell 跳转到详情，然后接着有返回到 TableView 的页面这时候当我们用指针指向下一页面的属性变量时，还没来得及获取下一页面的指针空 间，下一页面就释放掉了。所以指针变成了野指针。就会出现崩溃，这种崩溃你很难找到问题。 境下是将我们的变量在适当的时候自动释放，但是这个适当的时候是不确定的，所有有时候就会处理不 了，就会崩溃。所以一般我们的请求不写在每一个页面里，这样不好管理，所以一般都要封装下载类， 和下载管理类。这样我们可以把每次请求都统一交给下载管理类管理。当我们请求未完成，页面返回销 毁时，我们就把他的请求的对象置为 nil

4. 清除缓存 ( 了解原理 )
我们我们软件很多的设置里边会有，缓存大小，和清除缓存的功能，计算缓存大小:如果我们的软件用 了缓存机制，缓存的文件数据会储存在沙河目录下的 Cache 的文件夹里，我们可以用系统的文件管理 NSFileManager 这个单例，深层便利文件缓存路径 Library/Caches 文件夹下的所有文件，一切的文件类 型，然后累计相加计算出缓存字节的大小。然后进行缓存大小的显示。清除缓存数据:可以用系统的文
件管理 NSFileManager 这个单例，对缓存区 Library/Caches 文件夹下的所有文件，进行浅层便利，浅层 便利就是只便利 Caches 这一层下的文件和文件夹，然后进行删除。

7. 瀑布流怎么理解和实现的
1. 如果简单的来说 , 用 3 个 tableview 就可以实现瀑布流 ,3 个
tableview 实现联动滚动。
2. 其实最好的做法在 scrollview 上使用 3 个复用队列 ,如果一种一个 cell 超过屏幕 ,不能 release, 而是把它 回收到复用队列中 , 如果要创建一个 cell, 首先从复用队列中取一个 , 然后使用。
8. 做过的项目是否涉及网络访问功能，使用什么对象完成网络功能? 答案: ASIHTTPRequest 与 NSURLConnection

11.coredata 有哪几种持久化存储机制?
答案: coredatat 提供以下几种存储机制: XML (iOS 系统不支持) ,自动存储 ,SQLite, 内存存储。
补充说明:这个问题问的是， coredate 框架的存储机制，平时使用 coredata 时，更多关注的是 managed 的对象，这里是 coerdata 框架的存储实现细节。 BTW: 其他常用的持久化存储方法:存入到文
件、 存入到 NSUserDefaults (系统 plist 文件中)。
16.如果我们不创建内存池，是否有内存池提供给我们?
答案 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
17.什么时候需要在程序中创建内存池?
答案:用户自己创建的数据线程，则需要创建该线程的内存池 18.When retain count increase? 什么时候内存计数会增加?
20.什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber
的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithI nt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象， 并且不需要手动释放。
24.在 iPhone 应用中如何保存数据? 答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中 3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.What is coredata?
25. 什么是 coredata ?
答案: coredata 框架是 apple 提供的一套通用自动的解决方案，包括了对象生存周期、对象关系图、持 久化机制。
补充答案:上面是翻译的，按我个人理解 coredata 提供一种一机制，让我们可以方便的把内存中对象， 及对象间的关系，映射到 coredata ，然后由它为我们持久化数据。相比普通的文件数据库 SQlite ，它的 功能更强大，不需要我们先将对象数据 format 成 SQL 语句，存入数据库，再用 select 语句读出，而现在 是从内存到 coredata 的数据管理，我们只需管理 coredata 的 managed 对象。
是苹果提供一套数据保存
26.What is NSManagedObject model? 什么是 NSManagedObject模型?
答案: NSManagedObject 是 NSObject 的子类，也是 coredata 的重要组成部分，它是一个通用的类 ,实 现了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。
15.什么是 NSManagedobjectContext?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
16.委托是什么？委托和委托方双方的property声明用什么属性？为什么？
委托：一个对象保存另外一个对象的引用，被引用的对象实现了事先确定的协议，该协议用于将引用对象中的变化通知给被引用对象。
委托和委托方双方的property声明属性都是assign而不是retain
为了避免循环引用造成的内存泄露。
      循环引用的问题这样理解：
    比如在main函数中创建了两个类的对象A和B，现在引用计数都是1。现在让A和B互相引用(A有一个属性是B对象，属性说明是retain；B有一个属性是A对象，属性说明是retain)，现在两个对象的引用计数都增加了1，都变成了2。
  现在执行[A release]; [B release]; 此时创建对象的main函数已经释放了自己对对象的所有权，但是此时A和B的引用计数都还是1，因为他们互相引用了。
  这时你发现A和B将无法释放，因为要想释放A必须先释放B，在B的dealloc方法中再释放A。同理，要想释放B必须先释放A，在A的dealloc方法中再释放B。所以这两个对象将一直存在在内存中而不释放。这就是所谓的循环引用的问题。要想解决这个问题，一般的方法可以将引用的属性设置为assign,而不是retain来处理。
4、延展是什么？作用是什么？
答：延展（extension）:在自己类的实现文件中添加类目来声明私有方法。
延展（Extension）“匿名”的类目，延展定义类的私有方法，一般是在类的实现文件@implementation之上定义如：Person（） 和类目的区别在于括号里面是空的，没有名字的，暂时性的存在，只能本类调用方法，子类也无法调用父类的延展
另外在本类的实现文件@implementation之上也可以定义私有方法，私有的静态变量
延展的特点就是定义私有方法
9、内存管理的几条原则是什么？按照默认法则，哪些关键字生成的对象需要手动释放？哪些情况下不需要手动释放，会直接进入自动释放池？
•       当使用new、alloc或copy方法创建一个对象时，该对象引用计数器为1。如果不需要使用该对象，可以向其发送release或autorelease消息，在其使用完毕时被销毁。
•       如果通过其他方法获取一个对象，则可以假设这个对象引用计数为1，并且被设置为autorelease，不需要对该对象进行清理，如果确实需要retain这个对象，则需要使用完毕后release。
•       如果retain了某个对象，需要release或autorelease该对象，保持retain方法和release方法使用次数相等。
 
使用new、alloc、copy关键字生成的对象和retain了的对象需要手动释放。设置为autorelease的对象不需要手动释放，会直接进入自动释放池。
 
10、怎样实现一个单例模式的类，给出思路，不写代码。
•       首先必须创建一个全局实例，通常存放在一个全局变量中,此全局变量设置为nil
•       提供工厂方法对该全局实例进行访问，检查该变量是否为nil，如果nil就创建一个新的实例，最后返回全局实例
•       全局变量的初始化在第一次调用工厂方法时会在+allocWithZone:中进行，所以需要重写该方法，防止通过标准的alloc方式创建新的实例
•       为了防止通过copy方法得到新的实例，需要实现-copyWithZone方法
•       只需在此方法中返回本身对象即可，引用计数也不需要进行改变，因为单例模式下的对象是不允许销毁的，所以也就不用保留
•       因为全局实例不允许释放，所以retain,release,autorelease方法均需重写

30、网络传输层协议中，基于TCP/IP协议和UDP/IP的连接有什么区别？
TCP：TransmissionControl Protocol 传输控制协议TCP是一种面向连接 （连接导向）的、可靠的、基于字节流的运输层（Transport layer）通信协议， 由IETF的RFC 793说明（specified）。
UDP 是User Datagram Protocol的简称， 中文名是用户数据包协议，是OSI 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。
面向连接：是指通信双方在通信时，要事先建立一条通信线路，其有三个过程：建立连接、使用连接和释放连接。电话系统是一个面向连接的模式，拨号、通话、挂机；TCP协议就是一种面向连接的协议。
面向无连接：是指通信双方不需要事先建立一条通信线路，而是把每个带有目的地址的包（报文分组）送到线路上，由系统自主选定路线进行传输。邮政系统是一个无连接的模式，天罗地网式的选择路线，天女散花式的传播形式；IP、UDP协议就是一种无连接协议。
 
33、iOS中有哪些回调机制，并作简单的比较。
各种回调机制的比较：
1）目标动作对：当两个对象之间有比较紧密的关系时，如视图控制器与其下的某个视图。
2）代理：也叫委托，当某个对象收到多个事件，并要求同一个对象来处理所有事件时。委托机制依赖于某个协议定义的方法来发送消息。
3）通告机制：当需要多个对象或两个无关对象处理同一个事件时。
4）Block：适用于回调只发生一次的简单任务。

34、列出在编码中哪些编码习惯有助于提高代码质量、软件性能和健壮性，减少程序崩溃。
＃使用严格的命名规则（如匈牙利命名法）能够避免不必要的类型转换错误。
＃在编码前先设计好流程图或使用伪代码，清晰化整个设计意图。
＃对自己的代码进行严格的单元测试（unit testing）。
单元测试是指对软件中的最小可测试单元进行检查和验证。如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。
＃异常的处理
首先不要轻易使用异常的捕获，其次要尽可能捕获具体的异常。对于异常的处理最好能够采用封装的方式，大家统一使用。这样可以保证异常处理的一致性也可以保证当异常出现时性能的稳定。
# 使用内省的方法检查方法的输入
＃采用增量式的编程方式。
采用增量式编程和测试，会倾向于创建更小的方法和更具内聚性的类。你应该经常评估代码质量，并不时的进行许多小调整，而不是一次修改许多东西。在写了几行代码之后，就应该进行一次构建/测试。在没有得到反馈时，你不要走的太远。
＃使用工具（如Instrument）来帮助检查内存泄漏、过早释放内存、CPU使用效率等问题。
＃消除所有的编译警告，警告就是错误。
＃写防御性的代码，使用内省的方法检查传入的参数。
 
42. 类别的作用？
答：有时我们需要在一个已经定义好的类中增加一些方法，而不想去重写该类。可以使用类别对该类扩充新的方法。
注意：类别只能扩充方法，而不能扩充成员变量。
代理的作用
委托代理（degegate），目的是改变和传递控制链
 顾名思义，把某个对象要做的事情委托给别的对象去做。那么别的对象就是这个对象的代理，代替它来打理要做的事。反映到程序中，首先要明确一个对象的委托方是哪个对象，委托所做的内容是什么。
委托机制是一种设计模式。
多态：子类的指针可以赋值给父类
 
43．链表和数组的区别在哪里?
二者都属于一种数据结构
从逻辑结构来看
1. 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。
2. 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素
从内存存储来看
1. (静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小
2. 链表从堆中分配空间, 自由度大但是申请管理比较麻烦
从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反， 如果需要经常插入和删除元素就需要用链表数据结构了。
 
46. 写一个NSString类的实现
+(id)initWithCString:(const char *)nullTerminatedCStringencoding:(NSStringEncoding)encoding;
+ (id)stringWithCString: (const char*)nullTerminatedCString             encoding: (NSStringEncoding)encoding
 {   NSString *obj;
     obj = [selfallocWithZone: NSDefaultMallocZone()];
     obj = [objinitWithCString: nullTerminatedCString encoding: encoding];
     returnAUTORELEASE(obj);
}

57.自动释放池是什么,如何工作？
答：当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。
1）ojc-c是通过一种"referring counting"(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁.
2） NSAutoreleasePool就是用来做引用计数的管理工作的,这个东西一般不用你管的.
3）autorelease 和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一。

16. 类别的作用?继承和类别在实现中有何区别 ?
A 引用的对象同样 , 内存中存在了
答案: category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法， 只能添加，不能删除修改。
并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类 别具有更高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
 (2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
17. 类别和类扩展的区别。
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方 法是必须要实现的。
extensions 可以认为是一个私有的 Category 。
18. oc 中的协议和 java 中的接口概念有何不同 ?
答案: OC中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者 和 Java 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果 有实现，就会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学 习教程里
“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的 方法，你可以使用他们更好的完成工作”。
这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样 的类别去实现。然后你在后期可以直接使用这些更好的方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。”
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 “非正式协议使用 interface 修饰“，
现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
19. 什么是 KVO和 KVC?
答案: kvc: 键 – 值编码是一种间接访问对象的属性使用字符串来标识属性， 而不 是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。 kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个 button
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
 change:(NSDictionary *)change context:(void *)context {
if ([keyPath isEqualToString:@"highlighted"] ) {
[self setNeedsDisplay];
}
}
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的 道理是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
“当通过 KVC调用对象时，比如: [self valueForKey:@ ”someKey”] 时，程序会 自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方 法，如果没找到，会继续查找对象是否带有 someKey这个实例变量 (iVar) ，如果还没有 找到，程序会继续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还 是没有被实现的话，程序会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方法，还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变 量，也会查找 _someKey这个变量是否存在。 )
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从 对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多 好处，下面的两个例子说明了这样做的好处。“
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted add 一个相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
20. 代理的作用 ?
实例变量 . 因此为何上面我们只是
答案:代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。

 22. 我们说的 oc 是动态运行时语言是什么意思 ?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类
别对象指定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物
类 (life) 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物， 都继承了 life
我们只需调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息 因此也可以说，运行时机制是多态的基础 ?~~~
后，实现各自的 eat ，但是调用是 (响应了 eat 这个选择器 )。
23. 通知和协议的不同之处 ?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链 (专业术语了 ~)。但是简单分析下通知和
代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。 代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，
很多时候一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要
处理 A明星要一个发布会，代理人发出处理发布会的消息后，别称 B的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链 (has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
24. 是推送消息 ?
首先是应用程序注册消息推送。
IOS 跟 APNS Server 要 deviceToken 。应用程序接受 deviceToken 。 应用程序将 deviceToken 发送给 PUSH服务端程序。
服务端程序向 APNS服务发送消息。
APNS服务将消息发送给 iPhone 应用程序
25. 关于多态性 答案:多态，子类指针可以赋值给父类。

38. 如果我们不创建内存池，是否有内存池提供给我们 ?
答案 : 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池

 39. 什么时候需要在程序中创建内存池 ? 答案:用户自己创建的数据线程，则需要创建该线程的内存池
40. 类 NSObject 的那些方法经常被使用 ?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。 其中类方法 alloc 、 class 、 description 对象方法 init 、 dealloc 、–
performSelector:withObject:afterDelay: 等经常被使用
41. 什么是简便构造方法 ?
答案:简便构造方法一般由 CocoaTouch框架提供，如 NSNumbe的r + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法， 我们可以通过简便构造方法， 获得系统 给我们创建好的对象，并且不需要手动释放。

 45. 什么是 coredata?
答案: coredata 是苹果提供一套数据保存框架，其基于 SQlite
46. 什么是 NSManagedObject 模型 ?
答案: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成部分， 它 是一个通用的类 , 实现了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject，建立自己的数据模型。
47. 什么是 NSManagedobjectContext?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。
49. 和 coredata 一起有哪几种持久化存储机制 ?
答案:存入到文件、 存入到 NSUserDefaults( 系统 plist 文件中 ) 、存入到 Sqlite 文件数据库

50. 谈谈对 Block 的理解 ?并写出一个使用 Block 执行 UIVew动画 ?
答案: Block 是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可 以大幅提高应用的执行效率 ( 多核心 CPU可直接处理 Block 指令 )
[UIView transitionWithView:self.view
duration:0.2
options:UIViewAnimationOptionTransitionFlipFromLeft
animations:^{ [[blueViewController view] removeFromSuperview]; [[self view]
insertSubview:yellowViewController.view atIndex:0]; } completion:NULL];

59. block 实现原理
Objective-C 是对 C 语言的扩展， block 的实现是基于指针和函数指针。 从计算语言的发展，最早的 goto ，高级语言的指针，到面向对象语言的 block ，从
机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻 辑( 需求 ) 。
下面是两篇很好的介绍 block 实现的博文 iOS 中 block 实现的探究
谈 Objective-C Block 的实现
3 block 的使用
使用实例
cocoaTouch 框架下动画效果的
使用 typed 声明 block
typedef void(^didFinishBlock) (NSObject *ob);
这就声明了一个 didFinishBlock 类型的 block ，
然后便可用
@property (nonatomic,copy) didFinishBlock finishBlock;
声明一个 blokc 对象，注意对象属性设置为 copy ，接到 block 参数时，便会自动
Block 的调用
复制一份。
__block 是一种特殊类型， 使用该关键字声明的局部变量，可以被
改变。
4 常见系列面试题
面试时，面试官会先问一些，是否了解 于开场白，往往是下面一系列问题的开始，所以一定要如实根据自己的情况回答。
1 使用 block 和使用 delegate 完成委托模式有什么优点 ?
首先要了解什么是委托模式， 委托模式在 iOS 中大量应用， 其在设计模式中是适配 器模式中的对象适配器， Objective-C 中使用 id 类型指向一切对象， 使委托模式更为简 洁。了解委托模式的细节:
iOS设计模式— -委托模式
使用 block 实现委托模式， 其优点是回调的 block 代码块定义在委托对象函数内部， 使代码更为紧凑 ;
适配对象不再需要实现具体某个 protocol ，代码更为简洁。
block 所改变，并且其在原函数中的值会被
block ，是否使用过 block ，这些问题相当

 2 多线程与block
GCD与 Block
使用 dispatch_async 系列方法，可以以指定的方式执行 block
GCD编程实例
dispatch_async 的完整定义
void dispatch_async(
dispatch_queue_t queue,
dispatch_block_t block);
功能:在指定的队列里提交一个异步执行的
通过 queue 来控制 block 执行的线程。主线程执行前文定义的 finishBlock 对象 dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();});
委托是什么?委托和委托方双方的 property 声明用什么属性?为什么? 委托:一个对象保存另外一个对象的引用，被引用的对象实现了事先确定的协议，该协
议用于将引用对象中的变化通知给被引用对象。
委托和委托方双方的 property 声明属性都是 assign 而不是 retain 为了避免循环引用造成的内存泄露。
      循环引用的问题这样理解:
比如在 main函数中创建了两个类的对象 A和B，现在引用计数都是 1。现在 让A和B互相引用 (A有一个属性是 B对象，属性说明是 retain ;B有一个属性是 A对象，属 性说明是 retain) ，现在两个对象的引用计数都增加了 1，都变成了 2。
现在执行 [A release]; [B release]; 此时创建对象的 main函数已经释放了自己对 对象的所有权，但是此时 A和 B的引用计数都还是 1，因为他们互相引用了。
这时你发现 A和 B将无法释放，因为要想释放 A必须先释放 B，在B的 dealloc 方法中再 释放 A。同理，要想释放 B必须先释放 A，在 A的 dealloc 方法中再释放 B。所以这两个对象 将一直存在在内存中而不释放。这就是所谓的循环引用的问题。要想解决这个问题，一 般的方法可以将引用的属性设置为 assign, 而不是 retain 来处理。
4、延展是什么?作用是什么?
答: 延展( extension ): 在自己类的实现文件中添加类目来声明私有方法。
block ，不阻塞当前线程

 延展( Extension )“匿名”的类目，延展定义类的私有方法，一般是在类的实现文件 @implementation 之上定义如: Person()和类目的区别在于括号里面是空的， 没有名字的， 暂时性的存在，只能本类调用方法，子类也无法调用父类的延展
另外在本类的实现文件 @implementation 之上也可以定义私有方法，私有的静态变量 延展的特点就是定义私有方法
9、内存管理的几条原则是什么?按照默认法则， 哪些关键字生成的对象需要手动释放? 哪些情况下不需要手动释放，会直接进入自动释放池?
1.当使用 new、alloc 或copy方法创建一个对象时， 该对象引用计数器为 1。 如果不需要使用该对象， 可以向其发送 release 或 autorelease 消息，在其使用完毕时被 销毁。
2.如果通过其他方法获取一个对象，则可以假设这个对象引用计数为 1， 并且被设置为 autorelease ，不需要对该对象进行清理， 如果确实需要 retain 这个对象， 则需要使用完毕后 release 。
 3.如果 retain 了某个对象，需要 release 或 autorelease 该对象，保持 retain 方法和 release 方法使用次数相等。
使用 new、 alloc 、 copy 关键字生成的对象和 retain 了的对象需要手动释放。设置为 autorelease 的对象不需要手动释放，会直接进入自动释放池。

首先不要轻易使用异常的捕获， 其次要尽可能捕获具体的异常。 对于异常的处理最好能 够采用封装的方式， 大家统一使用。这样可以保证异常处理的一致性也可以保证当异常 出现时性能的稳定。
# 使用内省的方法检查方法的输入 #采用增量式的编程方式。
采用增量式编程和测试， 会倾向于创建更小的方法和更具内聚性的类。 你应该经常评估 代码质量， 并不时的进行许多小调整， 而不是一次修改许多东西。 在写了几行代码之后， 就应该进行一次构建 / 测试。在没有得到反馈时，你不要走的太远。
#使用工具(如 Instrument )来帮助检查内存泄漏、过早释放内存、 CPU使用效率等问 题。
#消除所有的编译警告，警告就是错误。 #写防御性的代码，使用内省的方法检查传入的参数。
35、 JSON中{ } 代表 _____， [ ] 代表 _____，试将下面的 JSON串用 OC对象表示出来: { "people": [
{ "firstName": "Brett","lastName":"McLaughlin", "email":"aaaa" },
{ "firstName": "Jason","lastName":"Hunter", "email": "bbbb"},
{ "firstName": "Elliotte","lastName":"Harold", "email": "cccc" } ]，
“location ”: ”中华人民共和国” }
JSON中{ } 代表对象，数据结构为{ key1:value1, key2:value2, key3:,, } [ ] 代表数组，与其他语言中的数组类似。

@interface People: NSObject

@property(nonatomic, copy) NSString* strFirstName; @property(nonatomic, copy) NSString* strLastName; @property(nonatomic, copy) NSString* strEmail;
@end

@interfaceJSonData : NSObject
@property(nonatomic, retain) NSMutableArray* arrPeople; // @property(nonatomic, copy) NSString* strLocation;
@end
37.bject-C 有私有方法吗?私有变量呢?
objective-c – 类里面的方法只有两种 , 静态方法和实例方法 .
在类里面声名一个私有方法 ?@interface Controller : NSObject
存放 People 对象
{ NSString *something;
} ?+ (void)thisIsAStaticMethod; @interface Controller
(private) -(void)thisIsAPrivateMethod;
@private 可以用来修饰私有变量 所有实例方法默认都是公有的
?– (void)thisIsAnInstanceMethod;
?@end?
?@end
?在 Objective ‐ C中，所有实例变量默认都是私有的，

57. 自动释放池是什么 , 如何工作?
答:当您向一个对象发送一个 autorelease 消息时， Cocoa就会将该对象的一个引用放入 到最新的自动释放池。 它仍然是个正当的对象，因此自动释放池定义的作用域内的其它 对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放， 池中的所有对象也就被释放。
1)ojc-c 是通过一种 "referring counting"( 引用计数 ) 的方式来管理内存的 , 对象在开 始分配内存 (alloc) 的时候引用计数为一 , 以后每当碰到有 copy,retain 的时候引用计数 都会加一 , 每当碰到 release 和autorelease 的时候引用计数就会减一 , 如果此对象的计 数变为了 0, 就会被系统销毁 .
2) NSAutoreleasePool 就是用来做引用计数的管理工作的 , 这个东西一般不用你管的 . 3)autorelease 和 release 没什么区别 , 只是引用计数减一的时机不同而已 ,autorelease
会在对象的使用真正结束的时候才做引用计数减一。

 使用 FMDatabaseQueue很简单，首先用一个数据库文件地址来初使化 FMDatabaseQueue，然 后就可以将一个闭包 (block) 传入 inDatabase 方法中。在闭包中操作数据库，而不直接参
与 FMDatabase 的管理。
12、 HTTP 协议， TCP,UDP
http :请求头、相应头、请求体、相应体

27. 什么是安全释放?
28.为什么有些 4.0独有的objective-c 函数在3.1上运行时会报错 .而 4.0独有的类在 3.1上分配内存时不会报错?分配的结果是什么?
29.为什么 4.0独有的 c函数在 3.1的机器上运行不会报错(在没有调用 的情况下?)而 4.0独有的类名在 3.1的机器上一运行就报错?
30.异常exception 怎么捕获?不同的 CPU结构上开销怎样? C中又 什么类似的方法?
31.property 中属性 retain,copy,assgin 的含义分别是什么?有什么区 别?将其转换成 get/set方法怎么做?有什么注意事项?
32.委托是什么?委托的 property 声明用什么属性?为什么? 34.Cocoa 中有虚基类的概念么?怎么简洁的实现?
35.自动释放池跟 GC(垃圾回收)有什么区别? iPhone 上有GC么? [pool release ]和[pool drain ]有什么区别? iPhone 上没有 GC。 iPhone 开发的时候没有垃圾回收机制。 在垃圾回收环境中， release 是一个空操作。因此， NSAutoreleasePool 提供了 drain 方法，在引用 计数环境中，该方法的作用等同于调用 release ，但在垃圾回收环境 中，它会触发垃圾回收 (如果自上次垃圾回收以来分配的内存大于当 前的阈值)。因此，在通常情况下，您应该使用 drain 而不是 release 来销毁自动释放池。
36. for(int index = 0; index < 20; index ++){ NSString *tempStr = @”tempStr ”;NSLog(tempStr); NSNumber *tempNumber =
[NSNumber numberWithInt:2]; NSLog(tempNumber); } 这段代 码有什么问题 .?会不会造成内存泄露(多线程)?在内存紧张的设 备上做大循环时自动释放池是写在循环内好还是循环外好?为什么?
37. 内存管理的几条原则时什么?按照默认法则 . 那些关键字生成的 对象需要手动释放?在和 property 结合的时候怎样有效的避免内存 泄露?
38. 在一个对象释放前 .如果他被加到了 notificationCenter 中 .不在 notificationcenter 中remove这个对象可能会出现什么问题?
39.怎样实现一个 singleton 的类 .给出思路。
40.什么是序列化或者 Acrchiving, 可以用来做什么 ,怎样与 copy结合,
原理是什么 ?.
42.在iphone上有两件事情要做 ,请问是在一个线程里按顺序做效率 高还是两个线程里做效率高?为什么?
43.runloop 是什么?在主线程中的某个函数里调用了异步函数，怎么 样 block 当前线程 ,且还能响应当前线程的 timer 事件， touch 事件等 .
UNIX 主要支持三种通信方式:
1. 基本通信:主要用来协调进程间的同步和互斥 (1) 锁文件通信
通信的双方通过查找特定目录下特定类型的文件
成进程间 对临界资源访问时的互斥; 例如进程 p1访问一个临界资源， 首先查看是否有一个特定类型文件， 若有，则等待一段时间再查找锁 文件。
(2) 记录锁文件
2. 管道通信:适应大批量的数据传递;

63.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象 的一个引用放入到最新的自动释放池。 它仍然是个正当的对象， 因此 自动释放池定义的作用域内的其它对象可以向它发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象 也就被释放。
1. ojc-c 是通过一种 "referringcounting"( 引用计数 )的方式来管理内存 的 , 对象在开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到
有 copy,retain 的时候引用计数都会加一 , 每当碰到 release 和 autorelease 的时候引用计数就会减一 ,如果此对象的计数变为了 0,
就会被系统销毁 . 2. NSAutoreleasePool 就是用来做引用计数的管 理工作的 ,这个东西一般不用你管的 . 3. autorelease 和release 没什 么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的 使用真正结束的时候才做引用计数减一 .

81. Objective C 中的 protocal 是什么?
@protocal obj 里面的协议就如同 java 里面的 interface 。
82. Objective C 中的 selector 是什么?
你可以理解 @selector() 就是取类方法的编号 , 他的行为基本可以等 同C语言的中函数指针 ,只不过C语言中，可以把函数名直接赋给一个 函数指针，而 Objective-C 的类不能直接应用函数指针，这样只能做 一个 @selector 语法来取 .它的结果是一个 SEL 类型。这个类型本质是 类方法的编号 (函数地址 )。

83. Objective C 中的 category 是什么 ?
Objective-C 提供了一个非常灵活的类 (Class) 扩展机制-类别
(Category) 。类别用于对一个已经存在的类添加方法 (Methods) 。你 只需要知道这个类的公开接口， 不需要知道类的源代码。 需要注意的 是，类别不能为已存在的类添加实例变量 (Instance Variables) 。
子类(subclassing) 是进行类扩展的另一种常用方法。与子类相比，类 别最主要的优点是: 系统中已经存在的类可以不需修改就可使用类别 的扩展功能。
类别的第二大优点是实现了功能的局部化封装。 类别定义可以放在一 个已存在的类 (类 A)的定义文件中 (.h)。这意味着这个类别只有在类 A 被引用的前提下才会被外部看到。 如果另一个类 (类 B) 不需要用到类 A 的功能 (没有包含类 A的 .h文件 )，也就不会看到依附类 A存在的类别。 iOS SDK 中广泛运用这种类别定义法来封装功能。
84. 什么是 Notification ?什么时候用 delegate ，什么时候用 Notification ?
观察者模式， controller 向defaultNotificationCenter 添加自己的 notification ，其他类注册这个 notification 就可以收到通知， 这些类可 以在收到通知时做自己的操作 (多观察者默认随机顺序发通知给观察 者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到他来操作，可以用 NotificationQueue 的方式安排观察者的反应顺序， 也可以在添加观察者中设定反映时间，取消观察需要在
viewDidUnload 跟dealloc中都要注销)。
delegate 针对 one-to-one 关系，并且 reciever 可以返回值给 sender ， notification 可以针对 one-to- one/many/none,reciever 无法返回值给 sender. 所以， delegate 用于 sender 希望接受到 reciever 的某个功能反 馈值，
notification 用于通知多个 object 某个事件。
85. 什么是 KVC 和KVO ?Notification 和KVO 有什么不同? KVO 在 ObjC 中是怎么实现的?
86. ViewController 的 loadView,viewDidLoad, viewDidUnload 分 别是在什么时候调用的?在自定义 ViewController 的时候这几个函数 里面应该做什么工作?
答: viewDidLoad 在 view 从 nib 文件初始化时调用， loadView 在 controller 的view为nil时调用。此方法在 编程实现view时调用 ,view 控
制器默认会注册 memory warning notification, 当view controller 的任 何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将

11. 内存管理的几条原则时什么 ?按照默认法则 .那些关键字生成的对象需要手动释放 ?在和 property 结合的时候怎样有效的避免内存泄露 ?
答:谁申请，谁释放
遵循 Cocoa Touch 的使用原则 ;
内存管理主要要避免 ―过早释放 ‖和―内存泄漏 ‖，对于 ―过早释放 ‖需要注意 @property 设置特 性时，一定要用对特性关键字，对于 ―内存泄漏 ，一定要申请了要负责释放，要细心。
 关键字 alloc 或 new 生成的对象需要手动释放 ;
设置正确的 property 属性，对于 retain 需要在合适的地方释放，

16. 类别的作用 ?继承和类别在实现中有何区别 ?
答:category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不
能删除修改， 并且如果类别和原来类中的方法产生名称冲突， 为类别具有更高的优先级。
类别主要有 3 个作用:
1). 将类的实现分散到多个不同文件或多个不同框架中。
2). 创建对私有方法的前向引用。
3). 向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
则类别将覆盖原来的方法，
17. 类别和类扩展的区别。
答: category 和 extensions 的不同在于后者可以添加属性。另外后者添加的方法是必须要实现的。
extensions 可以认为是一个私有的 Category。

 18. oc 中的协议和 java 中的接口概念有何不同 ?
答: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里
―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法， 你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。 ‖
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协
议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。

22. 我们说的 oc 是动态运行时语言是什么意思 ? 答:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
 简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 以及调用该类别对象指 定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类 (life) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们只需 调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息 ( 响应了 eat 这个选择器 )。 因此也可以说，运行时机制是多态的基础 ?
23. 通知和协议的不同之处 ? 答:协议有控制链 (has-a)的关系，通知没有。
首先我一开始也不太明白，什么叫控制链 (专业术语了 ~) 。但是简单分析下通知和代理的行 为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候 一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链 (has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
38. 如果我们不创建内存池，是否有内存池提供给我们 ?
 答 : 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
 39. 什么时候需要在程序中创建内存池 ?
答:用户自己创建的数据线程，则需要创建该线程的内存池

83. 自动释放池是什么 ,如何工作?
 答:当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最 新的自动释放 .它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向 它发送消息。 当程序执行到作用域结束的位置时， 自动释放池就会被释放， 池中的所有对象 也就被释放。
87. http 和 scoket 通信的区别。
答: http 是客户端用 http 协议进行请求，发送请求时候需要封装 http 请求头，并绑定请求
的数据，服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发 起请求， 服务器才能给响应， 一次请求完毕后则断开连接， 以节省资源。服务器不能主动给 客户端响应(除非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket 套―接字 ‖进行连接，并没有规定连接后断开，所以 客户端和服务器可以保持连接通道， 双方都可以主动发送数据。 一般在游戏开发或股票开发 这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是 CFSocketRef 。
88. TCP 和 UDP 的区别
答: TCP 全称是 Transmission Control Protocol ，中文名为传输控制协议，它可以提供可靠
的、面向连接的网络数据传递服务。传输控制协议主要包含下列任务和功能: * 确保 IP 数据报的成功传递。
* 对程序发送的大块数据进行分段和重组。
* 确保正确排序及按顺序传递分段的数据。
* 通过计算校验和，进行传输数据的完整性检查。
TCP 提供的是面向连接的、可靠的数据流传输，而 UDP 提供的是非面向连接的、不可靠的 数据流传输。
简单的说， TCP 注重数据安全，而 UDP 数据传输快点，但安全性一般。
92. fmmpeg 框架
答:音视频编解码框架，内部使用 UDP 协议针对流媒体开发，内部开辟了六个端口来接受
流媒体数据，完成快速接受之目的。 93. fmdb 框架
答:数据库框架，对 sqllite 的数据操作进行了封装，使用着可把精力都放在 sql语句上面。 94. 320 框架
答: ui 框架，导入 320 工程作为框架包如同添加一个普通框架一样。 cover(open) flower 框架 (2d 仿射技术 )，内部核心类是 CATransform3D.
107. UIView 与 CLayer 有什么区别? 答:
1).UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是
由 CoreAnimation 来实现的。它真正的绘图部分，是由一个 CALayer 类来管理。 UIView
本身更像是一个 CALayer 的管理器，访问它的跟绘图和跟坐标有关的属性。 2).UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。
3).UIView 的 CALayer 类似 UIView 的子 View 树形结构， 也可以向它的 layer 上添加子 layer ，来完成某些特殊的表示。即 CALayer 层是可以嵌套的。
4).UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻辑树，这里是代码可 以操纵的;动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作;显示
树，其内容就是当前正被显示在屏幕上得内容。
5).动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改，系统将自动进行 动画生成，动画持续时间的缺省值似乎是 0.5 秒。
 6).坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint
结构表示， 值域是 0~1 ，是个比例值。 这个点是各种图形变换的坐标原点， 同时会更改 的 position 的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。
layer
7). 渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用 setNeedsDisplay 方法来重绘显示。
8). 变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform affineTransform 属性。
或
9).变形: Quartz Core 的渲染能力，使二维图像可以被自由操纵，就好像是三维的。 以在一个三维坐标系中以任意角度被旋转， 缩放和倾斜。 CATransform3D 的一套方法提供
了一些魔术般的变换效果。
108. Quatrz 2D 的绘图功能的三个核心概念是什么并简述其作用。 答:上下文:主要用于描述图形写入哪里; 路径:是在图层上绘制的内容; 状态:用于保存配置变换的值、填充和轮廓， alpha 值等。
 
ios类是否可以多继承？如果没有，那可以用其他方法实现吗？简述实现过程。
没有用catogory 和 extension 可以实现
堆和栈的区别？
堆需要用户手动释放内存，而栈则是编译器自动释放内存
ios本地数据存储都有哪几种方式？
         1.  NSKeyedArchiver（加密形式）
         2.  NSUserDefaults
           3.  Write写入方式
     4.  SQLite3
写出方法获取ios内存使用情况。
void logMemoryInfo()
写一个便利构造器
UIImage初始化一张图片有几种方法？简述各自的优缺点。
回答person的retainCount值，并解释为什么
这段代码有什么问题吗:
这段代码有什么问题,如何修改
截取字符串”20 | http://www.baidu.com”中，”|”字符前面和后面的数据，分别输出它们。
用obj-c写一个冒泡排序
简述你对UIView、UIWindow和CALayer的理解
写一个完整的代理，包括声明，实现
分析json、xml的区别？json、xml解析方式的底层是如何处理的？
ViewController 的 didReceiveMemoryWarning 是在什么时候被调用的？默认的操作是什么?
面向对象的三大特征，并作简单的介绍
重写一个NSStrng类型的，retain方式声明name属性的setter和getter方法
简述NotificationCenter、KVC、KVO、Delegate？并说明它们之间的区别？
What is lazy loading?
什么是Protocol？什么是代理？写一个委托的interface？委托的property声明用什么属性？为什么？
分别描述类别（categories）和延展（extensions）是什么？以及两者的区别？继承和类别在实现中有何区别？为什么Category只能为对象添加方法，却不能添加成员变量？
谈谈你对MVC的理解？为什么要用MVC？在Cocoa中MVC是怎么实现的？你还熟悉其他的OC设计模式或别的设计模式吗？
如监测系统键盘的弹出
举出5个以上你所熟悉的ios  sdk库有哪些和第三方库有哪些？
如何将产品进行多语言发布？
如何将敏感字变成**
objc中的减号与加号代表什么？
单例目的是什么，并写出一个？
说说响应链
http和scoket通信的区别？socket连接相关库，TCP,UDP的区别？http的几种常用方式？

声明一个静态方法和一个实例方法？
什么是push？远程推送？
init和initwithobject区别（语法）？
请写出代码,用blocks来取代上例中的protocol,并比较两种方法的优势。实际应用部分？请写出代码，用blocks取代协议或回调方法
你做iphone开发时候，有哪些传值方式，view和view之间是如何传值的？
给定的一个字符串，判断字符串中是否还有png，有就删除它？
对于语句NSString* testObject = [[NSData alloc] init];testObject 在编译时和运行时分别是什么类型的对象？
OC中是所有对象间的交互是如何实现的？
什么是沙盒（sandbox）？沙盒包含哪些文件，描述每个文件的使用场景。如何获取这些文件的路径？如何获取应用程序包中文件的路径？
介绍一下XMPP？有什么优缺点吗？
谈谈对性能优化的看法，如何做？
应用程序如何省电？
写一个递归方法：计算N的阶乘，然后将计算结果进行存储。以便应用退出后下次启动课直接获取该值。
NSArray和NSMutableArray的区别，多线程操作哪个更安全？
当前有一个数组，里面有若干重复的数据，如何去除重复的数据？（会几个写几个）
isKindOfClass、isMemberOfClass作用分别是什么？
写出下面程序段的输出结果
NSDictionary *dict = [NSDictionary dictionaryWithObject:@"a string value" forKey:@"akey"];
NSLog(@"%@", [dict objectForKey:@"akey"]);
[dict release];
请写出以下代码的执行结果
NSString  * name = [ [ NSString alloc] init ];
name = @”Habb”;
[ name  release]；
请分别写出SEL、id的意思？

线程中有哪些函数？写出来。
有没有写过自定义的控件？
调用一个类的静态方法需不需要release？
do-while 与 while-do的区别？
写出几个死循环？
main.m中都发生了什么？
int retVal = UIApplicationMain(argc, argv, nil, nil); 是什么意思？
编写NSArray的setter和getter？
cocoa touch框架
你了解svn,cvs等版本控制工具么？
Cocoa中有虚基类的概念么？怎么简洁的实现？
关于Objective-C++中的异常处理，可以相互捕获到吗？
OC中异常exception 怎么捕获？不同的CPU结构上开销怎样？C中又什么类似的方法？
obc中可修改和不可以修改类型
获取项目根路径，并在其下创建一个名称为userData的目录？
objective-c中的类型转换分为哪几类？
xml解析的原理是什么，你还用过其他解析方式么？
iphone阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的？另外像pdf格式的文件，你如何读取。?
你在开发大型项目的时候，如何进行内存泄露检测的? 内存泄露怎么处理？
iphone app为什么会被打回来，如何制止?
iphone应用程序的项目基本结构？
编译语言和解释语言的区别
给用户推送的通知的伪代码
什么是动态链接库和静态链接库？调用一个类的静态方法需不需要release？
OC中的数字对象都有哪些，简述它们与基本数据类型的区别是什么
在一个对象释放前.如果他被加到了notificationCenter 中，在notificationcenter中remove这个对象可能会出现什么问题？
你连接服务器用的是什么方法，如果请求过程中，网络出了问题这么办？
委托是什么？委托的property声明用什么属性？为什么？
fmmpeg框架(了解一下)、fmdb框架(了解一下)、320框架（了解一下）
说说UISplitViewController的使用机制
你了解哪些加密方式？
请简述cocoa中 NSWindowController类的作用？
请用objective - c实现将一段NSString字符串放入剪贴板的代码，并加中文注释？
请用objective - c 实现获得当前运行模块的路径，并添加中文注释？
不使用继承，为NSStirng类添加新方法 myPrint？
单链表、多链表区别？
制作相册，写思路和步骤
做过哪些动画，举例说明

环信相关面试题:
1 、对环信的理解:主要回答环信是干嘛的，有哪些优 缺点，使用的什么通讯协议
环信是一个即时通信的服务提供商
环信使用的是 XMPP 协议，它是再 XMPP 的基础上进行二次开发，对服 务器 Openfire 和客户端进行功能模型的添加和客户端 SDK 的封装，环信 的本质还是使用 XMPP，基本于Socket的网络通信 环信内部实现了数据缓存， 会把聊天记录添加到 数据库 ，把附件 (如音频 文件，图片文件 )下载到本地， 使程序员更多时间是花到用户即时体验上 环信内部已经实现了视频，音频，图片，其它附件发送功能 环信使用公司可以节约时间成本，不需要公司内部搭建服务器，客户端 的开发，使用环信 SDK比使用XMPPFramework 更简洁方便
2 、环信中图片消息以及语言消息实现的逻辑是什么 图片消息:首先通过相册或相机得到图片对象，然后将图片转换成
NSData 类型或将图片保存到沙盒，通过环信的 EMImageMessageBody 的 initWithData 或者 initWithLocalPath 方法，构造出图片消息，然后发
送出去，收到图片消息时，客户端会主动将图片下载到本地，同时消息
对象包含两个路径(本地和网络)，我们可以根据路径得到图片，然后
显示
AVAudioRecorder 类进行录音，将 录音文件转化成 NSData类型或将文件保存到沙盒，构造出语音
消息，然后发送出去，收到语音消息时，客户端会主动将图片下载到本
地，同时消息对象包含两个路径(本地和网络)，我们可以根据路径得
语音消息:首先通过
AVAudioPlayer 类继续播放 3 、环信中是怎么实现好友管理的
所谓的好友管理就是好友关系的维护，包括增、删以及黑名单的设置，环信
到文件，然后通过
IEMContactManager 类有关，好友
中好友相关的操作都与
列表可以通过 FriendListViewController 方法获得，好友的增加可以通过两种方式，一是主动添加 (addContact )，一是被动添加
( didReceiveFriendInvitationFromUsername )， 删除好友关系的方法是 deleteContact ，同时可以 通过addUserToBlackList 方法将好友拉近黑名单
4、即时通讯 app 中的气泡聊天是怎么处理图片拉伸的 气泡拉伸有三种方式:
1、 ios5 之前:
- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapW
idth topCapHeight:(NSInteger)topCapHeight; 这个方法只有 2个参数， leftCapWidth 代表左端盖宽度， topCapHeight 代表顶端盖高度。 系统会自动计算出右端盖宽度 (rightCapWidth) 和底端盖高度 (bottomCapHeight) ，使用这个方法只会拉伸图片中间的区域， 并不 会影响到边缘和角落
2、 ios5 :
- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets 这个方法只接收一个 UIEdgeInsets 类型的参数，可以通过设置 UIEdgeInsets 的left 、right 、top 、bottom 来分别指定左端盖宽 度、右端盖宽度、顶端盖高度、底端盖高度
3、ios6 :
- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets
。
resizingMode:(UIImageResizingMode)resizingMode ，
对比 iOS5.0 中的方法，只多了一个 UIImageResizingMode 参数，用
来指定拉伸的模式:
? UIImageResizingModeStretch :拉伸模式，通过拉伸 UIEdgeInsets 指定的矩形区域来填充图片
? UIImageResizingModeTile :平铺模式，通过重复显示 UIEdgeInsets 指定的矩形区域来填充图片
5 、环信与公司自己的服务器是怎么结合使用的环信中有自己的一套用户信息，同时我们自己的服务器也有自己的用户表，该表中 保存着 app 中的用户名、密码、性别等嘻嘻，同时存着环信的用户名、密码，客户
端的登陆首先会登进自己的服务器，然后在登进环信，这样我们的 app 就可以对用 户提供很多东西
6 、环信中单聊与群聊消息的区分 环信中的聊天分三种 : EMChatTypeChat( 单
聊 )/EMChatTypeGroupChat (群聊)
/EMChatTypeChatRoom (聊天室)，我们可以通 过message 的chatType 来区分聊天类型
7 、环信中，收到消息时，怎么区分是谁发出的 通过每条消息的会话 ID ，无论是单聊还是群聊，在发送
消息时都会跟随一个 这个 ID区分消息
ConversationID ，我们可以根据
8 、如果要在环信中实现聊天记录的功能，怎么处理 首先，环信自己帮我们保存了聊天记录的，如果我们需要自己实现，则可以将消息 保存的本地数据库，或者服务端
9 、怎么通过环信实现阅后即焚需求 可以通过消息扩展配合已读回执进行实现。 流程如下:
A-->B 发送阅后即焚消息: 首先，如果是阅后即焚消息，需要在消息中标明，该消息是阅后即焚，
这个时候，
用到了 EMMessage 的 ext 属性，
NSMutableDictionary *fireDict = [NSMutableDictionary dictionary];
message.ext = [NSDictionary dictionaryWithObject:[NSNumbernumberWithBool:YES] forKey:@"isFire"]; [fireDictsetObject:messageforKey:message.messageId]; [[EaseMobsharedInstance].chatManagerasyncSendMessage:message progress:nil];
到此， A构建了一个带有 ext的message，其中带有 isFire的key，并且将 其发出给 B。
同时，我本地维护了一个 dict ，里面的 key 为 messageID ， value 为阅后 即焚的 message
当 B实现了 IChatManagerDelegate 委托，会调用回调方法，收到 A发来 的消息
B收到消息: -(void)didReceiveMessage:(EMMessage *)message{
// 此时收到了 A 发来的消息， 这个时候， 我们需要对这个消息进行分析， 看它是否是阅后即焚的消息
BOOL isFire = [[message.extobjectForKey:@"isFire"] boolValue];
如果该消息为阅后即焚，在 B看过这条消息后，调用
- (void)sendHasReadResponseForMessage:(EMMessage *)message; 方法，向 A发送 “已读”
如 A实现 IChatManagerDelegate 委托，会调用方法:
- (void)didReceiveHasReadResponse:(EMReceiptResp *)resp;
具体处理如下，
A收到消息后:从我们的 fireDict 中，通过 id ，查找该 message 是否存在 EMMessage *message = [fireDictobjectForKey:resp.chatId]; 此时如果存在，说明该消息是阅后即焚，且 B已读。
接下来就是 ui处理和db处理，
到目前为止，可以判断 B收到的消息是否为阅后即焚消息。
EMConversation *conversation = [[EaseMobsharedInstance].chatManager conversationForChatter:resp.from
isGroup:NO]; // 因为只有单聊中存在阅后即焚，所以 isGroup 始终为 NO
通过 resp.from 来查到 message 对应的 conversation ， [conversationremoveMessage:resp.chatId];
然后调用删除 message 的接口把它删掉，之后处理 ui 上的删除。 此时，阅后即焚功能就已经完成。
7. 大量数据表的优化方案
1. 对查询进行优化， 要尽量避免全表扫描， 首先应考虑在 where 及 order by 涉
及的列上建立索引。
2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃 使用索引而进行全表扫描，如
1select id from t where num is null
最好不要给数据库留 NULL，尽可能的使用 NOT NULL填充数据库 . 备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用 NULL。
不要以为 NULL 不需要空间，比如: char(100) 型，在字段建立时，空间就固定 了， 不管是否插入值( NULL也包含在内)，都是占用 100 个字符的空间的，如 果是 varchar 这样的变长字段， null 不占用空间。
可以在 num上设置默认值 0，确保表中 num列没有 null 值，然后这样查询: 1select id from t where num=0
3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索 引而进行全表扫描。
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一 个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如:
1select id from t where num=10 or Name='admin'
可以这样查询:
1select id from t where num=10 union all select id from t where Name='admin'
5.in 和 not in 也要慎用，否则会导致全表扫描，如: 1select id from t where num in (1,2,3) 对于连续的数值，能用 between 就不要用 in 了:
1select id from t where num between 1 and 3 很多时候用 exists 代替 in 是一个好的选择:
1select num from a where num in (select num from b)
用下面的语句替换:
1select num from a where exists (select 1 from b where num =a.num)
6. 下面的查询也将导致全表扫描:
1s elect id from t where name like ‘ %abc%’
若要提高效率，可以考虑全文检索。
7. 如果在 where 子句中使用参数， 也会导致全表扫描。 因为 SQL只有在运行时 才会解析局部变量， 但优化程序不能将访问计划的选择推迟到运行时; 它必须在 编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的， 因而无法作为索引选择的输入项。如下面语句将进行全表扫描:
1select id from t where num=@num
可以改为强制查询使用索引:
1select id from t with (index( 索引名)) where num=@num
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索 引而进行全表扫描。如:
1select id from t where num/2=100
应改为 :
1select id from t where num=100*2
9. 应尽量避免在 where 子句中对字段进行函数操作， 这将导致引擎放弃使用索引 而进行全表扫描。如:
select id from t 1abc 开头的 id
2select id from t
0 -–‘2015-11- 30’ 应改为 :
where substring(name,1,3)= ’abc’ -–name以
where datediff(day,createdate, -- 生成的 id
’2015-11- 30′)=
and createdat
select id from t where name like'abc%' 1
select id from t where createdate>='2005-11-30' 2
e<'2005-12-1'
10. 不要在 where 子句中的“ =”左边进行函数、算术运算或其他表达式运算，
否则系统将可能无法正确使用索引。
11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索 引中的第一个字段作为条件时才能保证系统使用该索引， 否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。
12. 不要写一些没有意义的查询，如需要生成一个空表结构:
1select col1,col2 into #t from t where1=0
这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样:
1create table #t(,)
13.Update 语句，如果只更改 1、2 个字段，不要 Update 全部字段，否则频繁调
用会引起明显的性能消耗，同时带来大量日志。
14.对于多张大数据量(这里几百条就算大了)的表 JOIN，要先分页再 JOIN，否 则逻辑读会很高，性能很差。
15.select count(*) from table ;这样不带任何条件的 count 会引起全表扫描， 并且没有任何业务意义，是一定要杜绝的。
16. 索引并不是越多越好， 索引固然可以提高相应的 select 的效率， 但同时也 降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索 引，所以怎样建索引需要慎重考虑， 视具体情况而定。 一个表的索引数最好不要 超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
17. 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列 的顺序就是表记录的物理存储顺序， 一旦该列值改变将导致整个表记录的顺序的 调整，会耗费相当大的资源。 若应用系统需要频繁更新 clustered 索引数据列， 那么需要考虑是否应将该索引建为 clustered 索引。
18. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会 降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接
时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
19. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存 储空间小，可以节省存储空间， 其次对于查询来说， 在一个相对较小的字段内搜 索效率显然要高些。
20. 任何地方都不要使用
1select * from t
用具体的字段列表代替“ * ”，不要返回用不到的任何字段。
21. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常 有限(只有主键索引)。
22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可 使用， 适当地使用它们可以使某些例程更有效， 例如， 当需要重复引用大型表或 常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。
23. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table ，避免造成大量 log ，以提高速度;如果数据量不大，为了
缓和系统表的资源，应先 create table ，然后 insert 。
24. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先
truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
25. 尽量避免使用游标， 因为游标的效率较差， 如果游标操作的数据超过 1 万行，
那么就应该考虑改写。
26. 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决 问题，基于集的方法通常更有效。
27. 与临时表一样， 游标并不是不可使用。 对小型数据集使用 FAST_FORWAR游D 标通常要优于其他逐行处理方法， 尤其是在必须引用几个表才能获得所需的数据 时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。 如果开发 时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的 效果更好。
28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT O，N在结束时设置 SET NOCOUNT OF。F无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PRO消C息。
29. 尽量避免大事务操作，提高系统并发能力。
30. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
实际案例分析:拆分大的 DELETE或 INSERT语句，批量提交 SQL语句
如果你需要在一个在线的网站上去执行一个大的 DELETE或 INSERT 查询，你需 要非常小心， 要避免你的操作让你的整个网站停止相应。 因为这两个操作是会锁 表的，表一锁住了，别的操作都进不来了。
Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服 务器也不希望有太多的子进程， 线程和数据库链接， 这是极大的占服务器资源的
事情，尤其是内存。
如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站 点来说，这 30 秒所积累的访问进程 / 线程，数据库链接，打开的文件数，可能不 仅仅会让你的 WEB服务崩溃，还可能会让你的整台服务器马上挂了。
所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top) 条件是一个好的方法。 下面是一个 mysql 示例:
1while(1){// 每次只做 1000条
 mysql_query( “delete from logs where log_date < ’2015-11- 01’ limit 1000”);
usleep(50000)
}
11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效 果。
12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。
13. 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI 。如果有 需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成， imageDecoder:didFinishDecodingImage:userInfo: 回调给
SDWebImageDownloade。r
15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager告知
图片下载完成。
16. 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17. 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到 硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18.SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台 的时候清理内存图片缓存，应用结束的时候清理过期图片。
19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便 使用。
20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。
SDWebImag库的作用
通过对 UIImageView的类别扩展来实现异步加载替换图片的工作。
主要用到的对象:
1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调
2、 SDWebImageManag，er对图片进行管理的中转站，记录那些图片正在读取。
向下层读取Cache(调用SDImageCach)e，或者向网络读取对象(调用 SDWebImageDownloade)r 。
实现SDImageCache和SDWebImageDownloade的r回调。 3、SDImageCach，e根据URL的MD5摘要对图片进行存储和读取(实现存在内存
中或者存在硬盘上两种实现) 实现图片和内存清理工作。
4、SDWebImageDownloade，r根据 URL向网络读取数据(实现部分读取和全部读 取后再通知回调两种方式)
其他类: SDWebImageDecod，er异步对图像进行了一次解压?? 1、 SDImageCache是怎么做数据管理的?
SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。内存层面 的相当是个缓存器， 以 Key-Value 的形式存储图片。 当内存不够的时候会清除所 有缓存图 片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位， 剔除时间大于一周的图片文件。 当 SDWebImageManage向r SDImageCache要资源 时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从 磁盘读取出来，然后做 Decoder，将图片对 象放到内存层面做备份，再返回调 用层。
2、为啥必须做 Decoder??
由于 UIImage 的 imageWithData 函数是每次画图的时候才将 Data 解压成 ARGB 的图像，所以在每次画图的时候，会有一个解压操作，这样效率 很低，但是只 有瞬时的内存需求。为了提高效率通过 SDWebImageDecode将r包装在Data下的 资源解压，然后画在另外一张图片上， 这样这张新 图片就不再需要重复解压了。
这种做法是典型的空间换时间的做法。
有关 SDWebImage 一、 clear 和 clean 的区别 ?
clear 先把之前的缓存文件夹删除掉 ,然后在新建一个文件夹
clean 先删除过期的文件 ,然后计算剩余缓存文件的大小 (currrentSize)>maxSize, 继续删除 , 按
照它缓存文件创建的时间删除 ,直到 (currrentSize)<=maxSize 二、内存缓存机制 ?
NSCache
三、使用缓存的目的 是为了使用的应用程序能更快速的响应用户输入，使程序高效的运行。
四、内存缓存时间是多久 ? 一周
五、 SDWeblmage 任务的执行 ?是怎么实现的 ? 两种 :先进先出和先进后出
实现 :依赖来实现的
六、默认的缓存路径 沙盒下的 default 下
七、怎么处理图片的名称 ? 对 URL 进行 MD5 加密
八、如何判读图片的首个字节 得到二进制的首个字节
十、 默认的超时时间是多少 ? 15 秒
十一、该框架内部对内存警告的处理方式 ? 监听系统发出的警告通知 ,然后清空内存缓存
十二、如何计算图片的成本 ? 长宽缩放比例 * 缩放比例
image.size.height * image.size.width * image.scale * image.scale
十三、保证错误的 URL 不会被尝试重新下载 因为内部设置了一个黑名单 (内部是 NSMutableset)
十四、最大的并发线程数是多少?
最大并发数是指执行任务的线程最多是两个 ,但是 ,处于回收状态的线程不算此列 .也就是说 , 执行任务的时候不只有两个线程 ,还有处于回收状态的线程 . 加起来最多也就六个。
十五、 ios允许最近本地通知数量最大为多少?
通知完一定要取消 , iOS 最多允许最近本地通知数量是 64 个 ,超过限制的本地通知将被忽略。
结语 :与 SDWebImage 相关的面试题差不多就这么多了 有遗漏的或者有错误的地方，欢迎小伙伴们在北风社区进行补充和斧正。
CALayer 和 UIView 的区别联系
(1) UIView 是 UIKIt 的只能在 iOS 使用 , CALayer 是 QuartzCore 的 iOS 和 mac os 通用 (2) CALayer 比 UIView 更加轻量级 ,但是可以实现同样的效果
(3)UIView 的 CALayer 类似 UIView 的子 View 树形结构
(4)UIView 比 CALayer 多了一个事件处理功能 ,也就是说 UIView 能处理用户触摸
( 5) UIView 有个重要的属性 layer, 可以返回它的主 CALayer 实例 .CALayer *layer = myView.layer
(6)坐标系统 : CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性
(7) UIView 是 iOS 系统中界面的基本元素 ,所有的界面元素都是继承自它 .它本身完全是由
CoreAnimation 来实现的 .它真正的绘图部分 ,是由一个 CALayer 类来管理的 .UIView 本身更像 是一个 CALayer 的管理权 ,访问它的跟绘图和跟坐标有关的属性 ,如 frame,bounds 等 ,实际上内
部都是在访问它所包含的 CALayer 的相关属性 .
layer 可以设置圆角显示 cornerRadius 也可以设置阴影 shadowColor 但是如果 layer 中某个
layer 设置了圆角 中所有 layer 的阴影效果将都不显示 .因此要死设置有圆角还要阴影 ,可以 做两个 UIView 重叠 ,一个 layer 显示圆角一个 layer 显示阴影
( 8)渲染:当更新层 改变不能立即显示在屏幕上 .当所有的层都准备好时 , 可以调用 setNeedsDisplay 方法来重绘显示 .
( 9 )变换:要在一个层中添加一个 3D 或仿射变换 , 可以分别设置层的 transform 或者 affineTransform 属性
( 10 )变形: Quartz Core 的渲染能力 使二维图像可以被自由的操纵 ,就像是三维的 .图像可 以在一个三维坐标系中以任意的角度被旋转 缩放 和倾斜 .CATransform3D 的一套方法提供 了一些魔术般的效果。
四. 简要说明什么时候使用继承 ,什么时候使用类别
在 OC 中 ,一个类继承另一个类 ,就是继承了父类所有的属性和方法 ,并且可以扩充自己的属性 而类别是在不改变原有类的基础上进行方法扩充 ;
因此 ,根据开发需求 ,如果这个类需要扩充属性 ,或者需要重写系统的类的某些方法 ,用继承 ;如 果只是对一个类扩充接口和模块 , 使用类别更加方便 .
六 关键字 const 有什么含意 ?修饰类呢 ?static 的作用 , 用于类呢 ?还有 extern c 的作用 ?
const 修饰基数数据类型变量时 ,该变量就变为常量 ,进入静态区 const 修饰指针类型变量时 :
const 在指针类型两边 , 那么该指针变量指向的内存空间的内容就不能改变了 ,但指针
的指向可以改变 .
如果 const 在变量的左边 , 那么该指针的指向不能改变了 ,而指向内存空间的内容可以改变
当使用 const 修饰符时 ,const NSSting *str, 相当于修饰该对象 ,表示对象是不可更改的 .
static 修饰变量 ,表示这个内部全局变量 ,只能在本文件中访问 .系统会将该变量放进静态区的生命周期被延长到了程序结束
static 修饰类 , 表示这个内部的方法 , 只能在本文件中访问 .
extern c 表示声明了一外部变量 , 多个外部变量如果同名 ,实际指向的是同一块存储空间
十六 . NSTimer 和 GCD 的定时器有什么区别
NSTimer 可以调用 invalidate 进行撤销 ,创建和撤销必须在同一线程
NSTimer 需要交定时器添加到当前的 runloop 中 它的时间单位是秒
GCD 一旦执行就不能撤销
CGD 中的定时器不受 runloop 模式的影响
时间单位是纳秒

16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系， 并且 reciever 可以返回值 给 sender ，notification 可以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。
17 什么是 KVC 和 KVO ?答: KVC(Key-Value-Coding) 内部的实现:一个对象在调用 setValue 的时候，( 1)首先根据方法名找到运行方法的时候所需要的环境参数。( 2 )他
会从自己 isa 体的方法实现。
被观察对象的
指针结合环境参数，找到具体的方法实现的接口。( 3 )再直接查找得来的具 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，
isa 指针被修改的时候， isa 指针就会指向一个中间类，而不是真实的类。所以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于 isa 指针。 在调用类的方法的时候，最好要明确对象实例的类名
18ViewController 的 loadView, viewDidLoad, viewDidUnload 分别是在什么时候调用的? 在自定义 ViewController 的时候这几个函数里面应该做什么工作?答: viewDidLoad 在
view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。此方法在编 程实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release, 如果是 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。
"NSMutableString *" 这个数据类型则是代表的。
而 NSString 只是对象的指针而已。
面向过程就是分析出解决问题所需要的步骤，
时候一个一个依次调用就可以了。
面向对象是把构成问题事务分解成各个对象， 为了描叙某个事物在整个解决问题的步骤中的行为。;

25 .Difference between categories and extensions?
只能添加，
因为类别具有更
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须
要实现的。
extensions 可以认为是一个私有的 Category 。
26 .Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接
口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 ―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法， 你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协 议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。


27What is purpose of delegates?
代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
28What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。
答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的， 后者可 以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动态运行时语言是什么意思? 答案:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~
30 what is difference between NSNotification and protocol?
通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 ~)。但是简单分析下通知和代理的 行为模式，我们大致可以有自己的理解
以及调用该类别对象指
意思就是假设生物类 ( life )
eat ，但是调用是我们只需
eat 这个选择器)。

36 NSOperation queue?
答案:存放 NSOperation 的集合类。
操作和操作队列，基本可以看成 java 中的线程和线程池的概念。用于处理 ios 多线程开发 的问题。
网上部分资料提到一点是，虽然是 queue ，但是却并不是带有队列的概念，放入的操作并 非是按照严格的先进现出。
这边又有个疑点是， 对于队列来说， 先进先出的概念是 Afunc 添加进队列， Bfunc 紧跟着也 进入队列， Afunc 先执行这个是必然的，
但是 Bfunc 是等 Afunc 完全操作完以后， B 才开始启动并且执行，因此队列的概念离乱上 有点违背了多线程处理这个概念。
但是转念一想其实可以参考银行的取票和叫号系统。
因此对于 A 比 B 先排队取票但是 B 率先执行完操作，我们亦然可以感性认为这还是一个队
列。
但是后来看到一票关于这操作队列话题的文章，其中有一句提到 ―因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。 ‖ 瞬间觉得这个 queue 名字有点忽悠人了，还不如 pool~ 综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。
37What is lazy loading?
答案:懒汉模式，只在用到的时候才去初始化。
也可以理解成延时加载。
我觉得最好也最简单的一个列子就是 tableView 中图片的加载显示了。 一个延时载，避免内存过高，一个异步加载，避免线程堵塞。

38 Can we use two tableview controllers on one viewcontroller? 是否在一个视图控制器中嵌入两个 tableview 控制器?
答案:一个视图控制只提供了一个 View 视图，理论上一个 tableViewController 也不能放吧， 只能说可以嵌入一个 tableview 视图。当然，题目本身也有歧义，如果不是我们定性思维认
为的 UIViewController ，
而是宏观的表示视图控制者， 那我们倒是可以把其看成一个视图控制者， 它可以控制多个视 图控制器，比如 TabbarController
那样的感觉。
39 Can we use one tableview with two different datasources? How you will achieve this?
一个 tableView 是否可以关联两个不同的数据源?你会怎么处理?
答案: 首先我们从代码来看， 数据源如何关联上的， 其实是在数据源关联的代理方法里实现 的。
因此我们并不关心如何去关联他， 他怎么关联上， 方法只是让我返回根据自己的需要去设置 如相关的数据源。
因此， 我觉得可以设置多个数据源啊， 但是有个问题是， 你这是想干嘛呢?想让列表如何显 示，不同的数据源分区块显示?
40id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object 的一个指针，这
个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject )类的对象。需 要注意的是 id 是一个指针，所以你在使用 id 的时候不需要加星号。比如 id foo=nil 定义了
一个 nil 指针，这个指针指向 NSObject 的一个任意子类。 而 id *foo=nil 则定义了一个指针， 这个指针指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C 语言的 NULL 相同，在 objc/objc.h 中定义。 nil 表示一个 Objctive-C 对象，这个对 象的指针指向空(没有东西就是空)。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类 (是 Class ，而不是对象) 。 SEL 是―selector ‖的一个类型，表示一个方法的名字
Method (我们常说的方法)表示一种类型，这种类型与 selector 和实现 (implementation) 相关

IMP 定义为 id (* IMP ) ( id, SEL , ⋯)。这样说来， IMP 是一个指向函数的指针，这个被指向 的函数包括 id( ―self ‖指针 ) ，调用的 SEL (方法名)，再加上一些其他参数 . 说白了 IMP 就是 实现方法。
41 层和 UIView 的区别是什么?
答:两者最大的区别是 , 图层不会直接渲染到屏幕上， UIView 是 iOS 系统中界面元素的基础， 所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图 部分，是由一个 CALayer 类来管理。UIView 本身更像是一个 CALayer 的管理器。一个 UIView 上可以有 n 个 CALayer ，每个 layer 显示一种东西，增强 UIView 的展现能力。

44. 可扩展标记语言 extensible markup language;XML
2. 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一
种允许用户对自己的标记语言进行定义的源语言。
3，数据库提供了更强有力的 数据存储 和分析能力，例如:数据索引、排序、查找、相关一
致性等， XML 仅仅是存储数据。
46 ASIDownloadCache 设置下载缓存
它对 Get 请求的响应数据进行缓存(被缓存的数据必需是成功的
[ASIHTTPRequest setDefaultCache:[ASIDownloadCache sharedCache]];
当设置缓存策略后，所有的请求都被自动的缓存起来。 另外，如果仅仅希望某次请求使用缓存操作，也可以这样使用: ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url]; [request setDownloadCache:[ASIDownloadCache sharedCache]];
200 请求):
缓存存储方式
你可以设置缓存的数据需要保存多长时间， ASIHTTPRequest a，ASICacheForSessionDurationCacheStoragePolicy ，默认策略，基于 session 的缓存数 据存储。当下次运行或 [ASIHTTPRequest clearSession] 时，缓存将失效。
b， ASICachePermanentlyCacheStoragePolicy ，把缓存数据永久保存在本地，
提供了两种策略:
ASIHTTPRequest *request = [ ASIHTTPRequest requestWithURL:url ];
[ request setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy ];
47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议， 由于其简捷、快速的方式，适用于分布式超媒 体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基于
TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速:客户向服务器请求服务时， 只需传送请求方法和路径。
HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于
得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活:HTTP 允许传输任意类型的数据对象。 正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
48 URL
HTTP URL (URL 是一种特殊类型的 URI 是他的子类， 包含了用于查找某个资源的足够的信
息 ) 的格式如下:
错误 ! 超链接引用无效。 ]
http 表示要通过 HTTP 协议来定位网络资源; host 表示合法的 Internet 主机域名或者 IP 地 址; port 指定一个端口号，为空则使用缺省端口 80 ; abs_path 指定请求资源的 URI ;如果 URL 中没有给出 abs_path ，那么当它作为请求 URI 时，必须以 ―的/ ‖形式给出，通常这个工 作浏览器自动帮我们完成。
49TCP/UDP 区别联系
请求方法常用的有 GET 、 HTTP 协议简单，使Content-Type 加以标记。
 TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能 建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包;
2. 主机 B 向主机 A 发送同意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收， 协调工作)的数据包; 3. 主机 A 再发出一个数据包确认主机 B 的要求同步: ―我现在就发， 你接着吧! ‖，这是第三次对话。三次 ―对话 ‖的目的是使数据包的发送和接收同步， 经过三次
―对话 ‖之后，主机 A 才向主机 B 正式发送数据。
UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协议。它是面向非连接
的协议，它不与对方建立连接，而是直接就把数据包发送过去! 少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接 传输可靠性可靠不可靠 应用场合传输大量数据少量数据 速度慢快
50 socket 连接和 http 连接的区别
简单说， 你浏览的网页 (网址以 http:// 开头 )都是 http 协议传输到你的浏览器的
于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层
ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
UDP 适用于一次只传送
, 而 http 是基连接的
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接:http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read
–> 关闭 close ‖模式来操作。我的理解就是 Socket 就是该模式的一个实现， socket 即是一 种特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数 我们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样 的话，如果没有应用层， 便无法识别数据内容， 如果想要使传输的数据有意义， 则必须使用 到应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自己定义应用 层协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信
的能力。 )
2 )Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数
接口。
51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过 ―四次握手 (‖过程就不细写了， 就是服务器和客户端交互， 最终确定断开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址
和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。
55、oc语法里的 @perpoerty 不用写 @synzhesize 了，自动填充了。并且的 _name; 写方法时候不用提前声明。 llvm 全局方法便利。
枚举类型。 enum hello:Integer{ } 冒号后面直接可以跟类型，以前是: enum hello{} 后面在指定为 Integer .
桥接。 ARC 自动 release retain 的时候 CFString CFArray . Core Fountion. 加上桥接 _brige 才能区分 CFString 和 NSString 而现在自动区分了，叫固定桥接。
下拉刷新封装好了。
UICollectionViewController. 可以把表格分成多列。
Social Framework( 社交集成 ) UIActivityViewController 来询问用户的社交行为
缓存:就是存放在临时文件里，比如新浪微博请求的数据， 值。
和图片，下次请求看这里有没有
56Singleton (单例模式)，也叫单子模式，是一种常用的软件设计模式。在应用这个 模式时，单例对象的类必须保证只有一个实例存在。
代码如下:
static ClassA *classA = nil
+ (ClassA *)sharedManager
{
@synchronized(self) {
if (!classA) {
classA = [[super allocWithZone:NULL]init]; }
return classA;
}
}
+ (id)allocWithZone:(NSZone *)zone {
; //静态的该类的实例
return [[self sharedManager] retain]; }
- (id)copyWithZone:(NSZone *)zone { return self;
}
- (id)retain {
return self;
}
- (NSUIntger)retainCount {
return NSUIntgerMax;
}
- (oneway void)release { }
- (id)autorelease { return self;
}
-(void)dealloc{
}
12 怎样防止指针的越界使用问题 ? 必须让指针指向一个有效的内存地址 ,
1 防止数组越界
 2 防止向一块内存中拷贝过多的内容
  3 防止使用空指针
4 防止改变 const 修改的指针
5 防止改变指向静态存储区的内容
6 防止两次释放一个指针 7 防止使用野指针 .
13 指针的类型转换
指针转换通常是指针类型和 void * 类型之前进行强制转换 ,从而与期望或返回 void 指针的函 数进行正确的交接 .
63static 有什么用途?(请至少说明两种) 1. 限制变量的作用域
2. 设置变量的存储域
7. 引用与指针有什么区别?
1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。 2) 不存在指向空值的引用，但是存在指向空值的指针。
64 全局变量和局部变量在内存中是否有区别?如果有，是什么区别? 全局变量储存在静态数据库，局部变量在堆栈
10. 什么是平衡二叉树? 左右子树都是平衡二叉树且左右子树的深度差值的绝对值不大于 1
13. 冒泡排序算法的时间复杂度是什么? O(n^2)
1 、局部变量能否和全局变量重名?
答:能，局部会屏蔽全局。要用全局变量，需要使用 "::" 局部变量可以与全局变量同名， 在函数内引用这个变量时， 会用到同名的局部变量，
不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局 部变
量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就 在那
个循环体内
2 、如何引用一个已经定义过的全局变量?
答: extern
可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用
某个
    在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如
果你
用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而接期间报错

1. iOS类是否可以多继承?如果没有， 那可以用其他方法实现吗?简述实现过程。 不可以，可以通过消息转发、 delegate 和 protocol 和类别来实现类似多继承。
1. iOS本地数据存储都有哪几种方式? iOS如何实现复杂对象的存储? NSKeyedArchiver (归档)采用归档的形式来保存数据，该数据对象需要遵守
NSCoding协议，并且该对象对应的类必须提供 encodeWithCoder: 和initWithCoder: 方法。
1. NSUserDefaults :用来保存应用程序设置和属性、用户保存的数据。用户再 次打开程序或开机后这些数据仍然存在。 NSUserDefaults 可以存储的 数据类型包括: NSData 、NSString 、NSNumber 、NSDate 、NSArray 、 NSDictionary 。
2. Write 写入方式:永久保存在磁盘中。
3. SQLite ( FMDB 、 CoreData )
NSCoding + NSKeyedArchiver 实现复杂对象的存储。

2. 简述你对 UIView 、UIWindow和 CALayer的理解
UIView 继承于 UIResponder, UIResponder 继承于 NSObject,UIView 可以响应
用户事件。 CALayer 继承于 NSObject ，所以 CALayer 不能响应事件。 UIView 构建界 面 ,UIView 侧重于对内容的管理， CALayer 侧重于对内容的绘制。 UIView 是用来显 示内容的，可以处理用户事件; CALayer 是用来绘制内容的， 对内容进行动画处理， 依赖与 UIView 来进行显示，不能处理用户事件。

1. 什么是 Protocol?什么是代理?写一个委托的 interface?委托的 property声明 用什么属性?为什么? 协议提供了一组方法，但是并不负责实现，如果一个 类遵循了某个协议，并且实现了协议里面的方法，那么我们称这个类就是遵 循了某个协议的代理。属性的声明使用 assign ，防止出现循环引用的问题。
1. 分别描述类别(categorie)s和延展(extensions)是什么?以及两者的区别? 继承和类别在实现中有何区别?为什么 Category只能为对象添加方法， 却不能 添加成员变量?
category 类目:在不知道源码的情况下为一个类扩展方法， extension : 为一个类声明私有方法和变量。继承是创建了一个新的类，而类别
只是对类的一个扩展，还是之前的类。类目的作用就是为已知的类添加方法。

1. 如 何 监 测 系 统 键 盘 的 弹 出 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector( name:UIKeyboardWillShowNotification object:nil];

Foundation,UIKit,MapKit,CoreLocation,CFNetWork,MessageUI,ImageIO,CoreData ， AFNetWorking,MKNetWorkKit,ASIHttpRequest,FMDB,ZXing,ZBar,SDWeb Image
1. 如何将产品进行多语言发布? 程序的国际化
1. 如何将敏感字变成 ** 字符串替换 stringByReplacingOccurrencesOfString:
withString:
+ 静态方法，也叫类方法， -实例方法
1. 给定的一个字符串，判断字符串中是否还有 png ，有就删除它? [string
stringByReplacingOccurrencesOfString:@"png" withString: @ “"]
1. 对于语句 NSString* testObject = [[NSData alloc] init];testObject在编译时和运行 时分别是什么类型的对象? 编译的时候是 NSString 类型，运行的时候是 NSData 类型
1. OC中是所有对象间的交互是如何实现的? 函数指针实现

 1. NSArray和NSMutableArray的区别，多线程操作哪个更安全? NSArray 不可变 数组，NSMutableArray 可变数组，NSArray更安全，多线程操作的时候记得 加锁。
1. 当前有一个数组，里面有若干重复的数据，如何去除重复的数据?(会几个 写几个) 最简单的方式，把数组里面的元素放到集合里面。 也可以对数组进行排序，排序之后把数组里相同的元素删除掉

 1.什么时候使用 NSMutableArray ，什么时候使用 NSArray ?
答案: 当数组在程序运行时， 需要不断变化的， 使用 NSMutableArray ，当数组在初始化后， 便不再改变的， 使用 NSArray 。需要指出的是，使用 NSArray 只表明的是该数组在运行时不发生改变，即不能往 NSAarry 的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。 NSArray 是线程安全的， NSMutableArray 不是线程安全的，多线程使用到 NSMutableArray 需要注意。

3.在应用中可以创建多少 autorelease 对象，是否有限制?
答案:无
4.如果我们不创建内存池，是否有内存池提供给我们?
答案 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池
5.什么时候需要在程序中创建内存池?
答案:用户自己创建的数据线程，则需要创建该线程的内存池
6.When retain count increase?
什么时候内存计数会增加?
答案: 见 iOS 面试题(一)
7.What are commonly used NSObject class methods?
类 NSObject 的那些方法经常被使用?
答案: NSObject 是 Objetive-C 的基类，其由 NSObject 类及一系列协议构成。
其中类方法 alloc 、class 、 description 对象方法 init 、dealloc 、– performSelector:withObject:afterDelay: 等经常被使用
8.什么是简便构造方法?
答案:简便构造方法一般由 CocoaTouch 框架提供，如 NSNumber 的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:
Foundation 下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象， 并且不需要手动释放。

11.UIView 的动画效果有那些?
答案:有很多，如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn
UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown
如何使用可见该博文
12.在 iPhone 应用中如何保存数据?
答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中
3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.什么是 coredata ?
答案: coredata 是苹果提供一套数据保存框架，其基于 SQlite
14.什么是 NSManagedObject 模型?
答案: NSManagedObject 是 NSObject 的子类 ，也是 coredata 的重要组成部分， 它是一个通用的类 , 实现 了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。
类别的作用?继承和类别在实现中有何区别?
答案:category 可以在不获悉， 不改变原来代码的情况下往里面添加新的方法， 不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。
继承可以增加，扩展父类方法，并且可以增加属性。
3.Difference between categories and extensions?
因为类别具有更
类别和类扩展的区别。
答案: category 和 extensions 的不同在于 后者可以添加属性。另外后者添加的方法是
必须要实现的。
extensions 可以认为是一个私有的 Category 。
4.Difference between protocol in objective c and interfaces in java?
oc 中的协议和 java 中的接口概念有何不同?
答案: OC中的协议有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java
, 那么发现 A 引用的对象同样被修改， , 内存中存在了只能添加，接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现， 就会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 “非正式协议概念其实就是类别的另一种表达方式 “这里有一些你可能希望实现的方法， 你 可以使用他们更好的完成工作”。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说“非正式 协议使用 interface 修饰“，
现在我们看到协议中两个修饰词:“必须实现 (@requied) ”和“可选实现 (@optional) ”。
OC中的协议 (formal protocol) 与 java 中的接口概念基本一致， OC中非正式协议 (informal protocol) 就是类别。在 java 中如果继承了接口，但不实现其方法，会得到一个
error (无法编译) ;在 OC中的正式协议， 如果不实现， 会得到一个 warning(可编译执行) ， 如果想去除 waring ，还可以加关键字( @optional )，让它可选实现方法。
5.What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调 用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{

 if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
} }
对于系统是根据 keypath 去取的到相应的值发生改变，理论上来说是和 理是一样的。
kvc 机制的道
对于 kvc 机制如何通过 key 寻找到 value :
“当通过 KVC调用对象时，比如: [self valueForKey:@ 通过几种不同的方式解析这个调用。首先查找对象是否带有
到，会继续查找对象是否带有 someKey 这个实例变量(
续试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话， 程序会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注:Key-Value Coding 查找方法的时候， 不仅仅会查找 someKey这个方法， 还会查找 getsomeKey 这个方法，前面加一个 get ，或者 _someKey以及 _getsomeKey 这几种 形式。同时，查找实例变量的时候也会不仅仅查找 someKey这个变量，也会查找 _someKey 这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中 请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面
的两个例子说明了这样做的好处。“
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 . 因此为何上面我们只是 相关的 keypath 就行了，
可以按照 kvc 查找的逻辑理解，就说的过去了。
6.代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
7.What are mutable and immutable types in Objective C? oc 中可修改和不可以修改类型。
add 一个
而不需
” someKey” ] 时，程序会自动试图 someKey 这个方法，如果没找
iVar )，如果还没有找到，程序会继
 答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的，后者可 以添加等，可以动态申请新的内存空间。
8.我们说的 oc 是动态运行时语言是什么意思?
答案:多态。 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别，
定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类 ( life ) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat ，但是调用是我们只 需调用各自的 eat 方法。
也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础? ~~~

12.在 iPhone 应用中如何保存数据?
答案:有以下几种保存机制:
1.通过 web 服务，保存在服务器上
2. 通过 NSCoder 固化机制，将对象保存在文件中
3. 通过 SQlite 或 CoreData 保存在文件数据库中
13.什么是 coredata ?
答案: coredata 框架是 apple 提供的一套通用自动的解决方案，包括了对象生存周期、对象关系图、持久 化机制。
补充答案:上面是翻译的，按我个人理解 coredata 提供一种一机制，让我们可以方便的把内存中对象，及 对象间的关系，映射到 coredata ，然后由它为我们持久化数据。相比普通的文件数据库 SQlite ，它的功能 更强大，不需要我们先将对象数据 format 成 SQL 语句，存入数据库，再用 select 语句读出，而现在是从 内存到 coredata 的数据管理，我们只需管理 coredata 的 managed 对象。
是苹果提供一套数据保存
14.什么是 NSManagedObject 模型?
答案: NSManagedObject 是 NSObject 的子类，也是 coredata 的重要组成部分，它是一个通用的类 ,实现 了 core data 模型层所需的基本功能，用户可通过子类化 NSManagedObject ，建立自己的数据模型。
15. 什么是 NSManagedobjectContext ?
答案: NSManagedobjectContext 对象负责应用和数据库之间的交互。

9.用预处理指令 #define 声明一个常数，用以表明 1 年中有多少秒(忽略闰年问题)
答: #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情:
#define 语法的基本知识(例如:不能以分号结束，括号的使用，等等) 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而 没有代价的。
意识到这个表达式将使一个 16 位机的整型数溢出 -因此要用到长整型符号 L,告诉编译器这个常数是的长整型数。 如果你在你的表达式中用到 UL(表示无符号长整型) ，那么你有了一个好的起点。记住，第一印象很重要。

11.数组和指针的区别
( 1)数组可以申请在栈区和数据区;指针可以指向任意类型的内存块
( 2) sizeof 作用于数组时，得到的是数组所占的内存大小;作用于指针时，得到的都是
例如:当你写下面的代码时会发生什
4 个字节的大小
( 3 )数组名表示数组首地址，值不可以改变，如不可以将++作用于数组名上;普通指针的值可以改变，如可将++作用于指针上
( 4)用字符串初始化字符数组是将字符串的内容拷贝到字符数组中;用字符串初始化字符指针是将字符串的首地址赋给指针， 也就是指针指向了该数组

21.ARC 机制
ARC 就是 automatic reference counting ，简单说就是就是代码中自动加入了 理的引用计数的代码可以自动地由编译器完成了。
使用 ARC 的好处
使用 ARC 有什么好处呢?
retain/release，原先需要手动添加的用来处理内存管
看到上面的例子，大家就知道了，以后写 Objective-C 的代码变得简单多了，因为我们不需要担心烦人的内存管理，担心内存泄 露了
代码的总量变少了，看上去清爽了不少，也节省了劳动力 代码高速化，由于使用编译器管理引用计数，减少了低效代码的可能性
不好的地方
记住一堆新的 ARC 规则—关键字及特性等需要一定的学习周期 一些旧的代码，第三方代码使用的时候比较麻烦;修改代码需要工数，要么修改编译开关
22.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对 象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释 放，池中的所有对象也就被释放。
1. ojc-c 是 通过一种” referring counting ”(引用计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc)的时候引用计数为一 ,以后 每当碰到有 copy,retain的时候引用计数都会加一 , 每当碰到 release和 autorelease的时候引用计数就会减一 ,如果此对象的计数变 为了 0, 就会被系统销毁 .
2. NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不用你管的 .
3. autorelease和 release没什么区别 ,只是引用计数减一的时机不同而已 ,autorelease会在对象的使用真正结束的时候才做引用计数 减一.

31. iOS 的系统架构分为( 核心操作系统层 theCore OS layer )、( 核心服务层 theCore Services layer )、( 媒体层 theMedia layer )和( Cocoa界面服务层 the Cocoa Touch layer)四个层次。
32. 控件主要响应 3 种事件:( 基于触摸的事件 )、( 基于值的事件 )和( 基于编辑的事件 )。
33. xib 文件的构成分为哪 3 个图标?都具有什么功能。 (10 分)
答: File’ s Owner 是所有 nib 文件中的每个图标，它表示从磁盘加载 First Responder 就是用户当前正在与之交互的对象;
View 显示用户界面;完成用户交互;是 UIView 类或其子类。
34. 简述视图控件器的生命周期( 10 分)。
答: loadView 尽管不直接调用该方法， 如多手动创建自己的视图， 性。
nib 文件的对象;
那么应该覆盖这个方法并将它们赋值给试图控制器的
view 属用于
viewDidLoad 只有在视图控制器将其视图载入到内存之后才调用该方法，这是执行任何其他初始化操作的入口。 viewDidUnload 当试图控制器从内存释放自己的方法的时候调用，用于清楚那些可能已经在试图控制器中创建的对象。
viewVillAppear 当试图将要添加到窗口中并且还不可见的时候或者上层视图移出图层后本视图变成顶级视图时调用该方法， 执行诸如改变视图方向等的操作。实现该方法时确保调用 [super viewWillAppear:].
viewDidAppear 当视图添加到窗口中以后或者上层视图移出图层后本视图变成顶级视图时调用， 执行的代码。确保调用 [super viewDidAppear : ] 。
35. 动画有基本类型有哪几种;表视图有哪几种基本样式( 10 分)?
答:动画有两种基本类型:隐式动画和显式动画。
36. 实现简单的表格显示需要设置 UITableView 的什么属性、实现什么协议( 10 分)?
用于放置那些需要在视图显示后
答 : 实 现 简 单 的 表 格 显 示 需 要 设 置 UITableView 的 dataSource 和 delegate 属 性 ， 实 现 UITableViewDataSource 和 UITableViewDelegate 协议。
37. Cocoa Touch提供了哪几种 Core Animation 过渡类型( 10 分)?
答: Cocoa Touch 提供了 4 种 Core Animation 过渡类型，分别为:交叉淡化、推挤、显示和覆盖。
38. UIView 与 CLayer 有什么区别( 10 分)?
答: 1. UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由 CoreAnimation 来实现的。它真 正的绘图部分，是由一个 CALayer 类来管理。 UIView 本身更像是一个 CALayer 的管理器，访问它的跟绘图和跟坐标有关的属 性。

2. UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。
3. UIView 的 CALayer 类似 UIView 的子 View 树形结构，也可以向它的 layer 上添加子 layer ，来完成某些特殊的表示。 即 CALayer 层是可以嵌套的。
4. UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻辑树，这里是代码可以操纵的;动画树，是一个中间层，系 统就在这一层上更改属性，进行各种渲染操作;显示树，其内容就是当前正被显示在屏幕上得内容。
5. 动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改，系统将自动进行动画生成，动画持续时间的缺省值似乎 是 0.5 秒。
6. 坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint 结构表示，值域是 0~1 ，是个比例值。 这个点是各种图形变换的坐标原点，同时会更改 layer 的 position 的位置，它的缺省值是 {0.5,0.5} ，即在 layer 的中央。
7. 渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用 setNeedsDisplay 方法来重绘显示。 8. 变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform 或 affineTransform 属性。
9. 变形: Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的。图像可以在一个三维坐标系中以任意角度被 旋转，缩放和倾斜。 CATransform3D 的一套方法提供了一些魔术般的变换效果。
39.链表翻转。
40. 链表逆序(C语言)(10分)。
链表逆序就是把一个链表按照原来的链接顺序逆序实现(也就是将头变成尾，尾变成头) 。 编程思路:其实最关键的是先通过原来的链接顺序找到下个节点，然后再把前个节点反序。
50. 类别的作用?继承和类别在实现中有何区别?
答案: category可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。 来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。 类别主要有 分散到多个不同文件或多个不同框架中。 (2) 创建对私有方法的前向引用。 (3) 向对象添加非正式协议。 法，并且可以增加属性。
51.通知和协议的不同之处?
并且如果类别和原 3 个作用: (1) 将类的实现
继承可以增加，修改方
答案:协议有控制链 (has-a)的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 通知和代理的行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受 者。代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的
事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发 出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因 此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
52.关于多态性
答案:多态，子类指针可以赋值给父类。 这个题目其实可以出到一切面向对象语言中， 因此关于多态，继承和封装基本最好都 有个自我意识的理解，也并非一定要把书上资料上写的能背出来。 最重要的是转化成自我理解。
53.对于单例的理解
答案: 基本能用熟悉的语言写出一个单例， 以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。 考虑下如何在多线程访问单例时的安全性。

56. Object - c 的类可以多重继承么?可以实现多个接口么?重写一个类的方式用继承好还是分类 好?为什么?
答案: Objective-c 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现， cocoa 中所有的类都 是 NSObject 的子类，多继承在这里是用 protocol 委托代理来实现的。

58. 自动释放池跟 GC (垃圾回收)有什么区别? iPhone 上有 GC 么?[ poolrelease] 和[ pooldrain]有什么区别?
iPhone 上没有 GC 。iPhone 开发的时候没有垃圾回收机制。 在垃圾回收环境中， release 是一个空操作。 因此，NSAutoreleasePool 提 供了 drain 方法，在引用计数环境中，该方法的作用等同于调用 release，但在垃圾回收环境中，它会触发垃圾回收(如果自上次 垃圾回收以来分配的内存大于当前的阈值) 。因此，在通常情况下，您应该使用 drain 而不是 release来销毁自动释放池。

iOS 中可以有四种持久化数据的方式:属性列表、对象归档、
式快速的定义 app 的数据模型， 同时在你的代码中容易获取到它。
撤销和重做，允许你在 app 中继续创建新的任务。在使用 core data 的时候，你不用安装额外的数据库系统，因为 core data 使用 内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组定义在内存中的数据对象。 coredata 会追踪这些对象的改变，同时 可以根据需要做相反的改变，例如用户执行撤销命令。当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些 数据归档，并永久性保存。 mac os x 中 sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在 多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。与 core data 框架不同的是， sqlite 是使用程序式的， sql 的主要 的 API 来直接操作数据表。 Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 Core Dta 支持
SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支 持对一、对多的关系。
61. obj-c 有多重继承么 ? 如果没有什么替代方法 ?
cocoa中所有的类都是 NSObject 的子类， 多继承在这里是用 protocol 委托代理来实现的。 你不用去考虑繁琐的多继承， 虚基类 的概念。
// xxx
NSString *documentsDirectory = [paths objectAtIndex:];
// 创建文件系统管理器
NSFileManager *fileManager = [[NSFileManageralloc] init];
// 判断 userData 目录是否存在
if(![fileManagerfileExistsAtPath:[NSStringstringWithFormat:@
// 不存在 , 创建一个 userData 目录
[fileManagercreateDirectoryAtPath:[NSStringstringWithFormat:@ ”%@/userData ”,documentsDirectory]withIntermediateDir ectories:falseattributes:nilerror:nil];
}

73. 获取项目根路径，并在其下创建一个名称为 userData 的目录。
// 获取根路径
NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString*documentsDirectory = [paths objectAtIndex:];
// 创建文件系统管理器
NSFileManager *fileManager= [[NSFileManageralloc] init];
// 判断 userData 目录是否存在
if(![fileManagerfileExistsAtPath:[NSStringstringWithFormat:@
// 不存在 , 创建一个 userData 目录
[fileManagercreateDirectoryAtPath:[NSStringstringWithFormat:@ ”%@/userData ”,documentsDirectory]withIntermediateDir ectories:falseattributes:nilerror:nil];
}

6.自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease消息时， Cocoa就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释 放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域 结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。
1)objc-c 是 通过一种 ”referringcounting 引”用(计数 )的方式来管理内存的 , 对象在开始分配内存 (alloc)的时候引用计数为一 ,以后每当碰到有 copy,retain
的时候引用计数都会加一 , 每当碰到 release和 autorelease的时候引用计数 就会减一 ,如果此对象的计数变为了 0, 就会被系统销毁 .
2)NSAutoreleasePool 就是用来做引用计数的管理工作的 ,这个东西一般不 用你管的 .
3) autorelease和 release没什么区别 ,只是引用计数减一的时机不同而 已 ,autorelease会在对象的使用真正结束的时候才做引用计数减一 .

24.TCP/UDP 区别联系
TCP---传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户
和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才 能传输数据。 TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等 功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议， 是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它只是把应用程序传给 IP 层的数据报发送出去，但是并不
能保证它们能到达目的地。由于 UDP 在传输数据报前不用在客户和服务器 之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
TCP(TransmissionControl Protocol，传输控制协议)是基于连接的协 议，也就是说， 在正式收发数据前， 必须和对方建立可靠的连接。 一个 TCP 连接必须要经过三次 “对话 ”才能建立起来，我们来看看这三次对话的简单过 程: 1.主机 A 向主机 B 发出连接请求数据包; 2.主机 B 向主机 A 发送同意 连接和要求同步(同步就是两台主机一个在发送，一个在接收，协调工作) 的数据包; 3.主机 A 再发出一个数据包确认主机 B 的要求同步: “我现在就
 发，你接着吧! ”，这是第三次对话。三次 “对话 ”的目的是使数据包的发送 和接收同步，经过三次 “对话 ”之后，主机 A 才向主机 B 正式发送数据。
UDP( User Data Protocol，用户数据报协议)是与 TCP 相对应的协议。 它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送 过去! UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接 传输可靠性可靠不可靠 应用场合传输大量数据少量数据 速度慢快
25.socket 连接和 http 连接的区别 简单说，你浏览的网页(网址以
http://开头)都是 http 协议传输到你的 浏览器的,而http是基于 socket之上的。socket是一套完成 tcp，udp协议的接口。
HTTP 协议:简单对象访问协议， 对应于应用层，HTTP 协议是基于 TCP 连接的。
tcp 协议:对应于传输层 ip 协议:对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是 应用层协议，主要解决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调 用接口( API )，通过 Socket，我们才能使用 TCP/IP 协议。
http 连接:http 连接就是所谓的短连接，即客户端向服务器端发送一次 请求，服务器端响应后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端 一旦建立起连接将不会主动断掉;但是由于各种环境因素可能会是连接断
开，比如说:服务器端或客户端主机 down 了，网络故障，或者两者之间长 时间没有数据传输，网络防火墙可能会断开该连接以释放网络资源。所以
当一个 socket连接中没有数据的传输，那么为了维持连接需要发送心跳消 息 ~~具体心跳消息格式是开发者自己定义的。
我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 “一切皆文件 ”， 都可以用 “打开 open –>读写 write/read –>关闭 close ”模式来操作。我的理解 就是 Socket就是该模式的一个实现， socket即是一种特殊的文件， 一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数我们在后面 进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是 那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数 据有意义，则必须使用到应用层协议， 应用层协议有很多， 比如 HTTP、FTP、 TELNET 等，也可以自己定义应用层协议。 WEB 使用 HTTP 协议作应用层 协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网 络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层。 而 http 是个应用层的协议， 它 实际上也建立在 TCP 协议之上。 (HTTP 是轿车，提供了封装或者显示数据 的具体形式; Socket是发动机，提供了网络通信的能力。 )
2)Socket是对 TCP/IP 协议的封装， Socket本身并不是协议，而是一 个调用接口( API )，通过 Socket，我们才能使用 TCP/IP 协议。 Socket 的
出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议 的抽象，从而形成了我们知道的一些最基本的函数接口。
26 什么是 TCP 连接的三次握手
第一次握手:客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND
状态，等待服务器确认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN(ack=j+1)，
同时自己也发送一个 SYN 包( syn=k)，即 SYN+ACK 包，此时服务器进 入 SYN_RECV 状态;
 第三 不次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送 确认包 ACK(ack=k+1) ，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务 器才正式开始传送数据。理想状态下， TCP 连接一旦建立，在通信双方中 的任何一方主动关闭连接之前， TCP 连接都将被一直保持下去。断开连接 时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经 过“四次握手 ”(过程就不细写了， 就是服务器和客户端交互， 最终确定断开) 27利用 Socket建立网络连接的步骤
建立 Socket连接至少需要一对套接字，其中一个运行于客户端，称为
ClientSocket，另一个运行于服务器端，称为 ServerSocke。t 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连
接确认。
1)服务器监听:服务器端套接字并不定位具体的客户端套接字，而是 处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
2)客户端请求:指客户端的套接字提出连接请求，要连接的目标是服 务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器 的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接 字提出连接请求。
3)连接确认:当服务器端套接字监听到或者说接收到客户端套接字的 连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器
端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立 连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字 的连接请求。

29指针与地址的区别:
1)指针意味着已经有一个指针变量存在 ,他的值是一个地址 ,指针变量 本身也存放在一个长度为四个字节的地址当中 ,而地址概念本身并不代表有 任何变量存在。
2)指针的值 ,如果没有限制 ,通常是可以变化的 ,也可以指向另外一个地 址。
地址表示内存空间的一个位置点 ,他是用来赋给指针的 ,地址本身是没 有大小概念 ,指针指向变量的大小 ,取决于地址后面存放的变量类型。

30.id、nil 代表什么?
id 和 void * 并非完全一样。在上面的代码中， id 是指向 struct objc_object
的一个指针，这个意思基本上是说， id 是一个指向任何一个继承了 Object (或者 NSObject)类的对象。需要注意的是 id 是一个指针，所以你在使用
id 的时候不需要加星号。比如 id foo=nil 定义了一个 nil 指针，这个指针指 向 NSObject 的一个任意子类。而 id *foo=nil 则定义了一个指针，这个指针
指向另一个指针，被指向的这个指针指向 NSObject 的一个子类。
nil 和 C语言 的 NULL 相同 ，在 objc/objc.h 中定 义。 nil 表示 一个
Objctive-C 对象，这个对象的指针指向空(没有东西就是空)。
首字母大写的 Nil 和 nil 有一点不一样， Nil 定义一个指向空的类 (是 Class， 而不是对象)。
SEL是“selecto的r一”个类型，表示一个方法的名字Method(我们常说 的方法)表示一种类型，这种类型与 selector和实现(implementation)相关IMP
定义为 id(*IMP) (id,SEL, ⋯)。这样说来， IMP 是一个指向函数的指针，这 个被指向的函数包括 id( “sel指f ”针 )，调用的 SEL(方法名)，再加上一些 其他参数 .说白了 IMP 就是实现方法。

8. 关键字 const 有什么含意?修饰类呢 ?static 的作用 , 用于类呢 ?还有 extern c 的作用
const 意味着 " 只读 " ，下面的声明都是什么意思? const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，
第三个意味着 a 是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。
第四个意思 a 是一个指向整型数的常指针(也就是说，指针指向的整型数是可以修改的，但指 针是不可修改的)。
最后一个意味着 a 是一个指向常整型数的常指针 (也就是说， 指针指向的整型数是不可修改的， 同时指针也是不可修改的)。
结论:
关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量 是为了告诉了用户这个参数的应用目的。
如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。(当然， 懂得用 const 的程序员很少会留下的垃圾让
别人 来清理的。) 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的 代码。
合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意 的代码修改。简而言之，这样可以减少 bug
的出 现。
a 是一个常整型数。

(1 )欲阻止一个变量被改变，可以使用 它进行初
始化，因为以后就没有机会再去改变它了; (2 )对指针来说，可以指定指针本身为 同时指
定为 const ;
const
const
关键字。 在定义该 const 变量时， 通常需要对
，也可以指定指针所指的数据为 const ，或二者
(3 )在一个函数声明中， const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变 其值;
(4 )对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成 员变量;
(5 )对于类的成员函数， 有时候必须指定其返回值为 const 类型，以使得其返回值不为 “左值 ”。
关键字 volatile 有什么含意 ?并给出三个不同的例子。
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设
这个变量的值了。
精确地说就是， 优化器在用到这个变量时必须每次都小心地重新读取这个变量的值， 保存在寄存器里的备份。
下面是 volatile 变量的几个例子: 并行设备的硬件寄存器(如:状态寄存器)
一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables) 多线程应用中被几个任务共享的变量
一个参数既可以是 const 还可以是 volatile 吗?解释为什么。 一个指针可以是 volatile 吗?解释为什么。
下面是答案:
是的。一个例子是只读的状态寄存器。 它是 volatile 因为它可能被意想不到地改变。 因为程序不应该试图去修改它。
而不是使用
它是 const 是的。尽管这并不很常见。 一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。
9. static 关键字的作用:
(1 )函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分 配一次，
因此其值在下次调用时仍维持上次的值;
(2 )在模块内的 (3 )在模块内的 在声明 它的模块内; (4 )在类中的
static static
static
全局变量可以被模块内所用函数访问， 但不能被模块外其它函数访问; 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制
成员变量属于整个类所拥有，对类的所有对象只有一份拷贝;

23.http 和 scoket 通信的区别。
http 是客户端用 http 协议进行请求， 发送请求时候需要封装 http 请求头，并绑定请求的数据， 服务器一般有 web 服务器配合(当然也非绝对)。 http 请求方式为客户端主动发起请求，服 务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应(除
非采取 http 长连接技术)。 iphone 主要使用类是 NSUrlConnection 。
scoket 是客户端跟服务器直接使用 socket “套接字 ”进行连接， 并没有规定连接后断开， 所以客
户端和服务器可以保持连接通道， 双方都可以主动发送数据。 求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是

33. 线程的常见方法有哪些，你是如何处理多线程的，多线程同步问题你了解么? 线程创建的几种方式，线程的加锁，休眠，唤醒，解锁，退出，
多线程要考虑同步问题 , 解决同步问题的方式就是对某一资源加锁，当一个线程操作本资源时， 其他线程不能操作 。
系统自带线程池( NSOpertionQueue )的作用:
凡是需要启动多个线程的地方都可以使用 NSOpertionQueue ，加入到 NSOpertionQueue 中 的对象都需要继承 NSOpertion 。 NSOpertionQueue 会在系统内部启动一个独立线程去执行 这个被加入对象的 main 方法。
常用的地方是用 nsoprationqueue 下载图片，文件。如果是自己创建一个线程池，无非就是 启动多个线程的时候，
把这些线程对象放到一个大数组中，如果需要启动线程的时候，先从数组中找空闲线程来使用。
自己管理线程池最大的难题是不好处理当启动多个线程后， 用户在多个界面的跳转的时候， 对线 程方法的回调管理。
而 NSOpertionQueue 可以很好的处理他。
34.init 和 initwithobject 区别(语法)? init 创建的对象不带自动释放
36. 你使用过 json 解析方式么，他们的底层是如何处理的你了解么?
json 解析的用法，用框架的用法简单介绍: 底层原理遍历字符串中的字符，最终根据格式规定的特殊字符，比如
{} 号， [] 号 , :
号 等进行
区分，
{} 号是一个字典的开始， [] 号是一个数组的开始 , : 号是字典的键和值的分水岭，最终乃是将
json 数据转化为字典， 字典中值可能是字典，数组，或字符串而已。

37.xml 解析的原理是什么，你还用过其他解析方式么?
NSXMLParser, 其他解析方式有自定义二进制解析，就是按字节去解析，电话会谈就是如此，
还可以是字符串之间用特殊符号连接的数据，将此数据用特殊符号可以分割成所用数据。
38. 协议是什么，有什么作用 . ?
协议很像 java 中的接口，某个类实现协议后，就必须实现协议中规定的 @require 的方法，比 如一个类 A, 一个类 B 都实现某 “协议 ”后，
这个类 A 的对象和 B 的对象都可以赋值给这个协议的类型变量，比如 id< 协议 > 变量名 = A 类或 B 类的对象，
于是这个变量就完成了能够指向多个不同的类的对象并调用对象中的实现协议的方法。
39. 类别有什么作用?
类别的使用 。 类别有三大作用，
1. 可以使本来需要在 .h 中声明的方法放到 .m 文件中声明，达到了可以使方法不对外公开。 2. 可以方便的扩展类，甚至系统类都可以轻易扩展，维护了代码原本的结构不受影响。
3. 类别可以写到不同的 .h 或 .m 文件中，可以分散代码到跟类别的扩展功能想关联的地方，方 便查看。
40. 分线程回调主线程方法是什么，有什么作用?
[self performSelectorOnMainThread:@selector(buttonGo2) withObject:nil
waitUntilDone:YES];
[self performSelector:@selector(buttonGo2) onThread:[NSThread mainThread]
withObject:nil waitUntilDone:YES]; 需要即时刷新 ui 控件的时候，经常使用。
41.iphone 阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的?另外像 式的文件，你如何读取。 ?
pdf 格
iphone 手机阅读器中对于 上下到很多直接读取 pdf 格式的代码
控件显示，也可以从网
直接从 pdf 中得到数据。 复杂表格动画
- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths
withRowAnimation:(UITableViewRowAnimation)animation; -(void)deleteRowsAtIndexPaths:(NSArray *)indexPaths
PDF 格式的阅读，可以直接用
UIWebView

 withRowAnimation:(UITableViewRowAnimation)animation; - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths
withRowAnimation:(UITableViewRowAnimation)animation;
42. 你在开发大型项目的时候，如何进行内存泄露检测的 ?
可以通过 xcode 的自带工具 run---start with performance tool 里有 instruments 下有
个 leaks 工具， 启动此工具后，运行项目，工具里可以显示内存泄露的情况，双击可找到源码位置，可以帮助
进行内存泄露的处理。
43. 你做 iphone 开发时候，有哪些传值方式， view 和 view 之间是如何传值的? 压栈。
44. 让一个物体从界面中的一点运动到另外一点，有哪些方法? 四种方式:
1. beginAnimation
2. 线程
3. NSTimer
4. 图层动画(路径)
45. 你了解哪些加密方式?
Base64, MD5, 循环右移位等 .
46. 地图定位
CLLocationManager 位置管理器 使用 Core Location 框架来确定 iphone 的位置( GPS，
蜂窝基站三角网， wps 三种方式) MKMapView提供了一套可植入的地图接口，可以让我们在应用中展示地图，并对其
进行相关的操作。一般来说，我们可以指定一个展示区域，放一些标记在上面，还 可以加盖一些层在上面。
MKMapView依赖 Google map 里面相关服务(如 Google Earth API 等)，所以地图 的左下角会有 Google 字样。
48. http 网络通信
ASIHTTPRequest 是一个直接在 CFNetwork 上做的开源项目:提供直接提交 (HTTP POST)
文件的 API ，异步请求与队列，自动管理上传与下载队列管理机 适合上传文件，图片数据。
49. 图片浏览
UIImagePickerController 可以从相册，相机，胶卷里获得图片。
50. 对像序列化
NSCoding encodeWithCoder initWithCoder
NSKeyedUnarchiver NSKeyedArchiver
51. 各种 picker UIDatePicker UIPickerView
52. 电影播放 MPMoviePlayerController
音乐播放
MPMusicPlayerController
16. 类别的作用 ?继承和类别在实现中有何区别 ?
答:category 可以在不获悉，不改变原来代码的情况下往里面添加新 的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法 产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先 级。
类别主要有 3个作用: 1).将类的实现分散到多个不同文件或多个不同框架中。
2).创建对私有方法的前向引用。 3).向对象添加非正式协议。 继承可以增加，修改或者删除方法，并且可以增加属性。
17. 类别和类扩展的区别。
答: category和extensions的不同在于后者可以添加属性。另外后者添加
的方法是必须要实现的。 extensions可以认为是一个私有的 Category。
18. oc中的协议和 java中的接口概念有何不同 ?
答: OC中的代理有 2层含义，官方定义为 formal 和informal protocol 。
前者和 Java接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，
但是如果有实现，就会改变类的属性。
其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，
―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能 希望实现的方法，你可以使用他们更好的完成工作 ‖。
这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会 申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的 方法。
这么看，总觉得类别这玩意儿有点像协议的可选协议。 ‖ 现在来看，其实 protocal已经开始对两者都统一和规范起来操作，因为
资料中说 ―非正式协议使用 interface修饰―， 现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和―可选实现
(@optional) 。‖
19. 什么是 KVO 和KVC?
答:KVC:键 –值编码是一种间接访问对象的属性使用字符串来标识 属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。
很多情况下可以简化程序代码。 apple文档其实给了一个很好的例子。 KVO: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化
了代码。
具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监 控。
比如我自定义的一个 button
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{

if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
}
}
对于系统是根据 keypath去取的到相应的值发生改变，理论上来说是和 kvc 机制的道理是一样的。
对于kvc机制如何通过 key寻找到 value:
―当通过 KVC 调用对象时，比如: [self valueForKey:@ ‖ someKe时y‖，]
程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是 否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有 someKey这个实例变量 (iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的 话，程序会抛出一个 NSUndefinedKeyException异常错误。
(cocoachina.com注: Key-Value Coding查找方法的时候，不仅仅会查找 someKey这个方法，还会查找 getsomeKey这个方法，前面加一个 get， 或者 _someKey以及 _getsomeKey这几种形式。同时，查找实例变量的时 候也会不仅仅查找 someKey这个变量，也会查找 _someKey这个变量是 否存在。 )
设计 valueForUndefinedKey:方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应 这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处
来至 cocoa，这个说法应该挺有道理。
因为我们知道 button却是存在一个 highlighted实例变量 .因此为何上面我
们只是 add一个相关的 keypath就行了， 可以按照 kvc查找的逻辑理解，就说的过去了。 20. 代理的作用 ?

答:代理的目的是改变或传递控制链。允许一个类在某些特定时刻通 知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java中的回调监听机制的一种类似。 21. oc中可修改和不可以修改类型。
答:可修改不可修改的集合类。这个我个人简单理解就是可动态添加 修改和不可动态添加修改一样。
比如 NSArray和NSMutableArray 。前者在初始化后的内存空间就是固定 不可变的，后者可以添加等，可以动态申请新的内存空间。
22. 我们说的 oc是动态运行时语言是什么意思 ?
答:多态。主要是将数据类型的确定由编译时，推迟到了运行时。
这个问题其实浅涉及到两个概念，运行时和多态。
简单来说，运行时机制使我们直到运行时才去决定一个对象的类别， 以及调用该类别对象指定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。意思 就是假设生物类 (life) 都用有一个相同的方法 -eat;
那人类属于生物，猪也属于生物，都继承了 life后，实现各自的 eat，但 是调用是我们只需调用各自的 eat方法。
也就是不同的对象以自己的方式响应了相同的消息 (响应了 eat这个选择 器)。
因此也可以说，运行时机制是多态的基础 ?~~~ 23. 通知和协议的不同之处 ?

答:协议有控制链 (has-a)的关系，通知没有。 首先我一开始也不太明白，什么叫控制链 (专业术语了 ~)。但是简单分
析下通知和代理的行为模式，我们大致可以有自己的理解
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息 接受者。
代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星 经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不 可能说明天要处理 A明星要一个发布会，代理人发出处理发布会的消息 后，别称 B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接 收到感兴趣要处理。
因此控制链 (has-a从英语单词大致可以看出，单一拥有和可控制的对应 关系。

30. OC的垃圾回收机制 ?
答: OC2.0有Garbage collection，但是 iOS平台不提供。
一般我们了解的 objective-c对于内存管理都是手动操作的，但是也有自 动释放池。
但是差了大部分资料，貌似不要和 arc机制搞混就好了。 31. NSOperation queue?
答:存放 NSOperation的集合类。
操作和操作队列，基本可以看成 java中的线程和线程池的概念。用于处
理 ios多线程开发的问题。
网上部分资料提到一点是，虽然是 queue，但是却并不是带有队列的概
念，放入的操作并非是按照严格的先进现出。
这边又有个疑点是，对于队列来说，先进先出的概念是 Afunc 添加进队 列， Bfunc紧跟着也进入队列， Afunc 先执行这个是必然的，

38. 如果我们不创建内存池，是否有内存池提供给我们 ?
答 :界面线程维护着自己的内存池，用户自己创建的数据线程，则需要
创建该线程的内存池
39. 什么时候需要在程序中创建内存池 ? 答:用户自己创建的数据线程，则需要创建该线程的内存池
58. 什么是 block
答: 对于闭包 (block),有很多定义，其中闭包就是能够读取其它函数内
部变量的函数，这个定义即接近本质又较好理解。对于刚接触 Block 的
同学，会觉得有些绕，因为我们习惯写这样的程序 main(){ funA();}
funA(){funB();} funB(){ ⋯就.是.};函数 main调用函数 A ，函数 A 调用函
数 B⋯ 函数们依次顺序执行，但现实中不全是这样的，例如项目经理
M，手下有 3个程序员 A、B、C，当他给程序员 A安排实现功能 F1时， 他并不等着 A 完成之后，再去安排 B去实现 F2，而是安排给 A 功能 F1，
B 功能 F2， C功能 F3，然后可能去写技术文档，而当 A 遇到问题时，他 会来找项目经理 M，当B做完时，会通知 M，这就是一个异步执行的例 子。在这种情形下， Block 便可大显身手，因为在项目经理 M ，给 A 安 排工作时，同时会告诉 A 若果遇到困难，如何能找到他报告问题 (例如 打他手机号 )，这就是项目经理 M 给 A 的一个回调接口，要回掉的操作， 比如接到电话，百度查询后，返回网页内容给 A，这就是一个 Block， 在M交待工作时，已经定义好，并且取得了 F1的任务号 (局部变量 )，却 是在当 A遇到问题时，才调用执行，跨函数在项目经理 M查询百度，获 得结果后回调该 block。
59. block 实现原理

答: Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。
从计算语言的发展，最早的 goto，高级语言的指针，到面向对象语言的 block，从机器的思维，一步步接近人的思维，以方便开发人员更为高
效、直接的描述出现实的逻辑 (需求 )。 使用实例
cocoaTouch框架下动画效果的 Block 的调用 使用 typed声明 block
typedef void(^didFinishBlock) (NSObject *ob); 这就声明了一个 didFinishBlock类型的block，
然后便可用
@property (nonatomic,copy) didFinishBlock finishBlock;
声明一个 blokc对象，注意对象属性设置为 copy，接到 block 参数时，
便会自动复制一份。 __block是一种特殊类型，
使用该关键字声明的局部变量，可以被 block所改变，并且其在原函数 中的值会被改变。
60.关于 block
答: 面试时，面试官会先问一些，是否了解 block，是否使用过 block， 这些问题相当于开场白，往往是下面一系列问题的开始，所以一定要 如实根据自己的情况回答。
1). 使用 block和使用 delegate完成委托模式有什么优点 ?
首先要了解什么是委托模式，委托模式在 iOS中大量应用，其在设计模 式中是适配器模式中的对象适配器， Objective-C中使用 id类型指向一切 对象，使委托模式更为简洁。了解委托模式的细节:
iOS设计模式 —-委托模式
使用block实现委托模式，其优点是回调的 block代码块定义在委托对象
函数内部，使代码更为紧凑 ;
适配对象不再需要实现具体某个 protocol，代码更为简洁。
2). 多线程与 block
GCD与Block
使用 dispatch_async 系列方法，可以以指定的方式执行
GCD 编程实例
dispatch_async的完整定义
void dispatch_async( dispatch_queue_t queue, dispatch_block_t block);
对象
dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();});
62.谈谈 Object-C 的内存管理方式及过程?
答: 1).当你使用 new,alloc和copy方法创建一个对象时 ,该对象的保留计数 器值为 1.当你不再使用该对象时 ,你要负责向该对象发送一条 release或 autorelease消息 .这样 ,该对象将在使用寿命结束时被销毁 .
block ，不阻塞当前线程 通过 queue来控制 block执行的线程。主线程执行前文定义的 finishBlock
功能:在指定的队列里提交一个异步执行的block
TCP提供的是面向连接的、可靠的数据流传输，而 UDP提供的是非面向 连接的、不可靠的数据流传输。
简单的说， TCP注重数据安全，而 UDP数据传输快点，但安全性一般

107. UIView 与CLayer 有什么区别?
1).UIView 是 iOS 系统中界面元素的基础，所有的界面元素都是继承 自它。它本身完全是由 CoreAnimation 来实现的。它真正的绘图部分，
是由一个 CALayer 类来管理。 UIView 本身更像是一个 CALayer 的 管理器，访问它的跟绘图和跟坐标有关的属性。
2).UIView 有个重要属性 layer ，可以返回它的主 CALayer 实例。 3).UIView 的 CALayer 类似 UIView 的子 View 树形结构，也可以向
它的 layer 上添加子 layer ，来完成某些特殊的表示。即 CALayer 层 是可以嵌套的。
4).UIView 的 layer 树形在系统内部，被维护着三份 copy 。分别是逻 辑树，这里是代码可以操纵的;动画树，是一个中间层，系统就在这 一层上更改属性，进行各种渲染操作;显示树，其内容就是当前正被 显示在屏幕上得内容。
5).动画的运作:对 UIView 的 subLayer (非主 Layer )属性进行更改， 系统将自动进行动画生成，动画持续时间的缺省值似乎是 0.5 秒。
6).坐标系统: CALayer 的坐标系统比 UIView 多了一个 anchorPoint 属性，使用 CGPoint 结构表示，值域是 0~1 ，是个比例值。这个点是 各种图形变换的坐标原点，同时会更改 layer 的 position 的位置，它 的缺省值是 {0.5,0.5} ，即在 layer 的中央。
7).渲染:当更新层，改变不能立即显示在屏幕上。当所有的层都准备 好时，可以调用 setNeedsDisplay方法来重绘显示。
8).变换:要在一个层中添加一个 3D 或仿射变换，可以分别设置层的 transform 或affineTransform 属性。
9).变形: Quartz Core 的渲染能力，使二维图像可以被自由操纵，就 好像是三维的。图像可以在一个三维坐标系中以任意角度被旋转，缩 放和倾斜。 CATransform3D 的一套方法提供了一些魔术般的变换效果。

110. 使用 AVAudioPlayer 类调用哪个框架、使用步骤? 答: AVFoundation.framework
步骤:配置 AVAudioPlayer 对象;
实现 AVAudioPlayer 类的委托方法;
控制 AVAudioPlayer 类的对象;
监控音量水平;回放进度和拖拽播放。

__block 和 __weak 修饰符的区别其实是挺明显的:
1.__block 不管是 ARC 还是 MRC 模式下都可以使用， 可以修饰对象， 还可以修饰基本数据 类型。
2.__weak 只能在 ARC 模式下使用，也只能修饰对象( NSString )，不能修饰基本数据类 型( int )。
3.__block 对象可以在 block 中被重新赋值， __weak 不可以。
，否则不能循环执行。

 tableView 滑动卡的问题主要是因为:从缓存中或者是从本地读取图片给 UIImage 的时候
耗费的时间。需要把下面的两句话放到子线程里面:
1. NSData *imgData = [NSData dataWithContentsOfURL :[NSURL URLWithString :app.ico
n]]; // 得到图像数据
2. UIImage *image = [UIImage imageWithData :imgData];
把 UIImage 赋值给图片的时候在主线程。
子线程不能更新 UI 所有的 UI 跟新都是主线程执行了。手指滑动屏幕了。或者屏幕的某个 方法执行了。
子线程里面加入 NSTimer 的时候需要手动添加 NSRunloop 否则不能循环。 单利里面添加 NSMutableArray 的时候，防止多个地方对它同时便利和修改的话，需要加
原子属性。 并且用 strong ，，，并且写一个遍历和修改的方法。 加上锁。 Lock UnLock
__weak ViewController* weakSelf = self;
GCD 里面用 __weak 防止内存释放不了，循环引用。

二、 SDWebImage 内部实现过程
1. 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，
然后 SDWebImageManager 根据 URL 开始处理图片。
2. 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:
SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
3. 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存， SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: SDWebImageManager 。
4. SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: UIImageView+WebCache 等前端展示图片。
，交给
5. 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片 是否已经缓存。
 6. 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。 这一步是在 NSOperation 进行 的操作，所以回主线程进行结果回调 notifyDelegate: 。
7. 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中(如果空闲内存过小， 会先清空内存缓存)。 SDImageCacheDelegate 回调
imageCache:didFindImage:forKey:userInfo: 。进而回调展示图片。
8. 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，
回调 imageCache:didNotFindImageForKey:userInfo: 。
9. 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。

13. 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对
下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14. 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，
imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader 。
15. imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下 载完成。
16. 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17. 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也
在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18. SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台的时候
清理内存图片缓存，应用结束的时候清理过期图片。
19. SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache ，方便使 用。
20. SDWebImagePrefetcher 可以预先下载图片，方便后续使用。
从上面流程可以看出，当你调用 setImageWithURL: 方法的时候，他会自动去给你干这么多 事， 当你需要在某一具体时刻做事情的时候， 你可以覆盖这些方法。 比如在下载某个图片的 过程中要响应一个事件，就覆盖这个方法:
1 // 覆盖方法，指哪打哪，这个方法是下载 imagePath2 的时候响应
2 SDWebImageManager*manager = [SDWebImageManager sharedManager];
10 NSLog(@下"载完成"); 11 }];
[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed NSLog(@显"示当前进度");
} completed:^(UIImage *image, NSError
*error, SDImageCacheType cac
对于初级来说，用 sd_setImageWithURL: 的若干个方法就可以实现很好的图片缓存。
UIButton 的父类是
UIControl UIControl 的父类是
UIView UIView 的父类是 UIResponder
http 状态吗:302 是请求重定向。500 以上是服务器错误。 400 以上是请求
链接错误或者找不到服务器。 200 以 上是正确。100 以上是请求接受成功。
timeout :过期时间 5 秒(对应 httpd.conf 里的参数是: KeepAliveTimeout )， max 是最 多一百次请求，强制断掉连接
就是在 timeout 时间内又有新的连接过来，同时 面的四个图，注意看 Date 的值(前后时间差都是在
HTTP/1.0
在 HTTP/1.0 版本中，并没有官方的标准来规定
max 会自动减 1 ，直到为 0 ，强制断掉。见下 5 秒之内)!
Keep-Alive 如何工作，因此实际上它是被附 加到 HTTP/1.0 协议上， 如果客户端浏览器支持 Keep-Alive ，那么就在 HTTP 请求头中添加一
个字段 Connection: Keep-Alive ，当服务器收到附带有 Connection: Keep-Alive 的请求 时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之
间的 HTTP 连接就会被保持， 不会断开(超过 Keep-Alive 规定的时间， 意外断电等情况除外) ， 当客户端发送另外一个请求时，就使用这条已经建立的连接
HTTP/1.1
在 HTTP/1.1 版本中，官方规定的 Keep-Alive 使用标准和在 HTTP/1.0 版本中有些不同，默
认情况下所在 HTTP1.1 中所有连接都被保持，除非在请求头或响应头中指明要关闭:
Connection: Close ，这也就是为什么 Connection: Keep-Alive 字段再没有意义的原因。
另外，还添加了一个新的字段 Keep-Alive: ，因为这个字段并没有详细描述用来做什么，可忽 略它
Not reliable (不可靠)
HTTP 是一个无状态协议，这意味着每个请求都是独立的， Keep-Alive 没能改变这个结果。另
外， Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也 如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于
Keep-Alive 的保持连接特性，否则会有意想不到的后果 Keep-Alive 和 POST
在 HTTP1.1 细则中规定了在一个 POST 消息体后面不能有任何字符， 还指出了对于某一个特定 的浏览器可能并不遵循这个标准(比如在 POST 消息体的后面放置一个 CRLF 符)。而据我所 知，大部分浏览器在 POST 消息体后都会自动跟一个 CRLF 符再发送，如何解决这个问题呢? 根据上面的说明在 POST 请求头中禁止使用 Keep-Alive ，或者由服务器自动忽略这个 CRLF ， 大部分服务器都会自动忽略，但是在未经测试之前是不可能知道一个服务器是否会这样做。

16 什么时候用 delegate ，什么时候用 Notification ?答: delegate 针对 one-to-one 关系， 并且 reciever 可以返回值 给 sender ，notification 可以针对 one-to-one/many/none,reciever 无法返回值给 sender. 所以，delegate 用于 sender 希望接受到 reciever 的某个功能反馈值， notification 用于通知多个 object 某个事件。
以 isa 指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于 isa 指针。 在调用类的方法的时候，最好要明确对象实例的类名
指针结合环境参数，找到具体的方法实现的接口。( 3 )再直接查找得来的具 KVO ( Key-Value- Observing ):当观察者为一个对象的属性进行了注册，
isa 指针被修改的时候， isa 指针就会指向一个中间类，而不是真实的类。所
18ViewController 的 loadView, viewDidLoad, viewDidUnload 分别是在什么时候调用的? 在自定义 ViewController 的时候这几个函数里面应该做什么工作?答: viewDidLoad 在
view 从 nib 文件初始化时调用， loadView 在 controller 的 view 为 nil 时调用。 此方法在编程 实现 view 时调用 ,view 控制器默认会注册 memory warning notification, 当 view controller 的任何 view 没有用的时候， viewDidUnload 会被调用，在这里实现将 retain 的 view release, 如果是 retain 的 IBOutlet view 属性则不要在这里 release,IBOutlet 会负责 release 。
"NSMutableString *" 这个数据类型则是代表 的。
"NSMutableString" 对象本身，这两者是有区别
而 NSString 只是对象的指针而已。 面向过程就是分析出解决问题所需要的步骤， 时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象， 为了描叙某个事物在整个解决问题的步骤中的行为。; 20 类别的作用
类别主要有 3 个作用: (1)将类的实现分散到多个不同文件或多个不同框架中。 (2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。
类别的局限性
有两方面局限性: (1)无法向类中添加新的实例变量，类别没有位置容纳实例变量。
然后用函数把这些步骤一步一步实现， 使用的 建立对象的目的不是为了完成一个步骤， 而是
 (2)名称冲突，即当类别中的方法与原始类方法名称冲突时，类别具有更高的优先级。类别 方法将完全取代初始方法从而无法再使用初始方法。 无法添加实例变量的局限可以使用字典对象解决
24.类别的作用?继承和类别在实现中有何区别?
答案: category 可以在不获悉， 不改变原来代码的情况下往里面添加新的方法， 不能删除修改。
并且如果类别和原来类中的方法产生名称冲突， 则类别将覆盖原来的方法， 高的优先级。
类别主要有 3 个作用:
(1) 将类的实现分散到多个不同文件或多个不同框架中。
(2) 创建对私有方法的前向引用。
(3) 向对象添加非正式协议。
继承可以增加，修改或者删除方法，并且可以增加属性。

25 .类别和类扩展的区别。
  只能添加，
因为类别具有更
答案:category 和 extensions 的不同在于 后者可以添加属性。 另外后者添加的方法是必须 要实现的。
extensions 可以认为是一个私有的 Category 。

26 .oc 中的协议和 java 中的接口概念有何不同?
答案: OC 中的代理有 2 层含义，官方定义为 formal 和 informal protocol 。前者和 Java 接口一样。
informal protocol 中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就 会改变类的属性。
其实关于正式协议， 类别和非正式协议我很早前学习的时候大致看过， 也写在了学习教程里 ―非正式协议概念其实就是类别的另一种表达方式 ―这里有一些你可能希望实现的方法，你可 以使用他们更好的完成工作 ‖。
这个意思是， 这些是可选的。 比如我门要一个更好的方法， 我们就会申明一个这样的类别去 实现。然后你在后期可以直接使用这些更好的方法。 这么看，总觉得类别这玩意儿有点像协议的可选协议。 "
现在来看，其实 protocal 已经开始对两者都统一和规范起来操作，因为资料中说 ―非正式协 议使用 interface 修饰 ―，
现在我们看到协议中两个修饰词: ―必须实现 (@requied) ‖和 ―可选实现 (@optional) ‖。

 26 What are KVO and KVC?
答案: kvc: 键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用
存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。 apple 文档其实给了一个很好的例子。
kvo: 键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。
比如我自定义的一个 button
[cpp]
[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
{
if ([keyPath isEqualToString:@"highlighted"] ) { [self setNeedsDisplay];
} }
对于系统是根据 keypath 去取的到相应的值发生改变， 理论上来说是和 kvc 机制的道理 是一样的。
对于 kvc 机制如何通过 key 寻找到 value :
―当通过 KVC 调用对象时， 比如: [self valueForKey:@ 几种不同的方式解析这个调用。首先查找对象是否带有
会继续查找对象是否带有 someKey 这个实例变量(
试图调用 -(id) valueForUndefinedKey: 这个方法。如果这个方法还是没有被实现的话，程序 会抛出一个 NSUndefinedKeyException 异常错误。
(cocoachina.com 注: Key-Value Coding 查找方法的时候，不仅仅会查找 someKey 这个方 法，还会查找 getsomeKey 这个方法，前面加一个 get，或者 _someKey 以及 _getsomeKey 这几种形式。同时，查找实例变量的时候也会不仅仅查找 someKey 这个变量，也会查找 _someKey 这个变量是否存在。)
设计 valueForUndefinedKey: 方法的主要目的是当你使用 -(id)valueForKey 方法从对象中请 求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的 两个例子说明了这样做的好处。 ―
来至 cocoa ，这个说法应该挺有道理。
因为我们知道 button 却是存在一个 highlighted 实例变量 .因此为何上面我们只是 add 一个 相关的 keypath 就行了，
‖ someKe时y，‖]程序会自动试图通过 someKey 这个方法，如果没找到，
iVar )，如果还没有找到，程序会继续

27.代理的作用?
答案: 代理的目的是改变或传递控制链。 允许一个类在某些特定时刻通知到其他类， 而不需 要获取到那些类的指针。可以减少框架复杂度。
另外一点，代理可以理解为 java 中的回调监听机制的一种类似。
28What are mutable and immutable types in Objective C?
oc 中可修改和不可以修改类型。
答案: 可修改不可修改的集合类。 这个我个人简单理解就是可动态添加修改和不可动态添加 修改一样。
比如 NSArray 和 NSMutableArray 。前者在初始化后的内存控件就是固定不可变的， 后者可 以添加等，可以动态申请新的内存空间
29When we call objective c is runtime language what does it mean? 我们说的 oc 是动态运行时语言是什么意思? 答案:多态。主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
简单来说， 运行时机制使我们直到运行时才去决定一个对象的类别， 定方法。
多态: 不同对象以自己的方式响应相同的消息的能力叫做多态。 都用有一个相同的方法 -eat; 那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 调用各自的 eat 方法。 也就是不同的对象以自己的方式响应了相同的消息(响应了 因此也可以说，运行时机制是多态的基础?

30.通知和协议的不同之处?
答案:协议有控制链 (has-a) 的关系，通知没有。 首先我一开始也不太明白，什么叫控制链(专业术语了 ~ )。但是简单分析下通知和代理的 行为模式，我们大致可以有自己的理解 简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解， 到不是直接说不能一对多， 比如我们知道的明星经济代理人， 很多时候 一个经济人负责好几个明星的事务。 只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理 A 明星要一个发布会，代理人发出处理发布会的消息后，别称 B 的 发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。 因此控制链( has-a 从英语单词大致可以看出，单一拥有和可控制的对应关系。
以及调用该类别对象指 意思就是假设生物类 ( life )
eat ，但是调用是我们只需 eat 这个选择器)。

 47HTTP 协议详解
HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒
体信息系统。目前在 WWW 中使用的是 HTTP/1.0 的第六版， HTTP/1.1 的规范化工作正在 进行之中。
http (超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议，常基于
TCP 的连接方式， HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都 是构建在 HTTP 协议之上的 Web 应用。
HTTP 协议的主要特点可概括如下:
1.支持客户 /服务器模式。
2.简单快速:客户向服务器请求服务时， 只需传送请求方法和路径。
HEAD 、 POST 。每种方法规定了客户与服务器联系的类型不同。由于
得 HTTP 服务器的程序规模小，因而通信速度很快。
3. 灵活:HTTP 允许传输任意类型的数据对象。 正在传输的类型由
4. 无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收 到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态: HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息， 则它必须重传， 这样可能导致每次连接传送的数据 量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

49TCP/UDP 区别联系
TCP--- 传输控制协议 ,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数 据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。 TCP 提供超时重发，丢 弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP--- 用户数据报协议，是一个简单的面向数据报的运输层协议。 UDP 不提供可靠性，它 只是把应用程序传给 IP 层的数据报发送出去， 但是并不能保证它们能到达目的地。 由于 UDP
在传输数据报前不用在客户和服务器之间建立一个连接， 且没有超时重发等机制， 故而传输 速度很快
请求方法常用的有 GET 、 HTTP 协议简单，使
Content-Type 加以标记。
 TCP ( Transmission Control Protocol ，传输控制协议)是基于连接的协议，也就是说，在 正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次 ―对话 ‖才能 建立起来，我们来看看这三次对话的简单过程: 1. 主机 A 向主机 B 发出连接请求数据包;
2. 主机 B 向主机 A 发送同意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收，
协调工作)的数据包; 3. 主机 你接着吧! ‖，这是第三次对话。
―对话 ‖之后，主机 A 才向主机
UDP (User Data Protocol ，用户数据报协议)是与 TCP 相对应的协议。它是面向非连接
A 再发出一个数据包确认主机 B 的要求同步: ―我现在就发， 三次 ―对话 ‖的目的是使数据包的发送和接收同步，经过三次
B 正式发送数据。
的协议，它不与对方建立连接，而是直接就把数据包发送过去! 少量数据、对可靠性要求不高的应用环境。
tcp 协议和 udp 协议的差别 是否连接面向连接面向非连接
传输可靠性可靠不可靠
应用场合传输大量数据少量数据
速度慢快

50 socket 连接和 http 连接的区别
简单说， 你浏览的网页 (网址以 http:// 开头 ) 都是 http 协议传输到你的浏览器的 于 socket 之上的。 socket 是一套完成 tcp ， udp 协议的接口。
HTTP 协议:简单对象访问协议，对应于应用层 ， HTTP 协议是基于 TCP
tcp 协议: 对应于传输层 ip 协议: 对应于网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输;而 HTTP 是应用层协议，主要解 决如何包装数据。
Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议，而是一个调用接口( API )，通 过 Socket ，我们才能使用 TCP/IP 协议。
http 连接: http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应 后连接即会断掉;
socket 连接: socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将 不会主动断掉; 但是由于各种环境因素可能会是连接断开， 比如说: 服务器端或客户端主机
down 了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该连接以 释放网络资源。所以当一个 socket 连接中没有数据的传输，那么为了维持连接需要发送心 跳消息 ~~具体心跳消息格式是开发者自己定义的
UDP 适用于一次只传送, 而 http 是基连接的
 我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢? socket 起源于 Unix ，而 Unix/Linux 基本哲学之一就是 ―一切皆文件 ‖，都可以用 ―打开 open –> 读写 write/read –> 关闭 close ‖模式来操作。 我的理解就是 Socket 就是该模式的一个实现， socket 即是一种 特殊的文件，一些 socket 函数就是对其进行的操作(读 /写 IO、打开、关闭)，这些函数我 们在后面进行介绍。我们在传输数据时，可以只使用(传输层) TCP/IP 协议，但是那样的 话，如果没有应用层，便无法识别数据内容， 如果想要使传输的数据有意义，则必须使用到 应用层协议，应用层协议有很多，比如 HTTP 、FTP 、TELNET 等，也可以自己定义应用层 协议。 WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做 传输层协议将它发到网络上。
1)Socket 是一个针对 TCP 和 UDP 编程的接口， 你可以借助它建立 TCP 连接等等。 而 TCP 和 UDP 协议属于传输层 。
而 http 是个应用层的协议，它实际上也建立在 TCP 协议之上。
(HTTP 是轿车，提供了封装或者显示数据的具体形式; Socket 是发动机，提供了网络通信
的能力。 )
2 )Socket 是对 TCP/IP 协议的封装， Socket 本身并不是协议， 而是一个调用接口 ( API )，
通过 Socket ，我们才能使用 TCP/IP 协议。 Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们知道的一些最基本的函数 接口。

51 什么是 TCP 连接的三次握手
第一次握手: 客户端发送 syn 包 (syn=j) 到服务器， 并进入 SYN_SEND 状态， 等待服务器确 认;
第二次握手:服务器收到 syn 包，必须确认客户的 SYN (ack=j+1 )，同时自己也发送一个 SYN 包( syn=k )，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态; 第三次握手:客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=k+1) ， 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。
握手过程中传送的包里不包含数据， 三次握手完毕后， 客户端与服务器才正式开始传送数据。 理想状态下， TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前， TCP 连接 都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求， 断开过程需要经过 ―四次握手 (‖过程就不细写了， 就是服务器和客户端交互， 最终确定断开)
52 利用 Socket 建立网络连接的步骤
建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一
个运行于服务器端，称为 ServerSocket 。 套接字之间的连接过程分为三个步骤:服务器监听，客户端请求，连接确认。
 1。服务器监听: 服务器端套接字并不定位具体的客户端套接字， 而是处于等待连接的状态， 实时监控网络状态，等待客户端的连接请求。
2。客户端请求:指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为 此，客户端的套接字必须首先描述它要连接的服务器的套接字， 指出服务器端套接字的地址 和端口号，然后就向服务器端套接字提出连接请求。
3。连接确认:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应 客户端套接字的请求， 建立一个新的线程， 把服务器端套接字的描述发给客户端， 一旦客户
端确认了此描述， 双方就正式建立连接。 而服务器端套接字继续处于监听状态， 继续接收其 他客户端套接字的连接请求。

 7. runtime 如何通过 selector 找到对应的 IMP 地址?(分别考虑类方法和实例 方法)
每一个类对象中都一个方法列表 , 方法列表中记录着方法的名称 ,方法实现 , 以及参数类型 , 其实 selector 本质就是方法名称 ,通过这个方法名称就可以在方法列表中找到对应的方法实现

11.苹果是如何实现 autoreleasepool的?
autoreleasepool 以一个队列数组的形式实现 objc_autoreleasepoolPush objc_autoreleasepoolPop objc_aurorelease
release、访问已经释放对象的成员变
看函数名就可以知道， 对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行 操作。
release

4. 图层动画(路径)
 
45. 你了解哪些加密方式?
Base64, MD5, 循环右移位

34.Cocoa 中有虚基类的概念么?怎么简洁的实现?

35. 自动释放池跟 GC(垃圾回收)有什么区别? iPhone 上有 GC么?[ pool release] 和[ pool drain]有什么区别?
iPhone 上没有 GC。iPhone 开发的时候没有垃圾回收机制。
在垃圾回收环境中， release 是一个空操作。因此， NSAutoreleasePool 提供了 drain 方法，在引用计数环境中，该方法的作用等同于调用 release ，但在垃圾 回收环境中，它会触发垃圾回收(如果自上次垃圾回收以来分配的内存大于当前的阈值)。因此，在通常情况下，您应该使用 动释放池。

62. objc的内存管理 如果您通过分配和初始化(比如
)的方式来创建对象，您
[[MyClass alloc] init] 就拥?有这个对象，需要负责该对象的释放。这个规则在使用 NSObject 的便利
方法 new 时也同样适用 . 如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放 .
如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对 象。 如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它 (这个规则有少数?的 例外，在参考文档中有显式的说明)。
63. 自动释放池是什么 ,如何工作
当您向一个对象发送一个 autorelease 消息时， Cocoa 就会将该对 象的一个引 用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的 作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置 时， 自动释放池就会被释放，池中的所有对象也就被释放。
1. ojc-c 是通过一种 "referring counting"( 引用计数 )的方式来管理内存的 , 对象在 开始分配内存 (alloc) 的时候引用计数为一 ,以后每当碰到有 copy,retain 的时候引 用计数都会加一 , 每当碰到 release 和 autorelease 的时候引用计数就会减一 ,如 果此对象的计数变为了 0, 就会被系统销毁 2.?. NSAutoreleasePool 就是用来做 引用计数的管理工作的 ,这个东西一般不用你管的 3..?autorelease 和 release 没 什么区别 ,只是引用计数减一的时机不同而已 ,autorelease 会在对象的使用真正 结束的时候才做引用计数 减一 .

 kvo 的实现
kvo 键 -值观察机制 Key-Value Observing : 当制定的对象的属性被修改后，对象就会接到通知。每次指
定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。

网络请求传表单
用 NSURLRequest ，自已拼接 post 体，然后发请求，比较
麻烦。
可以利用第三方的如 afnetworking 完成
[urlRequest setHTTPMethod: @"POST"];
[urlRequest setValue: IPADDRESS forHTTPHeaderField:@"Host"]; [urlRequest setValue: postLength forHTTPHeaderField:@"Content-Length"]; [urlRequest setValue: @"application/x-www-form-urlencoded"
forHTTPHeaderField:@"Content-Type"]; [urlRequest setHTTPBody: postData];

如何和服务器进行交互， 交互怎么向服务器 传一个表单。
还有除了 afnetworking 和 sdwebimage 还 有哪些请求方式。
比较原始的 NSURLRequest ， nsurlconection 其他著名第三方， ASihttprequest, MKNetworkKit

观察者模式
观察者模式完美的将观察者和被观察者分离开。 观察者模式定义了对象间的一种一对多的依赖关系，以便一个对象的状态
发生变化时，所有依赖它的对象都得到通知并自动刷新。 在IOS 开发中经典观察者模式的实现方式有:
NSNotificationCenter 、KVO 等 优势: 解耦合
解耦合: 把原来引用很紧密的对象通过中间一层的分离， 敏捷原则: 开放 —封闭原则
不直接引用
通知 NSNotificationCenter :
一般为 model 层对 controller 和 view 进行的通知方式，不关心
谁去接收，只负责发布信息。
通知可以是一对一，也可以是一对多。 实例: Notification 通 知中心，注册通知中心，任何位置可以发送消息，注册观察 者的对象可以接收。
kvo 键 -值观察机制 Key-Value Observing :

 当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。

代理模式 代理的目的是改变或传递控制链。
允许一个类在某些特定时刻通知到其他类，而不需要获取到 那些类的指针。可以减少框架复杂度。
应用场景: 当一个类的某些功能需要由别的类实现，但是又 不确定由哪个类实现，可以使用代理实现。
实例: tableview 、 Scrollview 等中的 delegete ⋯
 ********************************************
 解释一下多态
多态:用父类指针指向子类的对象。 通过不同的对象调用相
同的名称的方法，却产生不同的结果。
通过父类指针得到的几个对象， 都调用了父类中某个方法， 但实际上 在运行的时候，是执行的自己真实类中的方法。
多态增强了软件的 灵活性 和重用性 。
方法的重载也是多态的一种体现，但是在 OC 中，方法的参 数个数不同，方法名也不同，因此不符合方法重载的定义。
********************************************
nsstring 拼接字符串，内部实现机制
Objective C 中有很多不定参函数， 例如 NSLog(format, arg1, arg2) ， 还 有 字 符 串 或 数 组 在 构 造 时 所 用 的 [NSString
stringWithFormat: format, arg1, arg2, arg3] ，它们的方法原 型分别是:
FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);
http://jingyan.baidu.com/article/f0062228c4679efbd3f0c82 7.html
******************************************** 网络请求 afnetworking
1. 首 先 需 要 实 例 化 一 个 请 求 管 理 器 对 象 AFHTTPRequestOperationManager
2. 设置请求和返回数据格式(是二进制? json ? plist ?)

 3. 如果登陆传参，设置传递的参数，字典(键名为参数名， 键值为参数值)
4. 发get 或 post 请求，去网络取数据。返回的数据成功和失败 分别是在两个块中进行处理。
********************************************
不用块怎么做 用协议代理实现
******************************************** 工厂模式怎么做 ,画图
工厂模式是我们最常用的实例化对象模式了 ， 是用工厂方 法代替 new 操作的一种模式 。

********************************************
视频和音频的上传和下载怎么实现 可以用第三方的 afnetworking 实现
上传:
找到要上传资料的 url –> 获取服务器上的 php 文件
url 创建请求 –> 创建管理者 –> 设置数据类型 发送请求
下载:
获取要下载的资源的 url 创建下载请求
******************************************** kvo 和 kvc 是什么，什么时候用到过
kvo 键 -值观察机制 Key-Value Observing :
当制定的对象的属性被修改后，对象就会接到通知。每次指 定的被观察的对象的属性被修改后， KVO 自动通知相应的观 察者。
键值对改变通知的观察者，极大的简化了代码。 kvc 键 -值编码 Key-Value Coding :
是一种间接访问对象的属性。使用字符串来标识属性，而不 是通过调用存取方法，直接或通过实例变量访问的机制。

 ********************************************
频道和下边显示的新闻切换是如何实现的 每个频道是一个按钮， 然后把频道放到小的 scrollview
上面;
每个频道的新闻的详情都可以用 tableview 展示，把
多个 tableview 放到大的 scrollview 上; 点击上面的频道按钮是，可以调整下面 scroolview 的
contentoffset ，展示对应的新闻列表;同样，当切换 下面展示的新闻列表是，上面选中的频道按钮改变;
完成方式最好采用自定义 ContainerController
********************************************
做没做过注册，怎么做注册 注册有很多方式，常用的方式有电话注册、 邮箱注册。
发短信注册可以使用第三方的， 比如友盟、 shareSDK， 去下载对应的 SDK 实现
注册的界面: 注册需要有输入框，并且输入的电话或 者邮箱要进行客户端的验证，符合格式才发送到服务 器。进行 格式验证 有多种方式，比较简单灵活的方式 是选择正则表达式验证。
注册通常还需要一个 验证码 ，验证码可以通过手机发 送，如果是图形的验证码，可以通过第三方生成。

******************************************** 用没用过 sqlite ，怎么用
创建数据库 引入类库 获得沙盒路径 创 建或打开数据库 判断是否打开成功，如果成功， 可以进行增、删、改、查操作 关闭数据库
********************************************
什么是索引
索引是对数据库表中一列或者多列的值进行排序的 一种结构。通过索引，可以快速的访问数据表中的特
定信息。
********************************************
数据库里的主键是什么 数据库中存储的是多张表，每张表中有多行数据，能
够唯一标示表中每一行的数据项就是主键。 另外主键可以是一个或者多个联合主键

快速排序的时间复杂度是多少 平均 时间复杂度
插入排序 O(n^2 ) 冒泡排序 O(n^2 ) 选择排序 O(n^2 ) 快速排序 O(n log n) 堆排序 O(n log n) 归并排序 O(n log n) 基数排序 O(n) 希尔排序 O(n^1.25 )

做没做过缓存，怎么做缓存？？？？？
第一种: 将服务器第一次返回的数据保存在沙盒里
面。这样在手机断网的情况下可以从本地读取数据了。 取数据时先去沙盒取，要是没有再联网获取。
第二种:使用 ASIHTTPRequest 和 ASIDownloadCache 实现本地缓存
1、可以将数据缓存到本地磁盘。
2、可以判断一个资源是否已经被缓存。如果已经被缓存，在请求相同的资源，先到本地磁盘搜索。
3、可以判断文件缓存什么时候过期。 这里为了简单起见这里， 我们在请求 url 资源的时候， 给每次请求的文件设定一个过期的时间。
4、可以实现:如果文件已经被缓存，而且没有过期，这将本地的数据返回，否则重新请求 url 。
5、可以实现:如果文件下载不成功或者下载没有完成，下次打开程序的时候，移除这些没 有成功或者没有下载完成的文件。
6、可以实现:同时请求或者下载多个资源。

AFN 传值方式?
AFNetworking 用于网络数据传输以及网络中多线程的处 理。
AFN 中我们常用的功能有发 GET/POST 请求， json 、plist 数据的解析，上传和下载等 ⋯
如何使用 AFN ?
1. 首 先 需 要 实 例 化 一 个 请 求 管 理 器 对 象 AFHTTPRequestOperationManager
2. 设置请求和返回数据格式(是二进制? json ? plist ?) 3. 如果登陆传参，设置传递的参数，字典(键名为参数名，
键值为参数值)
4. 发get 或 post 请求，去网络取数据。返回的数据成功和失败 分别是在两个块中进行处理。
AFN 特性
1. 登录传参时，传递字典即可(键名为参数名，键值为参数值)
2. 自动到子线程中执行，执行完返回到主线程 返回的结果自动序列化为 NSDictionary

让你做一个类似 QQ 音乐的东西，怎么做?
< 一 > QQ 音乐最核心的功能就是 歌曲的播放 。
播放音频， 首先想到可以用 AVFoundation 框架， 来完成播放 音乐的主要功能。但是 AVFoundation 只能播放本地的音乐， 不能在线播放。虽然可以先从网络下载资源到本地在播放， 但是必须要整首歌都下载完成后才能播放，这样效果并不好。
如果想在线播放， 可以选择 AudioToolbox 框架中的音频队列 服务 Audio Queue Services 。音频队列服务可以完成音频的 录制和播放。
一个音频服务队列 Audio Queue 有三部分组成: 三个缓冲器 Buffers: 每个缓冲器都是一个存储音频数据的临时仓库。
一个缓冲队列 Buffer Queue: 一个包含音频缓冲器的有序队列。 一个回调 Callback: 一个自定义的队列回调函数。
音频播放的流程:
将音频读取到缓冲器中， 一旦一个缓冲器填充满之后就放到缓冲队列 中，然后继续填充其他缓冲器;当开始播放时，则从第一个缓冲器中 读取音频进行播放; 一旦播放完之后就会触发回调函数， 开始播放下 一个缓冲器中的音频， 同时填充第一个缓冲器放; 填充满之后再次放 回到缓冲队列。
流媒体
好的音乐播放器要保证播放的流畅性，一定是边加载边播放， 如果做得再好一些，可以用流媒体来做。
详细内容后续给大家补充 ⋯
< 二 > 获取歌单，显示在界面
这部分主要通过 AFN 来从网络获取歌曲信息，然后展示在界 面上。对于界面展示这部分比较熟悉，做起来难度不大。 自 己补充分析一下 ⋯
< 三 > 歌曲下载到本地存储
歌曲离线下载管理这部分，也很重要。歌曲名称、作者等相 关信息可以存储到数据库中，歌曲的源文件以及歌词文件， 下载之后存到沙盒中指定的文件夹中。
<四>其他 其他的设置等功能和其他软件大同小异。
可以比照 QQ 播放器，挑自己熟悉的地方详细的解释说明一 下，是如何实现的。

json序列化反序列化
序列化就是将数据转成NSData然后进行传输。 反序列化就是把得到的数据， 转为字典或数组使用。 可以使用NSJSONSerialzation完成

流媒体
流媒体技术也称流式媒体技术。所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器，让用户一边下载一边观看、收听，而不需要等整个压缩文件下载到自己的计算机上才可以看到的网络传输技术。
该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲

什么时候会报 unrecognized selector 的异常?
一个 objc 对象如何进行内存布局?(考虑有父类的情况)

runtime通过selector找到对应的IMP地址?(分别考 虑类方法和实例方法)
使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么?中o的bjc类方法和实例方法有什么本质区别和联系?
objc_msgForward 函数是做什么的， 直接调用它将会发 生什么?
runtime如何实现 weak 变量的自动置 nil ?
能否向编译后得到的类中增加实例变量?能否向运行时 创建的类中添加实例变量?为什么?
通AR过C什么方式帮助开发者管理内存?
手动指定 autoreleasepool 的前提下，一个 autorealese 对象在什么时刻释放?(比如在一个 vc的viewDidLoad 中创建)
BACDC_EASS在什么情况下出现?
果是如何实现 autoreleasepool 的?

第三方登录分享
1. 注册并登陆第三方开放平台，向第三方平台注册 APP ，添加 APP 名称、图标、基本描述 等信息，等待审核通过;
2.APP 在第三方审核通过后，会获得一个 app id 和一个 app key (不同的平台可能名字不 一样，但都类似于 APP 账号和密码的意思)，这个 id 和 key 在 APP 代码里会用到，主要 用于提供给第三方获取认证信息用;
3. 将第三方 SDK 集成进我们的代码里，根据文档说明， Xcode 中设置相应的配置信息(如 跳转第三方的 URL 、一些第三方需要的特定编译选项等)，开发调试;
Socket :通常也称作 "套接字 "，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来 实现不同虚拟机或不同计算机之间的通信。任何用户在通话之前，首先要占有一部电话机，
相当于申请一个 Socket ;同时要知道对方的号码，相当于对方有一个固定的 Socket 。然后 向对方拨号呼叫，相当于发出连接请求(假如对方不在同一区内，还要拨对方区号，相当于 给出网络地址) 。假如对方在场并空闲(相当于通信的另一主机开机且可以接受连接请求) ， 拿起电话话筒，双方就可以正式通话，相当于连接成功。双方通话的过程，是一方向电话机 发出信号和对方从电话机接收信号的过程， 相当于向 Socket 发送数据和从 socket 接收数据。 通话结束后， 一方挂起电话机相当于关闭 Socket ，撤消连接。 Socket 的通信过程是透明的， 用户不需要了解具体的细节。
TCP/UDP :传输层协议; TCP 是面向连接的可靠传输; UDP 的传输不是面向连接的，不可 靠;TCP 应用于大量数据传输时， 慢;UDP 应用于少量数据时， 快。TCP ，浏览网页， UDP ，
聊天消息的发送。TCP 是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一
个 TCP 连接必须要经过三次“对话”才能建立起来，简单过程:主机 A 向主机 B 发出连接 请求数据包:“我想给你发数据，可以吗?”，这是第一次对话;主机 B 向主机 A 发送同 意连接和要求同步 (同步就是两台主机一个在发送， 一个在接收， 协调工作) 的数据包: “可 以，你什么时候发?”，这是第二次对话;主机 A 再发出一个数据包确认主机 B 的要求同 步:“我现在就发，你接着吧!”，这是第三次对话。三次“对话”的目的是使数据包的发 送和接收同步，经过三次“对话”之后，主机 A 才向主机 B 正式发送数据。
UDP ，是面向非连接的。“面向非连接”就是在正式通信前不必与对方先建立连接，不管 对方状态就直接发送。 与手机短信非常相似: 你在发短信的时候， 只需要输入对方手机号就 OK 了。
APP 审核被拒 :
提交 app 与描述不符
提交的描述中含有与 IOS 平台不相关的关键字，如 android windows phone 等 在版本信息中加入 Bate 字样，因为 apple 不希望你提交的软件还是不稳定 页面布局混乱
需要登录才能使用相关功能，未提交测试账号
存在明显的 bug
性能测试
Product->Profile
视频
音频
音乐播放:
AVAudioPlayer ，它支持多种音频格式，而且能够进行进度、音量、播放速度等控制。 AVAudioPlayer 的使用比较简单:
初始化 AVAudioPlayer 对象，此时通常指定本地文件路径。 设置播放器属性，例如重复次数、音量大小等。
调用 play 方法播放。

1.NSNotification是同步还是异步？作用是什么？
2.sizeof()的作用？

//////////////////////////////////////////////////////////////////////////////////////////
/******************************C语言基础******************************/
#变量：先定义、再使用
定义：可以改变的量；
格式：int a; //定义一个变量：申请一块存储空间
变量的赋值：int a = 3;//变量的初始化：在定义时直接赋值
注意：未初始化的变量的值是随机的，实质是垃圾数据；
命名：标识符-不能以关键字命名；
//输出：
printf("你好");//在""中写入要在终端输出的内容
printf("%d,%d",a,b);//在""里写入要输出的格式,后面跟着变量名
分类：作用域：变量在程序中的使用范围；
生命周期：变量在时间上的有效范围；
1).局部变量：定义在函数内部、代码块和形参列表中的变量；必须init
作用域：存储在栈中，在函数内部有效；
生命周期：从变量定义开始，到函数结束；
存储位置：局部变量存储在栈中，当作用域结束系统会自动释放栈中的局部变量；
2).全局变量：定义在所有函数外部的变量，只能通过对象来访问；不能定义的同时init、默认为0
作用域：存储在静态区，在整个文件内有效；
生命周期：从变量定义开始，到程序结束；
存储位置：全局变量存储在静态区中，随着程序的启动而创建，随着程序的结束而结束；
//extern和static的区别？
extern用来修饰全局变量，表示声明一个全局变量，仅仅是告诉系统我们有这个全局变量，不开辟内存空间；
extern用来修饰函数，表示声明/定义一个外部函数(可以被其他文件访问的函数)；
static用来修饰全局变量，表示定义一个内部全局变量，只能被当前文件访问，开辟内存空间；
static用来修饰局部变量，当执行到定义局部变量的代码就会分配存储空间，但只有程序结束才会释放该存储空间；
static用来修饰函数，表示定义一个内部函数(只能被当前文件访问的函数)；

#数据类型：任何变量都有数据类型
1).整型：默认int
类型     16位系统      32位系统       64位系统
short      2            2             2
int         2            4             4
long       4            4             8
unsigned //只能用来存正数
signed //有符号整数：二进制最高位是符号位
2).浮点型：用来存储小数，默认double
float   单精度   小数点后保留3—6位     4字节
double  双精度  小数点后保留13—16位    8字节
3).字符型：
char c;//定义一个字符型变量
字符型常量的表示形式：单引号只可以有一个字符 例如：'a'正确、'12'错误、'汉'错误
转义字符：'\n'
4).字符串常量："ABC"
ASCII码：字符型常量的整数表示形式，每个字符都对应一个ASCII码值
常用字符的ASCII码:'A'65 'a'97 '0'48
4).格式化输入输出的格式符：
%d      //十进制整型
%o      //八进制整型
%x      //十六进制整型
%f      //浮点型
%lf     //double型
%.mf    //保留小数点后m位
%c      //字符型格式符

#数组和指针：
概述：数组名作为函数参数，代表数组的首地址；
int *p = NULL;
int a = 5;
p = &a;
p++;//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
//指针数组
int *p[10];//数组：每个元素都是个指向整型的指针
//指向数组的指针
int (*p)[10];//指针：指向10个int元素的数组
//指向指针的指针
int **p;//指针：指向指针
//指向函数的指针
int (*p)(int a);//指向函数的指针
//指针作为函数返回值
格式：数据类型* 函数名(形参列表) {//...}
//交换两个变量？
1.传值：无法实现交换；
2.传地址：交换指针指向，无法实现交换；
3.传地址：交换指针指向变量的值，可以实现交换；

#结构体：
定义：相同或者不同数据类型变量的集合，自定义的数据类型；
格式：放在头文件下面、所有函数上面
//结构体定义用struct关键字，名字为data
struct data {
    //成员变量
    int a;
    char b;
    short c;
};
//结构体别名：wm_data
typedef struct data {
    int a;
    char b;
    short c;
}wm_data;
//难点：结构体指针？

#枚举：
定义：如果变量只有几种可能的值，可以使用枚举；
//枚举可以有无数个：不推荐使用
typedef enum direction {
    枚举1,
    枚举2,
    枚举3
} direction_t;
//定义通用枚举：只能同时存在一个枚举值
typedef NS_ENUM(NSInteger,WMDirection) {
    枚举1,
    枚举2,
    枚举3
};
//定义位移枚举：可以同时存在多个枚举值
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    枚举1,
    枚举2,
    枚举3
};

#共用体：使几个不同变量共同占用一段内存的结构
union date {
    int a;
    char b;
    short c;
};
大小：1.共用体变量所占内存长度等于最长成员的长度；
2.共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种；
3.共用体变量中起作用的成员是最后一次存放的成员；
/******************************Objective-C语言基础******************************/
#主头文件：
1.定义：拷贝了该工具箱中所有工具的头文件，只需要导入主头文件就可以使用该工具箱中所有的
工具，避免了每次使用都要导入一个对应头文件；
2.规律：所有的主头文件名称和工具箱名称一致；所有的主头文件都是导入了该工具箱中的所有的头文件
3.Frameworks地址：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks

#类：class
定义1：既可以存数数据，又可以管理数据-结构体(用来存储数据)+函数(用来管理数据)；
定义2：具有相同或相似性质对象的抽象就是类，对象的抽象就是类，类的具体化就是对象；
实质：类的实质也是一个对象、该对象会在这个类第一次被使用的时候创建；
//类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#类方法和对象方法的区别：
对象方法以"-"开头，必须用对象调用/类方法以"+"开头，必须用类调用；
对象方法中可以直接访问属性(成员变量)/类方法中不可以直接访问属性(成员变量);
类方法的执行效率比对象方法高；

#字符串：
//不可变字符串：NSString
Objective-C语言：NSString *msg = @"aaa";%@//在Cocoa中集成了一系列方法，可以很方便的操作字符串
C语言：char *msg = "aaa";/char msg[20] = "hello";%s//c语言将字符串作为字符数组
//可变字符串：NSMutableString
char c = ' ' //代表空格
见WMPayInfo.h/m；

#数组：
//不可变数组：NSArray
Objective-C语言：NSArray是一个类，任意类型对象地址的集合，不能存放简单的基本数据类型(int、float)；
C语言：数组是相同类型变量的有序集合，可以保存任意类型的数据；
注意：在iOS中，数组下标越界不会有警告，但是运行会直接报错；
//可变数组：NSMutableArray
定义：数组长度不确定的数组，是一个类；
特点：数组元素不能是基本数据类型，比如int；只能是对象的引用(指针)；
代码：见WMPayInfo.h/m；
遍历数组：通过下标遍历数组&快速枚举法(for in)&枚举器法

#NSEnumerator枚举器：直接作用于数组NSArray
NSEnumerator *enumerator = [array objectEnumerator];//返回一个枚举器
[array objectEnumerator];//正序输出所有元素：返回NSEnumerator
[array reverseObjectEnumerator];//逆序输出所有元素：返回NSEnumerator
NSArray *arr = [enumerator allObjects];//获取枚举器所有的元素
NSString *s = [enumerator nextObject];//nextObject指向第一个元素

#字典：
定义：由任意类型的对象地址构成键值对为元素的集合结构；
存储方式：无序保存的集合；
//不可变字典：NSDictionary
//可变字典：NSMutableDictionary
代码：见WMPayInfo.h/m；
遍历字典：枚举器法&快速枚举法；

#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？

#类扩展/匿名类别：声明和实现均在.m文件中
定义：可以定义不想对外公开的类的属性/方法；
格式：
@interface WMPayInfo()
-(void)show;
@end
功能：1.可以实现私有方法；
2.可以声明私有成员变量；

#虚方法：
定义：调用方法的时候，不看指针看对象，对象的地址指向什么对象就调用什么方法；
好处：可以描述不同事物被相同的事件触发，产生不同的响应；
特征：Objective-C语言每个方法都是虚方法；

#工厂类：NO
特点：NSString/NSArray/NSDictionary/NSNumber都是工厂类/抽象类，不能被继承；
不能被继承的原因：
NSString采用了“抽象工厂”模式，内部是个类簇(class cluster)，它在外层提供了很
多方法接口，但是这些方法的实现是由具体的内部类来实现的，当使用NSString生成一个对象时，
初始化方法会判断哪个“自己内部的类”最适合生成这个对象，然后这个“工厂”就会生成这个具体的
类对象返回给你，这种由外层类提供统一抽象的接口，然后隐藏具体的内部类来实现；

#内存管理：
//C语言：sizeof()是一个运算符，用来计算变量或数据类型的大小
1.静态内存分配：在编译阶段分配的内存
分配在数据段、只读数据段、栈区的内存，由编译器自动申请和释放的内存，称为静态内存分配；
2.动态内存分配：在运行阶段分配的内存
分配堆区的内存，手动申请100个字节的内存，并将这个空间的首地址返回给指针变量p；
char *p = (char *)malloc(100*sizeof (char)); //动态申请内存
free(p); //动态释放内存
3.注意：防止提前释放、防止内存泄露、防止重复释放；
4.区别：动态内存分配和静态内存分配的区别
静态内存分配：操作系统分配空间、空间在编译时确定，而非运行时、空间在栈段，数据段，只读数据段、自动释放空间
动态内存分配：程序员分配空间、运行时确定，每次运行都不同、空间在堆段、手动释放空间
5.总结：C语言的内存管理需要我们手动申请，手动释放
1>.手动申请内存，使用以后需要手动释放，如果不释放会造成内存泄露；
2>.不能多次释放，如果多次释放，则会崩溃；
3>.不能提前释放，如果提前释放再使用，也会崩溃；
6.问题：如果项目比较复杂，需要上百号人一起分工完成，就很容易出现问题：比如我们开辟了一块内存空间，
存放了一块很有用的数据。但是，这个数据不只有我在这一块代码里用，甚至有多个人，在程序的多个地方使用。
这样造成的结果：就算我使用完成这块内存，我也不能去释放他，因为我不能确定，别人在别的地方是否还需要
使用这块内存。内存泄露在所难免了；
//Objective-C语言：管理对象、基本数据类型不需要管理
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；

#协议protocol：直接新建、可以实现多继承
定义：Objective-C语言中用来规范方法的声明，可以实现多继承和对象间通信；
格式：见WMBook.h
注意：1.协议中只声明方法，不实现方法，也不能声明属性；
2.遵从协议的类必须导入协议头文件；
3.协议中@required权限的方法必须实现；//不实现不会报错、只会报警告
4.父类遵循某个协议，那么子类也遵循该协议；
5.协议的应用场景：类型限定？？？
遵从协议：见BaseViewController.h/m
/******************************iOS进阶******************************/
#KVC/KVO：
//KVC：键值编码(key-value-coding)
#作用：间接访问属性的方法
1.给对象赋值：[VC setValue:@"XWJ" forKey:@"name"];
2.通过键值路径获取属性的值：NSString *name = [VC valueForKey:@"name"];
NSString *name = [VC valueForKeyPath:@"name"];
3.字典转型Model：setValuesForKeysWithDictionary
NSDictionary *dic = @{
                        @"name":@"XWJ",
                        @{@"age",@"18"},
                    };//定义字典
PersonModel *p = [[PersonModel alloc]init];//创建模型
[p setValuesForKeysWithDictionary:dic];//字典转模型
注意：1.字典的key和Model的属性必须一一对应，否则会报错；
//KVO：键值观察者
#作用：用于监听对象属性的改变
1.下拉刷新/上拉加载监听UIScrollView的contentoffsize；
2.webview混排监听contentsize；
3.监听模型属性实时更新UI；
#步骤：
/**
给对象的属性添加观察者：
self.post-被观察者
self-观察者
array-属性
*/
[self.post addObserver:self forKeyPath:@"array" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL];
//给可变数组添加属性：
[[self mutableArrayValueForKeyPath:@"array"] addObject:@2];
//NSMutableSet==>[self mutableSetValueForKeyPath:@"可变集合属性名"];
//如果属性改变，自动调用方法：
-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {
    NSLog(@"new:%@",change[@"new"]);
    NSLog(@"old:%@",change[@"old"]);
}
//取消监听：
-(void)dealloc {
    [self.post removeObserver:self forKeyPath:@"name"];
}
代码：
https://www.jianshu.com/p/742b4b248da9
/******************************UI基础******************************/
#自定义控件：
1.在initWithFrame:方法中添加子控件，提供便利构造方法；
2.在layoutSubviews方法中设置子控件的frame：一定要调用[super layoutSubviews]；
3.增加模型属性，在模型属性set方法中设置数据到子控件；
代码：见WMGame

#跳转：
1).模态方式：见WidgetViewController.h/m->TimeViewController.h/m
基本方式传值：OK
block传值：实现回调
代理传值：OK
2).通过导航控制器迁移：见WidgetViewController.h/m

#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#数据源：
实质：数据源实质就是一个数组(NSArray、NSMutableArray)；
Model类必须是单例：全局都可能使用这个Model；
VC需要网络请求，可以委托(PostStore类)来进行网络请求；
PostStore类网络请求完成，需要告诉VC网络请求操作完成；

#懒加载：用到的时候再加载、全局只加载一次
定义：在开发中，程序启动的时候不加载资源，只有在运行中需要资源的时候，再去加载这些资源；
好处：1.不必将创建对象的代码全部写在viewDidLoad()中，代码的可读性强；
2.每个属性的getter方法中分别负责各自的实例化处理，只有真正需要资源的时候，才会加载资源，节省了内存资源；
//实现：重写getter方法
-(NSArray *)dataArr {
    if (_dataArr == nil) {  //这里不能使用self.dataArr：循环引用
        self.dataArr = @[@"",@"",@""];
    }
    return dataArr;
}
self.dataArr; //每次使用均会调用-(NSArray *)dataArr;

#瀑布流：
//实现原理：
我们利用多个UITableView联动就可以实现瀑布流效果：调用UIScrollView的代理方法
让多个UITableView的偏移量都等于UIScrollView的偏移量实现联动，当一个cell超过屏
幕，我们不要release，而是回收到复用队列，然后在创建cell的时候首先去复用队列中
取，如果没有我们在创建。
//代码：见WaterFall

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#实现画折线图：利用第三方库
1.加入tk库文件；
2.添加QuartzCore.framework；
/******************************iOS高级******************************/
#可视化布局：
//xib：可视化文件，可以通过拖拽进行界面布局，实质是一个xml文件
特点：只可以显示一个视图,在创建视图的时候可以同时创建(无需关联)；
- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
if (self) {
//xib初始化
}
return self;
}
xib加载UIViewController：
1.UIViewController *vc = [[SqliteViewController alloc]initWithNibName:@"One" bundle:nil];
//加载xib
NSArray *views = [[NSBundle mainBundle] loadNibNamed:@"xib名称" owner:nil options:nil];
UIView *view = [views firstObject];
2.关联class、拖线；
//xib的加载原理：NO
//storyboard：管理多个xib文件并处理场景与场景之间的跳转
UIStoryboard *main=[UIStoryboard storyboardWithName:@"Main" bundle:[NSBundle mainBundle]]; //Main指storyboard名字
UIViewController *vc=[main instantiateViewControllerWithIdentifier:@“VC”]; //VC指storyboard ID
UIViewController *vc = [main instantiateInitialViewController]; //启始ViewController实例化
总结：1.在storyboard/xib进行UI界面的布局；
2.通过Segue实现页面的跳转：自动型/手动型；
3.通过AutoLayout做适配；
4.UIStackView(iOS9.0以上)；
5.xib文件编译以后就成了nib文件；

#AutoLayout：
1.约束：通过给控件添加约束决定控件的位置和尺寸；
2.参照：在添加约束的时候是依照谁来添加的；
3.自动布局的核心计算公式：obj1.property1 = (obj2.property2 * multiplier)+constant value
https://www.jianshu.com/p/4ef0277e9c5e

#代码实现AutoLayout：NO

#VFL实现AutoLayout：NO

#多语言：en/tw/cn
定义：根据用户设置的Language and Region Format(语言和区域格式)修改应用
本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html //特别详细
https://www.jianshu.com/p/c7a6408410aa

#分享：
//原生分享
https://blog.csdn.net/qq_28009573/article/details/77744001
//shareSDK集成
注意：1.在Xcode7.0以上，需要在info.plist中设置访问权限；
https://www.cnblogs.com/xubojoy/p/3885932.html
https://www.jianshu.com/p/71499300a133

#第三方登录：基于OAuth2.0协议构建的OAuth2.0授权登录系统
1.微信登录：只提供原生登录方式(必须安装客户端)，所有使用之前必须判断；
https://www.cnblogs.com/sunfuyou/p/7843612.html
2.QQ登录：xxx
https://blog.csdn.net/alexander_wei/article/details/72626396
https://www.jianshu.com/p/133d84042483
3.微博登录：xxx
https://blog.csdn.net/zhonggaorong/article/details/51724810
https://blog.csdn.net/u010545480/article/details/53004699
https://www.jianshu.com/p/87d1d397d269

#断点续传：
定义：指任务在上传/下载的时候被人为划分为几个部分：每个部分采用一个线程进行上传/下载，如果遇到网络故障可以
继承在未完成的部分继续开始，没必要从头开始下载。
//原理
https://www.cnblogs.com/wangzehuaw/p/5610851.html
https://www.cnblogs.com/findumars/p/5745345.html
//实现
https://www.jianshu.com/p/0e6deea7de87
https://www.jianshu.com/p/01390c7a4957
https://blog.csdn.net/stree7cleaner/article/details/51440774
https://blog.csdn.net/lcg910978041/article/details/51487485

#即时通讯IM：
//底层原理：
1.协议：XMPP协议(基于xml的协议，具有超强的可扩展性)
2.XMPP的三个部分：服务器、网关、客户端(可以任意两者双向发生)
3.XMPP优缺点：
//优点：
1).XMPP协议是自由开源的，而且在C/S都有多种实现；
2).任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接；
3).利用XMPP技术开发软件，资源以及支持的来源都是多样的，这样就不会被“绑架”；
4).XMPP以TCP传递XML数据流，没有中央主服务器，任何人都可以运行自己的XMPP服务器；
5).XMPP基于XML具有很强的扩展性；
//缺点：
1).XMPP协议的服务器流量存在着被重复转发，数据负载太重；
2).XMPP协议基于XML文件(编码成单一的XML文件)，因此无法提供修改二进制数据；
//上层实现：环信
概述：环信通过云端开放的Rest api或者客户端SDK，摆脱IM底层开发，使App内置聊天功能；
步骤：1.制作推送证书、登录环信后台、创建应用生成AppKey；
2.通过cocoapods下载SDK：
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件：#import <EaseMobSDKFull/EaseMob.h>
3.按照环信集成开发文档操作；

#iOS与H5的交互：NO
//iOS与H5的交互
https://blog.csdn.net/sandyloo/article/details/65630863
https://www.jianshu.com/p/b0c847dcea9c
//利用WebViewJavascriptBridge
https://blog.csdn.net/qq_20455399/article/details/80353164
https://www.jianshu.com/p/96e01aed250b

#Swift和Objective-C混合编程：
//Objective-C工程调用Swift代码
https://blog.csdn.net/u010407865/article/details/62886943
https://www.jianshu.com/p/9f757a09eacd
//Swift工程调用Objective-C代码
https://blog.csdn.net/pjk1129/article/details/39644477
/******************************补充知识点******************************/
#PCH文件：参考Res/项目中常见的文件(PCH)

#正则表达式：
代码：NewNetworkViewController.h/m
搜索NSRegularExpression

#谓词： NSPredicate
概念：OC中谓词操作是针对于数组类型的，这样的好处是我们可以不需要编写很多代码就可以去操作数组、过滤数据；
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searcgString];
_ArrM = [NSMutableArray arrayWithArray:[_Arr filteredArrayUsingPredicate:predicate];//过滤数据

//获取当前时间
NSString *currentTime = [NSString stringWithFormat@"%@",[NSDate date]];
//隐藏NavigationBar
[self.navigationController setNavigationBarHidden:YES animated:YES];
//plist转NSArray
NSString *path = [[NSBundle mainBundle] pathForResource:@"Flower" ofType:@"plist"];
NSArray *array = [NSArray arrayWithContentsOfFile:path];
//跳转：隐藏TabBar
TestViewController *vc = [[TestViewController alloc] init];
vc.hidesBottomBarWhenPushed = YES;
[self.navigationController pushViewController:vc animated:YES];
//时间格式
NSString *data = [NSString stringWithFormat:@"%.2d:%.2d:%.2d",self.hour,self.minute,self.second];
//读取文件内容：dict.txt
NSString *fileConent = [[NSString alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"dict" ofType:@"txt"] encoding:NSUTF8StringEncoding error:nil];
NSArray *words = [fileConent componentsSeparatedByString:@"\n"];//转换成NSArray
//近距离感应
[[UIDevice currentDevice] setProximityMonitoringEnabled:YES];//打开红外线开关
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeAction:) name:@"UIDevieceProximityState" object:nil];//添加监听
- (void)changeAction:(NSNotification *)notification {
    if([[UIDevice currentDevice] proximityState]) {
        NSLog(@"靠近");
    } else {
        NSLog(@"远离");
    }
}
//json转换成字典
NSDictionary *dict=[NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
//根据字体计算高度：一行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = [name sizeWithAttributes:nameAtt];
CGFloat width = nameSize.width;
//根据最大宽度计算高度：多行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = CGSizeMake(100, MAXFLOAT);//宽度固定100，高度不确定
CGSize textSize = [name boundingRectWithSize:nameSize options:NSStringDrawingUsesLineFragmentOrigin attributes:nameAtt context:nil].size;
CGFloat height = textSize.height;
//https://www.cnblogs.com/niit-soft-518/p/6373601.html

#常见第三方库(Swift)：
https://github.com/SnapKit/Snapkit //Snapkit：自动布局
https://github.com/dacaizhao/MJExtensionSwift //MJExtensionSwift：字典转模型
https://www.jianshu.com/p/f4282df18537
https://www.jianshu.com/p/c74f6abc2eb7
https://www.jianshu.com/p/68e12b966d86

#DrawRect：NO
概念：Quartz 2D是一个基于CoreGraphics框架来实现的二维绘制引擎，同时支持iOS和Mac系统；
作用：绘制图形、线、三角形、圆、弧形；绘制文字；绘制/生成pdf；截图/裁剪图片；自定义UI；
https://blog.csdn.net/potato512/article/details/56845385
https://blog.csdn.net/mangosnow/article/details/37054765#0-qzone-1-85099-d020d2d2a4e8d1a374a433f596ad1440
/******************************面试部分******************************/
#Instruments：NO

#Interface Builder介绍：用来管理xib、storyboard

//UITableView的性能：cell的复用机制
移动设备的内存有限，如果使用一个cell就创建一个cell对象将会耗尽设备的内存。解决该问题需要引入
cell的复用机制：当UITableView发生滚动的时候，部分cell会移出窗口，这时候系统会将窗口外的
cell放入cell对象池中，等待复用。当UITableView要求dataSource返回cell的时候，dataSource
会首先查看cell对象池，返回cell对象池中未使用的cell给UITableView，从而避免创建新cell对象。
//http/https的区别：
http协议是明文协议、https是添加了加密和认证的协议
//常见的网络协议：
http协议、https协议、TCP/IP协议、FTP协议
//TCP/UDP的区别：
TCP是面向连接的，提供可靠的服务，UDP是无连接的，尽最大努力交付，不保证可靠服务；
TCP通过校验、重传控制、确认应答实现可靠传输，UDP具有较好的实时性；
TCP连接只能支持点对点，UDP支持交互通信；
//Internet采用哪种网络协议？该协议的主要层次结构？
tcp/ip协议，层次结构：应用层/传输层/网络层/数据链路层/物理层

//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；

//为什么加上__block就可以在block内部修改变量：
因为没有添加__block是值传递、加上__block是地址传递；
//[self class]|[self superclass]：
1.[self class]获取当前方法调用者的类；
2.[self superclass]获取当前方法调用者的父类；
//block怎么会导致循环引用：
xxx
//简述远程推送的步骤：
我们一般利用第三方极光推送完成远程推送功能：
1.登录苹果开发者后台，创建项目推送证书；
2.登录极光推送后台，上传证书，创建应用；
3.获取到AppKey、导入必要类库、按照开发文档操作；
//第三方登录总结：
xxx
//社会化分享总结：
1.对于系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：不需要集
成第三方库,不需要App Key;缺点：页面简单,不能自定制；
2.对于第三方分享：一般使用shareSDK，首先进入shareSDK官网获取App Key，集成shareSDK，
想要分享至哪些平台就去相应开放平台申请AppKey和AppSecret，然后按照文档构建分享内容。
//RSA加密算法：公钥加密算法
RSA加密算法除了可加密、解密之外，还可用来作签名校验：简单的说,RSA会生成一个私钥和
一个公钥，私钥你应该独自保管，公钥你可以分发出去；做签名验证时,你可以用私钥对需要传输
的数据做签名加密，生成一个签名值，之后分发数据,接收方通过公钥对签名值做校验，如果一致
则认为数据无篡改。
//参考：
http://blog.csdn.net/leaf8742
https://www.jianshu.com/p/1a94498de7f4
https://www.jianshu.com/p/2e1b3f54b4f3

2、数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速 访问数组中任何元素。链表恰好相反，其中的元素在内存中不是顺序存储的，而是通过 存在元素中的指针联系到一起。
3、发送同步请求，程序将停止用户交互，直至服务器返回数据完成，才可以进行下一 步操作。而发送异步请求不会阻塞主线程，会建立一个新的线程来操作，之后程序可以 继续运行。
4、autorelease 只是把 Object 放入了当前的 autorelease pool 中，当它被释放时，其中 的所有 Object 都会被调用 Release 。
5、作为 Objective-C 导入头文件的关键字， #import<> 用来包含系统的头文件， #import ”” 用来包含用户头文件。
三、简述题(每题 4分，共 20分)
1、delegate 和notification 有什么区别，什么情况下使用?
答: delegate :消息的发送者( sender )告知接收者( receiver )某个事件将要发生， delegate 同意然后发送者响应事件， delegate 机制使得接收者可以改变发送者的行为。

通常发送者和接收者的关系是直接的一对多的关系。
notification :消息的发送者告知接收者事件已经发生或者将要发生，仅此而已，接收 者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。

答:当一个视图控制器被创建，并在屏幕上显示的时候。代码的执行顺序 // 视图显示在屏幕上的顺序
1、 alloc
2、 init (initWithNibName) 3 、 viewload
有使用 xib 文件创建视图。 4、viewDidLoad
他控件。
5、viewWillAppear 在屏幕上。
6、 viewDidAppear
// 视图将被从屏幕上移除的顺序
1、 viewWillDisappear
2、 viewDidDisappear
3、dealloc 创建的对象进行释放。
4、viewDidUnload 前显示的 controller 执行。
创建对象，分配空间。 初始化对象 , 初始化数据。
从 nib 载入视图 , 这一步不需要去干涉。除非没
加载完毕，可以进行自定义数据以及动态创建其
视图将出现在屏幕之前，马上这个视图即将显示
视图已在屏幕上渲染完成。
视图将被从屏幕上移除之前执行。 视图已经被从屏幕上移除。 视图被销毁，此时需要在 init 和viewDidLoad 中
出现内存警告在内存不足时执行，并对所有非当
本视图的所有子视图将被销毁，以释放内存，此时开发者需要手动对 viewDidLoad 中创建的对象释放内存。
因为当这个视图再次显示在屏幕上的时候， viewLoad 、 viewDidLoad 以便再次构造视图。



/*
 
 在 IOS 中，少量的数据持久化可以使用属性列表、
 NSUserDefaults 、归档等;
 大量的数据持久化可以使用 SQLite 数据库、 Core Data 等，
 也可以使用 FMDB 第三方类库完成。

 58. 常见的数据持久化方法有哪些？
 1.NSUserDefaults: ?用来保存应 ?用程序设置和属性、 ?用户保存的数据。 ?用户再次 打开程序或开机后这些数据仍然存在。 NSUserDefaults 可以存储的数据类型包
 括:NSData 、NSString 、NSNumber 、NSDate 、NSArray 、NSDictionary 。
 如果要存储其他类型，则需要转换为前 储。
 ?面的类型，才能 ?用NSUserDefaults 存
 2.归档,反归档 3. ?文件读写 4.SQLite 5.CoreData


 1、 iOS 数据持久化存储方案有哪些?
 参考答案:
 plist属性列表存储(如 NSUserDefaults )
 文件存储 (如二进制数据写入文件存储， 通过 NSFileManager 来操作 将下载起来的二进制数据写一篇文件中存储)
 NSKeydeArchiver 归档存储，常见的是自动化归档 /解档处理，想要 学习如何通过 runtime 实现自动化归档 /解档，可
 数据库 SQLite3 存储(如 FMDB 、Core Data )
 2. 什么是数据持久化?简单谈一下你所了解的 中的数据持久化的方式。
 数据持久化就是将内存中的数据模型转换为存储模型 将存储模型转换为内存中的数据模型的统称 . 数据模型可以 是任何数据结构或对象模型 ,存储模型可以是关系模型、 XML 、 二进制流等。
 在 IOS 中，少量的数据持久化可以使用属性列表、 NSUserDefaults 、归档等;
 大量的数据持久化可以使用 SQLite 数据库、 CoreData 等， 也可以使用 FMDB 第三方类库完成。
 2.NSUserDefaults 适合存储轻量级的本地数据， 以键值对的形 式进行存储，只能存储基本的 OC 对象(不包括自定义的对象)。
 NSUserDefaults 非常好用，并不需要用户在程序中设置 NSUserDefaults 的全局变量，需要在哪里使用 NSUserDefaults 的数据，那么就在哪里创建一个 NSUserDefaults 对象，然后进行读或者写操作。
 针对同一个关键字对应的对象或者数据，可以对它进行重写， 重写之后关键字就对应新的对象或者数据，旧的对象或者数 据会被自动清理。
 NSUserDefaults 是典型的单例模式。
 3. ProtocolList属性列表，是一种用来存储串行化后的对象的文件。因为扩 展名为 plist ，因此通常被称为 plist 文件。
 plist 文件通常用于储存用户设置，也可以用于存储捆绑的信 息，其内容为 xml 格式。它可以在程序运行期间动态的创建
 和读写，因此可以用于少量数据时候的数据持久化。
 3. 归档优缺点?
  归档也叫序列化，是将文件存在硬盘，解档是从硬盘还原数 据。
 归档的形式来保存数据，只能一次性归档保存以及一次性解 压。所以只能针对小量数据，而且对数据操作比较笨拙，即 如果想改动数据的某一小部分，还是需要解压整个数据或者 归档整个数据。
 除了简单的归档，还可以实现对象的归档。对象归档是指对 象写入文件保存到硬盘上，当再次重写打开程序时，可以还
 原这些对象。可以实现对象序列化或者对象持久化。
 除了原有的 OC 对象以外，归档还可以对自定义的对象实现 归档，需要注意的是，自定义的归档对象必须要实现 NSCoding 协议，实现里面的解码和编码的方法。
 4. 什么是数据库?使用步骤?特点? 数据库是按照数据结构来组织、存储和管理数据的仓库。
 SQLite 使用步骤:创建数据库、引入类库、获得沙盒路径、 创建或打开数据库
 SQLite 比较原始，需要通过 sql 语句来创建表格，对数据进 行操作，用起来比较麻烦，但是可控性强。
 //数据持久化
 1.NSCache和数据持久化使用场景有什么区别？
 2.常用的数据持久化方法有哪些？各自有什么利弊？
 13.iOS怎么做数据持久化？coredata/sqlite之间又什么联系？coredata是关系型数据库吗？
 
 29.iOS平台怎么做数据持久化
 1、NSUserDefaults
 2、Plist
 3、数据库
 4、文件保存
 5、归档与反归档
 31.iOS平台怎么做数据的持久化?Core Data和SQLite有无必然联系？Core Data是一个关系型数据库吗？
 答：iOS中可以有四种持久化数据的方式： 属性列表、对象归档、SQLite3和Core Data
  Core data与sqlite还是有联系的，core data 是对sqlite的封装，因为sqlite是c语言的api，然而有人也需要obj-c 的api，所以有了 core data 另外，core data不仅仅是把c的api翻译成oc 的api，还提供了一些管理的功能，使用更加方便
 Core Data不是一个关系型数据库，也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型，但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系
 
 3、iOS有哪些数据持久化方式?
 答:四种:属性列表、对象归档、 SQLite3 和Core Data 。
 4、Objective-C 如何对内存管理的 , 说说你的看法和解决方法?
 答: Objective-C 的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内 存池。解决方法的话:谁持有，谁释放。
 
 #App的主目录：沙盒机制NSHomeDirectory()
 概念：沙盒机制是一种安全体系，规定了应用程序只能在该应用创建的文件夹内读取文件，不可以
 访问其他地方的内容。所有的非代码文件都保存在这个地方：比如图片、声音、属性列表和文本文件等；
 沙盒中的文件：Documents(持久化数据)、Library(缓存)、tmp(临时文件)
 NSString *home = NSHomeDirectory(); //沙盒根目录
 NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; //获取Documents(持久化数据)
 NSString *libarayPath = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject]; //获取Library(缓存)
 NSString *tempPath = NSTemporaryDirectory(); //获取tmp(临时文件)
 注意：1).每个应用程序都在自己的沙盒；
 2).不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容；
 3).应用程序向外请求或接收数据都需要经过权限认证；

 #数据持久化的方法：存放在沙盒
 原因：通常程序在运行中或者程序结束以后，需要保存一些信息，比如登录信息，视频播放记录，收藏等；
 常见方法：
 1.文件操作：见FileViewController.h/m
 2.plist：属性列表文件-只能存储NSString/NSNumber/NSDate/NSArray/NSDictionary
 作用：对一些登录、注册和配置信息进行持久化存储；
 格式：xml语法；
 创建：Xcode创建/代码创建
 读取：需要时自行百度
 3.NSUserDefaults：见FileViewController.h/m
 4.归档/解归档：一种序列化与反序列化
 //归档
 //解归档
 https://www.jianshu.com/p/3e08fa21316d
 5.数据库：
 //sql语句：结构化查询语言
 1.创建表
 create table if not exists sso (
 id integer primary key autoincrement,//将id设为主键
 author text,//文本
 price real,//浮点型
 pages integer);//整型
 2.插入
 insert into sso (author,price,pages) values(?,?,?);
 3.更新
 update sso set price = ?,pages = ? where author = ?;
 4.删除
 delete from sso where pages > ?;
 5.查询
 select * from sso;
 //FMDB
 代码：SqliteViewController.h/m
 //MagicalRecord：
 一.Core Data：
 1.新建Core Data；
 2.新建表：写上需要存储的文件；
 3.关联生成属性类；
 二.导入数据：
 4.导入MagicalRecord；
 三.app启动：
 5.设置数据库存放的文件名；
 6.让Magical Record支持数据库版本管理；
 7.查询所有的数据库内容，如果有内容则送到数据源；
 if([MusicInfo MR_findAll].count) {
     for(MusicInfo *music in [MusicInfo MR_findAll]) {
         MusicInformation *musicInfo = [[MusicInformation alloc] init];
         musicInfo.songUrl = music.songUrl;
         musicInfo.songName = music.songName;
         musicInfo.songId = music.songId;
         musicInfo.userName = music.userName;
         musicInfo.albumName = music.albumName;
         musicInfo.albumPic = music.albumPic;
         [[MusicManager sharedIntance].selectMusics addObject:musicInfo];//把对象加到数据源
     }
 }
 四.app杀掉：
 8.删除数据库里的表，将数据源保存；
 for(MusicInfo *music in [MusicInfo MR_findAll]) {
     [music MR_deleteEntity];//删除数据表
 }
 [[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
 9.新建数据库的表，将数据源所有内容放到数据库，保存；
 for(MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
     MusicInfo *zNewMusic = [MusicInfo MR_createEntity];//新建数据表
     zNewMusic.songName = newMusic.songName;
     zNewMusic.songUrl = newMusic.songName;
     zNewMusic.songId = newMusic.songId;
     zNewMusic.userName = newMusic.userName;
     zNewMusic.albumName = newMusic.albumName;
     zNewMusic.albumPic = newMusic.albumPic;
 }
 1.数据的增删改查
 2.多表的链接查询
 3.数据回滚
 http://hao.jobbole.com/magicalrecord/

文件操作
1.数据持久化的方法
通常程序在运行中或者程序结束之后，需要保存一些信息，而且需要持久化存储信息,比如登陆信息、视频播放记录、收藏记录等等,那么我们可以采用以下几种方式对数据进行持久化保存。1.文件    2.plist    3.数据库
2.常用文件操作类
1）NSFileManager（文件管理类）
<1>创建文件管理器单例对象
[NSFileManager defaultManager];

<2>遍历目录下的内容
//浅度遍历当前目录下的文件
[manager contentsOfDirectoryAtPath:path error:&error]

//深度遍历
[manager subpathsOfDirectoryAtPath:path error:&error]

<3>判断文件是否存在
[manager fileExistsAtPath:path]

<4>创建文件
//创建文件
参数1：创建文件的路径
参数2：内容，如果nil表示创建一个内容为空的文件。
参数3：nil表示采用默认的设置
//如果文件已经存在，会覆盖原来文件。
[manager createFileAtPath:path contents:data attributes:nil];
    
//创建目录
参数1：文件夹路径
参数2：是否有中间目录(YES针对所有的情况)
参数3：nil表示采用默认设置
参数4：错误

//不会覆盖文件夹内容
[manager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];

<5>拷贝文件/目录
//从哪个路径copy
NSString *fromPath = @"/Users/qianfeng/Desktop/文件夹/testff.txt";
//copy哪个路径
NSString *toPath = @"/Users/qianfeng/Desktop/文件夹/新建文件夹/testff.txt";
//如果文件已经存在是copy不成功的
[manager copyItemAtPath:fromPath toPath:toPath error:&error];

<6>移动文件/目录
[manager moveItemAtPath:fromPath toPath:toPath error:&error];

<7>删除文件/目录
[manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件夹/新建文件夹" error:nil]

<8>获取文件属性    (返回的是字典)
[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件夹/testff.txt" error:nil];

2.3 NSFileHandle（文件句柄类）
对文件进行读写首先需要NSFileHandle打开文件,NSFileHandle对文件进行读写都是NSData类型的二进制数据.
                
<1>打开文件方法
//以只读方式打开
NSFileHandle *readOnlyHandle =  [NSFileHandle fileHandleForReadingAtPath:path]
//以只写方式打开
NSFileHandle *writeOnlyHandle = [NSFileHandle fileHandleForWritingAtPath:path]
//以读写方式打开
NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:path]

<2>读指定长度的数据（单位为字节)
[readOnlyHandle readDataOfLength:5]或者 [readWriteHandle readDataOfLength:5]

<3>从当前偏移量读到文件尾
[readOnlyHandle readDataToEndOfFile];

<4>设置文件偏移量（单位为字节)
[readOnlyHandle seekToFileOffset:5];

<5>将文件偏移量定位到文件尾
[readOnlyHandle seekToEndOfFile];

//如果希望这次写入的数据完全覆盖掉原有数据
//常规做法，短的写入，无法覆盖长的数据
//可以截断原来数据
[readWriteHandle truncateFileAtOffset:0];
//截断到0字节长，即清空原有数据。

<6>写文件(不会覆盖的时候需要设置偏移量)
//当前偏移量指到文件最后
[readWriteHandle seekToEndOfFile];
//写入数据
[readWriteHandle writeData:data];

[readWriteHandle writeData:[@"12345678945343543534543" dataUsingEncoding:NSUTF8StringEncoding]];

 <7>关闭文件句柄
//关闭文件句柄,关闭后(不需要)就不能再操作文件了
[readOnlyHandle closeFile];
[readWriteHandle closeFile];
[writeOnlyHandle closeFile];
 
 */


/*
 FIXME
 十七 . 应用程序的沙盒下 ,都有哪些文件夹 ?它们有什么特点 ?本地缓存一般存在哪个文件下?
 1 Documents
 将应用程序的数据文件保存在该目录下 .不过这些数据类型仅限于不可以再生的数据 ,可再生 的数据文件应该存在 LIbrary/Cache 下
 2 Library 它有两个子文件
 caches 主要是缓存文件 ,用户使用过程中缓存都可以保存在这些目录中 .保存那些可再生的
 文件 ,比如网络数据请求 .因此 ,应用程序通常还需要负责删除这些文件 .
 Preferences 应用程序的偏好设置文件 . 我们使用 NSUserDefaults 写的设置数据都会保存到
 该目录下的一个 plist 文件中 它会被 iTunes 同步 3. tmp
 各种临时文件 , 保存应用再次启动时不需要的文件 将其删除 ,因为该目录下的东西随时有可能被系统清除
 统磁盘存储空间不足的时候
 .而且 ,当应用不在需要这些文件时应主动 ,目前已知的一种可能清理的原因是系
 二十 . plist 和 pct 文件的好处 ?
 plist 文件以便用来储存数组或者字典 ,它是 iOS 中特有的存储方式 .它可以将数据与代码隔离开 , 更便于数据的管理和展示 .
 pch 里面可以保存一些全局的宏和头文件 .
 pct 是预编译头文件 , 其中存放有工程中已有编译的部分代码 编译这些代码 .
 pct 头文件的内容能被项目中的其他所有源文件共享访问 存放一些全局的宏 (整个项目都用得上的宏 )
 用来包含一些全部的头文件 (整个项目都用得上的头文件 能自动打开或者关闭日志的输出功能
 pct 弊端 : 每个文件都会导入 ,有效率问题 .
 ; 在以后建立工程时就不用重新)

 94. 什么是沙盒模型?哪些操作是属于私有 api 范畴 ?
  答:某个 iphone 工程进行文件操作有此工程对应的指定的位置，不能逾越。
 iphone 沙箱模型的有四个文件夹 documents， tmp， app， Library ，永久数据存储一般放documents 文件夹，得到模拟器的路径的可使用 NSHomeDirectory() 方法。 Nsuserdefaults 保 存的文件在 tmp 文件夹里。

 2、沙盒的目录结构是怎样的?各自一般用于什么场合?
 参考答案:
 Application :存放程序源文件，上架前经过数字签名，上架后不可修改
 Documents: 保存运行时生成的需要持久化的数据 ,iTunes 同步 设备时会备份该目 录。例如 ,游戏应用可将游戏存档保存在该目录 tmp: 保存应 ?运行时所需的临时数据 ,使?完毕后再将相应的文件从 该目录删除。应用 没有运行时 ,系统也可能会清除该目录下的文件。 iTunes 同步设备时 不会备份该目录
 Library/Caches: 保存应用运行时 ? 成的需要持久化的数据 ,iTunes 同 步设备时不会备份 该目录。?一般存储体积大、 不需要备份的非重要 数据，比如网络数据缓存存储到 Caches 下
 Library/Preference: 保存应用的所有偏好设置，如 iOS 的Settings( 设 置) 应?会在该目录中查找应 ?的设置信息。iTunes同步设备时会备份 该目录


 对沙盒的理解
 每个 iOS 应用都被限制在“沙盒”中， 沙盒相当于一个加了仅主人可见权 限的文件夹， 及时在应用程序安装过程中， 系统为每个单独的应用程序生
 成它的主目录和一些关键的子目录。苹果对沙盒有几条限制 :
 1. 应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序的沙盒;
  2. 应用之间不能共享数据， 沙盒里的文件不能被复制到其他应用程序的文件夹中， 也不能把其他应用文件夹复制到沙盒中;
 3. 苹果禁止任何读写沙盒以外的文件， 禁止应用程序将内容写到沙盒以外的文件 夹中;
 4. 沙盒目录里有三个文件夹: Documents——存储;应用程序的数据文件，存储 用户数据或其他定期备份的信息; Library 下有两个文件夹， Caches存储应用程 序再次启动所需的信息， Preferences 包含应用程序的偏好设置文件，不可在这 更改偏好设置; temp存放临时文件即应用程序再次启动不需要的文件。
 获取沙盒根目录的方法，有几种方法:用 NSHomeDirectory 获取。 获取 Document路径:
 NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserD omainMask,YES).

 9.iphone 应用程序的项目基本结构
 classes: 里面存放 object-c 类源代码文件 ( 可以创建子文件夹来组织代码 );
 other sources: 存放除 objective-c 类之外的源代码文件;
 resources: 包含应用程序中的非代码文件 ( 因为应用程序只能在自己的沙盒中运行，不然找 不到 ) ;
 Frameworks: 特殊的库，可以存放库、框架、图像、声音等资源;
 Products :包含项目在编译时生成的应用程序 (xxx.app);
 10.Info.plist 文件里的 bundle identifier( 束标识符 ) 它是应用程序的唯一标识符，要始终配置，命名格式为:顶级 Internet 应用名称;
 域+.+公司名称 +.+

 77、什么是沙盒 ?沙盒包含哪些文件 ,描述每个文件 的使用场景。如何获取这些文件的路径 ?如何获取 应用程序包 中文件的路径 ?
 沙盒是某个 iphone工程进行文件操作有此工程对 应的指定的位臵 ,不能逾越。 包括 :四个文件
 夹:documents,tmp,app,Library。 手动保存的文件在 documents文件里。 Nsuserdefaults保存的文件在 tmp文件夹
 Documents 目录:您应该将所有 de应用程序数据文 件写入到这个目录下。 这个目录用于存储用户数据
 或其它应该定期备 份的信息。AppName.app 目录: 这是应用程序的程序包目录 ,包含应用程序的本身。 由于应用程序必须经过签名 ,所以 您在运行时不 能对这个目录中的内容进行修改 ,否则可能会使应 用程序无法启动。 Library 目录 :这个目录下有两个 子目 录:Caches 和 PreferencesPreferences目录包 含应用程序的偏好设臵文件。 您不应该直接创建偏 好设臵文件 ,而是 应该使用 NSUserDefaults类来取 得和设臵应用程序的偏好 .Caches 目录用于存放 应用程序专用的支持文件 ,保存应用程 序再次启 动过程中需要的信息。 tmp 目录 :这个目录用于存 放临时文件 ,保存应用程序再次启动过程中不需要 的信息。
 获取这些目录路径的方法 : 1,获取家目录路径的
 函数 : NSString *homeDir =
 NSHomeDirectory(); 2,获取 Documents目录路径的
 方法 : NSArray *paths =NSSearchPathForDirectoriesInDomains(NSDocum
 entDirectory, NSUserDomainMask, YES); NSString *docDir = [paths
 objectAtIndex:0]; 3,获取 Caches目录路径的方 法: NSArray *paths =
 NSSearchPathForDirectoriesInDomains(NSCachesDi rectory, NSUserDomainMask, YES); NSString
 *cachesDir = [paths objectAtIndex:0]; 4,获取 tmp目
 录路径的方法 : NSString *tmpDir =
 NSTemporaryDirectory(); 5,获取应用程序程序包
 中资源文件路径的方法 : 例如获取程序包中一个
 图片资源 (apple.png)路径的方法 : NSString
 *imagePath = [[NSBundle mainBundle] pathForResource:@ ” apple ” ofType:@ ” png ” ]; UIImage *appleImage = [[UIImage alloc]
 initWithContentsOfFile:imagePath]; 代码中的 mainBundle类方法用于返回一个代表应用程序包的对象。
 沙盒目录结构是怎样的？各自用于那些场景？
 * Application：存放程序源文件，上架前经过数字签名，上架后不可修改
 * Documents：常用目录，iCloud备份目录，存放数据
 * Library
     * Caches：存放体积大又不需要备份的数据
     * Preference：设置目录，iCloud会备份设置信息
 * tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能

 */
