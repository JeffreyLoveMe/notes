// NSString为什么使用Strong而不使用Copy?
//runloop常驻线程NSURLConnection：为什么AF2.0使用常驻线程？AF3.0就抛弃了？
//怎么获取app的全量日志（如何实现一套和业务解耦的日志系统）
//App启动优化：有哪些建议？了解过dyld吗？`
//符号是怎么绑定在地址上的？能写一个hotReload框架吗？
//iOS崩溃是什么导致的？如何监控不同类型的崩溃？
//如何获取详细的内存分配信息：比如不同线程的堆栈调用？
//Apple为什么设计元类？
// 什么是循环引用？block为什么会导致循环引用？weak怎么防止循环引用？请举例子说明。
1.对象A持有对象B的同时对象B持有对象A，这种情况我们称为循环引用，循环引用会导致两个对象都无法销毁；
//retain、copy/mutableCopy、release有什么区别？
1.retain引用计数+1，没有创建新对象；
2.copy（不可变对象）/mutableCopy（可变对象）引用计数+1，创建新对象；/不是所有
对象都具备copy功能：必须实现<NSCopying/NSMutableCoping>协议
3.release
//Xcode中选择模拟器编译，在 products 中生成的二进制文件后缀是什么？
/// 换一种通用写法
// 冒泡排序：将相邻元素两两排序让较大的数沉底、一共需要(N-1)轮排序
3 5 8 6 2  // 原始数据
3 5 6 2 8  // 第一轮排序
3 5 2 6 8  // 第二轮排序
3 2 5 6 8  // 第三轮排序
2 3 5 6 8  // 第四轮排序
#include <stdio.h>
int main() {
    int arr[5] = {3,5,8,6,2};
    int temp;
    //外层循环控制轮数
    for(int i = 0;i < 4;i++) {
        for(int j = 0;j < 4-i;j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
        for(int k = 0;k < 5;k++) {
            printf("%d ",arr[k]);
        }
        printf("\n");
    }
    return 0;
}
// 选择排序：从下标0开始，依次作为待比较的元素，从待比较的元素开始向后遍历数组找到最小的
元素与待比较的元素交换，一共需要(N-1)轮排序
4 8 7 2 6  // 原始数据
2 8 7 4 6  // 第一轮排序
2 4 7 8 6  // 第二轮排序
2 4 6 8 7  // 第三轮排序
2 4 6 7 8  // 第四轮排序
#include <stdio.h>
int main() {
    int arr[5]={4,8,7,2,6};
    int max;
    int pos;
    //外层循环控制排序轮数
    for(int i=0;i<4;i++) {
        max = arr[i];
        pos = i;
        //里层循环控制选择一个值最大的元素
        for(int j=i;j<5;j++) {
            if(max < arr[j]) {
                max = arr[j];
                pos = j;
            }
        }
        //用值最大的元素与待比较元素进行交换
        arr[pos] = arr[i];
        arr[i] = max;
    }
    printf("%d\n",arr[1]*arr[2]);
    return 0;
}
#快速排序：NO
#二分查找：NO
// 平时工作中遇到过哪些内存 crash/泄漏 的情况
// 包体大小优化
1.图片格式的存储算法
2.图片格式的识别算法
3.源码格式的二进制内容
4.CocoaPods打包方式
// 热修复
// 动态化
// 大前端
// 戴铭
https://github.com/ming1016
https://ming1016.github.io/categories/Programming
77.图片裁剪方法
92.多媒体（图片、音乐、录音、视频）
/*
1.多媒体：图片,声音,录音,视频
2.UIImagePickerController 选择图片类（代理类）
 
3.AVFoundation  音乐类（代理类）
1）导入第三方库
2）定义声音对象,创建声音对象
3)创建播放对象,需要传入一个URL,此URL指定了媒体文件的位置,从包里求出MP3的路径是个
字符串
4)设置代理
 
4.图片：
判断传入的参数(照相机、相册)是否被当前的设备所支持
创建选择图片的对象
设置图片对象打开相册还是照相机
设置控件的代理
显示控件
当选择了一张图片时,会进入到这个代理函数
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info {
     //被选择的图片,以UIImage对象封装起来,在info的UIImagePickerControllerOriginalImage key值里边
    UIImage *pickImage = info[UIImagePickerControllerOriginalImage];
    self.imageView.image = pickImage;
    //实现了此函数,就需要自己手动地隐藏控件
    [picker dismissViewControllerAnimated:YES completion:^{
    }];
}

音乐播放
 - (void)play:(id)sender {
 //播放之前,先准备播放
 if ([self.player prepareToPlay]) {
 //准备播放没问题,开始播放
 [self.player play];
 }
}
 - (void)pause:(id)sender {
 //暂停
 [self.player pause];
}
 - (void)stop:(id)sender {
 //停止
 [self.player stop];
 }
 
 currentTime:当前播放的位置(以秒为单位)(可读写)
 duration:声音的总长度(以秒为单位)(只读)
 
 - (NSString *)formatTimeWithTimeInterval:(NSTimeInterval)interval {
 NSInteger minute = interval / 60;
 NSInteger second = (NSInteger)interval % 60;
 return [NSString stringWithFormat:@"%ld:%02ld", minute, second];
 }
 
 - (void)timer:(id)sender {
 self.currentTime.text = [self formatTimeWithTimeInterval:self.player.currentTime];
 if (!self.slider.tracking) {
 self.slider.value = self.player.currentTime / self.player.duration;
 }
}
*/
93.数据存储（三种SQLite）
/*
 一.FMDB
 二.CoreData
 三.Magic Record
 //新建数据库
 1.新建Core Data
 2.新建表,写上需要存储的文件（姓名,歌词,年龄等）
 3.关联生成属性类
 
 //导入第三方库
 4.导入第三方库MagicalRecord
 
 //app启动时：
 5.设置数据库存放的文件名
 6.让MagicalRecord支持数据库版本管理
 7.查询所有的数据库内容(数组),如果有内容则送到数据源（数组）eg:
 if ([MusicInfo MR_findAll].count) {
 for (MusicInfo *music in [MusicInfo MR_findAll]) {
 //创建一个对象,把对象加到数据源
 MusicInformation *musicInfo = [[MusicInformation alloc] init];
 
 musicInfo.songUrl = music.songUrl;
 musicInfo.songName = music.songName;
 musicInfo.songId = music.songId;
 musicInfo.userName = music.userName;
 musicInfo.albumName = music.albumName;
 musicInfo.albumPic = music.albumPic;
 
 [[MusicManager sharedIntance].selectMusics addObject:musicInfo];
 }
 //app被杀掉:
 8.删除数据库里的表,保存
 for (MusicInfo *music in [MusicInfo MR_findAll]) {
 //删除数据表
 [music MR_deleteEntity];
 
 }
 
 [[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
 9.新建数据库的表,将数据源所有内容放到数据库,保存
 for (MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
 //新建数据表
 MusicInfo *zNewMusic = [MusicInfo MR_createEntity];
 
 zNewMusic.songName = newMusic.songName;
 zNewMusic.songUrl = newMusic.songName;
 zNewMusic.songId = newMusic.songId;
 zNewMusic.userName = newMusic.userName;
 zNewMusic.albumName = newMusic.albumName;
 zNewMusic.albumPic = newMusic.albumPic;
}
*/
94.多线程（三种）
/*
 /// NSOperation:任务为导向的多线程模型
 //创建线程数组
 self.orderThread=[[NSMutableArray alloc]init];
 
 //创建NSOperationQueue的队列
 self.queue=[[NSOperationQueue alloc]init];
 
 //设置队列的最大并发数量
 self.queue.maxConcurrentOperationCount=2;
 
 //创建多线程
 NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
 //执行多线程
 }];
 
 //多线程加到队列中
 [self.queue addOperation:blockOperation];
 
 //多线程加到线程数组中
 [self.orderThread addObject:blockOperation];
 
 //blockOperation.isCancelled
 
 //blockOperation.isExecuting
 
 //blockOperation.isFinished
 
 /// GCD:block版本的线程模型
 //创建GCD组别（记录有多少主线程之外的线程）
 dispatch_group_t group=dispatch_group_create();
 
 //将GCD组别+1(执行异步线程之前)
 dispatch_group_enter(group);
 
 //执行异步线程
 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0),^{
 //执行线程
 [self.lock lock];
 
 [self.lock unlock];
 
 //将GCD组别-1（异步线程执行外后）
 dispatch_group_leave(group);
 });
 
 //GCD组别为0时
 dispatch_group_notify(group, dispatch_get_main_queue(), ^{
 
 if(group==0){
 //刷新UI主线程
 }
});
*/
96.map（大头针）
/*
1.有哪些技术可以实现定位：GPS 基站
2.系统提供两个框架：MapKit.framework   CoreLocation.framework
3.MKMapView可以加载地图
4.有三种地图类型
typedef NS_ENUM(NSUInteger, MKMapType) {
MKMapTypeStandard = 0,
MKMapTypeSatellite,
MKMapTypeHybrid,
MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),
} NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED;
5.设置代理
*/
/*
1.CL-CoreLocation框架
2.导入CoreLocation框架,使用CLLocationManager核心类
3.创建CLLocationManager核心类
4.[self.locationmanager locationServicesEnabled]为YES-GPS服务可用
*/
/*
在地图上标注位置
1.导入两个框架 MapKit.framework   CoreLocation.framework
2.创建MKMapView把地图显示出来
3.定义显示标注的类（MyAnnotation类）,实现MKAnnotation协议
1）从协议复制属性
2）初始化协议属性：
4.给地图添加标注
MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
//给地图添加标注
[self.mapview addAnnotation:a];
//平移
MKCoordinateRegion region;
region.center.latitude=30.5;
region.center.longitude=116.8;
region.span.latitudeDelta=10;
region.span.longitudeDelta=10;
self.mapview.region=region;
5.知道经纬度就可以标注位置（具体位置借助API）
*/
97.地图导航
/*
 高德地图：
 1.高德LBS开放平台：LBS-基于位置的服务
 2.申请Key
 3.下载相关SDK和示例代码
 百度地图：
 1.百度LBS开放平台：
 2.获取密钥（一个密钥对应一个bundle identifier）
 3.相关下载-全部下载
 */
107.版本控制
/*
1.在MAC环境下,自带了SVN服务器端和SVN客户端功能,所以只需做一下简单地配置
2.SVN的使用
更新数据:
cd  工程目录
svn update
 
上传数据:
将数据放到工程目录
svn commit -m '本次修改你要说的话'
 
上传失败:
svn status
? 表示没有被svn工具管理的文件（夹）
A 表示被标记为新文件（夹）
C 表示冲突的文件（夹）
! 表示已经被版本管理控制,但是在文件夹下边找不到
D 表示已经被标记为删除
 
没有被svn工具管理的文件（夹）:
如果文件是？,代表这个文件夹不被svn所管理。可以
svn add 文件   //表示这个文件夹以及下边的所有的子目录和文件,全部变成add状态
 
删除被svn版本管理控制的文件:
svn delete
 
遇到冲突:
mc(mine  side)   保留自己做的修改,放弃别人做的修改
tc(their side)   保留别人做的修改,放弃自己做的修改
p(postpone)      保留冲突状态,手动解决
 
手动解决冲突:
在<<< === >>>有两个区间,每一个区间代表谁做的修改。解决冲突：要把左尖括号、右尖括
号、等号删除！
手动解决完了所有的冲突(一定要注意解决完了所有的冲突,可以在代码里边搜索======,都没
有的情况下,才算是解决完了所有的冲突)把已经标记为冲突的文件标记为已解决

svn地址重定向:
cd  工作目录
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --
username sally --password sallyssecret
10.5.154.237  上次svn的地址
10.5.154.142  本次svn的地址
sally         你的用户名
sallyssecret  你的密码
 
svn恢复:
svn revert . -R
*/
108.消息推送、本地推送
/*
推送功能一般分为两种:本地推送和远程推送
1.对于本地推送(UILocalNotification),我们可以先注册通知,然后新建本地推送
,设置本地推送的属性,最后我们执行推送（会调用一个方法）
2.对于远程推送,我们使用第三方极光推送。登录注册极光推送（创建iOS应用开发证
书,在极光推送递交证书创建应用,获取AppKey）
3.下载SDK,添加到项目中。最后按照极光推送官方文档操作
*/
109.第三方登陆、分享
/*
第三方登陆面试总结：
*/
/*
分享面试总结：
1.系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：
不需要集成第三方库,不需要App Key;缺点：页面简单,不能自定制。
2.对于第三方分享：我一般使用shareSDK,首先进入mob.com官网添加应用获取App
Key;然后利用cocoapods集成shareSDK,想要集成那些平台就去那些开放平台申请
AppKey和AppSecret;最后按照文档：首先导入头文件,然后添加各平台应用,最后构建
分享内容,分享~~~~
*/
110.支付
/*
iOS集成支付宝的步骤
1.下载支付宝SDK：https://openhome.alipay.com/platform/document.htm#down
2.提取支付宝SDK以下文件：
AlipaySDK.bundle
AlipaySDK.framework
libcrypto.a
libssl.a
openssl
Order.h
Order.m
Util
3.需要添加的依赖库：
Foundation.framework
UIKit.framework
CoreGraphice.framework
CoreText.framework
QuartzCore.framework
CoreTelephony.framework
SystemConfiguration.framework
libz.tbd
4.添加支付逻辑代码
1）填写商户App申请：商户ID 账号ID 私钥
2）生成订单信息以及签名
3）跳转支付宝钱包由支付宝客户端跟支付宝安全服务器打交道
4）支付完成返回给商户客户端和服务器
*/
112.即时通讯
/*
即时通讯（IM）
一.底层原理
1）用于IM的协议：XMPP（基于XML的协议,具有超强的可扩展性）
2）XMPP有三个部分：服务器 网关 客户端（可以任意两个双向发生）
2）XMPP的优缺点
1.优点：
XMPP协议是自由开源的,而且在C/S都有多种实现
任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接
我们用XMPP技术开发软件,资源以及支持的来源都是多样的,这样就不会被“绑架”
XMPP以TCP传递XML数据流,没有中央主服务器,任何人都可以运行自己的XMPP服务器
XMPP基于XML具有很强的扩展性
2.缺点
XMPP协议的服务器流量存在着被重复转发,使数据负载太重
XMPP协议是基于XML文件的（编码成单一的XML文件）,因此无法提供修改二进制数据
 
二.上层实现（利用环信）
1.环信：通过云端开放的Rest api或者客户端SDK包（摆脱了IM底层开发）,使APP内置聊天功能
2.步骤
1）注册登录“环信”
2）创建应用（应用名称会存在你的AppKey）,生成AppKey和相关配置文件
3）制作并上传推送证书
1.进入developer.apple.com
2.点击Member Center,进入Certificates,Identifiers&Profiles,制作证书
3.选择对应的App ID
4.根据Certificate Assistant的提示,创建Certificate Request
5.上传上一步中创建的Certificate Request文件
6.下载下来这个证书,并双击导入系统
4)上传证书
1.打开Application-Utilities-Keychain Access应用,我们会看到有刚刚制作
好的推送证书
2.选中证书对应的私钥,点右键,选择导出,并设定密码
3.登录环信后台
4.选择对应的App,填写证书名称
5.上传（选择的是开发环境证书还是生产证书）
5）通过cocoapods下载SDK
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件： #import <EaseMobSDKFull/EaseMob.h>
6）设置工程属性
1.导入SDK依赖库（Xcode7.0,后缀是tbd）
MobileCoreServices.framework
CFNetwork.framework
libEaseMobClientSDKLite.a
libsqlite3.dylib
libstdc++.6.0.9.dylib
libz.dylib
libiconv.dylib
libresolv.dylib
libxml2.dylib
2.向Build Settings-Linking-Other Linker Flags中添加-ObjC(注意大小
写）
如果项目中使用-ObjC有冲突,可以添加-force_load来解决：
格式：-force_load[空格]EaseMobSDK/lib/libEaseMobClientSDKLite.a(静
态库的路径-SDK lib里面拖过来) 在-force_load下面
3.编译没错误则说明集成SDK成功
*/
122.瀑布流
/*
1.简单地说:我们利用3个UITableView联动就可以实现瀑布流效果
2.我们利用UIScrollView的代理方法让3个UITableView的偏移量都等于
UIScrollView的偏移量实现联动
3.最好做法：一个cell超过屏幕,我们不要release,而是回收到复用队列,创建cell首先去
复用队列去取,如果没有我们在创建
*/






#数组：
定义：一组有序数据的集合；
特点：每个元素具有相同的数据类型；
1).一维数组：下标从0开始，到n－1结束
格式：int array[5];
int //定义一个长度为5的数组
array //数组名
5  //数组长度
array[0]...array[4] //数组元素
//初始化
int array[5]={1,2,3,4,5};//完全初始化
int array[5]={1,2,3};//部分初始化，剩下元素默认为0
//数组的访问越界
array[5]=4;
2).二维数组：
定义：元素是一维数组的数组称为二维数组；
格式：int array [3][4];//3代表横行X轴,4代表竖行Y轴
//初始化：3行4列
int array[3][4]={
    {1,2,3,4},
    {2,3,4,5},
    {3,4,5,6},
};


#函数：
定义：执行某种功能的代码块；
格式：
返回值类型 函数名(形式参数) {
    //函数体
    return 返回值;
}
分类：
标准函数：由官方或第三方库提供的函数，可以直接调用，无需实现；
自定义函数：由程序猿自己编写的函数；
步骤：
声明函数：.h
实现函数：.m
调用函数：整个程序
范例：
//无参无返回值
void log(void);//1.声明
void log(void) {
    //函数体：实现函数的功能
    printf("hello world!\n");
}//2.实现
log();//3.调用：相当于把函数体的代码执行一遍
//有参有返回值
int sum(int a,int b);//1.声明：形式参数(简称形参)，用,隔开
int sum(int a,int b) {
    //定义局部变量：不同的函数内部可以定义相同的变量名
    int sum = 0;
    return;//任何函数最多只有一个返回值，函数遇到return执行结束
}//2.实现
int ret = sum(10,15);//3.调用：相当于把函数体的代码执行一遍
//实参和形参的关系和区别
1.形参是在定义变量，实参是在传值；
2.实参的值直接赋给形参；
3.实参是在函数调用的地方传递值，形参是在函数实现的地方接收实参的值；

#指针：
定义：变量的地址(唯一标识一块内存的索引)；
int a;//a变量名、&a变量地址
int *p;//定义一个指针变量p：p指针变量名、*指向
指针变量p的作用：用来存储地址；
*p：指p指向的内容；
p = &a;//将整型变量a的地址赋给指针变量p
*p = a;//*p是p指向的变量
int *p;//变量p是int*类型、int是p指向变量的基类型
int *p = NULL;//指针变量p初始化为空、不能使用空指针
int *p;//未初始化的指针称为野指针、不能使用野指针
printf("&a=%p",&a);//输出变量a的地址：％p地址格式符
注意：1.定义指针时，一定要初始化为空；
2.指针做为参数或者已经赋值，则无需初始化为空；
3.使用指针前，一定要给指针赋值；
4.使用指针时，一定要判空；
if(p == NULL) {
    return;
}
//指针大小：固定4个字节-因为地址在内存中都是以整型的方式分配的

#数组和指针：
概述：数组名作为函数参数，代表数组的首地址；
int *p = NULL;
int a = 5;
p = &a;
p++;//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
//指针数组
int *p[10];//数组：每个元素都是个指向整型的指针
//指向数组的指针
int (*p)[10];//指针：指向10个int元素的数组
//指向指针的指针
int **p;//指针：指向指针
//指向函数的指针
int (*p)(int a);//指向函数的指针
//指针作为函数返回值
格式：数据类型* 函数名(形参列表) {//...}
//交换两个变量？
1.传值：无法实现交换；
2.传地址：交换指针指向，无法实现交换；
3.传地址：交换指针指向变量的值，可以实现交换；

#结构体：
定义：相同或者不同数据类型变量的集合，自定义的数据类型；
格式：放在头文件下面、所有函数上面
//结构体定义用struct关键字，名字为data
struct data {
    //成员变量
    int a;
    char b;
    short c;
};
//结构体别名：wm_data
typedef struct data {
    int a;
    char b;
    short c;
}wm_data;
//难点：结构体指针？

#枚举：枚举就是一串宏
定义：如果变量只有几种可能的值，可以使用枚举；
//枚举可以有无数个：不推荐使用
typedef enum direction {
    枚举1,
    枚举2,
    枚举3
} direction_t;
//定义通用枚举：只能同时存在一个枚举值
typedef NS_ENUM(NSInteger,WMDirection) {
    枚举1,
    枚举2,
    枚举3
};
//定义位移枚举：可以同时存在多个枚举值
typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) {
    枚举1,
    枚举2,
    枚举3
};

#共用体：使几个不同变量共同占用一段内存的结构
union date {
    int a;
    char b;
    short c;
};
大小：1.共用体变量所占内存长度等于最长成员的长度；
2.共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种；
3.共用体变量中起作用的成员是最后一次存放的成员；
/******************************Objective-C语言基础******************************/
#XX管理系统：特别重要
//首先把生活中的实物抽象成UserModel.h/m类：用户、汽车、商品等；
1.设置属性->2.设置初始化方法赋值：一般用dict
//新建Manager.h/m管理类：用于删除、增加、显示Model.h/m
1.设置数据源NSMutableArray->2.设置init(){//初始化数据源}->3.设置一般方法
//直接操作Manager.h/m
例题：图书租赁系统
1.图书信息：
纸质书：编号、书名、出版社、作者、日租金
电子书：编号、书名、作者、阅读网址、日租金
2.实现如下功能：
新增图书、
借书(提供编号)、
查找某本书(根据编号)、
还书(提供书的完整信息、提供天数)，计算租金、
查看所有图书信息
Demo：新建demo，包含Model、Manager、View、Controller？？？

#内存管理：
//C语言：sizeof()是一个运算符，用来计算变量或数据类型的大小
1.静态内存分配：在编译阶段分配的内存
分配在数据段、只读数据段、栈区的内存，由编译器自动申请和释放的内存，称为静态内存分配；
2.动态内存分配：在运行阶段分配的内存
分配堆区的内存，手动申请100个字节的内存，并将这个空间的首地址返回给指针变量p；
char *p = (char *)malloc(100*sizeof (char)); //动态申请内存
free(p); //动态释放内存
3.注意：防止提前释放、防止内存泄露、防止重复释放；
4.区别：动态内存分配和静态内存分配的区别
静态内存分配：操作系统分配空间、空间在编译时确定，而非运行时、空间在栈段，数据段，只读数据段、自动释放空间
动态内存分配：程序员分配空间、运行时确定，每次运行都不同、空间在堆段、手动释放空间
5.总结：C语言的内存管理需要我们手动申请，手动释放
1>.手动申请内存，使用以后需要手动释放，如果不释放会造成内存泄露；
2>.不能多次释放，如果多次释放，则会崩溃；
3>.不能提前释放，如果提前释放再使用，也会崩溃；
6.问题：如果项目比较复杂，需要上百号人一起分工完成，就很容易出现问题：比如我们开辟了一块内存空间，
存放了一块很有用的数据。但是，这个数据不只有我在这一块代码里用，甚至有多个人，在程序的多个地方使用。
这样造成的结果：就算我使用完成这块内存，我也不能去释放他，因为我不能确定，别人在别的地方是否还需要
使用这块内存。内存泄露在所难免了；
//Objective-C语言：管理对象、基本数据类型不需要管理
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；
/******************************网络基础******************************/
#异步网络请求：
//分类：
网络请求：get
网络上传：post
下载：NO
//原生网络请求：
CFNetwork：纯C语言
NSURLConnection：iOS7.0被废弃
NSURLSession：NO
https://www.jianshu.com/p/b0ddadd34037
//ASIHttpRequest：不在更新
//MKNetworkKit：简单易用，使用者较少
//AFNetworking：
1.概述：2.0使用的是NSURLConnection、3.0使用NSURLSession；
2.代码：NetworkViewController.h/m
注意：不要在子线程中更新UI；
//利用KVO、KVC进行网络请求：参考2015-10-13
1.新建数据模型PostInfo.h/m
2.新建数据源：必须初始化
3.设置单例：全局使用
3.监测数据源变化：KVO
4.新建下拉控件：进入VC->开始下拉加载->网络请求：改变数据源->加载UITableView
5.在View中更新UI
代码：NetworkViewController.h/m
//设置应用支持https
Xcode7.0以后：NSAppTransportSecurity->NSAllowsArbitraryLoads->YES
/******************************iOS进阶******************************/
#数据持久化的方法：存放在沙盒
原因：通常程序在运行中或者程序结束以后，需要保存一些信息，比如登录信息，视频播放记录，收藏等；
常见方法：
1.文件操作：见FileViewController.h/m
2.plist：属性列表文件-只能存储NSString/NSNumber/NSDate/NSArray/NSDictionary
作用：对一些登录、注册和配置信息进行持久化存储；
格式：xml语法；
创建：Xcode创建/代码创建
读取：需要时自行百度
3.NSUserDefaults：见FileViewController.h/m
4.归档/解归档：一种序列化与反序列化
//归档
//解归档
https://www.jianshu.com/p/3e08fa21316d
5.数据库：
//sql语句：结构化查询语言
1.创建表
create table if not exists sso (
id integer primary key autoincrement,//将id设为主键
author text,//文本
price real,//浮点型
pages integer);//整型
2.插入
insert into sso (author,price,pages) values(?,?,?);
3.更新
update sso set price = ?,pages = ? where author = ?;
4.删除
delete from sso where pages > ?;
5.查询
select * from sso;
//FMDB
代码：SqliteViewController.h/m
//MagicalRecord：
一.Core Data：
1.新建Core Data；
2.新建表：写上需要存储的文件；
3.关联生成属性类；
二.导入数据：
4.导入MagicalRecord；
三.app启动：
5.设置数据库存放的文件名；
6.让Magical Record支持数据库版本管理；
7.查询所有的数据库内容，如果有内容则送到数据源；
if([MusicInfo MR_findAll].count) {
    for(MusicInfo *music in [MusicInfo MR_findAll]) {
        MusicInformation *musicInfo = [[MusicInformation alloc] init];
        musicInfo.songUrl = music.songUrl;
        musicInfo.songName = music.songName;
        musicInfo.songId = music.songId;
        musicInfo.userName = music.userName;
        musicInfo.albumName = music.albumName;
        musicInfo.albumPic = music.albumPic;
        [[MusicManager sharedIntance].selectMusics addObject:musicInfo];//把对象加到数据源
    }
}
四.app杀掉：
8.删除数据库里的表，将数据源保存；
for(MusicInfo *music in [MusicInfo MR_findAll]) {
    [music MR_deleteEntity];//删除数据表
}
[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];
9.新建数据库的表，将数据源所有内容放到数据库，保存；
for(MusicInformation *newMusic in [MusicManager sharedIntance].selectMusics) {
    MusicInfo *zNewMusic = [MusicInfo MR_createEntity];//新建数据表
    zNewMusic.songName = newMusic.songName;
    zNewMusic.songUrl = newMusic.songName;
    zNewMusic.songId = newMusic.songId;
    zNewMusic.userName = newMusic.userName;
    zNewMusic.albumName = newMusic.albumName;
    zNewMusic.albumPic = newMusic.albumPic;
}
/*
1.数据的增删改查
2.多表的链接查询
3.数据回滚
*/
http://hao.jobbole.com/magicalrecord/

#通知中心：WMGameProxy直接看代码
定义：每个App都有一个通知中心，专门负责协助不同对象之间的消息通信
//创建消息对象
NSNotification *notice=[[NSNotification alloc]initWithName:@"123" object:nil userInfo:@{@"1":@"123"}];
[[NSNotificationCenter defaultCenter] postNotification:notice];
代码：ObserverViewController.h/m

#iOS动画：
//帧动画
_imgArray = [[NSMutableArray alloc]init];
for (int i =0;i<20;i++) {
    UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@"%d", i+1]];
    [_imgArray addObject:image];
}
_imgView.animationImages = _imgArray;//设置动画数组
_imgView.animationDuration = 0.5;//设置动画执行时间
_imgView.animationRepeatCount = 0;//设置播放动画次数：0表示无限重复
[_imgView startAnimating];//开始动画
[_imgView stopAnimating];//停止动画
//渐变动画
//核心动画
CAKeyframeAnimation/CABasicAnimation/CATransition
1).实现UIView的启动动画：WidgetViewController.h/m
2).gif：WidgetViewController.h/m
/******************************补充知识点******************************/
//获取当前时间
NSString *currentTime = [NSString stringWithFormat@"%@",[NSDate date]];
//block中使用self
__weak typeof(self) weakSelf = self;
//汉字转码
NSString *oriString = @"\u67aa\u738b";
NSString *escapedString = [oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
//屏幕中心x轴
self.view.center.x
//屏幕中心y轴
self.view.center.y
//UIWebView可以打开doc/pdf文件
UIWebView *webView = [[UIWebView alloc] initWithFrame: [UIScreen mainScreen].bounds];
webView.delegate = self;
webView.multipleTouchEnabled = YES;
webView.scalesPageToFit = YES;
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
NSString *docPath = [documentsDirectory stringByAppendingString:@"/readMe.doc"];
NSURL *url = [NSURL fileURLWithPath:docPath];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
[webView loadRequest:request];
[webview loadHTMLString:str baseURL:nil];//加载html页面
//屏幕常亮不变暗
[UIApplication sharedApplication].idleTimerDisabled = YES;
//隐藏NavigationBar
[self.navigationController setNavigationBarHidden:YES animated:YES];
//跳转：隐藏TabBar
TestViewController *vc = [[TestViewController alloc] init];
vc.hidesBottomBarWhenPushed = YES;
[self.navigationController pushViewController:vc animated:YES];
//跳转系统浏览器
if ([[UIApplication sharedApplication] respondsToSelector:@selector(openURL:options:completionHandler:)]) {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url] options:@{}
    completionHandler:^(BOOL success) {
    }];
} else {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
}
//时间格式
NSString *data = [NSString stringWithFormat:@"%.2d:%.2d:%.2d",self.hour,self.minute,self.second];
//读取文件内容：dict.txt
NSString *fileConent = [[NSString alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"dict" ofType:@"txt"] encoding:NSUTF8StringEncoding error:nil];
NSArray *words = [fileConent componentsSeparatedByString:@"\n"];//转换成NSArray
//近距离感应
[[UIDevice currentDevice] setProximityMonitoringEnabled:YES];//打开红外线开关
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeAction:) name:@"UIDevieceProximityState" object:nil];//添加监听
- (void)changeAction:(NSNotification *)notification {
    if([[UIDevice currentDevice] proximityState]) {
        NSLog(@"靠近");
    } else {
        NSLog(@"远离");
    }
}
//json转换成字典
NSDictionary *dict=[NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
//根据字体计算高度：一行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = [name sizeWithAttributes:nameAtt];
CGFloat width = nameSize.width;
//根据最大宽度计算高度：多行
NSString *name = @"谢吴军";
NSDictionary *nameAtt = @{NSFontAttributeName : [UIFont systemFontOfSize:15]};
CGSize nameSize = CGSizeMake(100, MAXFLOAT);//宽度固定100，高度不确定
CGSize textSize = [name boundingRectWithSize:nameSize options:NSStringDrawingUsesLineFragmentOrigin attributes:nameAtt context:nil].size;
CGFloat height = textSize.height;
//https://www.cnblogs.com/niit-soft-518/p/6373601.html
CGRectGetMaxX(self.view.size) //矩形中最大x值：布局简单多啦

#制作静态库SDK：
//打包.a：
https://www.jianshu.com/p/a1dc024a8a15
//打包framework：
https://blog.csdn.net/sadsadaadsd/article/details/77878279
//swift打包静态库：不支持静态库
https://blog.csdn.net/lvchenqiang_/article/details/79077679

#RunLoop：底层
作用：1.保持程序的持续运行；
2.处理App中各种事件(触摸事件、定时器事件)；
3.节省CPU资源，提高程序性能；
实质：RunLoop实质是一个死循环，由于main函数中启动了RunLoop才保证了程序不会马上退出，可以
保持持续运行状态；
//CFRunLoopRef
//NSRunLoop：基于CFRunLoopRef的封装
//RunLoop与线程
1.每条线程都有唯一与之对应的RunLoop对象；
2.主线程的RunLoop已经自动创建、子线程的RunLoop需要主动创建；
3.RunLoop在第一次获取线程时创建、在线程结束时销毁；
//RunLoop的运行模式：见Res
http://www.cocoana.com/ios/20150601/11970.html#0-qzone-1-74697-d020d2d2a4e8d1a374a433f596ad1440
/******************************补充知识点******************************/
#函数式编程思想(高聚合：代码聚合、方便管理)：把很多功能放在一个函数块(block)去处理
int a = ({
b = 2;
c = 3;
d = 4;
b + c + d; //最后一句设置返回什么
});
UIButton *btn = ({
UIButton *btn = [UIButton alloc]init];
btn.tag = 1;
btn;//最后一句设置返回什么
});

#马甲包：
//单机游戏和h5链接切换
//2d-x和Unity3d切换
https://github.com/klaus01/KLGenerateSpamCode
https://github.com/2361496651/AutoCreateSpamCode

#第三方服务商：
http://www.mob.com/ //掌淘科技：验证码
https://www.umeng.com/ //友盟：移动统计、消息推送、社会化分享
https://www.xfyun.cn/ //科大讯飞：语音识别、语音转写、语音唤醒

#H5游戏加速器引擎：
https://www.layabox.com/
https://www.egret.com/

#职(xin)业(ling)规(ji)划(tang)：
//项目驱动学习：做项目过程中遇到什么新技术就学习什么新技术
//空闲主动学习：利用空闲时间主动去学习
//主要技术：数据结构与算法->h5->js->java->C++
//技术进阶：C语言->Objective-C语言->iOS->Swift->Java->Android->C++(选修)—>
h5/css/js->前端->php->后端->python->运维->IT->word/excel/ppt
https://www.jianshu.com/p/c73aa144d513

#Model：字典转模型
好处：字典的key不会提示错误、Model的属性会提示错误；
//1.实现：需要封装
Shop *shop = [[Shop alloc]init];
shop.icon = dict[@"icon"];
shop.name = dict[@"name"];
[_arrM addObject:shop];
//2.实现：最终方案
//Shop *shop = [Shop alloc] initWithDict:dict];
Shop *shop = [Shop shopWithDict:dict];
/******************************Objective-C语言基础******************************/
#类对象：保存当前对象所有的对象方法，可以通过类对象来创建实例对象，实例对象中有一个isa指针，指向创建自己的类对象
1.获取类对象：一个类在内存中只有一份类对象
Person *p = [[Person alloc]init];
[p class];//[实例对象 class];
[Person class];//[类名 class];
2.应用场景：
1>.用于创建实例对象：Person *p = [[[p class] alloc]init];
2>.用于调用类方法：[[p class] test];
//启动过程：见WMBook.h/m；

#内存管理：
1.引用计数(Reference Count)/保留计数(retain Count)：
原理：对于一块动态申请的内存，有一个指针使用，就给这个内存的计数器+1，使用完成后，就给
这个计数器-1，当这个内存的引用计数为0，我们就释放；
2.Xcode 5.0版本以后默认是ARC模式；
3.ARC-Automatic Reference Counting：自动引用计数，由Xcode帮助我们管理内存；
4.区别：不同于java垃圾回收，在预处理时，直接在应该保留的地方，添加retain，应该释放的地
方，添加release；从效率上来说，ARC优于MRC；
5.MRC-Manual Reference Counting：手动引用计数，我们手动管理内存；
6.当对象需要销毁的时候会自动调用dealloc(析构方法)；
注意：1.指定文件不使用ARC：Build phase->Complie Source->加入-fno-objc-arc；
2.内存管理的黄金法则：谁创建谁释放
凡是用alloc、retain、new、copy、mutableCopy或者以copy开头、以mutableCopy开头的方法创建的对象，
都需要用release/autorelease进行释放；
3.release并不是销毁对象，只是让对象的引用计数-1，当对象的引用计数等于0的时候，自动调用dealloc；
-(void)dealloc { //销毁对象
    //执行代码
    [super dealloc]; //写在最底层
}
[p retain]; //引用计数+1
[p release]; //引用计数-1
retainCount //打印对象的引用计数
#数组的内存管理：数组内部也遵守内存管理
1.当创建数组的时候，数组会对每个对象进行引用计数+1；
2.当销毁数组的时候，数组会对每个对象进行引用计数-1；
3.当给数组添加对象的时候，会对对象进行引用计数+1；
4.当给数组删除对象的时候，会对对象进行引用计数-1；
#Autorelease&Autoreleasepool：延迟销毁
概述：Autoreleasepool相当于数组：如果哪个对象发送Autorelease消息，则是将对象的拥有权交给了
Autoreleasepool，当Autoreleasepool销毁的时候，持有的对象才会发送一个release消息；
//MRC：retain、release、autorelease、Autoreleasepool
#ARC模式下的关键字：
1.strong(强引用)：缺省属性，修饰的对象指针：指向哪个对象，会对该对象retain；
离开哪个对象，会对该对象release；
2.weak(弱引用)：修饰的对象指针：指向任何对象都不会retain，这样的指针指向的
对象随时可能消失，如果对象消失了，这个指针会自动变成nil；-可以防止循环引用
3.retain：自动帮我们生成get/set方法内存管理的代码；
4.assign：不会帮我们生成get/set方法内存管理的代码；
5.atomic：性能低(默认)；
6.nonatomic：性能高；
7.unsafe_unretained：修饰的对象指针：指向任何对象都不retain，当指向的对象消失，
该指针不会变成nil，仍然指向已经释放的对象；不建议使用；
注意：ARC模式下，原则上不能写retain、copy，只能写strong；实际开发中：字符串写copy、
代理对象写weak、基本数据类型写assign、其他的写strong；
//ARC的判断准则：只要没有强指针指向对象，对象就会释放
__strong Person *p = [[Person alloc]init]; //默认是强指针
__weak Person *p1 = p; //弱指针
//MRC/ARC下多个对象的内存管理怎么操作？、防止循环引用怎么做？
MRC：A对象想拥有B对象，需要对B对象进行一次retain；A对象不用B对象，需要修B对象进行一次release；
ARC：A对象想拥有B对象，需要用一个强指针指向B对象；A对象不用B对象，不需要进行任何操作；
ARC中的strong相当于MRC中的retain；
/******************************UI基础******************************/
#跳转：
1).模态方式：见WidgetViewController.h/m->TimeViewController.h/m
基本方式传值：OK
block传值：实现回调
代理传值：OK
2).通过导航控制器迁移：见WidgetViewController.h/m

#UIWebView&WKWebView：代理型视图
作用：加载URL、加载HTML网页；
练习：WKWebView添加进度条；

#多控制器：利用下列2种控制器管理多控制器
//导航控制器：UINavigationController
特征：以栈的形式管理子控制器-push压栈、pop出栈；
代码：见AppDelegate.h/m、WidgetViewController.h/m
//分栏控制器：UITabBarController
注意：UITabBarControllerDelegate很重要
代码：见AppDelegate.h/m
注意：1.把导航控制器UINavigationController添加到分栏控制器UITabBarControllerDelegate；

#数据源：
实质：数据源实质就是一个数组(NSArray、NSMutableArray)；
Model类必须是单例：全局都可能使用这个Model；
VC需要网络请求，可以委托(PostStore类)来进行网络请求；
PostStore类网络请求完成，需要告诉VC网络请求操作完成；

#瀑布流：
//实现原理：
我们利用多个UITableView联动就可以实现瀑布流效果：调用UIScrollView的代理方法
让多个UITableView的偏移量都等于UIScrollView的偏移量实现联动，当一个cell超过屏
幕，我们不要release，而是回收到复用队列，然后在创建cell的时候首先去复用队列中
取，如果没有我们在创建。
//代码：见WaterFall

#状态栏：
//通过UIViewController管理状态栏(每个VC都拥有自己不同的状态栏)
//状态栏样式
- (UIStatusBarStyle)preferredStatusBarStyle {
return UIStatusBarStyleLightContent;
}
//隐藏状态栏
- (BOOL)prefersStatusBarHidden {
return YES;
}
//通过UIApplication管理状态栏(app状态栏统一管理)
//修改info.plist：不让VC管理状态栏-添加key：View controller-based status bar appearance，设置为NO
[UIApplication sharedApplication].statusBarHidden = YES;
[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;

#像素和点之间的转换：效果图上标注的怎么转换？
https://blog.csdn.net/ridxmc/article/details/51346472

#实现画折线图：利用第三方库
1.加入tk库文件；
2.添加QuartzCore.framework；
/******************************iOS高级******************************/
#多语言：en/tw/cn
定义：根据用户设置的Language and Region Format(语言和区域格式)修改应用
本地化信息(语言、货币、日期格式等)；
http://www.cocoachina.com/ios/20170122/18609.html //特别详细
https://www.jianshu.com/p/c7a6408410aa

#多线程：三种形式
线程锁NSLock：百度
信号量：指同时可以执行几个多线程
//多线程：并发执行是假象，实质是CPU快速的在多条线程之间调度
1.使用场景：ASI网络请求、SDWebImage图片下载
2.使用目的：为了使界面流畅，防止界面假死；
3.原理：1s---1000个0.001s
//主线程(UI线程)：程序一启动，系统就会默认创建一条线程
作用：显示刷新UI界面、处理与用户的交互事件；
注意：1.不要处理耗时操作；
2.程序默认开启、程序员不能手动开启主线程；
//线程的状态
新建New-->就绪Runnable-->运行状态Running-->阻塞Blocked
//线程间通信：
定义：在一个进程中，多个线程往往不是彼此独立，需要经常进行通信；
体现：1.一个线程传递数据给另一个线程；
2.一个线程中执行完特定任务后，转到另一个线程继续执行任务；
//实现方案
三.NSOperation：基于GCD、任务为导向的多线程模型、需要管理线程
//1.创建多线程：NSOperation是抽象类，两个子类都可以创建对象
NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self
selector:@selector(downloadImage:) object:nil];
NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    //3.先加载、再更新UI
}]
//2.添加到队列：即可以并行、也可以串行，默认是并发队列、默认_queue.maxConcurrentOperationCount为8
_queue = [[NSOperationQueue alloc]init];//创建NSOperationQueue的队列
_queue.maxConcurrentOperationCount = 2;//设置队列的最大并发数量：同一时间最多有多少任务可以执行
[_queue setSuspended:YES];//暂停：可以恢复、不能暂停当前正在处于执行状态的任务
[_queue setSuspended:NO];//继续执行
[_queue cancelAllOperations];//取消：不可以恢复
[_queue addOperation:operation];
[_queue addOperation:blockOperation];//多线程加到队列中
//可以跨队列依赖
[blockOperation addDependency:operation];//操作依赖：不能循环依赖、blockOperation依赖于operation
//操作监听
blockOperation.completionBlock = ^{
    //注意：执行该block块代码的线程和执行blockOperation操作的线程不一定一致，因为使用GCD和NSOperation技术线程的分配是系统内部决定的
    NSLog(@"任务已经执行完毕--%@",[NSThread currentThread]);
};
//3.先加载、再更新UI
-(void)downloadImage:(NSOperation*)operation {
    //1.加载线程代码
    //2.在主线程更新UI
    [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];
}
/*
串行执行：不代表只开一条线程(线程同步)
maxConcurrentOperationCount = 0 不会执行任务
maxConcurrentOperationCount = 1 串行队列
maxConcurrentOperationCount > 1 并发队列
maxConcurrentOperationCount = -1 特殊意义：最大值、表示不受限制
*/
_queue.maxConcurrentOperationCount = 1;

#用户通知：
//概述：
推送功能一般分为两种：本地推送和远程推送；
1.对于本地推送(UILocalNotification)，我们可以先注册通知；
然后新建本地推送，设置属性；最后执行推送(会调用某个方法)；
2.对于远程推送，我们使用第三方极光推送，按照极光推送文档操作；
//本地通知(本地推送)：
定义：由App发送到当前设备，不需要网络支持；
问题：什么时候使用本地通知？App在前台需要与客户交互的时候使用本地通知；
本地通知怎么在AppDelegate.m中使用？
代码：AppDelegate.m
//远程通知(远程推送)：由App服务端->APNs服务器->设备
https://www.jianshu.com/p/ad43bc1a970a

#基于位置的服务LBS：
//系统定位
1.导入MapKit.framework，创建MKMapView
2.显示用户位置，把MKMapkit加到self.view，设置代理
3.导入CoreLocation.framework，创建CLLocationManager(定位对象)设置属性
4.问用户是否允许更新用户信息：开始更新
5.设置代理
6.需要在Info里边添加两项:
1)当APP在前台的时候才使用,会跟用户弹出一个确认框：
NSLocationWhenInUseUsageDescription
2)当APP总是请求用户定位的时候,会跟用户弹出一个确认框：
NSLocationAlwaysUsageDescription
代码：MapViewController.h/m
//大头针：知道经纬度就可以标注位置
1.导入两个框架 MapKit.framework、CoreLocation.framework；
2.创建MKMapView把地图显示出来；
3.定义显示标注的类(MyAnnotation类)，实现MKAnnotation协议；
4.从协议复制属性，初始化协议属性；
5.给地图添加标注：MyAnnotation *a=[[MyAnnotation alloc]initWith:CLLocationCoordinate2DMake(36.1, 116.8) andTitle:@"title" andSubTitle:@"subtitle"];
6.给地图添加标注：[self.mapview addAnnotation:a];
代码：MKAnnotation.h/m
//高德地图
1.登录LBS开放平台，申请Key；
2.下载相关SDK和实例代码；
https://blog.csdn.net/a910577347/article/details/73499515
//百度地图
1.登录LBS开放平台，获取密钥；
2.下载相关SDK和实例代码；
https://www.jianshu.com/p/b0169d332918
//腾讯地图
1.登录LBS开放平台，获取参数；
2.下载相关SDK和实例代码；
https://blog.csdn.net/liyun123gx/article/details/44222255

#多媒体：图片、音乐、录音、视频
//上传照片：UIImagePickerController-选择图片类(代理类)
注意：保存图片、UIAlertController打不开
//音频：流的形式
音频录音机-AVAudioRecorder
音频播放器-AVAudioPlayer
//视频：vitamio
视频播放器-MPMoviePlayerController
代码：MediaViewController.h/m
练习：找出实用的第三方框架开发出商用级别项目；
https://blog.csdn.net/Dreamandpassion/article/details/82459246
https://www.jianshu.com/p/d8062b1856f3

#程序之间通信：
概念：URL组成-协议类型+服务器地址+资源路径+请求参数
原理：从一个App跳转到另一个App的必要条件：另一个App必须配置scheme(skim)协议，这样App才可以根据协议找到需要打开的应用；
1.第三方登录、分享、支付：由于是封装的SDK，可以根据文档直接集成；
2.打电话、发短信、发邮件：https://blog.csdn.net/cc1991_/article/details/74990013
3.实现两个单独App之间的跳转：TestApp->Demo
1).在Demo中配置协议url scheme：test；
2).在TestApp执行跳转方法：
NSURL *url = [NSURL URLWithString:@"test://"];
if ([[UIApplication sharedApplication] canOpenURL:url]) {
    [[UIApplication sharedApplication] openURL:url];
} else {
    NSLog(@"尚未安装应用");
}
3).在TestDemo中配置协议白名单：iOS9.0以后
在info.plist中添加字段：LSApplicationQueriesSchemes(数组)；
配置需要跳转的协议白名单test；
4.实现两个App之间跳转到指定界面：
1).在"test://"协议后面跟上域名来标记需要跳转的界面；
NSURL *url = [NSURL URLWithString:@"test://map"];
if ([[UIApplication sharedApplication] canOpenURL:url]) {
[[UIApplication sharedApplication] openURL:url];
} else {
NSLog(@"尚未安装应用");
}
2).在AppDelegate.h中，监听代理方法：
- (BOOL)application:(UIApplication *)app openURL:(nonnull NSURL *)url options:(nonnull NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {
    if ([url.host isEqualToString:@"map"]) {
        //在此做界面的跳转处理
    }
}
https://blog.csdn.net/cc1991_/article/details/79050275

#分享：
//原生分享
https://blog.csdn.net/qq_28009573/article/details/77744001
//shareSDK集成
注意：1.在Xcode7.0以上，需要在info.plist中设置访问权限；
https://www.cnblogs.com/xubojoy/p/3885932.html
https://www.jianshu.com/p/71499300a133

#第三方登录：基于OAuth2.0协议构建的OAuth2.0授权登录系统
1.微信登录：只提供原生登录方式(必须安装客户端)，所有使用之前必须判断；
https://www.cnblogs.com/sunfuyou/p/7843612.html
2.QQ登录：xxx
https://blog.csdn.net/alexander_wei/article/details/72626396
https://www.jianshu.com/p/133d84042483
3.微博登录：xxx
https://blog.csdn.net/zhonggaorong/article/details/51724810
https://blog.csdn.net/u010545480/article/details/53004699
https://www.jianshu.com/p/87d1d397d269

#支付：
//内购
概述：如果你的App中销售的商品与App的功能有关必须通过内购方式购买；
特点：1.不允许自定义价格；
2.消耗型项目/非消耗型项目/自动续订订阅；
https://blog.csdn.net/xiaoxiangzhu660810/article/details/17434907#0-qzone-1-51422-d020d2d2a4e8d1a374a433f596ad1440
//第三方支付：
http://www.cocoachina.com/ios/20151008/13506.html#0-qzone-1-88885-d020d2d2a4e8d1a374a433f596ad1440
1.支付宝：
https://blog.yayuanzi.com/12276.html
https://openhome.alipay.com/platform/document.htm#down
http://www.cnblogs.com/siyuan123/p/4872378.html?from=timeline&isappinstalled=0
2.微信：
https://www.jianshu.com/p/af8cbc9d51b0
https://www.jianshu.com/p/162ece335b31
3.银联：NO
4.平台币：NO
5.集成三方平台支付：海马、同步推、爱思

#断点续传：
定义：指任务在上传/下载的时候被人为划分为几个部分：每个部分采用一个线程进行上传/下载，如果遇到网络故障可以
继承在未完成的部分继续开始，没必要从头开始下载。
//原理
https://www.cnblogs.com/wangzehuaw/p/5610851.html
https://www.cnblogs.com/findumars/p/5745345.html
//实现
https://www.jianshu.com/p/0e6deea7de87
https://www.jianshu.com/p/01390c7a4957
https://blog.csdn.net/stree7cleaner/article/details/51440774
https://blog.csdn.net/lcg910978041/article/details/51487485

#即时通讯IM：
//底层原理：
1.协议：XMPP协议(基于xml的协议，具有超强的可扩展性)
2.XMPP的三个部分：服务器、网关、客户端(可以任意两者双向发生)
3.XMPP优缺点：
//优点：
1).XMPP协议是自由开源的，而且在C/S都有多种实现；
2).任何IM供应商在遵循XMPP协议下都可以与Google Talk实现连接；
3).利用XMPP技术开发软件，资源以及支持的来源都是多样的，这样就不会被“绑架”；
4).XMPP以TCP传递XML数据流，没有中央主服务器，任何人都可以运行自己的XMPP服务器；
5).XMPP基于XML具有很强的扩展性；
//缺点：
1).XMPP协议的服务器流量存在着被重复转发，数据负载太重；
2).XMPP协议基于XML文件(编码成单一的XML文件)，因此无法提供修改二进制数据；
//上层实现：环信
概述：环信通过云端开放的Rest api或者客户端SDK，摆脱IM底层开发，使App内置聊天功能；
步骤：1.制作推送证书、登录环信后台、创建应用生成AppKey；
2.通过cocoapods下载SDK：
pod 'EaseMobSDKFull', :git => 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'
导入头文件：#import <EaseMobSDKFull/EaseMob.h>
3.按照环信集成开发文档操作；

#二维码：
应用：ZBarSDK第三方库
https://blog.csdn.net/he_jiabin/article/details/47786031

#App换肤：
http://www.cocoachina.com/ios/20171012/20762.html

#图文混排：
https://blog.csdn.net/qcx321/article/details/52194835

#webview混排：
https://blog.csdn.net/u010960265/article/details/80563668

#iPad开发：
//iPad和iPhone开发的异同
https://blog.csdn.net/wujakf/article/details/80223046
//iPad项目开发总结
https://www.jianshu.com/p/522c8993572b
/******************************实战操作******************************/
#svn：开源的集中式版本控制工具(trunk/branches/tags)
官网：https://subversion.apache.org/
客户端：SmartSVN、CornerStone
安装：NO
在mac环境下，自带svn服务端和客户端功能，只需要做简单配置；
svn help //查看svn所有命令
cd+工程目录 //进入工程目录
svn checkout 服务器地址 --username=xwj --password==xwj123456 //将服务器代码完整的下载到本地
------------------------------------------------------------
svn status //查看文件状态
' ' 没有修改
'A' 被添加到本地代码仓库
'C' 冲突
'D' 被删除
'I' 被忽略
'M' 被修改
'R' 被替换
'X' 外部定义创建的版本目录
'?' 文件没有被添加到本地版本库内,不在SVN的管理之下
'!' 文件丢失或者不完整(不识别该文件)
'~' 受控文件被其他文件阻隔
'U' 更新最新的代码到本地(本地有文件的情况下)
'G' 产生冲突后,更新操作去解决冲突,相当于进行合并
------------------------------------------------------------
svn add * //添加文件
svn commit -m "本地修改说明" //将本地修改的内容提交到服务器
svn update //将服务器最新代码更新到本地
svn remove person.h  //删除svn版本管理控制的person.h文件
//版本回退：
1.本地版本回退
svn update -r7 //回退到第7个版本：查看是否是需要的版本
svn update //更新到最新版本
svn merge -r7:6 person.h //person.h回退到第6个版本
2.服务器版本回退
svn update
//查看版本信息
svn update //更新
svn log //查看某个文件的日志
//遇到冲突
mc(mine side) //保留自己的修改，放弃别人的修改
tc(their side) //保留别人的修改，放弃自己的修改
p(post pone) //延迟解决冲突：展示所有冲突的文件，手动解决冲突
svn resolved 文件名 //解决了某个文件的冲突：必须写
//svn地址重定向：
cd ./workspace
/*
10.5.154.237 上次svn的地址
10.5.154.142 本次svn的地址
sally 你的用户名
sallyssecret 你的密码
*/
svn switch --relocate svn://10.5.154.237 svn://10.5.154.142 --username sally --password secret
//svn恢复
svn revert . -R
注意：1.本地版本号<服务器版本号->则不允许提交；
2.如果使⽤静态库需要特别注意：必须使⽤命令⾏将静态库添加到svn的管理之下；svn add xxx.a
https://my.oschina.net/joanfen/blog/194491#0-qzone-1-42949-d020d2d2a4e8d1a374a433f596ad1440

#git：开源的分布式版本控制工具(master/branches/tags)
开发者：Linux操作系统的作者Linus Torvalds；
客户端：SourceTree
安装：NO
创建代码仓库：git init
配置身份：查看是否配置OK
git config --global user.name "Tony"
git config --global user.email "tony@gmail.com"
添加：git add 文件名
提交：git commit -m "说明.txt"
加入.gitignore-允许用户将指定的文件或目录排除在版本控制之外的机制；
查看状态：git status
查看修改内容：git diff
撤销修改：git checkout
查看提交内容：git log
删除person.m文件：git rm person.m
版本回退：git reset --hard HEAD //没有push
1.git reset --hard HEAD^ //有push、回到上一个版本
2.git push -f //强制推送：必须让同事也要版本回退、不然同事本地不是消失！！！
git reset --hard HEAD^^ //回到上上一个版本
git reset --hard HEAD~100 //回到前100个版本
git reset --hard HEAD 版本号(前5位) //回到指定版本
//git分支：
查看分支：git branch -a
创建分支：git branch 分支名
合并分支：git checkout master->git merge 分支名
删除分支：git branch -D 分支名
解决冲突：git无法帮助你；
#与远程版本库协作：NO
//.gitignore
https://github.com/github/gitignore
//忽略UserInterfaceState.xcuserstate的方法：
https://blog.csdn.net/lovenjoe/article/details/50053255
//打tag：发现bug可以直接把这个tag变成分支
git tag -a tag名 -m "你想要说你的话"
git tag
git push origin tag名
//ssh keys认证
1.公钥：存在github上用来解密的key
2.私钥：存在本地一个.ssh文件夹下用来加密

#CocoaPods：https://segmentfault.com/a/1190000011428874
//安装Cocoapods
1.安装Ruby
1>安装RVM:
curl -L get.rvm.io | bash -s stable
rvm -v
2>安装homebrew:
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew -v
3>安装xcode command line:
xcode-select --install
xcode-select -v
4>安装ruby:
rvm list known
rvm install 2.4.0
ruby -v
2.安装Cocoapods
sudo gem install cocoapods
教程：https://blog.csdn.net/zhanglizhi111/article/details/76657982
//使用Cocoapods
cd ./project
pod init
pod install --no-repo-update
#Podfile
platform :ios, '8.0'
target '项目名' do
use_frameworks!
pod 'NSLogger'
pod 'AFNetworking'
pod 'FMDB'
pod 'UICKeyChainStore'
pod 'SCLAlertView-Objective-C'
pod 'FTIndicator/FTProgressIndicator'
pod 'FTIndicator/FTToastIndicator'
pod 'IQKeyboardManager'
pod 'MKDropdownMenu'
pod 'CLGO', :git => 'ssh://git@git.changmeng.com/ios/sdk.v3.8.git', :branch => 'appstore-bt'
end
pod update --no-repo-update
//升级本机pod库
pod repo update master
//编写podspec文件：NO
//利用CocoaPods创建静态库：NO
//新建静态库
https://segmentfault.com/a/1190000011428874
//打包静态库
#sudo gem install cocoapods-packager
#cd ./CLGO.podspec
#pod package CLGO.podspec --force --verbose //常规打包
#pod package CLGO.podspec --force --no-mangle --verbose //含.a的打包
http://www.jianshu.com/p/605350a7b1dd
/******************************补充知识点******************************/
#PCH文件：参考Res/项目中常见的文件(PCH)

#正则表达式：
代码：NewNetworkViewController.h/m
搜索NSRegularExpression

#谓词： NSPredicate
概念：OC中谓词操作是针对于数组类型的，这样的好处是我们可以不需要编写很多代码就可以去操作数组、过滤数据；
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF CONTAINS[c] %@",searcgString];
_ArrM = [NSMutableArray arrayWithArray:[_Arr filteredArrayUsingPredicate:predicate];//过滤数据

#深拷贝/浅拷贝：
//定义
深拷贝：生成值一样，内存地址不一样的全新对象-内容拷贝
浅拷贝：使原对象的引用计数+1，没有创建全新的对象，直接返回被拷贝对象的地址-指针拷贝
//不可变字符串：右侧如果是copy，那么就是浅拷贝；右侧如果是mutableCopy,那么就是深拷贝
NSString *msg0 = @"";
NSString *msg2 = [msg1 mutableCopy];//深拷贝
NSString *msg1 = [msg0 copy];//浅拷贝：对原对象进行一次retain、对拷贝出来的对象进行一次release
//可变字符串：右侧无论是copy还是mutableCopy，都是深拷贝
NSMutableString *msg3 = [NSMutableString stringWithString:@""];
NSString *msg1 = [msg0 copy];//深拷贝
NSString *msg2 = [msg1 mutableCopy];//深拷贝
注意：1.浅拷贝类似retain，深拷贝类似copy；
2.参考：https://blog.csdn.net/chenyufeng1991/article/details/51771728
-(id)copyWithZone:(NSZone *)zone {

}
-(id)mutableCopyWithZone:(NSZone *)zone {

}

#DrawRect：NO
概念：Quartz 2D是一个基于CoreGraphics框架来实现的二维绘制引擎，同时支持iOS和Mac系统；
作用：绘制图形、线、三角形、圆、弧形；绘制文字；绘制/生成pdf；截图/裁剪图片；自定义UI；
https://blog.csdn.net/potato512/article/details/56845385
https://blog.csdn.net/mangosnow/article/details/37054765#0-qzone-1-85099-d020d2d2a4e8d1a374a433f596ad1440

#iOS11/12新特性：
https://www.jianshu.com/p/39a5aee18778
/******************************面试部分******************************/
//self.name和_name的区别：
self.name是对set/get方法的简单操作，引用计数+1；
_name是直接操作变量，引用计数不+1；
//UITableView的性能：cell的复用机制
移动设备的内存有限，如果使用一个cell就创建一个cell对象将会耗尽设备的内存。解决该问题需要引入
cell的复用机制：当UITableView发生滚动的时候，部分cell会移出窗口，这时候系统会将窗口外的
cell放入cell对象池中，等待复用。当UITableView要求dataSource返回cell的时候，dataSource
会首先查看cell对象池，返回cell对象池中未使用的cell给UITableView，从而避免创建新cell对象。
//线程有几种状态：5种状态
新建New--就绪Runnable--运行Running--阻塞Blocked--死亡Dead
//http/https的区别：
http协议是明文协议、https是添加了加密和认证的协议
//get/post的区别：
1.get获取数据、post更新数据
2.get请求的数据会明文出现在url上、post请求的数据会封装在请求体种。 相对安全
3.get请求的数据受到浏览器/服务器对url长度的限制、post没有限制
//常见的网络协议：
http协议、https协议、TCP/IP协议、FTP协议
//TCP/UDP的区别：
TCP是面向连接的，提供可靠的服务，UDP是无连接的，尽最大努力交付，不保证可靠服务；
TCP通过校验、重传控制、确认应答实现可靠传输，UDP具有较好的实时性；
TCP连接只能支持点对点，UDP支持交互通信；
//Internet采用哪种网络协议？该协议的主要层次结构？
tcp/ip协议，层次结构：应用层/传输层/网络层/数据链路层/物理层
//进程和线程的区别：
进程：系统中正在运行的应用程序叫做进程(相互独立)，进程是OS资源分配的基本单位；
线程：任务调度和执行的基本单位：每个进程当中至少有一个线程；
//产生死锁的原因：
死锁：多个进程在执行过程中，因为资源竞争而造成的阻塞现象；
1.互斥条件：xxx
2.请求和保持条件：xxx
3.不剥夺条件：xxx
4.环路等待条件：xxx
//处理死锁的办法：
1.预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件；
2.避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁；
3.检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉；
4.解除死锁：该方法与检测死锁配合使用；
//进程的调度算法：
1.先来先服务(FCFS)
2.最短作业优先(SJF)
3.最高响应比优先法(HRRN)
4.时间片轮转算法(RR)
5.多级反馈队列(MFQ)
//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；
//请列举几种源代码管理工具，并说明区别：
源代码管理工具：svn、git
区别：1.在很多情况下，git的速度远远比svn快；
2.svn是集中式管理，git是分布式管理；
3.svn必须联网才可以正常工作,git支持本地版本控制；
//静态数据类型和动态数据类型的区别：
1.静态数据类型的特点：在编译期就明确变量的类型、可以访问属性和方法；
2.动态数据类型的特点：在编译期不清楚变量的类型、运行期才知道真实类型；
//为什么加上__block就可以在block内部修改变量：
因为没有添加__block是值传递、加上__block是地址传递；
//[self class]|[self superclass]：
1.[self class]获取当前方法调用者的类；
2.[self superclass]获取当前方法调用者的父类；
//简述远程推送的步骤：
我们一般利用第三方极光推送完成远程推送功能：
1.登录苹果开发者后台，创建项目推送证书；
2.登录极光推送后台，上传证书，创建应用；
3.获取到AppKey、导入必要类库、按照开发文档操作；
//第三方登录总结：
xxx
//有哪些技术可以实现定位：
基站、GPS
//社会化分享总结：
1.对于系统自带的分享：如果是分享到短信、邮箱,需要导入MessageUI系统库,然后创建分
享;如果是分享到新浪微博、腾讯微博,需要导入Social系统库,然后分享创建。优点：不需要集
成第三方库,不需要App Key;缺点：页面简单,不能自定制；
2.对于第三方分享：一般使用shareSDK，首先进入shareSDK官网获取App Key，集成shareSDK，
想要分享至哪些平台就去相应开放平台申请AppKey和AppSecret，然后按照文档构建分享内容。
//参考：
http://blog.csdn.net/leaf8742
https://www.jianshu.com/p/1a94498de7f4
https://www.jianshu.com/p/2e1b3f54b4f3
/******************************swift基础******************************/
#补充知识点：WMGame/swift

#选择器SEL：一个数据类型，内部是消息，类似于函数指针
原理：1.Objective-C在编译的时候，会根据方法的名字(包括参数序列)，生成用来区分这个方法的唯一ID，这个ID就是SEL类型；
2.SEL就是对方法的一种包装。包装的SEL类型数据对应相应的方法地址，找到方法地址就可以调用方法。在内存中每个类的方法都存储在类对象中，每个方法都有一个与之对应的SEL类型的数据，根据一个SEL数据就可以找到对应的方法地址，进而调用方法。
作用：提高执行的效率、增强程序的灵活性；
//创建
@selector 方法选择器
@selector (方法名)
//获取
SEL s1 = @selector(onClick:);
//将一个字符串转换为一个SEL类型
SEL s2 = NSSelectorFromString(@"onRun:");
/**
通过@selector方法获取
SEL s1 = @selector(compare:);
//这个方法用于编译时就能确定调用的方法

通过NSSelectorFromString将一个字符串转换为一个SEL类型
SEL s2 = NSSelectorFromString(@“run:”);
//这个方法用于运行时就能确定调用的方法
*/
//执行SEL
Dog *dog = [[Dog alloc]init];
[dog performSelector:s1];
[dog performSelector:@selector(setName:) withObject:@"Tom"];//最多支持两个参数
//使用@selector对数组排序：
代码：SelViewController.h/m
//在ARC(自动内存管理)的条件下，使用选择器很可能会报警：参照该方式去除报警
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
//执行代码
Dog *dog = [[Dog alloc]init];
SEL s1 = @selector(onClick:);
[dog performSelector:@selector(setName:) withObject:@"Tom"];
#pragma clang diagnostic pop

1.二维数组
1）定义：元素是一维数组的数组称为二维数组
int arr[4][4];

2）二维数组的初始化
int arr[4][4]={   {1,2,3,4},
               {2,3,4,5},
               {3,4,5,6},
               {4,5,6,7} };

3）二维数组的赋值
arr[0][0] = 4;
arr[2][1] = 4;


1.指针
1）指针就是变量的地址；地址就是唯一标识一块内存的索引
int  a;
a         //a是变量名
&a     //a的地址
&       //取地址符

2）指针变量
1.int  *p;   //定义一个指针变量p
   p           //p是指针变量名
  ＊        //指向
指针变量p的作用：指针变量时用来存储地址的
*p: 指p所指向的内容

2.给指针变量赋值
 p=&a;    // 将整型变量a的地址赋给指针变量p
               //p指向变量a，指针变量p同一时刻只能指向一个变量
  a＝3;    //直接的改变了变量a的值
 *p=5;   //间接的改变了变量a的值
            //＊p是p指向的变量

3.指针作为函数参数的使用
int *p; //变量p是int*类型
            //int是p指向的变量的基类型

4.空指针和野指针
int *p = NULL；   //指针变量p初始化为空
                              //NULL代表空，值为0；
                             //不能使用空指针

int  *p；     //未初始化的指针称为野指针
                   //不能使用野指针
3）printf("&a=%p,&b=%p\n",&a ,&b );   //输出变量a,b的地址，％p地址格式符
int *p=NULL;        //p初始化为空，不能使用空指针
4）使用指针注意事项：
1）定义指针时，一定要初始化为空；
int *p=NULL;//指针作为参数或者已经赋值，则无需初始化为空。
2）使用指针前，一定要给指针赋值；
3）使用指针时，一定要判空
if(p==NULL) {
    return;
}

5)指针大小
固定4个字节（因为地址在内存里都是一整型的方式分配的）
char *p
int *q
//p和q都是4个字节。

例如：交换两个变量
#include "jiaohuan.h"
//传值，无法实现交换
void Swap1(int a,int b)
{
    printf("swap1：%p,%p\n",&a,&b);
    int t;
    t = a;
    a = b;
    b = t;
}
//传地址，交换指针指向，无法实现交换
void Swap2(int *c,int *d)
{
    printf("swap2：%p,%p\n",c,d);
    int *t;
    t = c;
    c = d;
    d = t;
}
//传地址，交换指针指向变量的值，可以实现交换
void Swap3(int *e,int *f) {
    printf("swap3：%p,%p\n",e,f);
    int t;
    t = *e;
    *e = *f;
    *f = t;
}
#include <stdio.h>
void Swap1(int a,int b);
void Swap2(int *a,int *b);
void Swap3(int *a,int *b);

#include <stdio.h>
#include "jiaohuan.h"
int main(int argc, const char * argv[]) {
    // insert code here...
    int a = 3;
    int b = 5;
    printf("主函数:%p,%p\n",&a,&b);
    Swap1(a, b);
    printf("a=%d,b=%d\n",a,b);
    
    int c = 3;
    int d = 5;
    printf("主函数:%p,%p\n",&c,&d);
    Swap2(&c, &d);
    printf("c=%d,d=%d\n",c,d);
    
    int e = 3;
    int f = 5;
    printf("主函数:%p,%p\n",&e,&f);
    Swap3(&e, &f);
    printf("e=%d,f=%d\n",e,f);
}

1.指针
1） 数组和指针
数组名作为函数的参数
数组名代表数组的首地址

2）指针++
int *p=NULL;
int a=5;
p=&a;
p++;
//执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数。
//指针的移动：必须赋值地址才可以实现指针的移动，不可以赋值指针所指的内容
 q=p  //正确；
q=*p  //错误；
*q=*p//错误；

2.理解内容：
指针数组
int *p[10];
//这是一个数组，10个元素，每个元素都是个指向整型的指针。
//元素为指针的数组
练习：
快速的声明20个int *指针，分别指向int a[20]中的每个元素
指向数组的指针
int (*p)[10];
//这是一个指针，指向10个int元素的数组。
//指向数组的指针
指向指针的指针
int * * p;
//这是一个指针，指向指针
//二级指针
指向函数的指针
int (*p)(int a);//指向函数的指针
//这是一个指针，指向一个函数。
//函数指针
函数指针的声明方法为：
返回值类型 ( * 指针变量名) (形参列表);

3.字符串
1.认识字符串:字符串就是一串字符。
由一对双引号括起来，双引号里面可以写一串字符 。
//“hello world!”是字符串常量。
//字符串中的每个字符占1个字节，字符的个数，比可视的字符多一个。在字符串结尾处有一个’\0’，称作尾零，其ASCII值就是0.
//如上述字符串中有13个字符，12个有效字符。
例如：int arr[5] = {3,4,5,6,7};
char arr[10] = “hello”;   //长度10
char arr[] = “hello”;     //长度6

2.指向字符串的指针：
char * p = "1234567";
//当我们程序中写下"1234567"，就是在【只读数据段】存储了8个字符。
//"1234567”的值只代表第一个字符的所在空间的地址。
练习：
主函数定义一个字符串，编写函数，传递字符串，统计一下字符串中字母的个数；将统计结果返回给主函数。

3.指针作为函数返回值
数据类型＊  函数名（形参列表）
char * MyStr(char * const str,char c);
在字符串str中查找字符c，返回第一次找到c的首地址，如果找不到，则返回NULL；
#include <stdio.h>
char * MyStr(char * str,char c) {
    if(NULL == str) {
        return NULL;
    }
    
    while (*str != '\0') {
        if(*str == c)
        {
            break;
        }
        str++;
    }
    if (*str == '\0') {
        return NULL;
    } else {
        return str;
    }
}
int main(int argc, const char * argv[]) {
     char *p = "hello c dddworld!";
     char *r = MyStr2(p, 'c');
    printf("%s\n",r);
    return 0;
}

char * MyStr2(char * str,char c);

4.内存分配的两种方式
1）静态内存分配
分配在数据段、只读数据段、栈区的内存，由编译器自动申请和释放的内存，称为静态内存分配；在编译阶段分配的内存；

2）动态内存分配
分配堆区里的内存，由程序猿手动申请和释放的内存，称为动态内存分配；在运行阶段分配的内存；
动态申请内存：malloc函数；
动态释放内存：free函数
malloc函数返回值是void* 类型；void*是一个泛型指针；
sizeof();   //sizeof是一个运算符，用来计算变量或数据类型的大小；
free(p);
练习：
输入一个数n，动态分配n个int大小的内存空间，并向内存中写入n个int型数值，实现求n个数的平均值，并返回。
  ＃include<stdlib.h>
#include <stdio.h>
#include <stdlib.h>
int main(int argc, const char * argv[]) {
    int n;
    scanf("%d",&n);
    int *p = NULL;
    p = (int *)malloc(sizeof(int)*n);
    int *q = p;
    int sum = 0;
    float avg = 0;
    for (int i=0; i<n; i++) {
        *q = i+3;
        sum += *q;
        q++;
    }
    avg = (float)sum/n;
    printf("%f\n",avg);
    free(p);
    return 0;
}
3）动态内存释放的注意事项：
1、防止提前释放
2、防止内存泄露
3、防止重复释放

4）动态内存分配和静态内存分配的区别
静态内存分配
<1>操作系统分配空间
<2>空间在编译时确定，而非运行时。
<3>空间在栈段，数据段，只读数据段
<4>自动释放空间
动态内存分配
<1>程序员分配空间
<2>运行时确定，每次运行都不同。
<3>空间在堆段
<4>手动释放空间

2.结构体
定义：相同或不同数据类型变量的集合
1.结构体的定义
struct data {
    int a;
    char c;
    short b;
};
 
#include <stdio.h>
//结构体定义用struct关键字，结构体名字为data
//结构体命名遵循标示符的定义
//定义一个结构体后，一个新的数据类型诞生了，结构体是自定义的数据类型
//结构体的声明一般放在头文件内，或者 .c 文件的最上面(放在include定义的下面，放在所有函数的上面)
struct data {
    //{}里是定义结构体的成员变量，成员变量可以有无数个，成员变量的数据类型可以相同或不同
    //结构体的成员变量也叫做结构体的属性
    int i;
    char c;
    short b;
};

//结构体取别名
//方式1：在定义结构体时直接取别名，用typedef关键字
//如下定义相当于给struct student取别名为stu
typedef struct student {
    int age;
    char name[10];
    int num;
}stu;

//方式2：定义结构体之后，另起一行取别名
struct class {
    int a;
    short b;
};
//完成给struct class取别名为cla
typedef struct class  cla;

int main(int argc, const char * argv[]) {
    // insert code here...
    //定义一个结构体类型的变量d(也叫做创建一个结构体对象d)
    //struct data是一个结构体类型，相当于int
    //结构体变量也叫做结构体对象
    struct data d;
    //结构体的初始化
    //结构体初始化要分别对每个成员变量进行初始化
    struct data d1 = {5,'a',3};
    
    int a;
    a = 3;
    
    //结构体对象的赋值
    //通过对象访问结构体成员变量用 . 进行访问
    struct data d2;
    d2.i = 4;
    d2.c = 'x';
    d2.b = 3;
    
    //结构体指针
    int *p;
    p = &a;
    *p = 4;
    
    //定义一个结构体指针
    struct data *pst;
    pst = &d2;

    //结构体指针通过 -> 来访问成员变量
    pst->i = 5;
    pst->c = 't';
    
    //结构体数组
    int arr[5];
    
    //定义一个长度为5的结构体数组
    struct data sct[5];
    
    //通过结构体数组访问成员变量
    sct[0].i = 7;
    sct[0].c = 'u';
    sct[3].i = 6;
    
    return 0;
}

1.内存管理
1）内存管理
1.C的内存管理，以及麻烦之处
char *p = (char *)malloc(100*sizeof (char));
这是C的动态内存分配，我们手动跟系统申请了100个字节的内存；或者说系统在堆里开辟了100个字节的空间，并将这个空间的首地址返回给指针变量p。
free(p);
使用完成后，手动跟系统释放内存空间；或者说系统回收空间。
            
2.C的内存管理，我们手动申请，手动释放。这样来看，我们只需要注意三个问题就好了：
1.申请内存，使用完成后需要释放，如果不释放会造成内存泄露。
2.不能多次释放，如果多次释放，则会崩溃。
3.不能提前释放，如果提前释放了再使用，也会崩溃。

3.但是，如果项目比较复杂，需要有几十上百号人一起分工完成，就很容易出现问题。
比方说我们开辟了一块内存空间里存放了一块很有用的数据。但是，这个数据不只有我在这一块代码里用，甚至有多个人，在程序的多个地方使用。这样造成的结果就是，就算我使用完成这块内存，我也不能去释放他，因为我不能确定，别人在别的地方是否还需要使用这块内存。内存泄露在所难免了。

2)OC的内存管理
1.引用计数(Reference Count)/保留计数(retain Count)
对于一块动态申请的内存，有一个人（指针）使用，就给这个内存的计数器加1，使用完成后，就给这个计数器减1，当这个内存的引用计数为0了，我们再释放他，这样，上面的问题就解决了。OC，就是使用引用计数这种方式来管理内存的。

3. MRC
1)内存管理的黄金法则
对于引用计数来说，有一套内存管理的黄金法则:
The basic rule to apply is everything that increases the reference counter with alloc, [mutable]copy[withZone:] or retain is in charge of the corresponding [auto]release.
凡是用alloc，retain，new，copy，mutableCopy或者以copy开头，以mutableCopy开头的方法[创建]的对象，都需要用release或autorelease进行释放。
通俗一点的说法就是谁污染谁治理(谁创建谁释放)。
2)alloc与release
ARC模式下创建一个Dog类
@interface Dog : NSObject
@end
@implementation Dog
 - (void)dealloc {
    NSLog(@"dog dealloc");
    //[super dealloc];
}
  @end
dealloc是析构函数，当对象销毁的时候，会自动调用这个方法，我们在这里重写这个方法。

 在main函数里，写入如下代码：
  int main(int argc, const char * argv[]) {
          @autoreleasepool {
           Dog *dog = [[Dog alloc] init];
             }
           NSLog(@"程序即将退出");
           return 0;
      }
 从终端打印信息来看，“程序即将退出”这条打印之前，已经打印dog dealloc，也就是说在程序运行结束前，dog对象已经销毁了。这个是ARC，由Xcode帮我们管理dog对象。
 将ARC改为MRC，再执行程序，dog对象并没有销毁，因为我们现在是手动管理了，我们需要遵守内存管理的黄金法则，Dog *dog = [[Dog alloc] init]; 我们需要对dog进行release。
将main函数代码改为如下形式：
 int main(int argc, const char * argv[]) {
    @autoreleasepool {
       Dog *dog = [[Dog alloc] init];
       [dog release];
       }
    NSLog(@"程序即将退出");
    return 0;
     }
 再次执行程序，从打印可以看出，dog对象已经销毁。这就是黄金法则，我们对dog进行alloc，就要对dog进行release。
注意：release 并不是销毁对象，让对象的引用计数减1，当对象的引用计数为0的时候，自动调用dealloc方法，销毁对象。
3）retain与retainCount
retain：将对象进行保留操作，也就是使对象的引用计数加1。
retainCount：打印一个对象的引用计数。
4）类的组合中使用
在上面代码中，增加Person类
@interface Person : NSObject {
 // 一个人，养了一条狗（持有一条狗）
Dog *_dog;
 }
 - (void)setDog:(Dog *)dog;
  - (Dog *)dog;
 @end
 @implementation Person
/* 版本1 （有问题） 人并没有真正持有狗，如果在main函数里[dog release]，让dog的引用计数减1，就变为0，dog就销毁了。
  - (void)setDog:(Dog *)dog
 {
       _dog = dog;
 }*/

/* 版本2 （有问题） 如果人再持有别的狗，就会造成第一条狗得不到释放，内存泄露。
- (void)setDog:(Dog *)dog
  {
       _dog = [dog retain];
  }*/

 /* 版本3 （有问题） 如果本来持有一条狗，又重新设置这条狗，先进行release，这个时候，很可能dog就销毁了，然后，就没法再次retain了。
 - (void)setDog:(Dog *)dog {
      [_dog release];
      _dog = [dog retain];
}*/
 // 版本4 OK!，标准写法
- (void)setDog:(Dog *)dog {
    if (_dog != dog) {
     [_dog release];
      _dog = [dog retain];
      }
}
  - (Dog *)dog {
      return _dog;
 }
    - (void)dealloc {
    NSLog(@"person dealloc");
     // 人在销毁的时候，一并将持有的dog对象销毁
    [_dog release];
    [super dealloc];
}
7 数组的内存管理
1）当我们创建数组的时候，数组会对每个对象进行引用计数加1
 2）当数组销毁的时候，数组会对每个对象进行引用计数减1
 3）当我们给数组添加对象的时候，会对对象进行引用计数加1
 4）当我们给数组删除对象的时候，会对对象进行引用计数减1
总之，谁污染谁治理，管好自己就可以了（数组内部也遵守内存管理）。
8 ) autorelease与autoreleasepool
        在main函数里写如下代码:
        int main(int argc, const char * argv[]){
            @autoreleasepool {
                          Dog *dog = [[Dog alloc] init];

        //dog并没有马上销毁，而是延迟销毁，将dog对象的拥有权交给了autoreleasepool
            [dog autorelease];

        //这个是可以打印的，因为打印完dog的引用计数后，dog对象才销毁
            NSLog(@"retainCount = %lu",dog.retainCount);
             }
            NSLog(@"程序即将退出");
            return 0;
      }
 autoreleasepool相当于一个数组，如果哪个对象发送autorelease消息，实际将对象的拥有权交给了autoreleasepool；当autoreleasepool销毁的时候，autoreleasepool里持有的对象都发送一个release消息。
4.ARC
1）从Xcode5以后，默认自动内存管理
2）自动引用计数
简单点说就是让编译器完成堆空间的引用计数加减，自动释放。程序员不再写 retain release等方法
3）OC的自动内存管理，不同于JAVA垃圾回收。而是在预处理时，直接在应该保留的地方，添加retain，在应该释放的地方，添加release。是直接添加代码。
从效率上，ARC优于手动内存管理。
    
文件操作
1.数据持久化的方法
通常程序在运行中或者程序结束之后，需要保存一些信息，而且需要持久化存储信息,比如登陆信息、视频播放记录、收藏记录等等,那么我们可以采用以下几种方式对数据进行持久化保存。1.文件    2.plist    3.数据库
2.常用文件操作类
1）NSFileManager（文件管理类）
<1>创建文件管理器单例对象
[NSFileManager defaultManager];

<2>遍历目录下的内容
//浅度遍历当前目录下的文件
[manager contentsOfDirectoryAtPath:path error:&error]

//深度遍历
[manager subpathsOfDirectoryAtPath:path error:&error]

<3>判断文件是否存在
[manager fileExistsAtPath:path]

<4>创建文件
//创建文件
/*参数1：创建文件的路径
参数2：内容，如果nil表示创建一个内容为空的文件。
参数3：nil表示采用默认的设置*/
//如果文件已经存在，会覆盖原来文件。
[manager createFileAtPath:path contents:data attributes:nil];
    
//创建目录
/*参数1：文件夹路径
参数2：是否有中间目录(YES针对所有的情况)
参数3：nil表示采用默认设置
参数4：错误*/

//不会覆盖文件夹内容
[manager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];

<5>拷贝文件/目录
//从哪个路径copy
NSString *fromPath = @"/Users/qianfeng/Desktop/文件夹/testff.txt";
//copy哪个路径
NSString *toPath = @"/Users/qianfeng/Desktop/文件夹/新建文件夹/testff.txt";
//如果文件已经存在是copy不成功的
[manager copyItemAtPath:fromPath toPath:toPath error:&error];

<6>移动文件/目录
[manager moveItemAtPath:fromPath toPath:toPath error:&error];

<7>删除文件/目录
[manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件夹/新建文件夹" error:nil]

<8>获取文件属性    (返回的是字典)
[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件夹/testff.txt" error:nil];

2.3 NSFileHandle（文件句柄类）
对文件进行读写首先需要NSFileHandle打开文件,NSFileHandle对文件进行读写都是NSData类型的二进制数据.
                
<1>打开文件方法
//以只读方式打开
NSFileHandle *readOnlyHandle =  [NSFileHandle fileHandleForReadingAtPath:path]
//以只写方式打开
NSFileHandle *writeOnlyHandle = [NSFileHandle fileHandleForWritingAtPath:path]
//以读写方式打开
NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:path]

<2>读指定长度的数据（单位为字节)
[readOnlyHandle readDataOfLength:5]或者 [readWriteHandle readDataOfLength:5]

<3>从当前偏移量读到文件尾
[readOnlyHandle readDataToEndOfFile];

<4>设置文件偏移量（单位为字节)
[readOnlyHandle seekToFileOffset:5];

<5>将文件偏移量定位到文件尾
[readOnlyHandle seekToEndOfFile];

//如果希望这次写入的数据完全覆盖掉原有数据
//常规做法，短的写入，无法覆盖长的数据
//可以截断原来数据
[readWriteHandle truncateFileAtOffset:0];
//截断到0字节长，即清空原有数据。

<6>写文件(不会覆盖的时候需要设置偏移量)
//当前偏移量指到文件最后
[readWriteHandle seekToEndOfFile];
//写入数据
[readWriteHandle writeData:data];

[readWriteHandle writeData:[@"12345678945343543534543" dataUsingEncoding:NSUTF8StringEncoding]];

 <7>关闭文件句柄
//关闭文件句柄,关闭后(不需要)就不能再操作文件了
[readOnlyHandle closeFile];
[readWriteHandle closeFile];
[writeOnlyHandle closeFile];


#json解析：JavaScript Object Notification
定义：json可以将js对象中表示的一组数据转换为字符串；
格式：
//字典：key是：字符串、value可以是：字符串&数值&true&false&null&对象&数组
{
    key1:value1,
    key1:value1,
    ...
}
//数组
[
    {
        key1:value1,
        key1:value1,
    },
    {
        key1:value1,
        key1:value1,
    }
]
解析：见AnalyzeViewController.h/m
第三方库：JSONKit
4.json数据解析
(JavaScript Object Notation)
简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是JavaScript很容易解释它，而且 JSON 可以表示比"名称 / 值对"更复杂的结构。例如，可以表示数组和复杂的对象，而不仅仅是键和值的简单列表。

<1>Json数据的格式
JSON有两种表示结构
{}中表示一个字典  []中表示一个数组
对象结构以”{”大括号开始，以”}”大括号结束。中间部分多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码。
{
    key1:value1,
    key2:value2,
    ...
}
关键字是字符串，值可以是字符串，数值，true,false,null,对象或数组
数组结构以”[”开始，”]”结束。中间多个以”，”分隔的值列表组成，语法结构如代码。
[
    {
        key1:value1,
        key2:value2
    },
    {
         key3:value3,
         key4:value4
    }
]

<2> 如何解析
NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&error];


1.什么是XML？
extensible Markup Language   可扩展性标记语言
特点：1.可扩展性   2.标记
标记：A.就是标签 成对出现（有开始，有结束）   B.标签区分大小写
例如：
<students>董佳迪</students>
students是标签，董佳迪是标签的值
可扩展性：1.体现在标签的名字用户自己随意命名
                    2.XML中的标签是可以嵌套的，嵌套的结构也是随意的。
示例：
<?xml version="1.0" encoding="utf-8" ?>
<Students>
  <Student id="1" >
    <name>王也</name>
    <age>18</age>
  </Student>

  <Student id="2">
    <name>孟凡路</name>
    <age>17</age>
  </Student>

  <Student id="3">
    <name>高家兴</name>
    <age>48</age>
  </Student>

</Students>

XML的相关概念：
XML经常被理解成倒挂一棵树
根节点:只能有一对根节点，位于嵌套结构中最外层的节点
在本例中 Students为根节点。
id为属性     1为属性值（属性值必须加“”）
注意点：
1.文档扩展名  .XML
2.XML跨平台。
3.主要用途就是网络传输数据
4.声明，是整个XML的第一条语句
 <?xml version="1.0" encoding="utf-8" ?>
 属性：属性值必须加""；
 注意：文档扩展名.xml、跨平台
 作用：网络传输数据
 区别：json/xml的对比
 1.目前90%的使用json、10%的使用xml；
 2.json解析简单，但是结构不易理解、xml结构容易理解，但是数据冗余；
 解析：见AnalyzeViewController.h/m
 https://blog.csdn.net/qxuewei/article/details/52369067
 
2.XML和JSON的对比
1）90%使用JSON   10%使用XML
2）JSON解析简单   XML解析复杂
3）JSON阅读时结构不易理解  ， XML容易理解，但是有数据冗余

3.XML解析
Google的GData ——第三方库
使用Google的GData解析XML

1）相关类和方法
GDataXMLNode
//获取当前节点的值
- (NSString *)stringValue;

GDataXMLElement : GDataXMLNode
//根据子节点名字获取所有的节点名为name的子节点数组
- (NSArray *)elementsForName:(NSString *)name;
//获取节点的属性
- (NSArray *)attributes;
//根据属性名获取属性节点
- (GDataXMLNode *)attributeForName:(NSString *)name;

GDataXMLDocument    //XML节点树
//创建文档节点
- (id)initWithData:(NSData *)data options:(unsigned int)mask error:(NSError **)error;
//获取跟节点
- (GDataXMLElement *)rootElement;
//根据xpath 语法 获取 指定的节点数组
- (NSArray *)nodesForXPath:(NSString *)xpath error:(NSError **)error;

2）本地解析
//读取数据
NSData *data = [[NSData alloc]initWithContentsOfFile:PATH];
        
//建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];


3）网络解析
转换为URL类型网址
NSURL * url = [NSURL URLWithString:@"http://mps.manzuo.com/mps/cate?sid=(null)&id=0&cc=beijing&pt=all&ffst=1&mnt=10&st=-1&hs=1"];

向服务器请求数据，并获得数据
NSData * data = [NSData dataWithContentsOfURL:url];

建立节点数对象
GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];

数据接口
http://www.k780.com/api

xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)
练习：
<1>http://www.oschina.net/action/api/news_detail?id=44392
xml解析
Google的GData 第三方库

今日内容：
XPath语法的使用
//XML路径语法
作用：快速的锁定某一级的节点。可以免去一层层复杂的节点搜索
XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。掌握MVC设计模式

1.选择器
#import <Foundation/Foundation.h>

@interface Person : NSObject

@property NSInteger num;
@property NSString *name;
@property NSInteger age;

-(BOOL)shortreules:(Person*)person;

@end


#import "Person.h"

@implementation Person

-(BOOL)shortreules:(Person *)person {
    BOOL a=self.age>person.age;
    if(self.age==person.age) {
        if(NSOrderedDescending==[self.name compare:person.name])
            a=YES;
    }
    return a;
}

@end


#import <Foundation/Foundation.h>
#import "Person.h"
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                Person *person1=[[Person alloc]init];
                person1.num=001;
                person1.name=@"xiaoming";
                person1.age=12;
                
                Person *person2=[[Person alloc]init];
                person2.num=002;
                person2.name=@"xiaohong";
                person2.age=12;
                
                Person *person3=[[Person alloc]init];
                person3.num=003;
                person3.name=@"hanmeimei";
                person3.age=12;
                
                NSMutableArray *arr=[[NSMutableArray alloc]initWithObjects:person1,person2,person3, nil];
                SEL sel=@selector(shortreules:);
                //NSArray *arr1 = [arr sortedArrayUsingSelector:sel];
                
                [arr sortUsingSelector:sel];
                for (Person *person in arr) {
                    NSLog(@"学号：%lu 姓名：%@ 年龄：%lu",person.num,person.name,person.age);
                }
            }
    return 0;
}


2.文件NSFileManager
#import <Foundation/Foundation.h>

#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //创建文件管理单例对象
        //NSFileManager *file = [NSFileManager defaultManager];
        NSError *error = nil;
        
        NSFileManager *manager=[[NSFileManager alloc]init];
        /*浅度遍历
        NSArray *arr =  [file contentsOfDirectoryAtPath:PATH error:&error];
        if (error != nil) {
            NSLog(@"%@",error);
        }
        NSLog(@"%@",arr);
        
         深度遍历
       arr = [file subpathsOfDirectoryAtPath:PATH error:&error];
       NSLog(@"%@",arr);*/
        
        //判断文件是否存在
        NSLog(@"%d",[manager fileExistsAtPath:PATH]);
        
        //创建文件
        NSString *str=@"飞流直下三千尺";
        
        NSData *data=[str dataUsingEncoding:NSUTF8StringEncoding];
        
        [manager createFileAtPath:PATH contents:data attributes:nil];/*参数1：创建文件的路径
                   参数2：内容，如果nil表示创建一个内容为空的文件。
                   参数3：nil表示采用默认的设置
                   如果文件已经存在，会覆盖原来文件*/
        
       NSString *fromPath =@"/Users/qianfeng/Desktop/文件/文件/main.m";
        
       NSString *toPath =@"/Users/qianfeng/Desktop/文件/Manager.h";
      
        [manager copyItemAtPath:fromPath toPath:toPath error:&error];

        [manager moveItemAtPath:fromPath toPath:toPath error:&error];
        
        [manager removeItemAtPath:@"/Users/qianfeng/Desktop/文件/Manager.h" error:nil];
        
        //获取文件属性,返回的是字典
      NSDictionary *dic=[manager attributesOfItemAtPath:@"/Users/qianfeng/Desktop/文件/文件/main.m" error:nil];
        for(NSString *key in dic) {
            NSLog(@"%@",[dic objectForKey:key]);
        }
    }
    return 0;
}


3.文件NSHandle
#define PATH @"/Users/qianfeng/Desktop/文件/文件/main.m"

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str = @"飞流直下三千尺，不及汪伦送我情";
        
        NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
       
        [data writeToFile:PATH atomically:YES];
        
        //创建一个可读可写的文件句柄
        NSFileHandle *readWriteHandle = [NSFileHandle fileHandleForUpdatingAtPath:PATH];
        
        //设置偏移量
        [readWriteHandle seekToFileOffset:9];
        
        //读取指定长度数据
        data = [readWriteHandle readDataOfLength:6];
        
        NSString *str1 = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        
        NSLog(@"%@",str1);
        
        //设置偏移量到文件尾
        [readWriteHandle seekToEndOfFile];
        
        //从当前偏移量读取到文件尾
        data = [readWriteHandle readDataToEndOfFile];
        
        //关闭句柄
        [readWriteHandle closeFile];
        
    }
    return 0;
}


12.Json解析
1.本地解析
JSON:
{
    "error": 0,
    "status": "success",
    "date": "2015-08-24",
    "results": [
        {
            "currentCity": "北京市",
            "pm25": "30",
            "index": [
                {
                    "title": "穿衣",
                    "zs": "热",
                    "tipt": "穿衣指数",
                    "des": "天气热，建议着短裙、短裤、短薄外套、T恤等夏季服装。"
                },
                {
                    "title": "洗车",
                    "zs": "较适宜",
                    "tipt": "洗车指数",
                    "des": "较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。"
                },
                {
                    "title": "旅游",
                    "zs": "适宜",
                    "tipt": "旅游指数",
                    "des": "天气较好，但丝毫不会影响您的心情。微风，虽天气稍热，却仍适宜旅游，不要错过机会呦！"
                },
                {
                    "title": "感冒",
                    "zs": "少发",
                    "tipt": "感冒指数",
                    "des": "各项气象条件适宜，发生感冒机率较低。但请避免长期处于空调房间中，以防感冒。"
                },
                {
                    "title": "运动",
                    "zs": "适宜",
                    "tipt": "运动指数",
                    "des": "天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。"
                },
                {
                    "title": "紫外线强度",
                    "zs": "中等",
                    "tipt": "紫外线强度指数",
                    "des": "属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。"
                }
            ],
            "weather_data": [
                {
                    "date": "周一 08月24日 (实时：28℃)",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周二",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "30 ~ 20℃"
                },
                {
                    "date": "周三",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 20℃"
                },
                {
                    "date": "周四",
                    "dayPictureUrl": "http://api.map.baidu.com/images/weather/day/duoyun.png",
                    "nightPictureUrl": "http://api.map.baidu.com/images/weather/night/duoyun.png",
                    "weather": "多云",
                    "wind": "微风",
                    "temperature": "31 ~ 21℃"
                }
            ]
        }
    ]
}


#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *zs;
@property NSString *tipt;
@property NSString *des;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"
#define PATH @"/Users/qianfeng/Desktop/本地解析/解析/2.json"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data=[[NSData alloc]initWithContentsOfFile:PATH];
        NSMutableDictionary *dic=[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        NSArray *arr=dic[@"results"];
        NSMutableDictionary *dic1=arr[0];
        NSArray *arr1=dic1[@"index"];
        NSDictionary *dic2=arr1[0];
        
        NSMutableArray *array=[[NSMutableArray alloc]init];
        Model *m=[[Model alloc]init];
        
        for(int i=0;i<[arr1 count];i++) {
            dic2=arr1[i];
            m.title=dic2[@"title"];
            m.zs=dic2[@"zs"];
            m.tipt=dic2[@"tipt"];
            m.des=dic2[@"des"];
            [array addObject:m];
        }
        
        for(Model *m in array) {
            NSLog(@"title:%@ zs:%@ tipt:%@ des:%@",m.title,m.zs,m.tipt,m.des);
        }
    }
    return 0;
}


2。网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString*uid;
@property NSString*username;
@property NSString*groupid;
@property NSString*credit;
@property NSString*experience;
@property NSString*viewnum;
@property NSString*friendnum;
@property NSString*lastactivity;
@property NSString*headimage;
@property NSString*realname;

@end


#import "Model.h"

@implementation Model

@end


#import <Foundation/Foundation.h>
#import "Model.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //定义字符串网址
        NSString *strUrl = @"http://10.0.8.8/sns/my/user_list.php?number=20&page=1";
        
        //将网址转换为URL类型
        //string类型的字符串网址需要做一个转换
        //转换为NSURL类型的网址，才可以进行申请数据操作
        NSURL *url = [NSURL URLWithString:strUrl];
        
        //向网络服务器请求数据
        //同步请求数据，当服务器响应数据之前，线程一直处于卡死状态
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        
        //网络请求的数据都存储在data里了
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        
        //到这一步，所有的json数据都存储在字典里了
        NSArray *arr= dic[@"users"];
        NSDictionary *dic1=arr[0];
        NSMutableArray *array=[[NSMutableArray alloc]init];
        
        for(int i=0;i<[arr count];i++) {
            Model *m=[[Model alloc]init];
            dic1=[arr objectAtIndex:i];
            m.uid=dic1[@"uid"];
            m.username=dic1[@"username"];
            m.groupid=dic1[@"groupid"];
            m.credit=dic1[@"credit"];
            m.experience=dic1[@"experience"];
            m.viewnum=dic1[@"viewnum"];
            m.friendnum=dic1[@"friendnum"];
            m.lastactivity=dic1[@"lastactivity"];
            m.headimage=dic1[@"headimage"];
            m.realname=dic1[@"realname"];
            
            [array addObject:m];
        }
        for(Model *m in array) {
            NSLog(@"uid:%@ username:%@ groupid:%@ credit:%@ experience:%@ viewnum:%@ friendnum:%@ lastactivity:%@ headimage%@ realname:%@",m.uid,m.username,m.groupid,m.credit,m.experience,m.viewnum,m.friendnum,m.lastactivity,m.headimage,m.realname);
        }
    }
    return 0;
}


13.XML解析
1.本地解析
xml解析配置步骤
1、先把Gdata库拖入到项目中-》copy item if
needed  选择第一个单选钮（create groupes）
下面add to targets一般打上勾
2、到项目的build phases—》Link Binary With -Library里添加一个二进制库(搜索libxml2)—>选择libxml2.dylib—add
3、到项目的build phases—》compile里给Gdata文件添加禁用arc(-fno-objc-arc)
4、到项目的build settings-》搜索栏里搜索header search paths—》找到后双击-》添加(/usr/include/libxml2)———》   继续搜索（other linker flags）—》双击-》添加(-lxml2)

#import <Foundation/Foundation.h>

@interface Book : NSObject

@property NSString *ID;
@property NSString *lag;
@property NSString *name;
@property NSString *authorName;
@property NSInteger price;
@property NSString *summary;

@end


#import <Foundation/Foundation.h>
#import "Book.h"

@interface Manager : NSObject {
    NSMutableArray *arr;
}

- (void)addBook:(Book *)book;

- (void)show;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        arr = [[NSMutableArray alloc]init];
    }
    return self;
}

- (void)addBook:(Book *)book {
    [arr addObject:book];
}

- (void)show {
    for (Book *b in arr) {
        NSLog(@"%@",b.summary);
    }
}
@end


#import "Book.h"

@implementation Book

@end


#import <Foundation/Foundation.h>
#import "Book.h"
#import "Manager.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/demo/xml本地解析4/xml本地解析4/GData/book.xml"];
        GDataXMLDocument *doct = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootElement = [doct rootElement];
        
        //取books节点
        GDataXMLElement *booksElement = [rootElement elementsForName:@"books"].firstObject;
        
        Manager *m=[[Manager alloc]init];
        
        //取book节点
        NSArray *arr = [booksElement elementsForName:@"book"];
        
        for (GDataXMLElement *bookElement in arr) {
            GDataXMLNode *ID = [bookElement attributeForName:@"id"];
            GDataXMLNode *language = [bookElement attributeForName:@"language"];
            GDataXMLElement *nameElement = [bookElement elementsForName:@"name"].firstObject;
            GDataXMLElement *autherElement = [bookElement elementsForName:@"auther"].firstObject;
            GDataXMLElement *autNameElement = [autherElement elementsForName:@"name"].firstObject;
            GDataXMLElement *priceElement = [bookElement elementsForName:@"price"].firstObject;
            GDataXMLElement *summaryElement = [bookElement elementsForName:@"summary"].firstObject;
            
            Book *book = [[Book alloc]init];
            book.ID = [ID stringValue];
            book.lag = [language stringValue];
            book.name = [nameElement stringValue];
            book.authorName = [autNameElement stringValue];
            book.price = [[priceElement stringValue] doubleValue];
            book.summary = [summaryElement stringValue];

            [m addBook:book];
        }
        [m show];
    }
    return 0;
}


2.XML:
<?xml version="1.0" encoding="UTF-8"?>
<root name="中国">
  <province name="天津市" postcode="120000" >
    <city name="市辖区" postcode="120100" >
        <area name="和平区" postcode="120101" />
        <area name="河东区" postcode="120102" />
        <area name="河西区" postcode="120103" />
        <area name="南开区" postcode="120104" />
        <area name="河北区" postcode="120105" />
        <area name="红桥区" postcode="120106" />
        <area name="塘沽区" postcode="120107" />
        <area name="汉沽区" postcode="120108" />
        <area name="大港区" postcode="120109" />
        <area name="东丽区" postcode="120110" />
        <area name="西青区" postcode="120111" />
        <area name="津南区" postcode="120112" />
        <area name="北辰区" postcode="120113" />
        <area name="武清区" postcode="120114" />
        <area name="宝坻区" postcode="120115" />
    </city>
  </province>
</root>


#import <Foundation/Foundation.h>

@interface Area : NSObject

@property NSString *name;
@property NSString *postcode;

@end


#import "Area.h"

@implementation Area

@end


#import <Foundation/Foundation.h>
#import "Area.h"
@interface Manager : NSObject {
    NSMutableArray *_arr;
}

- (void)addArea:(Area *)area;

- (void)showAll;

@end


#import "Manager.h"

@implementation Manager

-(instancetype)init {
    if (self = [super init]) {
        _arr = [[NSMutableArray alloc]init];
    }
    return self;
}

-(void)addArea:(Area *)area {
    [_arr addObject:area];
}

-(void)showAll {
    for (Area *area in _arr) {
        NSLog(@"name:%@,postcode:%@",area.name,area.postcode);
    }
}

@end


#import <Foundation/Foundation.h>
#import "GDataXMLNode.h"
#import "Manager.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Manager *m = [[Manager alloc]init];
        
        NSData *data = [[NSData alloc]initWithContentsOfFile:@"/Users/qianfeng/Desktop/伯明利－下午 /2.t/tianjin.xml"];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        
        GDataXMLElement *rootElement = [doc rootElement];
        GDataXMLNode *rootNameElement = [rootElement attributeForName:@"name"];
        Area *area1 = [[Area alloc]init];
        area1.name = rootNameElement.stringValue;
        [m addArea:area1];
        
        GDataXMLElement *provinceElement = [rootElement elementsForName:@"province"].firstObject;
        GDataXMLNode *provinceName = [provinceElement attributeForName:@"name"];
        GDataXMLNode *provincePostcode = [provinceElement attributeForName:@"postcode"];
        Area *area2 = [[Area alloc]init];
        area2.name =provinceName.stringValue;
        area2.postcode =provincePostcode.stringValue;
        [m addArea:area2];
        
        GDataXMLElement *cityElement = [provinceElement elementsForName:@"city"].firstObject;
        GDataXMLNode *cityName = [cityElement attributeForName:@"name"];
        GDataXMLNode *cityPostcode = [cityElement attributeForName:@"postcode"];
        Area *area3 = [[Area alloc]init];
        area3.name = cityName.stringValue;
        area3.postcode = cityPostcode.stringValue;
        [m addArea:area3];
        
        NSArray *arr = [cityElement elementsForName:@"area"];
        for (GDataXMLElement *areaElement in arr) {
            GDataXMLNode *name = [areaElement attributeForName:@"name"];
            GDataXMLNode *postcode = [areaElement attributeForName:@"postcode"];
            Area *area = [[Area alloc]init];
            area.name = name.stringValue;
            area.postcode = postcode.stringValue;
            [m addArea:area];
        }
        [m showAll];
    }
    return 0;
}

3.网络解析
#import <Foundation/Foundation.h>

@interface Model : NSObject

@property NSString *title;
@property NSString *url;

@end


#import "Model.h"

@implementation Model

@end

#import <Foundation/Foundation.h>
#import "Model.h"
#import "GDataXMLNode.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSURL *url = [NSURL URLWithString:@"http://www.oschina.net/action/api/news_detail?id=44392"];
        NSData *data = [[NSData alloc]initWithContentsOfURL:url];
        GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:0 error:nil];
        GDataXMLElement *rootEle = [doc rootElement];
        GDataXMLElement *newsEle = [rootEle elementsForName:@"news"][0];
        GDataXMLElement *relEle = [newsEle elementsForName:@"relativies"][0];

        NSArray *arr = [relEle elementsForName:@"relative"];
        NSMutableArray *mArr = [[NSMutableArray alloc]init];
        
        for (GDataXMLElement *releEle in arr) {
            GDataXMLElement *titleEle = [releEle elementsForName:@"rtitle"][0];
            GDataXMLElement *urlEle = [releEle elementsForName:@"rurl"][0];
            
            Model *m = [[Model alloc]init];
            m.title = [titleEle stringValue];
            m.url = [urlEle stringValue];
            [mArr addObject:m];
        }
        for (Model *m in mArr) {
            NSLog(@"title=%@,url=%@",m.title,m.url);
        }
    }
    return 0;
}

#异步网络请求：
//分类：
网络请求：get
网络上传：post
下载：NO
//原生网络请求：
CFNetwork：纯C语言
NSURLConnection：iOS7.0被废弃
NSURLSession：NO
https://www.jianshu.com/p/b0ddadd34037
//ASIHttpRequest：不在更新
//MKNetworkKit：简单易用，使用者较少
//AFNetworking：
1.概述：2.0使用的是NSURLConnection、3.0使用NSURLSession；
2.代码：NetworkViewController.h/m
注意：不要在子线程中更新UI；
//利用KVO、KVC进行网络请求：参考2015-10-13
1.新建数据模型PostInfo.h/m
2.新建数据源：必须初始化
3.设置单例：全局使用
3.监测数据源变化：KVO
4.新建下拉控件：进入VC->开始下拉加载->网络请求：改变数据源->加载UITableView
5.在View中更新UI
代码：NetworkViewController.h/m
//设置应用支持https
Xcode7.0以后：NSAppTransportSecurity->NSAllowsArbitraryLoads->YES

#网络编程需要掌握的内容：NO
0.实时监测网络变化
1.数据请求、数据上传、下载
2.原生网络请求的原理
3.网络请求第三方库的使用
4.KVC在网络请求中的应用
5.进入VC以后怎么加载操作
